(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require('vue'));
  else if (typeof define === 'function' && define.amd) define([], factory);
  else if (typeof exports === 'object') exports['hqzh-vue-ui'] = factory(require('vue'));
  else root['hqzh-vue-ui'] = factory(root.Vue);
}((typeof self !== 'undefined' ? self : this), (__WEBPACK_EXTERNAL_MODULE__8bbf__) =>
/** *** */ (function (modules) { // webpackBootstrap
    /** *** */ 	// The module cache
    /** *** */ 	const installedModules = {};
    /** *** */
    /** *** */ 	// The require function
    /** *** */ 	function __webpack_require__(moduleId) {
      /** *** */
      /** *** */ 		// Check if module is in cache
      /** *** */ 		if (installedModules[moduleId]) {
        /** *** */ 			return installedModules[moduleId].exports;
        /** *** */ 		}
      /** *** */ 		// Create a new module (and put it into the cache)
      /** *** */ 		const module = installedModules[moduleId] = {
        /** *** */ 			i: moduleId,
        /** *** */ 			l: false,
        /** *** */ 			exports: {},
        /** *** */ 		};
      /** *** */
      /** *** */ 		// Execute the module function
      /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
      /** *** */
      /** *** */ 		// Flag the module as loaded
      /** *** */ 		module.l = true;
      /** *** */
      /** *** */ 		// Return the exports of the module
      /** *** */ 		return module.exports;
      /** *** */ 	}
    /** *** */
    /** *** */
    /** *** */ 	// expose the modules object (__webpack_modules__)
    /** *** */ 	__webpack_require__.m = modules;
    /** *** */
    /** *** */ 	// expose the module cache
    /** *** */ 	__webpack_require__.c = installedModules;
    /** *** */
    /** *** */ 	// define getter function for harmony exports
    /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
      /** *** */ 		if (!__webpack_require__.o(exports, name)) {
        /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
        /** *** */ 		}
      /** *** */ 	};
    /** *** */
    /** *** */ 	// define __esModule on exports
    /** *** */ 	__webpack_require__.r = function (exports) {
      /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        /** *** */ 		}
      /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
      /** *** */ 	};
    /** *** */
    /** *** */ 	// create a fake namespace object
    /** *** */ 	// mode & 1: value is a module id, require it
    /** *** */ 	// mode & 2: merge all properties of value into the ns
    /** *** */ 	// mode & 4: return value when already ns object
    /** *** */ 	// mode & 8|1: behave like require
    /** *** */ 	__webpack_require__.t = function (value, mode) {
      /** *** */ 		if (mode & 1) value = __webpack_require__(value);
      /** *** */ 		if (mode & 8) return value;
      /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
      /** *** */ 		const ns = Object.create(null);
      /** *** */ 		__webpack_require__.r(ns);
      /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
      /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
      /** *** */ 		return ns;
      /** *** */ 	};
    /** *** */
    /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
    /** *** */ 	__webpack_require__.n = function (module) {
      /** *** */ 		const getter = module && module.__esModule
      /** *** */ 			? function getDefault() { return module.default; }
      /** *** */ 			: function getModuleExports() { return module; };
      /** *** */ 		__webpack_require__.d(getter, 'a', getter);
      /** *** */ 		return getter;
      /** *** */ 	};
    /** *** */
    /** *** */ 	// Object.prototype.hasOwnProperty.call
    /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /** *** */
    /** *** */ 	// __webpack_public_path__
    /** *** */ 	__webpack_require__.p = '';
    /** *** */
    /** *** */
    /** *** */ 	// Load entry module and return exports
    /** *** */ 	return __webpack_require__(__webpack_require__.s = 'fb15');
    /** *** */ }({

    /***/ '03d6':
    /***/ (function (module, exports, __webpack_require__) {
      const has = __webpack_require__('9c0e');
      const toIObject = __webpack_require__('6ca1');
      const arrayIndexOf = __webpack_require__('39ad')(false);
      const IE_PROTO = __webpack_require__('5a94')('IE_PROTO');

      module.exports = function (object, names) {
        const O = toIObject(object);
        let i = 0;
        const result = [];
        let key;
        for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
        // Don't enum bug & hidden keys
        while (names.length > i) {
          if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }
        }
        return result;
      };
      /***/ }),

    /***/ '051b':
    /***/ (function (module, exports, __webpack_require__) {
      const dP = __webpack_require__('1a14');
      const createDesc = __webpack_require__('10db');
      module.exports = __webpack_require__('0bad') ? function (object, key, value) {
        return dP.f(object, key, createDesc(1, value));
      } : function (object, key, value) {
        object[key] = value;
        return object;
      };
      /***/ }),

    /***/ '05f5':
    /***/ (function (module, exports, __webpack_require__) {
      const isObject = __webpack_require__('7a41');
      const { document } = __webpack_require__('ef08');
      // typeof document.createElement is 'object' in old IE
      const is = isObject(document) && isObject(document.createElement);
      module.exports = function (it) {
        return is ? document.createElement(it) : {};
      };
      /***/ }),

    /***/ '072d':
    /***/ (function (module, exports, __webpack_require__) {
      // 19.1.2.1 Object.assign(target, source, ...)
      const DESCRIPTORS = __webpack_require__('0bad');
      const getKeys = __webpack_require__('9876');
      const gOPS = __webpack_require__('fed5');
      const pIE = __webpack_require__('1917');
      const toObject = __webpack_require__('0983');
      const IObject = __webpack_require__('9fbb');
      const $assign = Object.assign;

      // should work with symbols and should have deterministic property order (V8 bug)
      module.exports = !$assign || __webpack_require__('4b8b')(() => {
        const A = {};
        const B = {};
        // eslint-disable-next-line no-undef
        const S = Symbol();
        const K = 'abcdefghijklmnopqrst';
        A[S] = 7;
        K.split('').forEach((k) => { B[k] = k; });
        return ({ ...A })[S] != 7 || Object.keys({ ...B }).join('') != K;
      }) ? function assign(target, source) { // eslint-disable-line no-unused-vars
          const T = toObject(target);
          const aLen = arguments.length;
          let index = 1;
          const getSymbols = gOPS.f;
          const isEnum = pIE.f;
          while (aLen > index) {
            const S = IObject(arguments[index++]);
            const keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
            const { length } = keys;
            let j = 0;
            var key;
            while (length > j) {
              key = keys[j++];
              if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
            }
          } return T;
        } : $assign;
      /***/ }),

    /***/ '0983':
    /***/ (function (module, exports, __webpack_require__) {
      // 7.1.13 ToObject(argument)
      const defined = __webpack_require__('c901');
      module.exports = function (it) {
        return Object(defined(it));
      };
      /***/ }),

    /***/ '0ae2':
    /***/ (function (module, exports, __webpack_require__) {
      // all enumerable object keys, includes symbols
      const getKeys = __webpack_require__('9876');
      const gOPS = __webpack_require__('fed5');
      const pIE = __webpack_require__('1917');
      module.exports = function (it) {
        const result = getKeys(it);
        const getSymbols = gOPS.f;
        if (getSymbols) {
          const symbols = getSymbols(it);
          const isEnum = pIE.f;
          let i = 0;
          let key;
          while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
        } return result;
      };
      /***/ }),

    /***/ '0b99':
    /***/ (function (module, exports, __webpack_require__) {
      const $at = __webpack_require__('19fa')(true);

      // 21.1.3.27 String.prototype[@@iterator]()
      __webpack_require__('393a')(String, 'String', function (iterated) {
        this._t = String(iterated); // target
        this._i = 0; // next index
        // 21.1.5.2.1 %StringIteratorPrototype%.next()
      }, function () {
        const O = this._t;
        const index = this._i;
        let point;
        if (index >= O.length) return { value: undefined, done: true };
        point = $at(O, index);
        this._i += point.length;
        return { value: point, done: false };
      });
      /***/ }),

    /***/ '0bad':
    /***/ (function (module, exports, __webpack_require__) {
      // Thank's IE8 for his funny defineProperty
      module.exports = !__webpack_require__('4b8b')(() => Object.defineProperty({}, 'a', { get() { return 7; } }).a != 7);
      /***/ }),

    /***/ '0e15':
    /***/ (function (module, exports, __webpack_require__) {
      /* eslint-disable no-undefined */

      const throttle = __webpack_require__('597f');

      /**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}  [atBegin]     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                  to `callback` when the debounced-function is executed.
 *
 * @return {Function} A new, debounced function.
 */
      module.exports = function (delay, atBegin, callback) {
        return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
      };
      /***/ }),

    /***/ '0fae':
    /***/ (function (module, exports, __webpack_require__) {

      // extracted by mini-css-extract-plugin

      /***/ }),

    /***/ 1098:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      const _iterator = __webpack_require__('17ed');

      const _iterator2 = _interopRequireDefault(_iterator);

      const _symbol = __webpack_require__('f893');

      const _symbol2 = _interopRequireDefault(_symbol);

      const _typeof = typeof _symbol2.default === 'function' && typeof _iterator2.default === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === 'function' && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? 'symbol' : typeof obj; };

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      exports.default = typeof _symbol2.default === 'function' && _typeof(_iterator2.default) === 'symbol' ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
      } : function (obj) {
        return obj && typeof _symbol2.default === 'function' && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? 'symbol' : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
      };
      /***/ }),

    /***/ '10db':
    /***/ (function (module, exports) {
      module.exports = function (bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value,
        };
      };
      /***/ }),

    /***/ '12f2':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      exports.default = function (ref) {
        return {
          methods: {
            focus: function focus() {
              this.$refs[ref].focus();
            },
          },
        };
      };
      /***/ }),

    /***/ '14e9':
    /***/ (function (module, exports, __webpack_require__) {
      module.exports =
        /** *** */ (function (modules) { // webpackBootstrap
          /** *** */ 	// The module cache
          /** *** */ 	const installedModules = {};
          /** *** */
          /** *** */ 	// The require function
          /** *** */ 	function __webpack_require__(moduleId) {
            /** *** */
            /** *** */ 		// Check if module is in cache
            /** *** */ 		if (installedModules[moduleId]) {
              /** *** */ 			return installedModules[moduleId].exports;
              /** *** */ 		}
            /** *** */ 		// Create a new module (and put it into the cache)
            /** *** */ 		const module = installedModules[moduleId] = {
              /** *** */ 			i: moduleId,
              /** *** */ 			l: false,
              /** *** */ 			exports: {},
              /** *** */ 		};
            /** *** */
            /** *** */ 		// Execute the module function
            /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /** *** */
            /** *** */ 		// Flag the module as loaded
            /** *** */ 		module.l = true;
            /** *** */
            /** *** */ 		// Return the exports of the module
            /** *** */ 		return module.exports;
            /** *** */ 	}
          /** *** */
          /** *** */
          /** *** */ 	// expose the modules object (__webpack_modules__)
          /** *** */ 	__webpack_require__.m = modules;
          /** *** */
          /** *** */ 	// expose the module cache
          /** *** */ 	__webpack_require__.c = installedModules;
          /** *** */
          /** *** */ 	// define getter function for harmony exports
          /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
            /** *** */ 		if (!__webpack_require__.o(exports, name)) {
              /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
              /** *** */ 		}
            /** *** */ 	};
          /** *** */
          /** *** */ 	// define __esModule on exports
          /** *** */ 	__webpack_require__.r = function (exports) {
            /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
              /** *** */ 		}
            /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
            /** *** */ 	};
          /** *** */
          /** *** */ 	// create a fake namespace object
          /** *** */ 	// mode & 1: value is a module id, require it
          /** *** */ 	// mode & 2: merge all properties of value into the ns
          /** *** */ 	// mode & 4: return value when already ns object
          /** *** */ 	// mode & 8|1: behave like require
          /** *** */ 	__webpack_require__.t = function (value, mode) {
            /** *** */ 		if (mode & 1) value = __webpack_require__(value);
            /** *** */ 		if (mode & 8) return value;
            /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /** *** */ 		const ns = Object.create(null);
            /** *** */ 		__webpack_require__.r(ns);
            /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
            /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
            /** *** */ 		return ns;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
          /** *** */ 	__webpack_require__.n = function (module) {
            /** *** */ 		const getter = module && module.__esModule
            /** *** */ 			? function getDefault() { return module.default; }
            /** *** */ 			: function getModuleExports() { return module; };
            /** *** */ 		__webpack_require__.d(getter, 'a', getter);
            /** *** */ 		return getter;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// Object.prototype.hasOwnProperty.call
          /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
          /** *** */
          /** *** */ 	// __webpack_public_path__
          /** *** */ 	__webpack_require__.p = '/dist/';
          /** *** */
          /** *** */
          /** *** */ 	// Load entry module and return exports
          /** *** */ 	return __webpack_require__(__webpack_require__.s = 127);
          /** *** */ }({

          /***/ 127:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);

            // EXTERNAL MODULE: external "element-ui/lib/utils/resize-event"
            const resize_event_ = __webpack_require__(16);

            // EXTERNAL MODULE: external "element-ui/lib/utils/scrollbar-width"
            const scrollbar_width_ = __webpack_require__(38);
            const scrollbar_width_default = /* #__PURE__ */__webpack_require__.n(scrollbar_width_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/util"
            const util_ = __webpack_require__(3);

            // EXTERNAL MODULE: external "element-ui/lib/utils/dom"
            const dom_ = __webpack_require__(2);

            // CONCATENATED MODULE: ./packages/scrollbar/src/util.js
            const BAR_MAP = {
              vertical: {
                offset: 'offsetHeight',
                scroll: 'scrollTop',
                scrollSize: 'scrollHeight',
                size: 'height',
                key: 'vertical',
                axis: 'Y',
                client: 'clientY',
                direction: 'top',
              },
              horizontal: {
                offset: 'offsetWidth',
                scroll: 'scrollLeft',
                scrollSize: 'scrollWidth',
                size: 'width',
                key: 'horizontal',
                axis: 'X',
                client: 'clientX',
                direction: 'left',
              },
            };

            function renderThumbStyle(_ref) {
              const { move } = _ref;
              const { size } = _ref;
              const { bar } = _ref;

              const style = {};
              const translate = `translate${bar.axis}(${move}%)`;

              style[bar.size] = size;
              style.transform = translate;
              style.msTransform = translate;
              style.webkitTransform = translate;

              return style;
            }
            // CONCATENATED MODULE: ./packages/scrollbar/src/bar.js

            /* istanbul ignore next */
            /* harmony default export */ const src_bar = ({
              name: 'Bar',

              props: {
                vertical: Boolean,
                size: String,
                move: Number,
              },

              computed: {
                bar: function bar() {
                  return BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];
                },
                wrap: function wrap() {
                  return this.$parent.wrap;
                },
              },

              render: function render(h) {
                const { size } = this;
                const { move } = this;
                const { bar } = this;

                return h(
                  'div',
                  {
                    class: ['el-scrollbar__bar', `is-${bar.key}`],
                    on: {
                      mousedown: this.clickTrackHandler,
                    },
                  },
                  [h('div', {
                    ref: 'thumb',
                    class: 'el-scrollbar__thumb',
                    on: {
                      mousedown: this.clickThumbHandler,
                    },

                    style: renderThumbStyle({ size, move, bar }),
                  })],
                );
              },

              methods: {
                clickThumbHandler: function clickThumbHandler(e) {
                  // prevent click event of right button
                  if (e.ctrlKey || e.button === 2) {
                    return;
                  }
                  this.startDrag(e);
                  this[this.bar.axis] = e.currentTarget[this.bar.offset] - (e[this.bar.client] - e.currentTarget.getBoundingClientRect()[this.bar.direction]);
                },
                clickTrackHandler: function clickTrackHandler(e) {
                  const offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);
                  const thumbHalf = this.$refs.thumb[this.bar.offset] / 2;
                  const thumbPositionPercentage = (offset - thumbHalf) * 100 / this.$el[this.bar.offset];

                  this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
                },
                startDrag: function startDrag(e) {
                  e.stopImmediatePropagation();
                  this.cursorDown = true;

                  Object(dom_.on)(document, 'mousemove', this.mouseMoveDocumentHandler);
                  Object(dom_.on)(document, 'mouseup', this.mouseUpDocumentHandler);
                  document.onselectstart = function () {
                    return false;
                  };
                },
                mouseMoveDocumentHandler: function mouseMoveDocumentHandler(e) {
                  if (this.cursorDown === false) return;
                  const prevPage = this[this.bar.axis];

                  if (!prevPage) return;

                  const offset = (this.$el.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]) * -1;
                  const thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;
                  const thumbPositionPercentage = (offset - thumbClickPosition) * 100 / this.$el[this.bar.offset];

                  this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
                },
                mouseUpDocumentHandler: function mouseUpDocumentHandler(e) {
                  this.cursorDown = false;
                  this[this.bar.axis] = 0;
                  Object(dom_.off)(document, 'mousemove', this.mouseMoveDocumentHandler);
                  document.onselectstart = null;
                },
              },

              destroyed: function destroyed() {
                Object(dom_.off)(document, 'mouseup', this.mouseUpDocumentHandler);
              },
            });
            // CONCATENATED MODULE: ./packages/scrollbar/src/main.js
            // reference https://github.com/noeldelgado/gemini-scrollbar/blob/master/index.js

            /* istanbul ignore next */
            /* harmony default export */ const main = ({
              name: 'ElScrollbar',

              components: { Bar: src_bar },

              props: {
                native: Boolean,
                wrapStyle: {},
                wrapClass: {},
                viewClass: {},
                viewStyle: {},
                noresize: Boolean, // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
                tag: {
                  type: String,
                  default: 'div',
                },
              },

              data: function data() {
                return {
                  sizeWidth: '0',
                  sizeHeight: '0',
                  moveX: 0,
                  moveY: 0,
                };
              },

              computed: {
                wrap: function wrap() {
                  return this.$refs.wrap;
                },
              },

              render: function render(h) {
                const gutter = scrollbar_width_default()();
                let style = this.wrapStyle;

                if (gutter) {
                  const gutterWith = `-${gutter}px`;
                  const gutterStyle = `margin-bottom: ${gutterWith}; margin-right: ${gutterWith};`;

                  if (Array.isArray(this.wrapStyle)) {
                    style = Object(util_.toObject)(this.wrapStyle);
                    style.marginRight = style.marginBottom = gutterWith;
                  } else if (typeof this.wrapStyle === 'string') {
                    style += gutterStyle;
                  } else {
                    style = gutterStyle;
                  }
                }
                const view = h(this.tag, {
                  class: ['el-scrollbar__view', this.viewClass],
                  style: this.viewStyle,
                  ref: 'resize',
                }, this.$slots.default);
                const wrap = h(
                  'div',
                  {
                    ref: 'wrap',
                    style,
                    on: {
                      scroll: this.handleScroll,
                    },

                    class: [this.wrapClass, 'el-scrollbar__wrap', gutter ? '' : 'el-scrollbar__wrap--hidden-default'],
                  },
                  [[view]],
                );
                let nodes = void 0;

                if (!this.native) {
                  nodes = [wrap, h(src_bar, {
                    attrs: {
                      move: this.moveX,
                      size: this.sizeWidth,
                    },
                  }), h(src_bar, {
                    attrs: {
                      vertical: true,
                      move: this.moveY,
                      size: this.sizeHeight,
                    },
                  })];
                } else {
                  nodes = [h(
                    'div',
                    {
                      ref: 'wrap',
                      class: [this.wrapClass, 'el-scrollbar__wrap'],
                      style,
                    },
                    [[view]],
                  )];
                }
                return h('div', { class: 'el-scrollbar' }, nodes);
              },

              methods: {
                handleScroll: function handleScroll() {
                  const { wrap } = this;

                  this.moveY = wrap.scrollTop * 100 / wrap.clientHeight;
                  this.moveX = wrap.scrollLeft * 100 / wrap.clientWidth;
                },
                update: function update() {
                  let heightPercentage = void 0;
                  let widthPercentage = void 0;
                  const { wrap } = this;
                  if (!wrap) return;

                  heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
                  widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;

                  this.sizeHeight = heightPercentage < 100 ? `${heightPercentage}%` : '';
                  this.sizeWidth = widthPercentage < 100 ? `${widthPercentage}%` : '';
                },
              },

              mounted: function mounted() {
                if (this.native) return;
                this.$nextTick(this.update);
                !this.noresize && Object(resize_event_.addResizeListener)(this.$refs.resize, this.update);
              },
              beforeDestroy: function beforeDestroy() {
                if (this.native) return;
                !this.noresize && Object(resize_event_.removeResizeListener)(this.$refs.resize, this.update);
              },
            });
            // CONCATENATED MODULE: ./packages/scrollbar/index.js

            /* istanbul ignore next */
            main.install = function (Vue) {
              Vue.component(main.name, main);
            };

            /* harmony default export */ const scrollbar = __webpack_exports__.default = (main);
            /***/ }),

          /***/ 16:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('4010');
            /***/ }),

          /***/ 2:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('5924');
            /***/ }),

          /***/ 3:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8122');
            /***/ }),

          /***/ 38:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('e62d');
            /***/ }),

          /** *** */ }));
      /***/ }),

    /***/ 1609:
    /***/ (function (module, exports) {
      module.exports = function (it) {
        if (typeof it !== 'function') throw TypeError(`${it} is not a function!`);
        return it;
      };
      /***/ }),

    /***/ '17ed':
    /***/ (function (module, exports, __webpack_require__) {
      module.exports = { default: __webpack_require__('511f'), __esModule: true };
      /***/ }),

    /***/ 1836:
    /***/ (function (module, exports, __webpack_require__) {
      // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
      const toIObject = __webpack_require__('6ca1');
      const gOPN = __webpack_require__('6438').f;
      const { toString } = {};

      const windowNames = typeof window === 'object' && window && Object.getOwnPropertyNames
        ? Object.getOwnPropertyNames(window) : [];

      const getWindowNames = function (it) {
        try {
          return gOPN(it);
        } catch (e) {
          return windowNames.slice();
        }
      };

      module.exports.f = function getOwnPropertyNames(it) {
        return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
      };
      /***/ }),

    /***/ 1917:
    /***/ (function (module, exports) {
      exports.f = {}.propertyIsEnumerable;
      /***/ }),

    /***/ '19fa':
    /***/ (function (module, exports, __webpack_require__) {
      const toInteger = __webpack_require__('fc5e');
      const defined = __webpack_require__('c901');
      // true  -> String#at
      // false -> String#codePointAt
      module.exports = function (TO_STRING) {
        return function (that, pos) {
          const s = String(defined(that));
          const i = toInteger(pos);
          const l = s.length;
          let a; let
            b;
          if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
          a = s.charCodeAt(i);
          return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
            ? TO_STRING ? s.charAt(i) : a
            : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
        };
      };
      /***/ }),

    /***/ '1a14':
    /***/ (function (module, exports, __webpack_require__) {
      const anObject = __webpack_require__('77e9');
      const IE8_DOM_DEFINE = __webpack_require__('faf5');
      const toPrimitive = __webpack_require__('3397');
      const dP = Object.defineProperty;

      exports.f = __webpack_require__('0bad') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (IE8_DOM_DEFINE) {
          try {
            return dP(O, P, Attributes);
          } catch (e) { /* empty */ }
        }
        if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
        if ('value' in Attributes) O[P] = Attributes.value;
        return O;
      };
      /***/ }),

    /***/ '26dd':
    /***/ (function (module, exports, __webpack_require__) {
      const create = __webpack_require__('6f4f');
      const descriptor = __webpack_require__('10db');
      const setToStringTag = __webpack_require__('92f0');
      const IteratorPrototype = {};

      // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
      __webpack_require__('051b')(IteratorPrototype, __webpack_require__('cc15')('iterator'), function () { return this; });

      module.exports = function (Constructor, NAME, next) {
        Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
        setToStringTag(Constructor, `${NAME} Iterator`);
      };
      /***/ }),

    /***/ '299c':
    /***/ (function (module, exports, __webpack_require__) {
      module.exports =
        /** *** */ (function (modules) { // webpackBootstrap
          /** *** */ 	// The module cache
          /** *** */ 	const installedModules = {};
          /** *** */
          /** *** */ 	// The require function
          /** *** */ 	function __webpack_require__(moduleId) {
            /** *** */
            /** *** */ 		// Check if module is in cache
            /** *** */ 		if (installedModules[moduleId]) {
              /** *** */ 			return installedModules[moduleId].exports;
              /** *** */ 		}
            /** *** */ 		// Create a new module (and put it into the cache)
            /** *** */ 		const module = installedModules[moduleId] = {
              /** *** */ 			i: moduleId,
              /** *** */ 			l: false,
              /** *** */ 			exports: {},
              /** *** */ 		};
            /** *** */
            /** *** */ 		// Execute the module function
            /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /** *** */
            /** *** */ 		// Flag the module as loaded
            /** *** */ 		module.l = true;
            /** *** */
            /** *** */ 		// Return the exports of the module
            /** *** */ 		return module.exports;
            /** *** */ 	}
          /** *** */
          /** *** */
          /** *** */ 	// expose the modules object (__webpack_modules__)
          /** *** */ 	__webpack_require__.m = modules;
          /** *** */
          /** *** */ 	// expose the module cache
          /** *** */ 	__webpack_require__.c = installedModules;
          /** *** */
          /** *** */ 	// define getter function for harmony exports
          /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
            /** *** */ 		if (!__webpack_require__.o(exports, name)) {
              /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
              /** *** */ 		}
            /** *** */ 	};
          /** *** */
          /** *** */ 	// define __esModule on exports
          /** *** */ 	__webpack_require__.r = function (exports) {
            /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
              /** *** */ 		}
            /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
            /** *** */ 	};
          /** *** */
          /** *** */ 	// create a fake namespace object
          /** *** */ 	// mode & 1: value is a module id, require it
          /** *** */ 	// mode & 2: merge all properties of value into the ns
          /** *** */ 	// mode & 4: return value when already ns object
          /** *** */ 	// mode & 8|1: behave like require
          /** *** */ 	__webpack_require__.t = function (value, mode) {
            /** *** */ 		if (mode & 1) value = __webpack_require__(value);
            /** *** */ 		if (mode & 8) return value;
            /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /** *** */ 		const ns = Object.create(null);
            /** *** */ 		__webpack_require__.r(ns);
            /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
            /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
            /** *** */ 		return ns;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
          /** *** */ 	__webpack_require__.n = function (module) {
            /** *** */ 		const getter = module && module.__esModule
            /** *** */ 			? function getDefault() { return module.default; }
            /** *** */ 			: function getModuleExports() { return module; };
            /** *** */ 		__webpack_require__.d(getter, 'a', getter);
            /** *** */ 		return getter;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// Object.prototype.hasOwnProperty.call
          /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
          /** *** */
          /** *** */ 	// __webpack_public_path__
          /** *** */ 	__webpack_require__.p = '/dist/';
          /** *** */
          /** *** */
          /** *** */ 	// Load entry module and return exports
          /** *** */ 	return __webpack_require__(__webpack_require__.s = 131);
          /** *** */ }({

          /***/ 131:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);

            // EXTERNAL MODULE: external "element-ui/lib/utils/vue-popper"
            const vue_popper_ = __webpack_require__(5);
            const vue_popper_default = /* #__PURE__ */__webpack_require__.n(vue_popper_);

            // EXTERNAL MODULE: external "throttle-debounce/debounce"
            const debounce_ = __webpack_require__(17);
            const debounce_default = /* #__PURE__ */__webpack_require__.n(debounce_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/dom"
            const dom_ = __webpack_require__(2);

            // EXTERNAL MODULE: external "element-ui/lib/utils/util"
            const util_ = __webpack_require__(3);

            // EXTERNAL MODULE: external "vue"
            const external_vue_ = __webpack_require__(7);
            const external_vue_default = /* #__PURE__ */__webpack_require__.n(external_vue_);

            // CONCATENATED MODULE: ./packages/tooltip/src/main.js

            /* harmony default export */ const main = ({
              name: 'ElTooltip',

              mixins: [vue_popper_default.a],

              props: {
                openDelay: {
                  type: Number,
                  default: 0,
                },
                disabled: Boolean,
                manual: Boolean,
                effect: {
                  type: String,
                  default: 'dark',
                },
                arrowOffset: {
                  type: Number,
                  default: 0,
                },
                popperClass: String,
                content: String,
                visibleArrow: {
                  default: true,
                },
                transition: {
                  type: String,
                  default: 'el-fade-in-linear',
                },
                popperOptions: {
                  default: function _default() {
                    return {
                      boundariesPadding: 10,
                      gpuAcceleration: false,
                    };
                  },
                },
                enterable: {
                  type: Boolean,
                  default: true,
                },
                hideAfter: {
                  type: Number,
                  default: 0,
                },
                tabindex: {
                  type: Number,
                  default: 0,
                },
              },

              data: function data() {
                return {
                  tooltipId: `el-tooltip-${Object(util_.generateId)()}`,
                  timeoutPending: null,
                  focusing: false,
                };
              },
              beforeCreate: function beforeCreate() {
                const _this = this;

                if (this.$isServer) return;

                this.popperVM = new external_vue_default.a({
                  data: { node: '' },
                  render: function render(h) {
                    return this.node;
                  },
                }).$mount();

                this.debounceClose = debounce_default()(200, () => _this.handleClosePopper());
              },
              render: function render(h) {
                const _this2 = this;

                if (this.popperVM) {
                  this.popperVM.node = h(
                    'transition',
                    {
                      attrs: {
                        name: this.transition,
                      },
                      on: {
                        afterLeave: this.doDestroy,
                      },
                    },
                    [h(
                      'div',
                      {
                        on: {
                          mouseleave: function mouseleave() {
                            _this2.setExpectedState(false); _this2.debounceClose();
                          },
                          mouseenter: function mouseenter() {
                            _this2.setExpectedState(true);
                          },
                        },

                        ref: 'popper',
                        attrs: {
                          role: 'tooltip',
                          id: this.tooltipId,
                          'aria-hidden': this.disabled || !this.showPopper ? 'true' : 'false',
                        },
                        directives: [{
                          name: 'show',
                          value: !this.disabled && this.showPopper,
                        }],

                        class: ['el-tooltip__popper', `is-${this.effect}`, this.popperClass],
                      },
                      [this.$slots.content || this.content],
                    )],
                  );
                }

                const firstElement = this.getFirstElement();
                if (!firstElement) return null;

                const data = firstElement.data = firstElement.data || {};
                data.staticClass = this.addTooltipClass(data.staticClass);

                return firstElement;
              },
              mounted: function mounted() {
                const _this3 = this;

                this.referenceElm = this.$el;
                if (this.$el.nodeType === 1) {
                  this.$el.setAttribute('aria-describedby', this.tooltipId);
                  this.$el.setAttribute('tabindex', this.tabindex);
                  Object(dom_.on)(this.referenceElm, 'mouseenter', this.show);
                  Object(dom_.on)(this.referenceElm, 'mouseleave', this.hide);
                  Object(dom_.on)(this.referenceElm, 'focus', () => {
                    if (!_this3.$slots.default || !_this3.$slots.default.length) {
                      _this3.handleFocus();
                      return;
                    }
                    const instance = _this3.$slots.default[0].componentInstance;
                    if (instance && instance.focus) {
                      instance.focus();
                    } else {
                      _this3.handleFocus();
                    }
                  });
                  Object(dom_.on)(this.referenceElm, 'blur', this.handleBlur);
                  Object(dom_.on)(this.referenceElm, 'click', this.removeFocusing);
                }
                // fix issue https://github.com/ElemeFE/element/issues/14424
                if (this.value && this.popperVM) {
                  this.popperVM.$nextTick(() => {
                    if (_this3.value) {
                      _this3.updatePopper();
                    }
                  });
                }
              },

              watch: {
                focusing: function focusing(val) {
                  if (val) {
                    Object(dom_.addClass)(this.referenceElm, 'focusing');
                  } else {
                    Object(dom_.removeClass)(this.referenceElm, 'focusing');
                  }
                },
              },
              methods: {
                show: function show() {
                  this.setExpectedState(true);
                  this.handleShowPopper();
                },
                hide: function hide() {
                  this.setExpectedState(false);
                  this.debounceClose();
                },
                handleFocus: function handleFocus() {
                  this.focusing = true;
                  this.show();
                },
                handleBlur: function handleBlur() {
                  this.focusing = false;
                  this.hide();
                },
                removeFocusing: function removeFocusing() {
                  this.focusing = false;
                },
                addTooltipClass: function addTooltipClass(prev) {
                  if (!prev) {
                    return 'el-tooltip';
                  }
                  return `el-tooltip ${prev.replace('el-tooltip', '')}`;
                },
                handleShowPopper: function handleShowPopper() {
                  const _this4 = this;

                  if (!this.expectedState || this.manual) return;
                  clearTimeout(this.timeout);
                  this.timeout = setTimeout(() => {
                    _this4.showPopper = true;
                  }, this.openDelay);

                  if (this.hideAfter > 0) {
                    this.timeoutPending = setTimeout(() => {
                      _this4.showPopper = false;
                    }, this.hideAfter);
                  }
                },
                handleClosePopper: function handleClosePopper() {
                  if (this.enterable && this.expectedState || this.manual) return;
                  clearTimeout(this.timeout);

                  if (this.timeoutPending) {
                    clearTimeout(this.timeoutPending);
                  }
                  this.showPopper = false;

                  if (this.disabled) {
                    this.doDestroy();
                  }
                },
                setExpectedState: function setExpectedState(expectedState) {
                  if (expectedState === false) {
                    clearTimeout(this.timeoutPending);
                  }
                  this.expectedState = expectedState;
                },
                getFirstElement: function getFirstElement() {
                  const slots = this.$slots.default;
                  if (!Array.isArray(slots)) return null;
                  let element = null;
                  for (let index = 0; index < slots.length; index++) {
                    if (slots[index] && slots[index].tag) {
                      element = slots[index];
                    }
                  }
                  return element;
                },
              },

              beforeDestroy: function beforeDestroy() {
                this.popperVM && this.popperVM.$destroy();
              },
              destroyed: function destroyed() {
                const reference = this.referenceElm;
                if (reference.nodeType === 1) {
                  Object(dom_.off)(reference, 'mouseenter', this.show);
                  Object(dom_.off)(reference, 'mouseleave', this.hide);
                  Object(dom_.off)(reference, 'focus', this.handleFocus);
                  Object(dom_.off)(reference, 'blur', this.handleBlur);
                  Object(dom_.off)(reference, 'click', this.removeFocusing);
                }
              },
            });
            // CONCATENATED MODULE: ./packages/tooltip/index.js

            /* istanbul ignore next */
            main.install = function (Vue) {
              Vue.component(main.name, main);
            };

            /* harmony default export */ const tooltip = __webpack_exports__.default = (main);
            /***/ }),

          /***/ 17:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('0e15');
            /***/ }),

          /***/ 2:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('5924');
            /***/ }),

          /***/ 3:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8122');
            /***/ }),

          /***/ 5:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('e974');
            /***/ }),

          /***/ 7:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8bbf');
            /***/ }),

          /** *** */ }));
      /***/ }),

    /***/ '2a5e':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;
      exports.default = scrollIntoView;

      const _vue = __webpack_require__('8bbf');

      const _vue2 = _interopRequireDefault(_vue);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      function scrollIntoView(container, selected) {
        if (_vue2.default.prototype.$isServer) return;

        if (!selected) {
          container.scrollTop = 0;
          return;
        }

        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;

        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      /***/ }),

    /***/ '2bb5':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      const _util = __webpack_require__('8122');

      /**
 * Show migrating guide in browser console.
 *
 * Usage:
 * import Migrating from 'element-ui/src/mixins/migrating';
 *
 * mixins: [Migrating]
 *
 * add getMigratingConfig method for your component.
 *  getMigratingConfig() {
 *    return {
 *      props: {
 *        'allow-no-selection': 'allow-no-selection is removed.',
 *        'selection-mode': 'selection-mode is removed.'
 *      },
 *      events: {
 *        selectionchange: 'selectionchange is renamed to selection-change.'
 *      }
 *    };
 *  },
 */
      exports.default = {
        mounted: function mounted() {
          if (true) return;
          if (!this.$vnode) return;

          const _getMigratingConfig = this.getMigratingConfig();
          const _getMigratingConfig$p = _getMigratingConfig.props;
          const props = _getMigratingConfig$p === undefined ? {} : _getMigratingConfig$p;
          const _getMigratingConfig$e = _getMigratingConfig.events;
          const events = _getMigratingConfig$e === undefined ? {} : _getMigratingConfig$e;

          const _$vnode = this.$vnode;
          const { data } = _$vnode;
          const { componentOptions } = _$vnode;

          const definedProps = data.attrs || {};
          const definedEvents = componentOptions.listeners || {};

          for (let propName in definedProps) {
            propName = (0, _util.kebabCase)(propName); // compatible with camel case
            if (props[propName]) {
              console.warn(`[Element Migrating][${this.$options.name}][Attribute]: ${props[propName]}`);
            }
          }

          for (let eventName in definedEvents) {
            eventName = (0, _util.kebabCase)(eventName); // compatible with camel case
            if (events[eventName]) {
              console.warn(`[Element Migrating][${this.$options.name}][Event]: ${events[eventName]}`);
            }
          }
        },

        methods: {
          getMigratingConfig: function getMigratingConfig() {
            return {
              props: {},
              events: {},
            };
          },
        },
      };
      /***/ }),

    /***/ '2f9a':
    /***/ (function (module, exports) {
      module.exports = function () { /* empty */ };
      /***/ }),

    /***/ '301c':
    /***/ (function (module, exports, __webpack_require__) {
      __webpack_require__('e198')('asyncIterator');
      /***/ }),

    /***/ 3397:
    /***/ (function (module, exports, __webpack_require__) {
      // 7.1.1 ToPrimitive(input [, PreferredType])
      const isObject = __webpack_require__('7a41');
      // instead of the ES6 spec version, we didn't implement @@toPrimitive case
      // and the second argument - flag - preferred type is a string
      module.exports = function (it, S) {
        if (!isObject(it)) return it;
        let fn; let
          val;
        if (S && typeof (fn = it.toString) === 'function' && !isObject(val = fn.call(it))) return val;
        if (typeof (fn = it.valueOf) === 'function' && !isObject(val = fn.call(it))) return val;
        if (!S && typeof (fn = it.toString) === 'function' && !isObject(val = fn.call(it))) return val;
        throw TypeError("Can't convert object to primitive value");
      };
      /***/ }),

    /***/ '393a':
    /***/ (function (module, exports, __webpack_require__) {
      const LIBRARY = __webpack_require__('e444');
      const $export = __webpack_require__('512c');
      const redefine = __webpack_require__('ba01');
      const hide = __webpack_require__('051b');
      const Iterators = __webpack_require__('8a0d');
      const $iterCreate = __webpack_require__('26dd');
      const setToStringTag = __webpack_require__('92f0');
      const getPrototypeOf = __webpack_require__('ce7a');
      const ITERATOR = __webpack_require__('cc15')('iterator');
      const BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
      const FF_ITERATOR = '@@iterator';
      const KEYS = 'keys';
      const VALUES = 'values';

      const returnThis = function () { return this; };

      module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
        $iterCreate(Constructor, NAME, next);
        const getMethod = function (kind) {
          if (!BUGGY && kind in proto) return proto[kind];
          switch (kind) {
            case KEYS: return function keys() { return new Constructor(this, kind); };
            case VALUES: return function values() { return new Constructor(this, kind); };
          } return function entries() { return new Constructor(this, kind); };
        };
        const TAG = `${NAME} Iterator`;
        const DEF_VALUES = DEFAULT == VALUES;
        let VALUES_BUG = false;
        var proto = Base.prototype;
        const $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
        let $default = $native || getMethod(DEFAULT);
        const $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
        const $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
        let methods; let key; let
          IteratorPrototype;
        // Fix native
        if ($anyNative) {
          IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
          if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
            // Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, true);
            // fix for some old engines
            if (!LIBRARY && typeof IteratorPrototype[ITERATOR] !== 'function') hide(IteratorPrototype, ITERATOR, returnThis);
          }
        }
        // fix Array#{values, @@iterator}.name in V8 / FF
        if (DEF_VALUES && $native && $native.name !== VALUES) {
          VALUES_BUG = true;
          $default = function values() { return $native.call(this); };
        }
        // Define iterator
        if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
          hide(proto, ITERATOR, $default);
        }
        // Plug for library
        Iterators[NAME] = $default;
        Iterators[TAG] = returnThis;
        if (DEFAULT) {
          methods = {
            values: DEF_VALUES ? $default : getMethod(VALUES),
            keys: IS_SET ? $default : getMethod(KEYS),
            entries: $entries,
          };
          if (FORCED) {
            for (key in methods) {
              if (!(key in proto)) redefine(proto, key, methods[key]);
            }
          } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
        }
        return methods;
      };
      /***/ }),

    /***/ '39ad':
    /***/ (function (module, exports, __webpack_require__) {
      // false -> Array#indexOf
      // true  -> Array#includes
      const toIObject = __webpack_require__('6ca1');
      const toLength = __webpack_require__('d16a');
      const toAbsoluteIndex = __webpack_require__('9d11');
      module.exports = function (IS_INCLUDES) {
        return function ($this, el, fromIndex) {
          const O = toIObject($this);
          const length = toLength(O.length);
          let index = toAbsoluteIndex(fromIndex, length);
          let value;
          // Array#includes uses SameValueZero equality algorithm
          // eslint-disable-next-line no-self-compare
          if (IS_INCLUDES && el != el) {
            while (length > index) {
              value = O[index++];
              // eslint-disable-next-line no-self-compare
              if (value != value) return true;
            // Array#indexOf ignores holes, Array#includes - not
            }
          } else {
            for (;length > index; index++) {
              if (IS_INCLUDES || index in O) {
                if (O[index] === el) return IS_INCLUDES || index || 0;
              }
            }
          } return !IS_INCLUDES && -1;
        };
      };
      /***/ }),

    /***/ '39d8':
    /***/ (function (module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_show_overflow_tooltip_vue_vue_type_style_index_0_id_2640221e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__('b449');
      /* harmony import */ const _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_show_overflow_tooltip_vue_vue_type_style_index_0_id_2640221e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /* #__PURE__ */__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_show_overflow_tooltip_vue_vue_type_style_index_0_id_2640221e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
      /* unused harmony reexport * */
      /***/ }),

    /***/ '3c4e':
    /***/ (function (module, exports, __webpack_require__) {
      const isMergeableObject = function isMergeableObject(value) {
        return isNonNullObject(value)
		&& !isSpecial(value);
      };

      function isNonNullObject(value) {
        return !!value && typeof value === 'object';
      }

      function isSpecial(value) {
        const stringValue = Object.prototype.toString.call(value);

        return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value);
      }

      // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
      const canUseSymbol = typeof Symbol === 'function' && Symbol.for;
      const REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

      function isReactElement(value) {
        return value.$$typeof === REACT_ELEMENT_TYPE;
      }

      function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
      }

      function cloneIfNecessary(value, optionsArgument) {
        const clone = optionsArgument && optionsArgument.clone === true;
        return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
      }

      function defaultArrayMerge(target, source, optionsArgument) {
        const destination = target.slice();
        source.forEach((e, i) => {
          if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument);
          } else if (isMergeableObject(e)) {
            destination[i] = deepmerge(target[i], e, optionsArgument);
          } else if (target.indexOf(e) === -1) {
            destination.push(cloneIfNecessary(e, optionsArgument));
          }
        });
        return destination;
      }

      function mergeObject(target, source, optionsArgument) {
        const destination = {};
        if (isMergeableObject(target)) {
          Object.keys(target).forEach((key) => {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
          });
        }
        Object.keys(source).forEach((key) => {
          if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument);
          } else {
            destination[key] = deepmerge(target[key], source[key], optionsArgument);
          }
        });
        return destination;
      }

      function deepmerge(target, source, optionsArgument) {
        const sourceIsArray = Array.isArray(source);
        const targetIsArray = Array.isArray(target);
        const options = optionsArgument || { arrayMerge: defaultArrayMerge };
        const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

        if (!sourceAndTargetTypesMatch) {
          return cloneIfNecessary(source, optionsArgument);
        } if (sourceIsArray) {
          const arrayMerge = options.arrayMerge || defaultArrayMerge;
          return arrayMerge(target, source, optionsArgument);
        }
        return mergeObject(target, source, optionsArgument);
      }

      deepmerge.all = function deepmergeAll(array, optionsArgument) {
        if (!Array.isArray(array) || array.length < 2) {
          throw new Error('first argument should be an array with at least two elements');
        }

        // we are sure there are at least 2 values, so it is safe to have no initial value
        return array.reduce((prev, next) => deepmerge(prev, next, optionsArgument));
      };

      const deepmerge_1 = deepmerge;

      module.exports = deepmerge_1;
      /***/ }),

    /***/ '3f6b':
    /***/ (function (module, exports, __webpack_require__) {
      module.exports = { default: __webpack_require__('b9c7'), __esModule: true };
      /***/ }),

    /***/ 4010:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;
      exports.removeResizeListener = exports.addResizeListener = undefined;

      const _resizeObserverPolyfill = __webpack_require__('6dd8');

      const _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      const isServer = typeof window === 'undefined';

      /* istanbul ignore next */
      const resizeHandler = function resizeHandler(entries) {
        for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          const entry = _ref;

          const listeners = entry.target.__resizeListeners__ || [];
          if (listeners.length) {
            listeners.forEach((fn) => {
              fn();
            });
          }
        }
      };

      /* istanbul ignore next */
      const addResizeListener = exports.addResizeListener = function addResizeListener(element, fn) {
        if (isServer) return;
        if (!element.__resizeListeners__) {
          element.__resizeListeners__ = [];
          element.__ro__ = new _resizeObserverPolyfill2.default(resizeHandler);
          element.__ro__.observe(element);
        }
        element.__resizeListeners__.push(fn);
      };

      /* istanbul ignore next */
      const removeResizeListener = exports.removeResizeListener = function removeResizeListener(element, fn) {
        if (!element || !element.__resizeListeners__) return;
        element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
        if (!element.__resizeListeners__.length) {
          element.__ro__.disconnect();
        }
      };
      /***/ }),

    /***/ '417f':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      const _vue = __webpack_require__('8bbf');

      const _vue2 = _interopRequireDefault(_vue);

      const _dom = __webpack_require__('5924');

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      const nodeList = [];
      const ctx = '@@clickoutsideContext';

      let startClick = void 0;
      let seed = 0;

      !_vue2.default.prototype.$isServer && (0, _dom.on)(document, 'mousedown', (e) => startClick = e);

      !_vue2.default.prototype.$isServer && (0, _dom.on)(document, 'mouseup', (e) => {
        nodeList.forEach((node) => node[ctx].documentHandler(e, startClick));
      });

      function createDocumentHandler(el, binding, vnode) {
        return function () {
          const mouseup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          const mousedown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          if (!vnode || !vnode.context || !mouseup.target || !mousedown.target || el.contains(mouseup.target) || el.contains(mousedown.target) || el === mouseup.target || vnode.context.popperElm && (vnode.context.popperElm.contains(mouseup.target) || vnode.context.popperElm.contains(mousedown.target))) return;

          if (binding.expression && el[ctx].methodName && vnode.context[el[ctx].methodName]) {
            vnode.context[el[ctx].methodName]();
          } else {
            el[ctx].bindingFn && el[ctx].bindingFn();
          }
        };
      }

      /**
 * v-clickoutside
 * @desc 点击元素外面才会触发的事件
 * @example
 * ```vue
 * <div v-element-clickoutside="handleClose">
 * ```
 */
      exports.default = {
        bind: function bind(el, binding, vnode) {
          nodeList.push(el);
          const id = seed++;
          el[ctx] = {
            id,
            documentHandler: createDocumentHandler(el, binding, vnode),
            methodName: binding.expression,
            bindingFn: binding.value,
          };
        },
        update: function update(el, binding, vnode) {
          el[ctx].documentHandler = createDocumentHandler(el, binding, vnode);
          el[ctx].methodName = binding.expression;
          el[ctx].bindingFn = binding.value;
        },
        unbind: function unbind(el) {
          const len = nodeList.length;

          for (let i = 0; i < len; i++) {
            if (nodeList[i][ctx].id === el[ctx].id) {
              nodeList.splice(i, 1);
              break;
            }
          }
          delete el[ctx];
        },
      };
      /***/ }),

    /***/ '41b2':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      const _assign = __webpack_require__('3f6b');

      const _assign2 = _interopRequireDefault(_assign);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      exports.default = _assign2.default || function (target) {
        for (let i = 1; i < arguments.length; i++) {
          const source = arguments[i];

          for (const key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };
      /***/ }),

    /***/ '41f8':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

      exports.isVNode = isVNode;

      const _util = __webpack_require__('8122');

      function isVNode(node) {
        return node !== null && (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && (0, _util.hasOwn)(node, 'componentOptions');
      }
      /***/ }),

    /***/ 4726:
    /***/ (function (module, exports, __webpack_require__) {
      module.exports =
        /** *** */ (function (modules) { // webpackBootstrap
          /** *** */ 	// The module cache
          /** *** */ 	const installedModules = {};
          /** *** */
          /** *** */ 	// The require function
          /** *** */ 	function __webpack_require__(moduleId) {
            /** *** */
            /** *** */ 		// Check if module is in cache
            /** *** */ 		if (installedModules[moduleId]) {
              /** *** */ 			return installedModules[moduleId].exports;
              /** *** */ 		}
            /** *** */ 		// Create a new module (and put it into the cache)
            /** *** */ 		const module = installedModules[moduleId] = {
              /** *** */ 			i: moduleId,
              /** *** */ 			l: false,
              /** *** */ 			exports: {},
              /** *** */ 		};
            /** *** */
            /** *** */ 		// Execute the module function
            /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /** *** */
            /** *** */ 		// Flag the module as loaded
            /** *** */ 		module.l = true;
            /** *** */
            /** *** */ 		// Return the exports of the module
            /** *** */ 		return module.exports;
            /** *** */ 	}
          /** *** */
          /** *** */
          /** *** */ 	// expose the modules object (__webpack_modules__)
          /** *** */ 	__webpack_require__.m = modules;
          /** *** */
          /** *** */ 	// expose the module cache
          /** *** */ 	__webpack_require__.c = installedModules;
          /** *** */
          /** *** */ 	// define getter function for harmony exports
          /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
            /** *** */ 		if (!__webpack_require__.o(exports, name)) {
              /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
              /** *** */ 		}
            /** *** */ 	};
          /** *** */
          /** *** */ 	// define __esModule on exports
          /** *** */ 	__webpack_require__.r = function (exports) {
            /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
              /** *** */ 		}
            /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
            /** *** */ 	};
          /** *** */
          /** *** */ 	// create a fake namespace object
          /** *** */ 	// mode & 1: value is a module id, require it
          /** *** */ 	// mode & 2: merge all properties of value into the ns
          /** *** */ 	// mode & 4: return value when already ns object
          /** *** */ 	// mode & 8|1: behave like require
          /** *** */ 	__webpack_require__.t = function (value, mode) {
            /** *** */ 		if (mode & 1) value = __webpack_require__(value);
            /** *** */ 		if (mode & 8) return value;
            /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /** *** */ 		const ns = Object.create(null);
            /** *** */ 		__webpack_require__.r(ns);
            /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
            /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
            /** *** */ 		return ns;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
          /** *** */ 	__webpack_require__.n = function (module) {
            /** *** */ 		const getter = module && module.__esModule
            /** *** */ 			? function getDefault() { return module.default; }
            /** *** */ 			: function getModuleExports() { return module; };
            /** *** */ 		__webpack_require__.d(getter, 'a', getter);
            /** *** */ 		return getter;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// Object.prototype.hasOwnProperty.call
          /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
          /** *** */
          /** *** */ 	// __webpack_public_path__
          /** *** */ 	__webpack_require__.p = '/dist/';
          /** *** */
          /** *** */
          /** *** */ 	// Load entry module and return exports
          /** *** */ 	return __webpack_require__(__webpack_require__.s = 59);
          /** *** */ }({

          /***/ 0:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'a', () => normalizeComponent);
            /* globals __VUE_SSR_CONTEXT__ */

            // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
            // This module is a runtime utility for cleaner component module output and will
            // be included in the final webpack user bundle.

            function normalizeComponent(
              scriptExports,
              render,
              staticRenderFns,
              functionalTemplate,
              injectStyles,
              scopeId,
              moduleIdentifier, /* server only */
              shadowMode, /* vue-cli only */
            ) {
              // Vue.extend constructor export interop
              const options = typeof scriptExports === 'function'
                ? scriptExports.options
                : scriptExports;

              // render functions
              if (render) {
                options.render = render;
                options.staticRenderFns = staticRenderFns;
                options._compiled = true;
              }

              // functional template
              if (functionalTemplate) {
                options.functional = true;
              }

              // scopedId
              if (scopeId) {
                options._scopeId = `data-v-${scopeId}`;
              }

              let hook;
              if (moduleIdentifier) { // server build
                hook = function (context) {
                  // 2.3 injection
                  context = context // cached call
        || (this.$vnode && this.$vnode.ssrContext) // stateful
        || (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
                  // 2.2 with runInNewContext: true
                  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                    context = __VUE_SSR_CONTEXT__;
                  }
                  // inject component styles
                  if (injectStyles) {
                    injectStyles.call(this, context);
                  }
                  // register component module identifier for async chunk inferrence
                  if (context && context._registeredComponents) {
                    context._registeredComponents.add(moduleIdentifier);
                  }
                };
                // used by ssr in case component is cached and beforeCreate
                // never gets called
                options._ssrRegister = hook;
              } else if (injectStyles) {
                hook = shadowMode
                  ? function () { injectStyles.call(this, this.$root.$options.shadowRoot); }
                  : injectStyles;
              }

              if (hook) {
                if (options.functional) {
                  // for template-only hot-reload because in that case the render fn doesn't
                  // go through the normalizer
                  options._injectStyles = hook;
                  // register for functioal component in vue file
                  const originalRender = options.render;
                  options.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context);
                  };
                } else {
                  // inject component registration as beforeCreate hook
                  const existing = options.beforeCreate;
                  options.beforeCreate = existing
                    ? [].concat(existing, hook)
                    : [hook];
                }
              }

              return {
                exports: scriptExports,
                options,
              };
            }
            /***/ }),

          /***/ 14:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('14e9');
            /***/ }),

          /***/ 18:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('dcdc');
            /***/ }),

          /***/ 21:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('d397');
            /***/ }),

          /***/ 26:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('92fa');
            /***/ }),

          /***/ 3:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8122');
            /***/ }),

          /***/ 31:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('2a5e');
            /***/ }),

          /***/ 40:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('e452');
            /***/ }),

          /***/ 51:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('f494');
            /***/ }),

          /***/ 59:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader-panel/src/cascader-panel.vue?vue&type=template&id=34932346&
            const cascader_panelvue_type_template_id_34932346_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  class: ['el-cascader-panel', _vm.border && 'is-bordered'],
                  on: { keydown: _vm.handleKeyDown },
                },
                _vm._l(_vm.menus, (menu, index) => _c('cascader-menu', {
                  key: index,
                  ref: 'menu',
                  refInFor: true,
                  attrs: { index, nodes: menu },
                })),
                1,
              );
            };
            const staticRenderFns = [];
            cascader_panelvue_type_template_id_34932346_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-panel.vue?vue&type=template&id=34932346&

            // EXTERNAL MODULE: external "babel-helper-vue-jsx-merge-props"
            const external_babel_helper_vue_jsx_merge_props_ = __webpack_require__(26);
            const external_babel_helper_vue_jsx_merge_props_default = /* #__PURE__ */__webpack_require__.n(external_babel_helper_vue_jsx_merge_props_);

            // EXTERNAL MODULE: external "element-ui/lib/scrollbar"
            const scrollbar_ = __webpack_require__(14);
            const scrollbar_default = /* #__PURE__ */__webpack_require__.n(scrollbar_);

            // EXTERNAL MODULE: external "element-ui/lib/checkbox"
            const checkbox_ = __webpack_require__(18);
            const checkbox_default = /* #__PURE__ */__webpack_require__.n(checkbox_);

            // EXTERNAL MODULE: external "element-ui/lib/radio"
            const radio_ = __webpack_require__(51);
            const radio_default = /* #__PURE__ */__webpack_require__.n(radio_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/util"
            const util_ = __webpack_require__(3);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader-panel/src/cascader-node.vue?vue&type=script&lang=js&

            const stopPropagation = function stopPropagation(e) {
              return e.stopPropagation();
            };

            /* harmony default export */ const cascader_nodevue_type_script_lang_js_ = ({
              inject: ['panel'],

              components: {
                ElCheckbox: checkbox_default.a,
                ElRadio: radio_default.a,
              },

              props: {
                node: {
                  required: true,
                },
                nodeId: String,
              },

              computed: {
                config: function config() {
                  return this.panel.config;
                },
                isLeaf: function isLeaf() {
                  return this.node.isLeaf;
                },
                isDisabled: function isDisabled() {
                  return this.node.isDisabled;
                },
                checkedValue: function checkedValue() {
                  return this.panel.checkedValue;
                },
                isChecked: function isChecked() {
                  return this.node.isSameNode(this.checkedValue);
                },
                inActivePath: function inActivePath() {
                  return this.isInPath(this.panel.activePath);
                },
                inCheckedPath: function inCheckedPath() {
                  const _this = this;

                  if (!this.config.checkStrictly) return false;

                  return this.panel.checkedNodePaths.some((checkedPath) => _this.isInPath(checkedPath));
                },
                value: function value() {
                  return this.node.getValueByOption();
                },
              },

              methods: {
                handleExpand: function handleExpand() {
                  const _this2 = this;

                  const { panel } = this;
                  const { node } = this;
                  const { isDisabled } = this;
                  const { config } = this;
                  const { multiple } = config;
                  const { checkStrictly } = config;

                  if (!checkStrictly && isDisabled || node.loading) return;

                  if (config.lazy && !node.loaded) {
                    panel.lazyLoad(node, () => {
                      // do not use cached leaf value here, invoke this.isLeaf to get new value.
                      const { isLeaf } = _this2;

                      if (!isLeaf) _this2.handleExpand();
                      if (multiple) {
                        // if leaf sync checked state, else clear checked state
                        const checked = isLeaf ? node.checked : false;
                        _this2.handleMultiCheckChange(checked);
                      }
                    });
                  } else {
                    panel.handleExpand(node);
                  }
                },
                handleCheckChange: function handleCheckChange() {
                  const { panel } = this;
                  const { value } = this;
                  const { node } = this;

                  panel.handleCheckChange(value);
                  panel.handleExpand(node);
                },
                handleMultiCheckChange: function handleMultiCheckChange(checked) {
                  this.node.doCheck(checked);
                  this.panel.calculateMultiCheckedValue();
                },
                isInPath: function isInPath(pathNodes) {
                  const { node } = this;

                  const selectedPathNode = pathNodes[node.level - 1] || {};
                  return selectedPathNode.uid === node.uid;
                },
                renderPrefix: function renderPrefix(h) {
                  const { isLeaf } = this;
                  var {isChecked} = this;
                  var {config} = this;
                  const { checkStrictly } = config;
                  var {multiple} = config;

                  if (multiple) {
                    return this.renderCheckbox(h);
                  } if (checkStrictly) {
                    return this.renderRadio(h);
                  } if (isLeaf && isChecked) {
                    return this.renderCheckIcon(h);
                  }

                  return null;
                },
                renderPostfix: function renderPostfix(h) {
                  const { node } = this;
                  let { isLeaf } = this;

                  if (node.loading) {
                    return this.renderLoadingIcon(h);
                  } if (!isLeaf) {
                    return this.renderExpandIcon(h);
                  }

                  return null;
                },
                renderCheckbox: function renderCheckbox(h) {
                  const { node } = this;
                  const { config } = this;
                  const { isDisabled } = this;

                  const events = {
                    on: { change: this.handleMultiCheckChange },
                    nativeOn: {},
                  };

                  if (config.checkStrictly) {
                    // when every node is selectable, click event should not trigger expand event.
                    events.nativeOn.click = stopPropagation;
                  }

                  return h('el-checkbox', external_babel_helper_vue_jsx_merge_props_default()([{
                    attrs: {
                      value: node.checked,
                      indeterminate: node.indeterminate,
                      disabled: isDisabled,
                    },
                  }, events]));
                },
                renderRadio: function renderRadio(h) {
                  const { checkedValue } = this;
                  let { value } = this;
                  const { isDisabled } = this;

                  // to keep same reference if value cause radio's checked state is calculated by reference comparision;

                  if (Object(util_.isEqual)(value, checkedValue)) {
                    value = checkedValue;
                  }

                  return h(
                    'el-radio',
                    {
                      attrs: {
                        value: checkedValue,
                        label: value,
                        disabled: isDisabled,
                      },
                      on: {
                        change: this.handleCheckChange,
                      },
                      nativeOn: {
                        click: stopPropagation,
                      },
                    },
                    [h('span')],
                  );
                },
                renderCheckIcon: function renderCheckIcon(h) {
                  return h('i', { class: 'el-icon-check el-cascader-node__prefix' });
                },
                renderLoadingIcon: function renderLoadingIcon(h) {
                  return h('i', { class: 'el-icon-loading el-cascader-node__postfix' });
                },
                renderExpandIcon: function renderExpandIcon(h) {
                  return h('i', { class: 'el-icon-arrow-right el-cascader-node__postfix' });
                },
                renderContent: function renderContent(h) {
                  const { panel } = this;
                  const { node } = this;

                  const render = panel.renderLabelFn;
                  const vnode = render ? render({ node, data: node.data }) : null;

                  return h(
                    'span',
                    { class: 'el-cascader-node__label' },
                    [vnode || node.label],
                  );
                },
              },

              render: function render(h) {
                const _this3 = this;

                const { inActivePath } = this;
                const { inCheckedPath } = this;
                const { isChecked } = this;
                const { isLeaf } = this;
                const { isDisabled } = this;
                const { config } = this;
                const { nodeId } = this;
                const { expandTrigger } = config;
                const { checkStrictly } = config;
                const { multiple } = config;

                const disabled = !checkStrictly && isDisabled;
                const events = { on: {} };

                if (expandTrigger === 'click') {
                  events.on.click = this.handleExpand;
                } else {
                  events.on.mouseenter = function (e) {
                    _this3.handleExpand();
                    _this3.$emit('expand', e);
                  };
                  events.on.focus = function (e) {
                    _this3.handleExpand();
                    _this3.$emit('expand', e);
                  };
                }
                if (isLeaf && !isDisabled && !checkStrictly && !multiple) {
                  events.on.click = this.handleCheckChange;
                }

                return h(
                  'li',
                  external_babel_helper_vue_jsx_merge_props_default()([{
                    attrs: {
                      role: 'menuitem',
                      id: nodeId,
                      'aria-expanded': inActivePath,
                      tabindex: disabled ? null : -1,
                    },
                    class: {
                      'el-cascader-node': true,
                      'is-selectable': checkStrictly,
                      'in-active-path': inActivePath,
                      'in-checked-path': inCheckedPath,
                      'is-active': isChecked,
                      'is-disabled': disabled,
                    },
                  }, events]),
                  [this.renderPrefix(h), this.renderContent(h), this.renderPostfix(h)],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-node.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_cascader_nodevue_type_script_lang_js_ = (cascader_nodevue_type_script_lang_js_);
            // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
            const componentNormalizer = __webpack_require__(0);

            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-node.vue
            let cascader_node_render; let
              cascader_node_staticRenderFns;

            /* normalize component */

            const component = Object(componentNormalizer['a' /* default */])(
              src_cascader_nodevue_type_script_lang_js_,
              cascader_node_render,
              cascader_node_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let api; }
            component.options.__file = 'packages/cascader-panel/src/cascader-node.vue';
            /* harmony default export */ const cascader_node = (component.exports);
            // EXTERNAL MODULE: external "element-ui/lib/mixins/locale"
            const locale_ = __webpack_require__(6);
            const locale_default = /* #__PURE__ */__webpack_require__.n(locale_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader-panel/src/cascader-menu.vue?vue&type=script&lang=js&

            /* harmony default export */ const cascader_menuvue_type_script_lang_js_ = ({
              name: 'ElCascaderMenu',

              mixins: [locale_default.a],

              inject: ['panel'],

              components: {
                ElScrollbar: scrollbar_default.a,
                CascaderNode: cascader_node,
              },

              props: {
                nodes: {
                  type: Array,
                  required: true,
                },
                index: Number,
              },

              data: function data() {
                return {
                  activeNode: null,
                  hoverTimer: null,
                  id: Object(util_.generateId)(),
                };
              },

              computed: {
                isEmpty: function isEmpty() {
                  return !this.nodes.length;
                },
                menuId: function menuId() {
                  return `cascader-menu-${this.id}-${this.index}`;
                },
              },

              methods: {
                handleExpand: function handleExpand(e) {
                  this.activeNode = e.target;
                },
                handleMouseMove: function handleMouseMove(e) {
                  const { activeNode } = this;
                  const { hoverTimer } = this;
                  const { hoverZone } = this.$refs;

                  if (!activeNode || !hoverZone) return;

                  if (activeNode.contains(e.target)) {
                    clearTimeout(hoverTimer);

                    const _$el$getBoundingClien = this.$el.getBoundingClientRect();
                    const { left } = _$el$getBoundingClien;

                    const startX = e.clientX - left;
                    const _$el = this.$el;
                    const { offsetWidth } = _$el;
                    const { offsetHeight } = _$el;

                    const top = activeNode.offsetTop;
                    const bottom = top + activeNode.offsetHeight;

                    hoverZone.innerHTML = `\n          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top} L${offsetWidth} 0 V${top} Z" />\n          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom} L${offsetWidth} ${offsetHeight} V${bottom} Z" />\n        `;
                  } else if (!hoverTimer) {
                    this.hoverTimer = setTimeout(this.clearHoverZone, this.panel.config.hoverThreshold);
                  }
                },
                clearHoverZone: function clearHoverZone() {
                  const { hoverZone } = this.$refs;

                  if (!hoverZone) return;
                  hoverZone.innerHTML = '';
                },
                renderEmptyText: function renderEmptyText(h) {
                  return h(
                    'div',
                    { class: 'el-cascader-menu__empty-text' },
                    [this.t('el.cascader.noData')],
                  );
                },
                renderNodeList: function renderNodeList(h) {
                  const { menuId } = this;
                  const { isHoverMenu } = this.panel;

                  const events = { on: {} };

                  if (isHoverMenu) {
                    events.on.expand = this.handleExpand;
                  }

                  const nodes = this.nodes.map((node, index) => {
                    const { hasChildren } = node;

                    return h('cascader-node', external_babel_helper_vue_jsx_merge_props_default()([{
                      key: node.uid,
                      attrs: {
                        node,
                        'node-id': `${menuId}-${index}`,
                        'aria-haspopup': hasChildren,
                        'aria-owns': hasChildren ? menuId : null,
                      },
                    }, events]));
                  });

                  return [].concat(nodes, [isHoverMenu ? h('svg', { ref: 'hoverZone', class: 'el-cascader-menu__hover-zone' }) : null]);
                },
              },

              render: function render(h) {
                const { isEmpty } = this;
                const { menuId } = this;

                const events = { nativeOn: {} };

                // optimize hover to expand experience (#8010)
                if (this.panel.isHoverMenu) {
                  events.nativeOn.mousemove = this.handleMouseMove;
                  // events.nativeOn.mouseleave = this.clearHoverZone;
                }

                return h(
                  'el-scrollbar',
                  external_babel_helper_vue_jsx_merge_props_default()([{
                    attrs: {
                      tag: 'ul',
                      role: 'menu',
                      id: menuId,

                      'wrap-class': 'el-cascader-menu__wrap',
                      'view-class': {
                        'el-cascader-menu__list': true,
                        'is-empty': isEmpty,
                      },
                    },
                    class: 'el-cascader-menu',
                  }, events]),
                  [isEmpty ? this.renderEmptyText(h) : this.renderNodeList(h)],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-menu.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_cascader_menuvue_type_script_lang_js_ = (cascader_menuvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-menu.vue
            let cascader_menu_render; let
              cascader_menu_staticRenderFns;

            /* normalize component */

            const cascader_menu_component = Object(componentNormalizer['a' /* default */])(
              src_cascader_menuvue_type_script_lang_js_,
              cascader_menu_render,
              cascader_menu_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let cascader_menu_api; }
            cascader_menu_component.options.__file = 'packages/cascader-panel/src/cascader-menu.vue';
            /* harmony default export */ const cascader_menu = (cascader_menu_component.exports);
            // EXTERNAL MODULE: external "element-ui/lib/utils/shared"
            const shared_ = __webpack_require__(21);

            // CONCATENATED MODULE: ./packages/cascader-panel/src/node.js
            const _createClass = (function () { function defineProperties(target, props) { for (let i = 0; i < props.length; i++) { const descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }());

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

            let uid = 0;

            const node_Node = (function () {
              function Node(data, config, parentNode) {
                _classCallCheck(this, Node);

                this.data = data;
                this.config = config;
                this.parent = parentNode || null;
                this.level = !this.parent ? 1 : this.parent.level + 1;
                this.uid = uid++;

                this.initState();
                this.initChildren();
              }

              Node.prototype.initState = function initState() {
                const _config = this.config;
                const valueKey = _config.value;
                const labelKey = _config.label;

                this.value = this.data[valueKey];
                this.label = this.data[labelKey];
                this.pathNodes = this.calculatePathNodes();
                this.path = this.pathNodes.map((node) => node.value);
                this.pathLabels = this.pathNodes.map((node) => node.label);

                // lazy load
                this.loading = false;
                this.loaded = false;
              };

              Node.prototype.initChildren = function initChildren() {
                const _this = this;

                const { config } = this;

                const childrenKey = config.children;
                const childrenData = this.data[childrenKey];
                this.hasChildren = Array.isArray(childrenData);
                this.children = (childrenData || []).map((child) => new Node(child, config, _this));
              };

              Node.prototype.calculatePathNodes = function calculatePathNodes() {
                const nodes = [this];
                let { parent } = this;

                while (parent) {
                  nodes.unshift(parent);
                  parent = parent.parent;
                }

                return nodes;
              };

              Node.prototype.getPath = function getPath() {
                return this.path;
              };

              Node.prototype.getValue = function getValue() {
                return this.value;
              };

              Node.prototype.getValueByOption = function getValueByOption() {
                return this.config.emitPath ? this.getPath() : this.getValue();
              };

              Node.prototype.getText = function getText(allLevels, separator) {
                return allLevels ? this.pathLabels.join(separator) : this.label;
              };

              Node.prototype.isSameNode = function isSameNode(checkedValue) {
                const value = this.getValueByOption();
                return this.config.multiple && Array.isArray(checkedValue) ? checkedValue.some((val) => Object(util_.isEqual)(val, value)) : Object(util_.isEqual)(checkedValue, value);
              };

              Node.prototype.broadcast = function broadcast(event) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }

                const handlerName = `onParent${Object(util_.capitalize)(event)}`;

                this.children.forEach((child) => {
                  if (child) {
                    // bottom up
                    child.broadcast.apply(child, [event].concat(args));
                    child[handlerName] && child[handlerName].apply(child, args);
                  }
                });
              };

              Node.prototype.emit = function emit(event) {
                const { parent } = this;

                const handlerName = `onChild${Object(util_.capitalize)(event)}`;
                if (parent) {
                  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    args[_key2 - 1] = arguments[_key2];
                  }

                  parent[handlerName] && parent[handlerName].apply(parent, args);
                  parent.emit.apply(parent, [event].concat(args));
                }
              };

              Node.prototype.onParentCheck = function onParentCheck(checked) {
                if (!this.isDisabled) {
                  this.setCheckState(checked);
                }
              };

              Node.prototype.onChildCheck = function onChildCheck() {
                const { children } = this;

                const validChildren = children.filter((child) => !child.isDisabled);
                const checked = validChildren.length ? validChildren.every((child) => child.checked) : false;

                this.setCheckState(checked);
              };

              Node.prototype.setCheckState = function setCheckState(checked) {
                const totalNum = this.children.length;
                const checkedNum = this.children.reduce((c, p) => {
                  const num = p.checked ? 1 : p.indeterminate ? 0.5 : 0;
                  return c + num;
                }, 0);

                this.checked = checked;
                this.indeterminate = checkedNum !== totalNum && checkedNum > 0;
              };

              Node.prototype.syncCheckState = function syncCheckState(checkedValue) {
                const value = this.getValueByOption();
                const checked = this.isSameNode(checkedValue, value);

                this.doCheck(checked);
              };

              Node.prototype.doCheck = function doCheck(checked) {
                if (this.checked !== checked) {
                  if (this.config.checkStrictly) {
                    this.checked = checked;
                  } else {
                    // bottom up to unify the calculation of the indeterminate state
                    this.broadcast('check', checked);
                    this.setCheckState(checked);
                    this.emit('check');
                  }
                }
              };

              _createClass(Node, [{
                key: 'isDisabled',
                get: function get() {
                  const { data } = this;
                  let { parent } = this;
                  let { config } = this;

                  const disabledKey = config.disabled;
                  const { checkStrictly } = config;

                  return data[disabledKey] || !checkStrictly && parent && parent.isDisabled;
                },
              }, {
                key: 'isLeaf',
                get: function get() {
                  const { data } = this;
                  let { loaded } = this;
                  let { hasChildren } = this;
                  let { children } = this;
                  const _config2 = this.config;
                  const { lazy } = _config2;
                  const leafKey = _config2.leaf;

                  if (lazy) {
                    const isLeaf = Object(shared_.isDef)(data[leafKey]) ? data[leafKey] : loaded ? !children.length : false;
                    this.hasChildren = !isLeaf;
                    return isLeaf;
                  }
                  return !hasChildren;
                },
              }]);

              return Node;
            }());

            /* harmony default export */ const src_node = (node_Node);
            // CONCATENATED MODULE: ./packages/cascader-panel/src/store.js
            function store_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

            const flatNodes = function flatNodes(data, leafOnly) {
              return data.reduce((res, node) => {
                if (node.isLeaf) {
                  res.push(node);
                } else {
                  !leafOnly && res.push(node);
                  res = res.concat(flatNodes(node.children, leafOnly));
                }
                return res;
              }, []);
            };

            const store_Store = (function () {
              function Store(data, config) {
                store_classCallCheck(this, Store);

                this.config = config;
                this.initNodes(data);
              }

              Store.prototype.initNodes = function initNodes(data) {
                const _this = this;

                data = Object(util_.coerceTruthyValueToArray)(data);
                this.nodes = data.map((nodeData) => new src_node(nodeData, _this.config));
                this.flattedNodes = this.getFlattedNodes(false, false);
                this.leafNodes = this.getFlattedNodes(true, false);
              };

              Store.prototype.appendNode = function appendNode(nodeData, parentNode) {
                const node = new src_node(nodeData, this.config, parentNode);
                const children = parentNode ? parentNode.children : this.nodes;

                children.push(node);
              };

              Store.prototype.appendNodes = function appendNodes(nodeDataList, parentNode) {
                const _this2 = this;

                nodeDataList = Object(util_.coerceTruthyValueToArray)(nodeDataList);
                nodeDataList.forEach((nodeData) => _this2.appendNode(nodeData, parentNode));
              };

              Store.prototype.getNodes = function getNodes() {
                return this.nodes;
              };

              Store.prototype.getFlattedNodes = function getFlattedNodes(leafOnly) {
                const cached = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

                const cachedNodes = leafOnly ? this.leafNodes : this.flattedNodes;
                return cached ? cachedNodes : flatNodes(this.nodes, leafOnly);
              };

              Store.prototype.getNodeByValue = function getNodeByValue(value) {
                if (value) {
                  const nodes = this.getFlattedNodes(false, !this.config.lazy).filter((node) => Object(util_.valueEquals)(node.path, value) || node.value === value);
                  return nodes && nodes.length ? nodes[0] : null;
                }
                return null;
              };

              return Store;
            }());

            /* harmony default export */ const src_store = (store_Store);
            // EXTERNAL MODULE: external "element-ui/lib/utils/merge"
            const merge_ = __webpack_require__(9);
            const merge_default = /* #__PURE__ */__webpack_require__.n(merge_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/aria-utils"
            const aria_utils_ = __webpack_require__(40);
            const aria_utils_default = /* #__PURE__ */__webpack_require__.n(aria_utils_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/scroll-into-view"
            const scroll_into_view_ = __webpack_require__(31);
            const scroll_into_view_default = /* #__PURE__ */__webpack_require__.n(scroll_into_view_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader-panel/src/cascader-panel.vue?vue&type=script&lang=js&
            const _extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const KeyCode = aria_utils_default.a.keys;

            const DefaultProps = {
              expandTrigger: 'click', // or hover
              multiple: false,
              checkStrictly: false, // whether all nodes can be selected
              emitPath: true, // wether to emit an array of all levels value in which node is located
              lazy: false,
              lazyLoad: util_.noop,
              value: 'value',
              label: 'label',
              children: 'children',
              leaf: 'leaf',
              disabled: 'disabled',
              hoverThreshold: 500,
            };

            const cascader_panelvue_type_script_lang_js_isLeaf = function isLeaf(el) {
              return !el.getAttribute('aria-owns');
            };

            const getSibling = function getSibling(el, distance) {
              const { parentNode } = el;

              if (parentNode) {
                const siblings = parentNode.querySelectorAll('.el-cascader-node[tabindex="-1"]');
                const index = Array.prototype.indexOf.call(siblings, el);
                return siblings[index + distance] || null;
              }
              return null;
            };

            const getMenuIndex = function getMenuIndex(el, distance) {
              if (!el) return;
              const pieces = el.id.split('-');
              return Number(pieces[pieces.length - 2]);
            };

            const focusNode = function focusNode(el) {
              if (!el) return;
              el.focus();
              !cascader_panelvue_type_script_lang_js_isLeaf(el) && el.click();
            };

            const checkNode = function checkNode(el) {
              if (!el) return;

              const input = el.querySelector('input');
              if (input) {
                input.click();
              } else if (cascader_panelvue_type_script_lang_js_isLeaf(el)) {
                el.click();
              }
            };

            /* harmony default export */ const cascader_panelvue_type_script_lang_js_ = ({
              name: 'ElCascaderPanel',

              components: {
                CascaderMenu: cascader_menu,
              },

              props: {
                value: {},
                options: Array,
                props: Object,
                border: {
                  type: Boolean,
                  default: true,
                },
                renderLabel: Function,
              },

              provide: function provide() {
                return {
                  panel: this,
                };
              },
              data: function data() {
                return {
                  checkedValue: null,
                  checkedNodePaths: [],
                  store: [],
                  menus: [],
                  activePath: [],
                  loadCount: 0,
                };
              },

              computed: {
                config: function config() {
                  return merge_default()({ ...DefaultProps }, this.props || {});
                },
                multiple: function multiple() {
                  return this.config.multiple;
                },
                checkStrictly: function checkStrictly() {
                  return this.config.checkStrictly;
                },
                leafOnly: function leafOnly() {
                  return !this.checkStrictly;
                },
                isHoverMenu: function isHoverMenu() {
                  return this.config.expandTrigger === 'hover';
                },
                renderLabelFn: function renderLabelFn() {
                  return this.renderLabel || this.$scopedSlots.default;
                },
              },

              watch: {
                options: {
                  handler: function handler() {
                    this.initStore();
                  },
                  immediate: true,
                  deep: true,
                },
                value: function value() {
                  this.syncCheckedValue();
                  this.checkStrictly && this.calculateCheckedNodePaths();
                },
                checkedValue: function checkedValue(val) {
                  if (!Object(util_.isEqual)(val, this.value)) {
                    this.checkStrictly && this.calculateCheckedNodePaths();
                    this.$emit('input', val);
                    this.$emit('change', val);
                  }
                },
              },

              mounted: function mounted() {
                if (!Object(util_.isEmpty)(this.value)) {
                  this.syncCheckedValue();
                }
              },

              methods: {
                initStore: function initStore() {
                  const { config } = this;
                  const { options } = this;

                  if (config.lazy && Object(util_.isEmpty)(options)) {
                    this.lazyLoad();
                  } else {
                    this.store = new src_store(options, config);
                    this.menus = [this.store.getNodes()];
                    this.syncMenuState();
                  }
                },
                syncCheckedValue: function syncCheckedValue() {
                  const { value } = this;
                  const { checkedValue } = this;

                  if (!Object(util_.isEqual)(value, checkedValue)) {
                    this.activePath = [];
                    this.checkedValue = value;
                    this.syncMenuState();
                  }
                },
                syncMenuState: function syncMenuState() {
                  const { multiple } = this;
                  const { checkStrictly } = this;

                  this.syncActivePath();
                  multiple && this.syncMultiCheckState();
                  checkStrictly && this.calculateCheckedNodePaths();
                  this.$nextTick(this.scrollIntoView);
                },
                syncMultiCheckState: function syncMultiCheckState() {
                  const _this = this;

                  const nodes = this.getFlattedNodes(this.leafOnly);

                  nodes.forEach((node) => {
                    node.syncCheckState(_this.checkedValue);
                  });
                },
                syncActivePath: function syncActivePath() {
                  const _this2 = this;

                  const { store } = this;
                  const { multiple } = this;
                  const { activePath } = this;
                  const { checkedValue } = this;

                  if (!Object(util_.isEmpty)(activePath)) {
                    const nodes = activePath.map((node) => _this2.getNodeByValue(node.getValue()));
                    this.expandNodes(nodes);
                  } else if (!Object(util_.isEmpty)(checkedValue)) {
                    const value = multiple ? checkedValue[0] : checkedValue;
                    const checkedNode = this.getNodeByValue(value) || {};
                    const _nodes = (checkedNode.pathNodes || []).slice(0, -1);
                    this.expandNodes(_nodes);
                  } else {
                    this.activePath = [];
                    this.menus = [store.getNodes()];
                  }
                },
                expandNodes: function expandNodes(nodes) {
                  const _this3 = this;

                  nodes.forEach((node) => _this3.handleExpand(node, true /* silent */));
                },
                calculateCheckedNodePaths: function calculateCheckedNodePaths() {
                  const _this4 = this;

                  const { checkedValue } = this;
                  const { multiple } = this;

                  const checkedValues = multiple ? Object(util_.coerceTruthyValueToArray)(checkedValue) : [checkedValue];
                  this.checkedNodePaths = checkedValues.map((v) => {
                    const checkedNode = _this4.getNodeByValue(v);
                    return checkedNode ? checkedNode.pathNodes : [];
                  });
                },
                handleKeyDown: function handleKeyDown(e) {
                  const { target } = e;
                  let { keyCode } = e;

                  switch (keyCode) {
                    case KeyCode.up:
                      var prev = getSibling(target, -1);
                      focusNode(prev);
                      break;
                    case KeyCode.down:
                      var next = getSibling(target, 1);
                      focusNode(next);
                      break;
                    case KeyCode.left:
                      var preMenu = this.$refs.menu[getMenuIndex(target) - 1];
                      if (preMenu) {
                        const expandedNode = preMenu.$el.querySelector('.el-cascader-node[aria-expanded="true"]');
                        focusNode(expandedNode);
                      }
                      break;
                    case KeyCode.right:
                      var nextMenu = this.$refs.menu[getMenuIndex(target) + 1];
                      if (nextMenu) {
                        const firstNode = nextMenu.$el.querySelector('.el-cascader-node[tabindex="-1"]');
                        focusNode(firstNode);
                      }
                      break;
                    case KeyCode.enter:
                      checkNode(target);
                      break;
                    case KeyCode.esc:
                    case KeyCode.tab:
                      this.$emit('close');
                      break;
                    default:
                  }
                },
                handleExpand: function handleExpand(node, silent) {
                  const { activePath } = this;
                  const { level } = node;

                  const path = activePath.slice(0, level - 1);
                  const menus = this.menus.slice(0, level);

                  if (!node.isLeaf) {
                    path.push(node);
                    menus.push(node.children);
                  }

                  this.activePath = path;
                  this.menus = menus;

                  if (!silent) {
                    const pathValues = path.map((node) => node.getValue());
                    const activePathValues = activePath.map((node) => node.getValue());
                    if (!Object(util_.valueEquals)(pathValues, activePathValues)) {
                      this.$emit('active-item-change', pathValues); // Deprecated
                      this.$emit('expand-change', pathValues);
                    }
                  }
                },
                handleCheckChange: function handleCheckChange(value) {
                  this.checkedValue = value;
                },
                lazyLoad: function lazyLoad(node, onFullfiled) {
                  const _this5 = this;

                  const { config } = this;

                  if (!node) {
                    node = node || { root: true, level: 0 };
                    this.store = new src_store([], config);
                    this.menus = [this.store.getNodes()];
                  }
                  node.loading = true;
                  const resolve = function resolve(dataList) {
                    const parent = node.root ? null : node;
                    dataList && dataList.length && _this5.store.appendNodes(dataList, parent);
                    node.loading = false;
                    node.loaded = true;

                    // dispose default value on lazy load mode
                    if (Array.isArray(_this5.checkedValue)) {
                      const nodeValue = _this5.checkedValue[_this5.loadCount++];
                      const valueKey = _this5.config.value;
                      const leafKey = _this5.config.leaf;

                      if (Array.isArray(dataList) && dataList.filter((item) => item[valueKey] === nodeValue).length > 0) {
                        const checkedNode = _this5.store.getNodeByValue(nodeValue);

                        if (!checkedNode.data[leafKey]) {
                          _this5.lazyLoad(checkedNode, () => {
                            _this5.handleExpand(checkedNode);
                          });
                        }

                        if (_this5.loadCount === _this5.checkedValue.length) {
                          _this5.$parent.computePresentText();
                        }
                      }
                    }

                    onFullfiled && onFullfiled(dataList);
                  };
                  config.lazyLoad(node, resolve);
                },

                /**
     * public methods
    */
                calculateMultiCheckedValue: function calculateMultiCheckedValue() {
                  this.checkedValue = this.getCheckedNodes(this.leafOnly).map((node) => node.getValueByOption());
                },
                scrollIntoView: function scrollIntoView() {
                  if (this.$isServer) return;

                  const menus = this.$refs.menu || [];
                  menus.forEach((menu) => {
                    const menuElement = menu.$el;
                    if (menuElement) {
                      const container = menuElement.querySelector('.el-scrollbar__wrap');
                      const activeNode = menuElement.querySelector('.el-cascader-node.is-active') || menuElement.querySelector('.el-cascader-node.in-active-path');
                      scroll_into_view_default()(container, activeNode);
                    }
                  });
                },
                getNodeByValue: function getNodeByValue(val) {
                  return this.store.getNodeByValue(val);
                },
                getFlattedNodes: function getFlattedNodes(leafOnly) {
                  const cached = !this.config.lazy;
                  return this.store.getFlattedNodes(leafOnly, cached);
                },
                getCheckedNodes: function getCheckedNodes(leafOnly) {
                  const { checkedValue } = this;
                  let { multiple } = this;

                  if (multiple) {
                    const nodes = this.getFlattedNodes(leafOnly);
                    return nodes.filter((node) => node.checked);
                  }
                  return Object(util_.isEmpty)(checkedValue) ? [] : [this.getNodeByValue(checkedValue)];
                },
                clearCheckedNodes: function clearCheckedNodes() {
                  const { config } = this;
                  const { leafOnly } = this;
                  const { multiple } = config;
                  const { emitPath } = config;

                  if (multiple) {
                    this.getCheckedNodes(leafOnly).filter((node) => !node.isDisabled).forEach((node) => node.doCheck(false));
                    this.calculateMultiCheckedValue();
                  } else {
                    this.checkedValue = emitPath ? [] : null;
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-panel.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_cascader_panelvue_type_script_lang_js_ = (cascader_panelvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-panel.vue

            /* normalize component */

            const cascader_panel_component = Object(componentNormalizer['a' /* default */])(
              src_cascader_panelvue_type_script_lang_js_,
              cascader_panelvue_type_template_id_34932346_render,
              staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let cascader_panel_api; }
            cascader_panel_component.options.__file = 'packages/cascader-panel/src/cascader-panel.vue';
            /* harmony default export */ const cascader_panel = (cascader_panel_component.exports);
            // CONCATENATED MODULE: ./packages/cascader-panel/index.js

            /* istanbul ignore next */
            cascader_panel.install = function (Vue) {
              Vue.component(cascader_panel.name, cascader_panel);
            };

            /* harmony default export */ const packages_cascader_panel = __webpack_exports__.default = (cascader_panel);
            /***/ }),

          /***/ 6:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('6b7c');
            /***/ }),

          /***/ 9:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('7f4d');
            /***/ }),

          /** *** */ }));
      /***/ }),

    /***/ 4897:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;
      exports.i18n = exports.use = exports.t = undefined;

      const _zhCN = __webpack_require__('f0d9');

      const _zhCN2 = _interopRequireDefault(_zhCN);

      const _vue = __webpack_require__('8bbf');

      const _vue2 = _interopRequireDefault(_vue);

      const _deepmerge = __webpack_require__('3c4e');

      const _deepmerge2 = _interopRequireDefault(_deepmerge);

      const _format = __webpack_require__('9d7e');

      const _format2 = _interopRequireDefault(_format);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      const format = (0, _format2.default)(_vue2.default);
      let lang = _zhCN2.default;
      let merged = false;
      let i18nHandler = function i18nHandler() {
        const vuei18n = Object.getPrototypeOf(this || _vue2.default).$t;
        if (typeof vuei18n === 'function' && !!_vue2.default.locale) {
          if (!merged) {
            merged = true;
            _vue2.default.locale(_vue2.default.config.lang, (0, _deepmerge2.default)(lang, _vue2.default.locale(_vue2.default.config.lang) || {}, { clone: true }));
          }
          return vuei18n.apply(this, arguments);
        }
      };

      const t = exports.t = function t(path, options) {
        let value = i18nHandler.apply(this, arguments);
        if (value !== null && value !== undefined) return value;

        const array = path.split('.');
        let current = lang;

        for (let i = 0, j = array.length; i < j; i++) {
          const property = array[i];
          value = current[property];
          if (i === j - 1) return format(value, options);
          if (!value) return '';
          current = value;
        }
        return '';
      };

      const use = exports.use = function use(l) {
        lang = l || lang;
      };

      const i18n = exports.i18n = function i18n(fn) {
        i18nHandler = fn || i18nHandler;
      };

      exports.default = { use, t, i18n };
      /***/ }),

    /***/ '4b26':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      const _vue = __webpack_require__('8bbf');

      const _vue2 = _interopRequireDefault(_vue);

      const _dom = __webpack_require__('5924');

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      let hasModal = false;
      let hasInitZIndex = false;
      let zIndex = void 0;

      const getModal = function getModal() {
        if (_vue2.default.prototype.$isServer) return;
        let { modalDom } = PopupManager;
        if (modalDom) {
          hasModal = true;
        } else {
          hasModal = false;
          modalDom = document.createElement('div');
          PopupManager.modalDom = modalDom;

          modalDom.addEventListener('touchmove', (event) => {
            event.preventDefault();
            event.stopPropagation();
          });

          modalDom.addEventListener('click', () => {
            PopupManager.doOnModalClick && PopupManager.doOnModalClick();
          });
        }

        return modalDom;
      };

      const instances = {};

      var PopupManager = {
        modalFade: true,

        getInstance: function getInstance(id) {
          return instances[id];
        },

        register: function register(id, instance) {
          if (id && instance) {
            instances[id] = instance;
          }
        },

        deregister: function deregister(id) {
          if (id) {
            instances[id] = null;
            delete instances[id];
          }
        },

        nextZIndex: function nextZIndex() {
          return PopupManager.zIndex++;
        },

        modalStack: [],

        doOnModalClick: function doOnModalClick() {
          const topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
          if (!topItem) return;

          const instance = PopupManager.getInstance(topItem.id);
          if (instance && instance.closeOnClickModal) {
            instance.close();
          }
        },

        openModal: function openModal(id, zIndex, dom, modalClass, modalFade) {
          if (_vue2.default.prototype.$isServer) return;
          if (!id || zIndex === undefined) return;
          this.modalFade = modalFade;

          const { modalStack } = this;

          for (let i = 0, j = modalStack.length; i < j; i++) {
            const item = modalStack[i];
            if (item.id === id) {
              return;
            }
          }

          const modalDom = getModal();

          (0, _dom.addClass)(modalDom, 'v-modal');
          if (this.modalFade && !hasModal) {
            (0, _dom.addClass)(modalDom, 'v-modal-enter');
          }
          if (modalClass) {
            const classArr = modalClass.trim().split(/\s+/);
            classArr.forEach((item) => (0, _dom.addClass)(modalDom, item));
          }
          setTimeout(() => {
            (0, _dom.removeClass)(modalDom, 'v-modal-enter');
          }, 200);

          if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {
            dom.parentNode.appendChild(modalDom);
          } else {
            document.body.appendChild(modalDom);
          }

          if (zIndex) {
            modalDom.style.zIndex = zIndex;
          }
          modalDom.tabIndex = 0;
          modalDom.style.display = '';

          this.modalStack.push({ id, zIndex, modalClass });
        },

        closeModal: function closeModal(id) {
          const { modalStack } = this;
          const modalDom = getModal();

          if (modalStack.length > 0) {
            const topItem = modalStack[modalStack.length - 1];
            if (topItem.id === id) {
              if (topItem.modalClass) {
                const classArr = topItem.modalClass.trim().split(/\s+/);
                classArr.forEach((item) => (0, _dom.removeClass)(modalDom, item));
              }

              modalStack.pop();
              if (modalStack.length > 0) {
                modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;
              }
            } else {
              for (let i = modalStack.length - 1; i >= 0; i--) {
                if (modalStack[i].id === id) {
                  modalStack.splice(i, 1);
                  break;
                }
              }
            }
          }

          if (modalStack.length === 0) {
            if (this.modalFade) {
              (0, _dom.addClass)(modalDom, 'v-modal-leave');
            }
            setTimeout(() => {
              if (modalStack.length === 0) {
                if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);
                modalDom.style.display = 'none';
                PopupManager.modalDom = undefined;
              }
              (0, _dom.removeClass)(modalDom, 'v-modal-leave');
            }, 200);
          }
        },
      };

      Object.defineProperty(PopupManager, 'zIndex', {
        configurable: true,
        get: function get() {
          if (!hasInitZIndex) {
            zIndex = zIndex || (_vue2.default.prototype.$ELEMENT || {}).zIndex || 2000;
            hasInitZIndex = true;
          }
          return zIndex;
        },
        set: function set(value) {
          zIndex = value;
        },
      });

      const getTopPopup = function getTopPopup() {
        if (_vue2.default.prototype.$isServer) return;
        if (PopupManager.modalStack.length > 0) {
          const topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
          if (!topPopup) return;
          const instance = PopupManager.getInstance(topPopup.id);

          return instance;
        }
      };

      if (!_vue2.default.prototype.$isServer) {
        // handle `esc` key when the popup is shown
        window.addEventListener('keydown', (event) => {
          if (event.keyCode === 27) {
            const topPopup = getTopPopup();

            if (topPopup && topPopup.closeOnPressEscape) {
              topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction('cancel') : topPopup.close();
            }
          }
        });
      }

      exports.default = PopupManager;
      /***/ }),

    /***/ '4b8b':
    /***/ (function (module, exports) {
      module.exports = function (exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
      /***/ }),

    /***/ '4d20':
    /***/ (function (module, exports, __webpack_require__) {
      const pIE = __webpack_require__('1917');
      const createDesc = __webpack_require__('10db');
      const toIObject = __webpack_require__('6ca1');
      const toPrimitive = __webpack_require__('3397');
      const has = __webpack_require__('9c0e');
      const IE8_DOM_DEFINE = __webpack_require__('faf5');
      const gOPD = Object.getOwnPropertyDescriptor;

      exports.f = __webpack_require__('0bad') ? gOPD : function getOwnPropertyDescriptor(O, P) {
        O = toIObject(O);
        P = toPrimitive(P, true);
        if (IE8_DOM_DEFINE) {
          try {
            return gOPD(O, P);
          } catch (e) { /* empty */ }
        }
        if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
      };
      /***/ }),

    /***/ '4d88':
    /***/ (function (module, exports) {
      const { toString } = {};

      module.exports = function (it) {
        return toString.call(it).slice(8, -1);
      };
      /***/ }),

    /***/ '4e4b':
    /***/ (function (module, exports, __webpack_require__) {
      module.exports =
        /** *** */ (function (modules) { // webpackBootstrap
          /** *** */ 	// The module cache
          /** *** */ 	const installedModules = {};
          /** *** */
          /** *** */ 	// The require function
          /** *** */ 	function __webpack_require__(moduleId) {
            /** *** */
            /** *** */ 		// Check if module is in cache
            /** *** */ 		if (installedModules[moduleId]) {
              /** *** */ 			return installedModules[moduleId].exports;
              /** *** */ 		}
            /** *** */ 		// Create a new module (and put it into the cache)
            /** *** */ 		const module = installedModules[moduleId] = {
              /** *** */ 			i: moduleId,
              /** *** */ 			l: false,
              /** *** */ 			exports: {},
              /** *** */ 		};
            /** *** */
            /** *** */ 		// Execute the module function
            /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /** *** */
            /** *** */ 		// Flag the module as loaded
            /** *** */ 		module.l = true;
            /** *** */
            /** *** */ 		// Return the exports of the module
            /** *** */ 		return module.exports;
            /** *** */ 	}
          /** *** */
          /** *** */
          /** *** */ 	// expose the modules object (__webpack_modules__)
          /** *** */ 	__webpack_require__.m = modules;
          /** *** */
          /** *** */ 	// expose the module cache
          /** *** */ 	__webpack_require__.c = installedModules;
          /** *** */
          /** *** */ 	// define getter function for harmony exports
          /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
            /** *** */ 		if (!__webpack_require__.o(exports, name)) {
              /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
              /** *** */ 		}
            /** *** */ 	};
          /** *** */
          /** *** */ 	// define __esModule on exports
          /** *** */ 	__webpack_require__.r = function (exports) {
            /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
              /** *** */ 		}
            /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
            /** *** */ 	};
          /** *** */
          /** *** */ 	// create a fake namespace object
          /** *** */ 	// mode & 1: value is a module id, require it
          /** *** */ 	// mode & 2: merge all properties of value into the ns
          /** *** */ 	// mode & 4: return value when already ns object
          /** *** */ 	// mode & 8|1: behave like require
          /** *** */ 	__webpack_require__.t = function (value, mode) {
            /** *** */ 		if (mode & 1) value = __webpack_require__(value);
            /** *** */ 		if (mode & 8) return value;
            /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /** *** */ 		const ns = Object.create(null);
            /** *** */ 		__webpack_require__.r(ns);
            /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
            /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
            /** *** */ 		return ns;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
          /** *** */ 	__webpack_require__.n = function (module) {
            /** *** */ 		const getter = module && module.__esModule
            /** *** */ 			? function getDefault() { return module.default; }
            /** *** */ 			: function getModuleExports() { return module; };
            /** *** */ 		__webpack_require__.d(getter, 'a', getter);
            /** *** */ 		return getter;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// Object.prototype.hasOwnProperty.call
          /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
          /** *** */
          /** *** */ 	// __webpack_public_path__
          /** *** */ 	__webpack_require__.p = '/dist/';
          /** *** */
          /** *** */
          /** *** */ 	// Load entry module and return exports
          /** *** */ 	return __webpack_require__(__webpack_require__.s = 61);
          /** *** */ }({

          /***/ 0:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'a', () => normalizeComponent);
            /* globals __VUE_SSR_CONTEXT__ */

            // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
            // This module is a runtime utility for cleaner component module output and will
            // be included in the final webpack user bundle.

            function normalizeComponent(
              scriptExports,
              render,
              staticRenderFns,
              functionalTemplate,
              injectStyles,
              scopeId,
              moduleIdentifier, /* server only */
              shadowMode, /* vue-cli only */
            ) {
              // Vue.extend constructor export interop
              const options = typeof scriptExports === 'function'
                ? scriptExports.options
                : scriptExports;

              // render functions
              if (render) {
                options.render = render;
                options.staticRenderFns = staticRenderFns;
                options._compiled = true;
              }

              // functional template
              if (functionalTemplate) {
                options.functional = true;
              }

              // scopedId
              if (scopeId) {
                options._scopeId = `data-v-${scopeId}`;
              }

              let hook;
              if (moduleIdentifier) { // server build
                hook = function (context) {
                  // 2.3 injection
                  context = context // cached call
        || (this.$vnode && this.$vnode.ssrContext) // stateful
        || (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
                  // 2.2 with runInNewContext: true
                  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                    context = __VUE_SSR_CONTEXT__;
                  }
                  // inject component styles
                  if (injectStyles) {
                    injectStyles.call(this, context);
                  }
                  // register component module identifier for async chunk inferrence
                  if (context && context._registeredComponents) {
                    context._registeredComponents.add(moduleIdentifier);
                  }
                };
                // used by ssr in case component is cached and beforeCreate
                // never gets called
                options._ssrRegister = hook;
              } else if (injectStyles) {
                hook = shadowMode
                  ? function () { injectStyles.call(this, this.$root.$options.shadowRoot); }
                  : injectStyles;
              }

              if (hook) {
                if (options.functional) {
                  // for template-only hot-reload because in that case the render fn doesn't
                  // go through the normalizer
                  options._injectStyles = hook;
                  // register for functioal component in vue file
                  const originalRender = options.render;
                  options.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context);
                  };
                } else {
                  // inject component registration as beforeCreate hook
                  const existing = options.beforeCreate;
                  options.beforeCreate = existing
                    ? [].concat(existing, hook)
                    : [hook];
                }
              }

              return {
                exports: scriptExports,
                options,
              };
            }
            /***/ }),

          /***/ 10:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('f3ad');
            /***/ }),

          /***/ 12:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('417f');
            /***/ }),

          /***/ 14:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('14e9');
            /***/ }),

          /***/ 16:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('4010');
            /***/ }),

          /***/ 17:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('0e15');
            /***/ }),

          /***/ 21:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('d397');
            /***/ }),

          /***/ 22:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('12f2');
            /***/ }),

          /***/ 3:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8122');
            /***/ }),

          /***/ 31:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('2a5e');
            /***/ }),

          /***/ 33:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option.vue?vue&type=template&id=7a44c642&
            const render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'li',
                {
                  directives: [
                    {
                      name: 'show',
                      rawName: 'v-show',
                      value: _vm.visible,
                      expression: 'visible',
                    },
                  ],
                  staticClass: 'el-select-dropdown__item',
                  class: {
                    selected: _vm.itemSelected,
                    'is-disabled': _vm.disabled || _vm.groupDisabled || _vm.limitReached,
                    hover: _vm.hover,
                  },
                  on: {
                    mouseenter: _vm.hoverItem,
                    click($event) {
                      $event.stopPropagation();
                      return _vm.selectOptionClick($event);
                    },
                  },
                },
                [_vm._t('default', [_c('span', [_vm._v(_vm._s(_vm.currentLabel))])])],
                2,
              );
            };
            const staticRenderFns = [];
            render._withStripped = true;

            // CONCATENATED MODULE: ./packages/select/src/option.vue?vue&type=template&id=7a44c642&

            // EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"
            const emitter_ = __webpack_require__(4);
            const emitter_default = /* #__PURE__ */__webpack_require__.n(emitter_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/util"
            const util_ = __webpack_require__(3);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option.vue?vue&type=script&lang=js&
            const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const optionvue_type_script_lang_js_ = ({
              mixins: [emitter_default.a],

              name: 'ElOption',

              componentName: 'ElOption',

              inject: ['select'],

              props: {
                value: {
                  required: true,
                },
                label: [String, Number],
                created: Boolean,
                disabled: {
                  type: Boolean,
                  default: false,
                },
              },

              data: function data() {
                return {
                  index: -1,
                  groupDisabled: false,
                  visible: true,
                  hitState: false,
                  hover: false,
                };
              },

              computed: {
                isObject: function isObject() {
                  return Object.prototype.toString.call(this.value).toLowerCase() === '[object object]';
                },
                currentLabel: function currentLabel() {
                  return this.label || (this.isObject ? '' : this.value);
                },
                currentValue: function currentValue() {
                  return this.value || this.label || '';
                },
                itemSelected: function itemSelected() {
                  if (!this.select.multiple) {
                    return this.isEqual(this.value, this.select.value);
                  }
                  return this.contains(this.select.value, this.value);
                },
                limitReached: function limitReached() {
                  if (this.select.multiple) {
                    return !this.itemSelected && (this.select.value || []).length >= this.select.multipleLimit && this.select.multipleLimit > 0;
                  }
                  return false;
                },
              },

              watch: {
                currentLabel: function currentLabel() {
                  if (!this.created && !this.select.remote) this.dispatch('ElSelect', 'setSelected');
                },
                value: function value(val, oldVal) {
                  const _select = this.select;
                  const { remote } = _select;
                  const { valueKey } = _select;

                  if (!this.created && !remote) {
                    if (valueKey && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && (typeof oldVal === 'undefined' ? 'undefined' : _typeof(oldVal)) === 'object' && val[valueKey] === oldVal[valueKey]) {
                      return;
                    }
                    this.dispatch('ElSelect', 'setSelected');
                  }
                },
              },

              methods: {
                isEqual: function isEqual(a, b) {
                  if (!this.isObject) {
                    return a === b;
                  }
                  const { valueKey } = this.select;
                  return Object(util_.getValueByPath)(a, valueKey) === Object(util_.getValueByPath)(b, valueKey);
                },
                contains: function contains() {
                  const arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                  const target = arguments[1];

                  if (!this.isObject) {
                    return arr && arr.indexOf(target) > -1;
                  }
                  const { valueKey } = this.select;
                  return arr && arr.some((item) => Object(util_.getValueByPath)(item, valueKey) === Object(util_.getValueByPath)(target, valueKey));
                },
                handleGroupDisabled: function handleGroupDisabled(val) {
                  this.groupDisabled = val;
                },
                hoverItem: function hoverItem() {
                  if (!this.disabled && !this.groupDisabled) {
                    this.select.hoverIndex = this.select.options.indexOf(this);
                  }
                },
                selectOptionClick: function selectOptionClick() {
                  if (this.disabled !== true && this.groupDisabled !== true) {
                    this.dispatch('ElSelect', 'handleOptionClick', [this, true]);
                  }
                },
                queryChange: function queryChange(query) {
                  this.visible = new RegExp(Object(util_.escapeRegexpString)(query), 'i').test(this.currentLabel) || this.created;
                  if (!this.visible) {
                    this.select.filteredOptionsCount--;
                  }
                },
              },

              created: function created() {
                this.select.options.push(this);
                this.select.cachedOptions.push(this);
                this.select.optionsCount++;
                this.select.filteredOptionsCount++;

                this.$on('queryChange', this.queryChange);
                this.$on('handleGroupDisabled', this.handleGroupDisabled);
              },
              beforeDestroy: function beforeDestroy() {
                const _select2 = this.select;
                const { selected } = _select2;
                const { multiple } = _select2;

                const selectedOptions = multiple ? selected : [selected];
                const index = this.select.cachedOptions.indexOf(this);
                const selectedIndex = selectedOptions.indexOf(this);

                // if option is not selected, remove it from cache
                if (index > -1 && selectedIndex < 0) {
                  this.select.cachedOptions.splice(index, 1);
                }
                this.select.onOptionDestroy(this.select.options.indexOf(this));
              },
            });
            // CONCATENATED MODULE: ./packages/select/src/option.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_optionvue_type_script_lang_js_ = (optionvue_type_script_lang_js_);
            // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
            const componentNormalizer = __webpack_require__(0);

            // CONCATENATED MODULE: ./packages/select/src/option.vue

            /* normalize component */

            const component = Object(componentNormalizer['a' /* default */])(
              src_optionvue_type_script_lang_js_,
              render,
              staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let api; }
            component.options.__file = 'packages/select/src/option.vue';
            /* harmony default export */ const src_option = __webpack_exports__.a = (component.exports);
            /***/ }),

          /***/ 37:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8bbc');
            /***/ }),

          /***/ 4:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('d010');
            /***/ }),

          /***/ 5:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('e974');
            /***/ }),

          /***/ 6:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('6b7c');
            /***/ }),

          /***/ 61:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select.vue?vue&type=template&id=0e4aade6&
            const render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  directives: [
                    {
                      name: 'clickoutside',
                      rawName: 'v-clickoutside',
                      value: _vm.handleClose,
                      expression: 'handleClose',
                    },
                  ],
                  staticClass: 'el-select',
                  class: [_vm.selectSize ? `el-select--${_vm.selectSize}` : ''],
                  on: {
                    click($event) {
                      $event.stopPropagation();
                      return _vm.toggleMenu($event);
                    },
                  },
                },
                [
                  _vm.multiple
                    ? _c(
                      'div',
                      {
                        ref: 'tags',
                        staticClass: 'el-select__tags',
                        style: { 'max-width': `${_vm.inputWidth - 32}px`, width: '100%' },
                      },
                      [
                        _vm.collapseTags && _vm.selected.length
                          ? _c(
                            'span',
                            [
                              _c(
                                'el-tag',
                                {
                                  attrs: {
                                    closable: !_vm.selectDisabled,
                                    size: _vm.collapseTagSize,
                                    hit: _vm.selected[0].hitState,
                                    type: 'info',
                                    'disable-transitions': '',
                                  },
                                  on: {
                                    close($event) {
                                      _vm.deleteTag($event, _vm.selected[0]);
                                    },
                                  },
                                },
                                [
                                  _c('span', { staticClass: 'el-select__tags-text' }, [
                                    _vm._v(_vm._s(_vm.selected[0].currentLabel)),
                                  ]),
                                ],
                              ),
                              _vm.selected.length > 1
                                ? _c(
                                  'el-tag',
                                  {
                                    attrs: {
                                      closable: false,
                                      size: _vm.collapseTagSize,
                                      type: 'info',
                                      'disable-transitions': '',
                                    },
                                  },
                                  [
                                    _c(
                                      'span',
                                      { staticClass: 'el-select__tags-text' },
                                      [_vm._v(`+ ${_vm._s(_vm.selected.length - 1)}`)],
                                    ),
                                  ],
                                )
                                : _vm._e(),
                            ],
                            1,
                          )
                          : _vm._e(),
                        !_vm.collapseTags
                          ? _c(
                            'transition-group',
                            { on: { 'after-leave': _vm.resetInputHeight } },
                            _vm._l(_vm.selected, (item) => _c(
                              'el-tag',
                              {
                                key: _vm.getValueKey(item),
                                attrs: {
                                  closable: !_vm.selectDisabled,
                                  size: _vm.collapseTagSize,
                                  hit: item.hitState,
                                  type: 'info',
                                  'disable-transitions': '',
                                },
                                on: {
                                  close($event) {
                                    _vm.deleteTag($event, item);
                                  },
                                },
                              },
                              [
                                _c('span', { staticClass: 'el-select__tags-text' }, [
                                  _vm._v(_vm._s(item.currentLabel)),
                                ]),
                              ],
                            )),
                            1,
                          )
                          : _vm._e(),
                        _vm.filterable
                          ? _c('input', {
                            directives: [
                              {
                                name: 'model',
                                rawName: 'v-model',
                                value: _vm.query,
                                expression: 'query',
                              },
                            ],
                            ref: 'input',
                            staticClass: 'el-select__input',
                            class: [_vm.selectSize ? `is-${_vm.selectSize}` : ''],
                            style: {
                              'flex-grow': '1',
                              width: `${_vm.inputLength / (_vm.inputWidth - 32)}%`,
                              'max-width': `${_vm.inputWidth - 42}px`,
                            },
                            attrs: {
                              type: 'text',
                              disabled: _vm.selectDisabled,
                              autocomplete: _vm.autoComplete || _vm.autocomplete,
                            },
                            domProps: { value: _vm.query },
                            on: {
                              focus: _vm.handleFocus,
                              blur($event) {
                                _vm.softFocus = false;
                              },
                              keyup: _vm.managePlaceholder,
                              keydown: [
                                _vm.resetInputState,
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k($event.keyCode, 'down', 40, $event.key, [
                              'Down',
                              'ArrowDown',
                            ])
                                  ) {
                                    return null;
                                  }
                                  $event.preventDefault();
                                  _vm.navigateOptions('next');
                                },
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k($event.keyCode, 'up', 38, $event.key, [
                              'Up',
                              'ArrowUp',
                            ])
                                  ) {
                                    return null;
                                  }
                                  $event.preventDefault();
                                  _vm.navigateOptions('prev');
                                },
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k(
                              $event.keyCode,
                              'enter',
                              13,
                              $event.key,
                              'Enter',
                            )
                                  ) {
                                    return null;
                                  }
                                  $event.preventDefault();
                                  return _vm.selectOption($event);
                                },
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k($event.keyCode, 'esc', 27, $event.key, [
                              'Esc',
                              'Escape',
                            ])
                                  ) {
                                    return null;
                                  }
                                  $event.stopPropagation();
                                  $event.preventDefault();
                                  _vm.visible = false;
                                },
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k(
                              $event.keyCode,
                              'delete',
                              [8, 46],
                              $event.key,
                              ['Backspace', 'Delete', 'Del'],
                            )
                                  ) {
                                    return null;
                                  }
                                  return _vm.deletePrevTag($event);
                                },
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k($event.keyCode, 'tab', 9, $event.key, 'Tab')
                                  ) {
                                    return null;
                                  }
                                  _vm.visible = false;
                                },
                              ],
                              compositionstart: _vm.handleComposition,
                              compositionupdate: _vm.handleComposition,
                              compositionend: _vm.handleComposition,
                              input: [
                                function ($event) {
                                  if ($event.target.composing) {
                                    return;
                                  }
                                  _vm.query = $event.target.value;
                                },
                                _vm.debouncedQueryChange,
                              ],
                            },
                          })
                          : _vm._e(),
                      ],
                      1,
                    )
                    : _vm._e(),
                  _c(
                    'el-input',
                    {
                      ref: 'reference',
                      class: { 'is-focus': _vm.visible },
                      attrs: {
                        type: 'text',
                        placeholder: _vm.currentPlaceholder,
                        name: _vm.name,
                        id: _vm.id,
                        autocomplete: _vm.autoComplete || _vm.autocomplete,
                        size: _vm.selectSize,
                        disabled: _vm.selectDisabled,
                        readonly: _vm.readonly,
                        'validate-event': false,
                        tabindex: _vm.multiple && _vm.filterable ? '-1' : null,
                      },
                      on: { focus: _vm.handleFocus, blur: _vm.handleBlur },
                      nativeOn: {
                        keyup($event) {
                          return _vm.debouncedOnInputChange($event);
                        },
                        keydown: [
                          function ($event) {
                            if (
                              !('button' in $event)
                  && _vm._k($event.keyCode, 'down', 40, $event.key, [
                    'Down',
                    'ArrowDown',
                  ])
                            ) {
                              return null;
                            }
                            $event.stopPropagation();
                            $event.preventDefault();
                            _vm.navigateOptions('next');
                          },
                          function ($event) {
                            if (
                              !('button' in $event)
                  && _vm._k($event.keyCode, 'up', 38, $event.key, [
                    'Up',
                    'ArrowUp',
                  ])
                            ) {
                              return null;
                            }
                            $event.stopPropagation();
                            $event.preventDefault();
                            _vm.navigateOptions('prev');
                          },
                          function ($event) {
                            if (
                              !('button' in $event)
                  && _vm._k($event.keyCode, 'enter', 13, $event.key, 'Enter')
                            ) {
                              return null;
                            }
                            $event.preventDefault();
                            return _vm.selectOption($event);
                          },
                          function ($event) {
                            if (
                              !('button' in $event)
                  && _vm._k($event.keyCode, 'esc', 27, $event.key, [
                    'Esc',
                    'Escape',
                  ])
                            ) {
                              return null;
                            }
                            $event.stopPropagation();
                            $event.preventDefault();
                            _vm.visible = false;
                          },
                          function ($event) {
                            if (
                              !('button' in $event)
                  && _vm._k($event.keyCode, 'tab', 9, $event.key, 'Tab')
                            ) {
                              return null;
                            }
                            _vm.visible = false;
                          },
                        ],
                        paste($event) {
                          return _vm.debouncedOnInputChange($event);
                        },
                        mouseenter($event) {
                          _vm.inputHovering = true;
                        },
                        mouseleave($event) {
                          _vm.inputHovering = false;
                        },
                      },
                      model: {
                        value: _vm.selectedLabel,
                        callback($$v) {
                          _vm.selectedLabel = $$v;
                        },
                        expression: 'selectedLabel',
                      },
                    },
                    [
                      _vm.$slots.prefix
                        ? _c('template', { slot: 'prefix' }, [_vm._t('prefix')], 2)
                        : _vm._e(),
                      _c('template', { slot: 'suffix' }, [
                        _c('i', {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: !_vm.showClose,
                              expression: '!showClose',
                            },
                          ],
                          class: [
                            'el-select__caret',
                            'el-input__icon',
                            `el-icon-${_vm.iconClass}`,
                          ],
                        }),
                        _vm.showClose
                          ? _c('i', {
                            staticClass:
                    'el-select__caret el-input__icon el-icon-circle-close',
                            on: { click: _vm.handleClearClick },
                          })
                          : _vm._e(),
                      ]),
                    ],
                    2,
                  ),
                  _c(
                    'transition',
                    {
                      attrs: { name: 'el-zoom-in-top' },
                      on: {
                        'before-enter': _vm.handleMenuEnter,
                        'after-leave': _vm.doDestroy,
                      },
                    },
                    [
                      _c(
                        'el-select-menu',
                        {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: _vm.visible && _vm.emptyText !== false,
                              expression: 'visible && emptyText !== false',
                            },
                          ],
                          ref: 'popper',
                          attrs: { 'append-to-body': _vm.popperAppendToBody },
                        },
                        [
                          _c(
                            'el-scrollbar',
                            {
                              directives: [
                                {
                                  name: 'show',
                                  rawName: 'v-show',
                                  value: _vm.options.length > 0 && !_vm.loading,
                                  expression: 'options.length > 0 && !loading',
                                },
                              ],
                              ref: 'scrollbar',
                              class: {
                                'is-empty':
                      !_vm.allowCreate
                      && _vm.query
                      && _vm.filteredOptionsCount === 0,
                              },
                              attrs: {
                                tag: 'ul',
                                'wrap-class': 'el-select-dropdown__wrap',
                                'view-class': 'el-select-dropdown__list',
                              },
                            },
                            [
                              _vm.showNewOption
                                ? _c('el-option', {
                                  attrs: { value: _vm.query, created: '' },
                                })
                                : _vm._e(),
                              _vm._t('default'),
                            ],
                            2,
                          ),
                          _vm.emptyText
              && (!_vm.allowCreate
                || _vm.loading
                || (_vm.allowCreate && _vm.options.length === 0))
                            ? [
                              _vm.$slots.empty
                                ? _vm._t('empty')
                                : _c('p', { staticClass: 'el-select-dropdown__empty' }, [
                                  _vm._v(
                                    `\n          ${
                                      _vm._s(_vm.emptyText)
                                    }\n        `,
                                  ),
                                ]),
                            ]
                            : _vm._e(),
                        ],
                        2,
                      ),
                    ],
                    1,
                  ),
                ],
                1,
              );
            };
            const staticRenderFns = [];
            render._withStripped = true;

            // CONCATENATED MODULE: ./packages/select/src/select.vue?vue&type=template&id=0e4aade6&

            // EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"
            const emitter_ = __webpack_require__(4);
            const emitter_default = /* #__PURE__ */__webpack_require__.n(emitter_);

            // EXTERNAL MODULE: external "element-ui/lib/mixins/focus"
            const focus_ = __webpack_require__(22);
            const focus_default = /* #__PURE__ */__webpack_require__.n(focus_);

            // EXTERNAL MODULE: external "element-ui/lib/mixins/locale"
            const locale_ = __webpack_require__(6);
            const locale_default = /* #__PURE__ */__webpack_require__.n(locale_);

            // EXTERNAL MODULE: external "element-ui/lib/input"
            const input_ = __webpack_require__(10);
            const input_default = /* #__PURE__ */__webpack_require__.n(input_);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select-dropdown.vue?vue&type=template&id=06828748&
            const select_dropdownvue_type_template_id_06828748_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-select-dropdown el-popper',
                  class: [{ 'is-multiple': _vm.$parent.multiple }, _vm.popperClass],
                  style: { minWidth: _vm.minWidth },
                },
                [_vm._t('default')],
                2,
              );
            };
            const select_dropdownvue_type_template_id_06828748_staticRenderFns = [];
            select_dropdownvue_type_template_id_06828748_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/select/src/select-dropdown.vue?vue&type=template&id=06828748&

            // EXTERNAL MODULE: external "element-ui/lib/utils/vue-popper"
            const vue_popper_ = __webpack_require__(5);
            const vue_popper_default = /* #__PURE__ */__webpack_require__.n(vue_popper_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select-dropdown.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const select_dropdownvue_type_script_lang_js_ = ({
              name: 'ElSelectDropdown',

              componentName: 'ElSelectDropdown',

              mixins: [vue_popper_default.a],

              props: {
                placement: {
                  default: 'bottom-start',
                },

                boundariesPadding: {
                  default: 0,
                },

                popperOptions: {
                  default: function _default() {
                    return {
                      gpuAcceleration: false,
                    };
                  },
                },

                visibleArrow: {
                  default: true,
                },

                appendToBody: {
                  type: Boolean,
                  default: true,
                },
              },

              data: function data() {
                return {
                  minWidth: '',
                };
              },

              computed: {
                popperClass: function popperClass() {
                  return this.$parent.popperClass;
                },
              },

              watch: {
                '$parent.inputWidth': function $parentInputWidth() {
                  this.minWidth = `${this.$parent.$el.getBoundingClientRect().width}px`;
                },
              },

              mounted: function mounted() {
                const _this = this;

                this.referenceElm = this.$parent.$refs.reference.$el;
                this.$parent.popperElm = this.popperElm = this.$el;
                this.$on('updatePopper', () => {
                  if (_this.$parent.visible) _this.updatePopper();
                });
                this.$on('destroyPopper', this.destroyPopper);
              },
            });
            // CONCATENATED MODULE: ./packages/select/src/select-dropdown.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_select_dropdownvue_type_script_lang_js_ = (select_dropdownvue_type_script_lang_js_);
            // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
            const componentNormalizer = __webpack_require__(0);

            // CONCATENATED MODULE: ./packages/select/src/select-dropdown.vue

            /* normalize component */

            const component = Object(componentNormalizer['a' /* default */])(
              src_select_dropdownvue_type_script_lang_js_,
              select_dropdownvue_type_template_id_06828748_render,
              select_dropdownvue_type_template_id_06828748_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let api; }
            component.options.__file = 'packages/select/src/select-dropdown.vue';
            /* harmony default export */ const select_dropdown = (component.exports);
            // EXTERNAL MODULE: ./packages/select/src/option.vue + 4 modules
            const src_option = __webpack_require__(33);

            // EXTERNAL MODULE: external "element-ui/lib/tag"
            const tag_ = __webpack_require__(37);
            const tag_default = /* #__PURE__ */__webpack_require__.n(tag_);

            // EXTERNAL MODULE: external "element-ui/lib/scrollbar"
            const scrollbar_ = __webpack_require__(14);
            const scrollbar_default = /* #__PURE__ */__webpack_require__.n(scrollbar_);

            // EXTERNAL MODULE: external "throttle-debounce/debounce"
            const debounce_ = __webpack_require__(17);
            const debounce_default = /* #__PURE__ */__webpack_require__.n(debounce_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/clickoutside"
            const clickoutside_ = __webpack_require__(12);
            const clickoutside_default = /* #__PURE__ */__webpack_require__.n(clickoutside_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/resize-event"
            const resize_event_ = __webpack_require__(16);

            // EXTERNAL MODULE: external "element-ui/lib/utils/scroll-into-view"
            const scroll_into_view_ = __webpack_require__(31);
            const scroll_into_view_default = /* #__PURE__ */__webpack_require__.n(scroll_into_view_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/util"
            const util_ = __webpack_require__(3);

            // CONCATENATED MODULE: ./packages/select/src/navigation-mixin.js
            /* harmony default export */ const navigation_mixin = ({
              data: function data() {
                return {
                  hoverOption: -1,
                };
              },

              computed: {
                optionsAllDisabled: function optionsAllDisabled() {
                  return this.options.filter((option) => option.visible).every((option) => option.disabled);
                },
              },

              watch: {
                hoverIndex: function hoverIndex(val) {
                  const _this = this;

                  if (typeof val === 'number' && val > -1) {
                    this.hoverOption = this.options[val] || {};
                  }
                  this.options.forEach((option) => {
                    option.hover = _this.hoverOption === option;
                  });
                },
              },

              methods: {
                navigateOptions: function navigateOptions(direction) {
                  const _this2 = this;

                  if (!this.visible) {
                    this.visible = true;
                    return;
                  }
                  if (this.options.length === 0 || this.filteredOptionsCount === 0) return;
                  if (!this.optionsAllDisabled) {
                    if (direction === 'next') {
                      this.hoverIndex++;
                      if (this.hoverIndex === this.options.length) {
                        this.hoverIndex = 0;
                      }
                    } else if (direction === 'prev') {
                      this.hoverIndex--;
                      if (this.hoverIndex < 0) {
                        this.hoverIndex = this.options.length - 1;
                      }
                    }
                    const option = this.options[this.hoverIndex];
                    if (option.disabled === true || option.groupDisabled === true || !option.visible) {
                      this.navigateOptions(direction);
                    }
                    this.$nextTick(() => _this2.scrollToOption(_this2.hoverOption));
                  }
                },
              },
            });
            // EXTERNAL MODULE: external "element-ui/lib/utils/shared"
            const shared_ = __webpack_require__(21);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const selectvue_type_script_lang_js_ = ({
              mixins: [emitter_default.a, locale_default.a, focus_default()('reference'), navigation_mixin],

              name: 'ElSelect',

              componentName: 'ElSelect',

              inject: {
                elForm: {
                  default: '',
                },

                elFormItem: {
                  default: '',
                },
              },

              provide: function provide() {
                return {
                  select: this,
                };
              },

              computed: {
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                readonly: function readonly() {
                  return !this.filterable || this.multiple || !Object(util_.isIE)() && !Object(util_.isEdge)() && !this.visible;
                },
                showClose: function showClose() {
                  const hasValue = this.multiple ? Array.isArray(this.value) && this.value.length > 0 : this.value !== undefined && this.value !== null && this.value !== '';
                  const criteria = this.clearable && !this.selectDisabled && this.inputHovering && hasValue;
                  return criteria;
                },
                iconClass: function iconClass() {
                  return this.remote && this.filterable ? '' : this.visible ? 'arrow-up is-reverse' : 'arrow-up';
                },
                debounce: function debounce() {
                  return this.remote ? 300 : 0;
                },
                emptyText: function emptyText() {
                  if (this.loading) {
                    return this.loadingText || this.t('el.select.loading');
                  }
                  if (this.remote && this.query === '' && this.options.length === 0) return false;
                  if (this.filterable && this.query && this.options.length > 0 && this.filteredOptionsCount === 0) {
                    return this.noMatchText || this.t('el.select.noMatch');
                  }
                  if (this.options.length === 0) {
                    return this.noDataText || this.t('el.select.noData');
                  }

                  return null;
                },
                showNewOption: function showNewOption() {
                  const _this = this;

                  const hasExistingOption = this.options.filter((option) => !option.created).some((option) => option.currentLabel === _this.query);
                  return this.filterable && this.allowCreate && this.query !== '' && !hasExistingOption;
                },
                selectSize: function selectSize() {
                  return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
                selectDisabled: function selectDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
                collapseTagSize: function collapseTagSize() {
                  return ['small', 'mini'].indexOf(this.selectSize) > -1 ? 'mini' : 'small';
                },
                propPlaceholder: function propPlaceholder() {
                  return typeof this.placeholder !== 'undefined' ? this.placeholder : this.t('el.select.placeholder');
                },
              },

              components: {
                ElInput: input_default.a,
                ElSelectMenu: select_dropdown,
                ElOption: src_option['a' /* default */],
                ElTag: tag_default.a,
                ElScrollbar: scrollbar_default.a,
              },

              directives: { Clickoutside: clickoutside_default.a },

              props: {
                name: String,
                id: String,
                value: {
                  required: true,
                },
                autocomplete: {
                  type: String,
                  default: 'off',
                },
                /** @Deprecated in next major version */
                autoComplete: {
                  type: String,
                  validator: function validator(val) {
                    false && false;
                    return true;
                  },
                },
                automaticDropdown: Boolean,
                size: String,
                disabled: Boolean,
                clearable: Boolean,
                filterable: Boolean,
                allowCreate: Boolean,
                loading: Boolean,
                popperClass: String,
                remote: Boolean,
                loadingText: String,
                noMatchText: String,
                noDataText: String,
                remoteMethod: Function,
                filterMethod: Function,
                multiple: Boolean,
                multipleLimit: {
                  type: Number,
                  default: 0,
                },
                placeholder: {
                  type: String,
                  required: false,
                },
                defaultFirstOption: Boolean,
                reserveKeyword: Boolean,
                valueKey: {
                  type: String,
                  default: 'value',
                },
                collapseTags: Boolean,
                popperAppendToBody: {
                  type: Boolean,
                  default: true,
                },
              },

              data: function data() {
                return {
                  options: [],
                  cachedOptions: [],
                  createdLabel: null,
                  createdSelected: false,
                  selected: this.multiple ? [] : {},
                  inputLength: 20,
                  inputWidth: 0,
                  initialInputHeight: 0,
                  cachedPlaceHolder: '',
                  optionsCount: 0,
                  filteredOptionsCount: 0,
                  visible: false,
                  softFocus: false,
                  selectedLabel: '',
                  hoverIndex: -1,
                  query: '',
                  previousQuery: null,
                  inputHovering: false,
                  currentPlaceholder: '',
                  menuVisibleOnFocus: false,
                  isOnComposition: false,
                  isSilentBlur: false,
                };
              },

              watch: {
                selectDisabled: function selectDisabled() {
                  const _this2 = this;

                  this.$nextTick(() => {
                    _this2.resetInputHeight();
                  });
                },
                propPlaceholder: function propPlaceholder(val) {
                  this.cachedPlaceHolder = this.currentPlaceholder = val;
                },
                value: function value(val, oldVal) {
                  if (this.multiple) {
                    this.resetInputHeight();
                    if (val && val.length > 0 || this.$refs.input && this.query !== '') {
                      this.currentPlaceholder = '';
                    } else {
                      this.currentPlaceholder = this.cachedPlaceHolder;
                    }
                    if (this.filterable && !this.reserveKeyword) {
                      this.query = '';
                      this.handleQueryChange(this.query);
                    }
                  }
                  this.setSelected();
                  if (this.filterable && !this.multiple) {
                    this.inputLength = 20;
                  }
                  if (!Object(util_.valueEquals)(val, oldVal)) {
                    this.dispatch('ElFormItem', 'el.form.change', val);
                  }
                },
                visible: function visible(val) {
                  const _this3 = this;

                  if (!val) {
                    this.broadcast('ElSelectDropdown', 'destroyPopper');
                    if (this.$refs.input) {
                      this.$refs.input.blur();
                    }
                    this.query = '';
                    this.previousQuery = null;
                    this.selectedLabel = '';
                    this.inputLength = 20;
                    this.menuVisibleOnFocus = false;
                    this.resetHoverIndex();
                    this.$nextTick(() => {
                      if (_this3.$refs.input && _this3.$refs.input.value === '' && _this3.selected.length === 0) {
                        _this3.currentPlaceholder = _this3.cachedPlaceHolder;
                      }
                    });
                    if (!this.multiple) {
                      if (this.selected) {
                        if (this.filterable && this.allowCreate && this.createdSelected && this.createdLabel) {
                          this.selectedLabel = this.createdLabel;
                        } else {
                          this.selectedLabel = this.selected.currentLabel;
                        }
                        if (this.filterable) this.query = this.selectedLabel;
                      }

                      if (this.filterable) {
                        this.currentPlaceholder = this.cachedPlaceHolder;
                      }
                    }
                  } else {
                    this.broadcast('ElSelectDropdown', 'updatePopper');
                    if (this.filterable) {
                      this.query = this.remote ? '' : this.selectedLabel;
                      this.handleQueryChange(this.query);
                      if (this.multiple) {
                        this.$refs.input.focus();
                      } else {
                        if (!this.remote) {
                          this.broadcast('ElOption', 'queryChange', '');
                          this.broadcast('ElOptionGroup', 'queryChange');
                        }

                        if (this.selectedLabel) {
                          this.currentPlaceholder = this.selectedLabel;
                          this.selectedLabel = '';
                        }
                      }
                    }
                  }
                  this.$emit('visible-change', val);
                },
                options: function options() {
                  const _this4 = this;

                  if (this.$isServer) return;
                  this.$nextTick(() => {
                    _this4.broadcast('ElSelectDropdown', 'updatePopper');
                  });
                  if (this.multiple) {
                    this.resetInputHeight();
                  }
                  const inputs = this.$el.querySelectorAll('input');
                  if ([].indexOf.call(inputs, document.activeElement) === -1) {
                    this.setSelected();
                  }
                  if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
                    this.checkDefaultFirstOption();
                  }
                },
              },

              methods: {
                handleComposition: function handleComposition(event) {
                  const _this5 = this;

                  const text = event.target.value;
                  if (event.type === 'compositionend') {
                    this.isOnComposition = false;
                    this.$nextTick((_) => _this5.handleQueryChange(text));
                  } else {
                    const lastCharacter = text[text.length - 1] || '';
                    this.isOnComposition = !Object(shared_.isKorean)(lastCharacter);
                  }
                },
                handleQueryChange: function handleQueryChange(val) {
                  const _this6 = this;

                  if (this.previousQuery === val || this.isOnComposition) return;
                  if (this.previousQuery === null && (typeof this.filterMethod === 'function' || typeof this.remoteMethod === 'function')) {
                    this.previousQuery = val;
                    return;
                  }
                  this.previousQuery = val;
                  this.$nextTick(() => {
                    if (_this6.visible) _this6.broadcast('ElSelectDropdown', 'updatePopper');
                  });
                  this.hoverIndex = -1;
                  if (this.multiple && this.filterable) {
                    this.$nextTick(() => {
                      const length = _this6.$refs.input.value.length * 15 + 20;
                      _this6.inputLength = _this6.collapseTags ? Math.min(50, length) : length;
                      _this6.managePlaceholder();
                      _this6.resetInputHeight();
                    });
                  }
                  if (this.remote && typeof this.remoteMethod === 'function') {
                    this.hoverIndex = -1;
                    this.remoteMethod(val);
                  } else if (typeof this.filterMethod === 'function') {
                    this.filterMethod(val);
                    this.broadcast('ElOptionGroup', 'queryChange');
                  } else {
                    this.filteredOptionsCount = this.optionsCount;
                    this.broadcast('ElOption', 'queryChange', val);
                    this.broadcast('ElOptionGroup', 'queryChange');
                  }
                  if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
                    this.checkDefaultFirstOption();
                  }
                },
                scrollToOption: function scrollToOption(option) {
                  const target = Array.isArray(option) && option[0] ? option[0].$el : option.$el;
                  if (this.$refs.popper && target) {
                    const menu = this.$refs.popper.$el.querySelector('.el-select-dropdown__wrap');
                    scroll_into_view_default()(menu, target);
                  }
                  this.$refs.scrollbar && this.$refs.scrollbar.handleScroll();
                },
                handleMenuEnter: function handleMenuEnter() {
                  const _this7 = this;

                  this.$nextTick(() => _this7.scrollToOption(_this7.selected));
                },
                emitChange: function emitChange(val) {
                  if (!Object(util_.valueEquals)(this.value, val)) {
                    this.$emit('change', val);
                  }
                },
                getOption: function getOption(value) {
                  let option = void 0;
                  const isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
                  const isNull = Object.prototype.toString.call(value).toLowerCase() === '[object null]';
                  const isUndefined = Object.prototype.toString.call(value).toLowerCase() === '[object undefined]';

                  for (let i = this.cachedOptions.length - 1; i >= 0; i--) {
                    const cachedOption = this.cachedOptions[i];
                    const isEqual = isObject ? Object(util_.getValueByPath)(cachedOption.value, this.valueKey) === Object(util_.getValueByPath)(value, this.valueKey) : cachedOption.value === value;
                    if (isEqual) {
                      option = cachedOption;
                      break;
                    }
                  }
                  if (option) return option;
                  const label = !isObject && !isNull && !isUndefined ? value : '';
                  const newOption = {
                    value,
                    currentLabel: label,
                  };
                  if (this.multiple) {
                    newOption.hitState = false;
                  }
                  return newOption;
                },
                setSelected: function setSelected() {
                  const _this8 = this;

                  if (!this.multiple) {
                    const option = this.getOption(this.value);
                    if (option.created) {
                      this.createdLabel = option.currentLabel;
                      this.createdSelected = true;
                    } else {
                      this.createdSelected = false;
                    }
                    this.selectedLabel = option.currentLabel;
                    this.selected = option;
                    if (this.filterable) this.query = this.selectedLabel;
                    return;
                  }
                  const result = [];
                  if (Array.isArray(this.value)) {
                    this.value.forEach((value) => {
                      result.push(_this8.getOption(value));
                    });
                  }
                  this.selected = result;
                  this.$nextTick(() => {
                    _this8.resetInputHeight();
                  });
                },
                handleFocus: function handleFocus(event) {
                  if (!this.softFocus) {
                    if (this.automaticDropdown || this.filterable) {
                      this.visible = true;
                      if (this.filterable) {
                        this.menuVisibleOnFocus = true;
                      }
                    }
                    this.$emit('focus', event);
                  } else {
                    this.softFocus = false;
                  }
                },
                blur: function blur() {
                  this.visible = false;
                  this.$refs.reference.blur();
                },
                handleBlur: function handleBlur(event) {
                  const _this9 = this;

                  setTimeout(() => {
                    if (_this9.isSilentBlur) {
                      _this9.isSilentBlur = false;
                    } else {
                      _this9.$emit('blur', event);
                    }
                  }, 50);
                  this.softFocus = false;
                },
                handleClearClick: function handleClearClick(event) {
                  this.deleteSelected(event);
                },
                doDestroy: function doDestroy() {
                  this.$refs.popper && this.$refs.popper.doDestroy();
                },
                handleClose: function handleClose() {
                  this.visible = false;
                },
                toggleLastOptionHitState: function toggleLastOptionHitState(hit) {
                  if (!Array.isArray(this.selected)) return;
                  const option = this.selected[this.selected.length - 1];
                  if (!option) return;

                  if (hit === true || hit === false) {
                    option.hitState = hit;
                    return hit;
                  }

                  option.hitState = !option.hitState;
                  return option.hitState;
                },
                deletePrevTag: function deletePrevTag(e) {
                  if (e.target.value.length <= 0 && !this.toggleLastOptionHitState()) {
                    const value = this.value.slice();
                    value.pop();
                    this.$emit('input', value);
                    this.emitChange(value);
                  }
                },
                managePlaceholder: function managePlaceholder() {
                  if (this.currentPlaceholder !== '') {
                    this.currentPlaceholder = this.$refs.input.value ? '' : this.cachedPlaceHolder;
                  }
                },
                resetInputState: function resetInputState(e) {
                  if (e.keyCode !== 8) this.toggleLastOptionHitState(false);
                  this.inputLength = this.$refs.input.value.length * 15 + 20;
                  this.resetInputHeight();
                },
                resetInputHeight: function resetInputHeight() {
                  const _this10 = this;

                  if (this.collapseTags && !this.filterable) return;
                  this.$nextTick(() => {
                    if (!_this10.$refs.reference) return;
                    const inputChildNodes = _this10.$refs.reference.$el.childNodes;
                    const input = [].filter.call(inputChildNodes, (item) => item.tagName === 'INPUT')[0];
                    const { tags } = _this10.$refs;
                    const sizeInMap = _this10.initialInputHeight || 40;
                    input.style.height = _this10.selected.length === 0 ? `${sizeInMap}px` : `${Math.max(tags ? tags.clientHeight + (tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)}px`;
                    if (_this10.visible && _this10.emptyText !== false) {
                      _this10.broadcast('ElSelectDropdown', 'updatePopper');
                    }
                  });
                },
                resetHoverIndex: function resetHoverIndex() {
                  const _this11 = this;

                  setTimeout(() => {
                    if (!_this11.multiple) {
                      _this11.hoverIndex = _this11.options.indexOf(_this11.selected);
                    } else if (_this11.selected.length > 0) {
                      _this11.hoverIndex = Math.min.apply(null, _this11.selected.map((item) => _this11.options.indexOf(item)));
                    } else {
                      _this11.hoverIndex = -1;
                    }
                  }, 300);
                },
                handleOptionSelect: function handleOptionSelect(option, byClick) {
                  const _this12 = this;

                  if (this.multiple) {
                    const value = (this.value || []).slice();
                    const optionIndex = this.getValueIndex(value, option.value);
                    if (optionIndex > -1) {
                      value.splice(optionIndex, 1);
                    } else if (this.multipleLimit <= 0 || value.length < this.multipleLimit) {
                      value.push(option.value);
                    }
                    this.$emit('input', value);
                    this.emitChange(value);
                    if (option.created) {
                      this.query = '';
                      this.handleQueryChange('');
                      this.inputLength = 20;
                    }
                    if (this.filterable) this.$refs.input.focus();
                  } else {
                    this.$emit('input', option.value);
                    this.emitChange(option.value);
                    this.visible = false;
                  }
                  this.isSilentBlur = byClick;
                  this.setSoftFocus();
                  if (this.visible) return;
                  this.$nextTick(() => {
                    _this12.scrollToOption(option);
                  });
                },
                setSoftFocus: function setSoftFocus() {
                  this.softFocus = true;
                  const input = this.$refs.input || this.$refs.reference;
                  if (input) {
                    input.focus();
                  }
                },
                getValueIndex: function getValueIndex() {
                  const arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                  const value = arguments[1];

                  const isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
                  if (!isObject) {
                    return arr.indexOf(value);
                  }
                  const { valueKey } = this;
                  let index = -1;
                  arr.some((item, i) => {
                    if (Object(util_.getValueByPath)(item, valueKey) === Object(util_.getValueByPath)(value, valueKey)) {
                      index = i;
                      return true;
                    }
                    return false;
                  });
                  return index;
                },
                toggleMenu: function toggleMenu() {
                  if (!this.selectDisabled) {
                    if (this.menuVisibleOnFocus) {
                      this.menuVisibleOnFocus = false;
                    } else {
                      this.visible = !this.visible;
                    }
                    if (this.visible) {
                      (this.$refs.input || this.$refs.reference).focus();
                    }
                  }
                },
                selectOption: function selectOption() {
                  if (!this.visible) {
                    this.toggleMenu();
                  } else if (this.options[this.hoverIndex]) {
                    this.handleOptionSelect(this.options[this.hoverIndex]);
                  }
                },
                deleteSelected: function deleteSelected(event) {
                  event.stopPropagation();
                  const value = this.multiple ? [] : '';
                  this.$emit('input', value);
                  this.emitChange(value);
                  this.visible = false;
                  this.$emit('clear');
                },
                deleteTag: function deleteTag(event, tag) {
                  const index = this.selected.indexOf(tag);
                  if (index > -1 && !this.selectDisabled) {
                    const value = this.value.slice();
                    value.splice(index, 1);
                    this.$emit('input', value);
                    this.emitChange(value);
                    this.$emit('remove-tag', tag.value);
                  }
                  event.stopPropagation();
                },
                onInputChange: function onInputChange() {
                  if (this.filterable && this.query !== this.selectedLabel) {
                    this.query = this.selectedLabel;
                    this.handleQueryChange(this.query);
                  }
                },
                onOptionDestroy: function onOptionDestroy(index) {
                  if (index > -1) {
                    this.optionsCount--;
                    this.filteredOptionsCount--;
                    this.options.splice(index, 1);
                  }
                },
                resetInputWidth: function resetInputWidth() {
                  this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
                },
                handleResize: function handleResize() {
                  this.resetInputWidth();
                  if (this.multiple) this.resetInputHeight();
                },
                checkDefaultFirstOption: function checkDefaultFirstOption() {
                  this.hoverIndex = -1;
                  // highlight the created option
                  let hasCreated = false;
                  for (let i = this.options.length - 1; i >= 0; i--) {
                    if (this.options[i].created) {
                      hasCreated = true;
                      this.hoverIndex = i;
                      break;
                    }
                  }
                  if (hasCreated) return;
                  for (let _i = 0; _i !== this.options.length; ++_i) {
                    const option = this.options[_i];
                    if (this.query) {
                      // highlight first options that passes the filter
                      if (!option.disabled && !option.groupDisabled && option.visible) {
                        this.hoverIndex = _i;
                        break;
                      }
                    } else {
                      // highlight currently selected option
                      if (option.itemSelected) {
                        this.hoverIndex = _i;
                        break;
                      }
                    }
                  }
                },
                getValueKey: function getValueKey(item) {
                  if (Object.prototype.toString.call(item.value).toLowerCase() !== '[object object]') {
                    return item.value;
                  }
                  return Object(util_.getValueByPath)(item.value, this.valueKey);
                },
              },

              created: function created() {
                const _this13 = this;

                this.cachedPlaceHolder = this.currentPlaceholder = this.propPlaceholder;
                if (this.multiple && !Array.isArray(this.value)) {
                  this.$emit('input', []);
                }
                if (!this.multiple && Array.isArray(this.value)) {
                  this.$emit('input', '');
                }

                this.debouncedOnInputChange = debounce_default()(this.debounce, () => {
                  _this13.onInputChange();
                });

                this.debouncedQueryChange = debounce_default()(this.debounce, (e) => {
                  _this13.handleQueryChange(e.target.value);
                });

                this.$on('handleOptionClick', this.handleOptionSelect);
                this.$on('setSelected', this.setSelected);
              },
              mounted: function mounted() {
                const _this14 = this;

                if (this.multiple && Array.isArray(this.value) && this.value.length > 0) {
                  this.currentPlaceholder = '';
                }
                Object(resize_event_.addResizeListener)(this.$el, this.handleResize);

                const { reference } = this.$refs;
                if (reference && reference.$el) {
                  const sizeMap = {
                    medium: 36,
                    small: 32,
                    mini: 28,
                  };
                  const input = reference.$el.querySelector('input');
                  this.initialInputHeight = input.getBoundingClientRect().height || sizeMap[this.selectSize];
                }
                if (this.remote && this.multiple) {
                  this.resetInputHeight();
                }
                this.$nextTick(() => {
                  if (reference && reference.$el) {
                    _this14.inputWidth = reference.$el.getBoundingClientRect().width;
                  }
                });
                this.setSelected();
              },
              beforeDestroy: function beforeDestroy() {
                if (this.$el && this.handleResize) Object(resize_event_.removeResizeListener)(this.$el, this.handleResize);
              },
            });
            // CONCATENATED MODULE: ./packages/select/src/select.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_selectvue_type_script_lang_js_ = (selectvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/select/src/select.vue

            /* normalize component */

            const select_component = Object(componentNormalizer['a' /* default */])(
              src_selectvue_type_script_lang_js_,
              render,
              staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let select_api; }
            select_component.options.__file = 'packages/select/src/select.vue';
            /* harmony default export */ const src_select = (select_component.exports);
            // CONCATENATED MODULE: ./packages/select/index.js

            /* istanbul ignore next */
            src_select.install = function (Vue) {
              Vue.component(src_select.name, src_select);
            };

            /* harmony default export */ const packages_select = __webpack_exports__.default = (src_select);
            /***/ }),

          /** *** */ }));
      /***/ }),

    /***/ '4e71':
    /***/ (function (module, exports, __webpack_require__) {
      __webpack_require__('e198')('observable');
      /***/ }),

    /***/ '4ebc':
    /***/ (function (module, exports, __webpack_require__) {
      // 7.2.2 IsArray(argument)
      const cof = __webpack_require__('4d88');
      module.exports = Array.isArray || function isArray(arg) {
        return cof(arg) == 'Array';
      };
      /***/ }),

    /***/ '511f':
    /***/ (function (module, exports, __webpack_require__) {
      __webpack_require__('0b99');
      __webpack_require__('658f');
      module.exports = __webpack_require__('fcd4').f('iterator');
      /***/ }),

    /***/ 5128:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;
      exports.PopupManager = undefined;

      const _vue = __webpack_require__('8bbf');

      const _vue2 = _interopRequireDefault(_vue);

      const _merge = __webpack_require__('7f4d');

      const _merge2 = _interopRequireDefault(_merge);

      const _popupManager = __webpack_require__('4b26');

      const _popupManager2 = _interopRequireDefault(_popupManager);

      const _scrollbarWidth = __webpack_require__('e62d');

      const _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);

      const _dom = __webpack_require__('5924');

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      let idSeed = 1;

      let scrollBarWidth = void 0;

      exports.default = {
        props: {
          visible: {
            type: Boolean,
            default: false,
          },
          openDelay: {},
          closeDelay: {},
          zIndex: {},
          modal: {
            type: Boolean,
            default: false,
          },
          modalFade: {
            type: Boolean,
            default: true,
          },
          modalClass: {},
          modalAppendToBody: {
            type: Boolean,
            default: false,
          },
          lockScroll: {
            type: Boolean,
            default: true,
          },
          closeOnPressEscape: {
            type: Boolean,
            default: false,
          },
          closeOnClickModal: {
            type: Boolean,
            default: false,
          },
        },

        beforeMount: function beforeMount() {
          this._popupId = `popup-${idSeed++}`;
          _popupManager2.default.register(this._popupId, this);
        },
        beforeDestroy: function beforeDestroy() {
          _popupManager2.default.deregister(this._popupId);
          _popupManager2.default.closeModal(this._popupId);

          this.restoreBodyStyle();
        },
        data: function data() {
          return {
            opened: false,
            bodyPaddingRight: null,
            computedBodyPaddingRight: 0,
            withoutHiddenClass: true,
            rendered: false,
          };
        },

        watch: {
          visible: function visible(val) {
            const _this = this;

            if (val) {
              if (this._opening) return;
              if (!this.rendered) {
                this.rendered = true;
                _vue2.default.nextTick(() => {
                  _this.open();
                });
              } else {
                this.open();
              }
            } else {
              this.close();
            }
          },
        },

        methods: {
          open: function open(options) {
            const _this2 = this;

            if (!this.rendered) {
              this.rendered = true;
            }

            const props = (0, _merge2.default)({}, this.$props || this, options);

            if (this._closeTimer) {
              clearTimeout(this._closeTimer);
              this._closeTimer = null;
            }
            clearTimeout(this._openTimer);

            const openDelay = Number(props.openDelay);
            if (openDelay > 0) {
              this._openTimer = setTimeout(() => {
                _this2._openTimer = null;
                _this2.doOpen(props);
              }, openDelay);
            } else {
              this.doOpen(props);
            }
          },
          doOpen: function doOpen(props) {
            if (this.$isServer) return;
            if (this.willOpen && !this.willOpen()) return;
            if (this.opened) return;

            this._opening = true;

            const dom = this.$el;

            const { modal } = props;

            const { zIndex } = props;
            if (zIndex) {
              _popupManager2.default.zIndex = zIndex;
            }

            if (modal) {
              if (this._closing) {
                _popupManager2.default.closeModal(this._popupId);
                this._closing = false;
              }
              _popupManager2.default.openModal(this._popupId, _popupManager2.default.nextZIndex(), this.modalAppendToBody ? undefined : dom, props.modalClass, props.modalFade);
              if (props.lockScroll) {
                this.withoutHiddenClass = !(0, _dom.hasClass)(document.body, 'el-popup-parent--hidden');
                if (this.withoutHiddenClass) {
                  this.bodyPaddingRight = document.body.style.paddingRight;
                  this.computedBodyPaddingRight = parseInt((0, _dom.getStyle)(document.body, 'paddingRight'), 10);
                }
                scrollBarWidth = (0, _scrollbarWidth2.default)();
                const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
                const bodyOverflowY = (0, _dom.getStyle)(document.body, 'overflowY');
                if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll') && this.withoutHiddenClass) {
                  document.body.style.paddingRight = `${this.computedBodyPaddingRight + scrollBarWidth}px`;
                }
                (0, _dom.addClass)(document.body, 'el-popup-parent--hidden');
              }
            }

            if (getComputedStyle(dom).position === 'static') {
              dom.style.position = 'absolute';
            }

            dom.style.zIndex = _popupManager2.default.nextZIndex();
            this.opened = true;

            this.onOpen && this.onOpen();

            this.doAfterOpen();
          },
          doAfterOpen: function doAfterOpen() {
            this._opening = false;
          },
          close: function close() {
            const _this3 = this;

            if (this.willClose && !this.willClose()) return;

            if (this._openTimer !== null) {
              clearTimeout(this._openTimer);
              this._openTimer = null;
            }
            clearTimeout(this._closeTimer);

            const closeDelay = Number(this.closeDelay);

            if (closeDelay > 0) {
              this._closeTimer = setTimeout(() => {
                _this3._closeTimer = null;
                _this3.doClose();
              }, closeDelay);
            } else {
              this.doClose();
            }
          },
          doClose: function doClose() {
            this._closing = true;

            this.onClose && this.onClose();

            if (this.lockScroll) {
              setTimeout(this.restoreBodyStyle, 200);
            }

            this.opened = false;

            this.doAfterClose();
          },
          doAfterClose: function doAfterClose() {
            _popupManager2.default.closeModal(this._popupId);
            this._closing = false;
          },
          restoreBodyStyle: function restoreBodyStyle() {
            if (this.modal && this.withoutHiddenClass) {
              document.body.style.paddingRight = this.bodyPaddingRight;
              (0, _dom.removeClass)(document.body, 'el-popup-parent--hidden');
            }
            this.withoutHiddenClass = true;
          },
        },
      };
      exports.PopupManager = _popupManager2.default;
      /***/ }),

    /***/ '512c':
    /***/ (function (module, exports, __webpack_require__) {
      const global = __webpack_require__('ef08');
      const core = __webpack_require__('5524');
      const ctx = __webpack_require__('9c0c');
      const hide = __webpack_require__('051b');
      const has = __webpack_require__('9c0e');
      const PROTOTYPE = 'prototype';

      var $export = function (type, name, source) {
        const IS_FORCED = type & $export.F;
        const IS_GLOBAL = type & $export.G;
        const IS_STATIC = type & $export.S;
        const IS_PROTO = type & $export.P;
        const IS_BIND = type & $export.B;
        const IS_WRAP = type & $export.W;
        const exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
        const expProto = exports[PROTOTYPE];
        const target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
        let key; let own; let
          out;
        if (IS_GLOBAL) source = name;
        for (key in source) {
          // contains in native
          own = !IS_FORCED && target && target[key] !== undefined;
          if (own && has(exports, key)) continue;
          // export native or passed
          out = own ? target[key] : source[key];
          // prevent global pollution for namespaces
          exports[key] = IS_GLOBAL && typeof target[key] !== 'function' ? source[key]
          // bind timers to global for call from export context
            : IS_BIND && own ? ctx(out, global)
            // wrap global constructors for prevent change them in library
              : IS_WRAP && target[key] == out ? (function (C) {
                const F = function (a, b, c) {
                  if (this instanceof C) {
                    switch (arguments.length) {
                      case 0: return new C();
                      case 1: return new C(a);
                      case 2: return new C(a, b);
                    } return new C(a, b, c);
                  } return C.apply(this, arguments);
                };
                F[PROTOTYPE] = C[PROTOTYPE];
                return F;
                // make static versions for prototype methods
              }(out)) : IS_PROTO && typeof out === 'function' ? ctx(Function.call, out) : out;
          // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
          if (IS_PROTO) {
            (exports.virtual || (exports.virtual = {}))[key] = out;
            // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
            if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
          }
        }
      };
      // type bitmap
      $export.F = 1; // forced
      $export.G = 2; // global
      $export.S = 4; // static
      $export.P = 8; // proto
      $export.B = 16; // bind
      $export.W = 32; // wrap
      $export.U = 64; // safe
      $export.R = 128; // real proto method for `library`
      module.exports = $export;
      /***/ }),

    /***/ 5488:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      const _dom = __webpack_require__('5924');

      function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

      const Transition = (function () {
        function Transition() {
          _classCallCheck(this, Transition);
        }

        Transition.prototype.beforeEnter = function beforeEnter(el) {
          (0, _dom.addClass)(el, 'collapse-transition');
          if (!el.dataset) el.dataset = {};

          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;

          el.style.height = '0';
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        };

        Transition.prototype.enter = function enter(el) {
          el.dataset.oldOverflow = el.style.overflow;
          if (el.scrollHeight !== 0) {
            el.style.height = `${el.scrollHeight}px`;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          } else {
            el.style.height = '';
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          }

          el.style.overflow = 'hidden';
        };

        Transition.prototype.afterEnter = function afterEnter(el) {
          // for safari: remove class then reset height is necessary
          (0, _dom.removeClass)(el, 'collapse-transition');
          el.style.height = '';
          el.style.overflow = el.dataset.oldOverflow;
        };

        Transition.prototype.beforeLeave = function beforeLeave(el) {
          if (!el.dataset) el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.dataset.oldOverflow = el.style.overflow;

          el.style.height = `${el.scrollHeight}px`;
          el.style.overflow = 'hidden';
        };

        Transition.prototype.leave = function leave(el) {
          if (el.scrollHeight !== 0) {
            // for safari: add class after set height, or it will jump to zero height suddenly, weired
            (0, _dom.addClass)(el, 'collapse-transition');
            el.style.height = 0;
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
          }
        };

        Transition.prototype.afterLeave = function afterLeave(el) {
          (0, _dom.removeClass)(el, 'collapse-transition');
          el.style.height = '';
          el.style.overflow = el.dataset.oldOverflow;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        };

        return Transition;
      }());

      exports.default = {
        name: 'ElCollapseTransition',
        functional: true,
        render: function render(h, _ref) {
          const { children } = _ref;

          const data = {
            on: new Transition(),
          };

          return h('transition', data, children);
        },
      };
      /***/ }),

    /***/ 5524:
    /***/ (function (module, exports) {
      const core = module.exports = { version: '2.6.12' };
      if (typeof __e === 'number') __e = core; // eslint-disable-line no-undef
      /***/ }),

    /***/ 5924:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;
      exports.isInContainer = exports.getScrollContainer = exports.isScroll = exports.getStyle = exports.once = exports.off = exports.on = undefined;

      const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; }; /* istanbul ignore next */

      exports.hasClass = hasClass;
      exports.addClass = addClass;
      exports.removeClass = removeClass;
      exports.setStyle = setStyle;

      const _vue = __webpack_require__('8bbf');

      const _vue2 = _interopRequireDefault(_vue);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      const isServer = _vue2.default.prototype.$isServer;
      const SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      const MOZ_HACK_REGEXP = /^moz([A-Z])/;
      const ieVersion = isServer ? 0 : Number(document.documentMode);

      /* istanbul ignore next */
      const trim = function trim(string) {
        return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
      };
      /* istanbul ignore next */
      const camelCase = function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, (_, separator, letter, offset) => (offset ? letter.toUpperCase() : letter)).replace(MOZ_HACK_REGEXP, 'Moz$1');
      };

      /* istanbul ignore next */
      const on = exports.on = (function () {
        if (!isServer && document.addEventListener) {
          return function (element, event, handler) {
            if (element && event && handler) {
              element.addEventListener(event, handler, false);
            }
          };
        }
        return function (element, event, handler) {
          if (element && event && handler) {
            element.attachEvent(`on${event}`, handler);
          }
        };
      }());

      /* istanbul ignore next */
      const off = exports.off = (function () {
        if (!isServer && document.removeEventListener) {
          return function (element, event, handler) {
            if (element && event) {
              element.removeEventListener(event, handler, false);
            }
          };
        }
        return function (element, event, handler) {
          if (element && event) {
            element.detachEvent(`on${event}`, handler);
          }
        };
      }());

      /* istanbul ignore next */
      const once = exports.once = function once(el, event, fn) {
        const listener = function listener() {
          if (fn) {
            fn.apply(this, arguments);
          }
          off(el, event, listener);
        };
        on(el, event, listener);
      };

      /* istanbul ignore next */
      function hasClass(el, cls) {
        if (!el || !cls) return false;
        if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');
        if (el.classList) {
          return el.classList.contains(cls);
        }
        return (` ${el.className} `).indexOf(` ${cls} `) > -1;
      }

      /* istanbul ignore next */
      function addClass(el, cls) {
        if (!el) return;
        let curClass = el.className;
        const classes = (cls || '').split(' ');

        for (let i = 0, j = classes.length; i < j; i++) {
          const clsName = classes[i];
          if (!clsName) continue;

          if (el.classList) {
            el.classList.add(clsName);
          } else if (!hasClass(el, clsName)) {
            curClass += ` ${clsName}`;
          }
        }
        if (!el.classList) {
          el.className = curClass;
        }
      }

      /* istanbul ignore next */
      function removeClass(el, cls) {
        if (!el || !cls) return;
        const classes = cls.split(' ');
        let curClass = ` ${el.className} `;

        for (let i = 0, j = classes.length; i < j; i++) {
          const clsName = classes[i];
          if (!clsName) continue;

          if (el.classList) {
            el.classList.remove(clsName);
          } else if (hasClass(el, clsName)) {
            curClass = curClass.replace(` ${clsName} `, ' ');
          }
        }
        if (!el.classList) {
          el.className = trim(curClass);
        }
      }

      /* istanbul ignore next */
      const getStyle = exports.getStyle = ieVersion < 9 ? function (element, styleName) {
        if (isServer) return;
        if (!element || !styleName) return null;
        styleName = camelCase(styleName);
        if (styleName === 'float') {
          styleName = 'styleFloat';
        }
        try {
          switch (styleName) {
            case 'opacity':
              try {
                return element.filters.item('alpha').opacity / 100;
              } catch (e) {
                return 1.0;
              }
            default:
              return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
          }
        } catch (e) {
          return element.style[styleName];
        }
      } : function (element, styleName) {
        if (isServer) return;
        if (!element || !styleName) return null;
        styleName = camelCase(styleName);
        if (styleName === 'float') {
          styleName = 'cssFloat';
        }
        try {
          const computed = document.defaultView.getComputedStyle(element, '');
          return element.style[styleName] || computed ? computed[styleName] : null;
        } catch (e) {
          return element.style[styleName];
        }
      };

      /* istanbul ignore next */
      function setStyle(element, styleName, value) {
        if (!element || !styleName) return;

        if ((typeof styleName === 'undefined' ? 'undefined' : _typeof(styleName)) === 'object') {
          for (const prop in styleName) {
            if (styleName.hasOwnProperty(prop)) {
              setStyle(element, prop, styleName[prop]);
            }
          }
        } else {
          styleName = camelCase(styleName);
          if (styleName === 'opacity' && ieVersion < 9) {
            element.style.filter = isNaN(value) ? '' : `alpha(opacity=${value * 100})`;
          } else {
            element.style[styleName] = value;
          }
        }
      }

      const isScroll = exports.isScroll = function isScroll(el, vertical) {
        if (isServer) return;

        const determinedDirection = vertical !== null || vertical !== undefined;
        const overflow = determinedDirection ? vertical ? getStyle(el, 'overflow-y') : getStyle(el, 'overflow-x') : getStyle(el, 'overflow');

        return overflow.match(/(scroll|auto)/);
      };

      const getScrollContainer = exports.getScrollContainer = function getScrollContainer(el, vertical) {
        if (isServer) return;

        let parent = el;
        while (parent) {
          if ([window, document, document.documentElement].includes(parent)) {
            return window;
          }
          if (isScroll(parent, vertical)) {
            return parent;
          }
          parent = parent.parentNode;
        }

        return parent;
      };

      const isInContainer = exports.isInContainer = function isInContainer(el, container) {
        if (isServer || !el || !container) return false;

        const elRect = el.getBoundingClientRect();
        let containerRect = void 0;

        if ([window, document, document.documentElement, null, undefined].includes(container)) {
          containerRect = {
            top: 0,
            right: window.innerWidth,
            bottom: window.innerHeight,
            left: 0,
          };
        } else {
          containerRect = container.getBoundingClientRect();
        }

        return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
      };
      /***/ }),

    /***/ '597f':
    /***/ (function (module, exports) {
      /* eslint-disable no-undefined,no-param-reassign,no-shadow */

      /**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset)
 * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @return {Function}  A new, throttled, function.
 */
      module.exports = function (delay, noTrailing, callback, debounceMode) {
        // After wrapper has stopped being called, this timeout ensures that
        // `callback` is executed at the proper times in `throttle` and `end`
        // debounce modes.
        let timeoutID;

        // Keep track of the last time `callback` was executed.
        let lastExec = 0;

        // `noTrailing` defaults to falsy.
        if (typeof noTrailing !== 'boolean') {
          debounceMode = callback;
          callback = noTrailing;
          noTrailing = undefined;
        }

        // The `wrapper` function encapsulates all of the throttling / debouncing
        // functionality and when executed will limit the rate at which `callback`
        // is executed.
        function wrapper() {
          const self = this;
          const elapsed = Number(new Date()) - lastExec;
          const args = arguments;

          // Execute `callback` and update the `lastExec` timestamp.
          function exec() {
            lastExec = Number(new Date());
            callback.apply(self, args);
          }

          // If `debounceMode` is true (at begin) this is used to clear the flag
          // to allow future `callback` executions.
          function clear() {
            timeoutID = undefined;
          }

          if (debounceMode && !timeoutID) {
            // Since `wrapper` is being called for the first time and
            // `debounceMode` is true (at begin), execute `callback`.
            exec();
          }

          // Clear any existing timeout.
          if (timeoutID) {
            clearTimeout(timeoutID);
          }

          if (debounceMode === undefined && elapsed > delay) {
            // In throttle mode, if `delay` time has been exceeded, execute
            // `callback`.
            exec();
          } else if (noTrailing !== true) {
            // In trailing throttle mode, since `delay` time has not been
            // exceeded, schedule `callback` to execute `delay` ms after most
            // recent execution.
            //
            // If `debounceMode` is true (at begin), schedule `clear` to execute
            // after `delay` ms.
            //
            // If `debounceMode` is false (at end), schedule `callback` to
            // execute after `delay` ms.
            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
          }
        }

        // Return the wrapper function.
        return wrapper;
      };
      /***/ }),

    /***/ '5a94':
    /***/ (function (module, exports, __webpack_require__) {
      const shared = __webpack_require__('b367')('keys');
      const uid = __webpack_require__('8b1a');
      module.exports = function (key) {
        return shared[key] || (shared[key] = uid(key));
      };
      /***/ }),

    /***/ '5c96':
    /***/ (function (module, exports, __webpack_require__) {
      module.exports =
        /** *** */ (function (modules) { // webpackBootstrap
          /** *** */ 	// The module cache
          /** *** */ 	const installedModules = {};
          /** *** */
          /** *** */ 	// The require function
          /** *** */ 	function __webpack_require__(moduleId) {
            /** *** */
            /** *** */ 		// Check if module is in cache
            /** *** */ 		if (installedModules[moduleId]) {
              /** *** */ 			return installedModules[moduleId].exports;
              /** *** */ 		}
            /** *** */ 		// Create a new module (and put it into the cache)
            /** *** */ 		const module = installedModules[moduleId] = {
              /** *** */ 			i: moduleId,
              /** *** */ 			l: false,
              /** *** */ 			exports: {},
              /** *** */ 		};
            /** *** */
            /** *** */ 		// Execute the module function
            /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /** *** */
            /** *** */ 		// Flag the module as loaded
            /** *** */ 		module.l = true;
            /** *** */
            /** *** */ 		// Return the exports of the module
            /** *** */ 		return module.exports;
            /** *** */ 	}
          /** *** */
          /** *** */
          /** *** */ 	// expose the modules object (__webpack_modules__)
          /** *** */ 	__webpack_require__.m = modules;
          /** *** */
          /** *** */ 	// expose the module cache
          /** *** */ 	__webpack_require__.c = installedModules;
          /** *** */
          /** *** */ 	// define getter function for harmony exports
          /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
            /** *** */ 		if (!__webpack_require__.o(exports, name)) {
              /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
              /** *** */ 		}
            /** *** */ 	};
          /** *** */
          /** *** */ 	// define __esModule on exports
          /** *** */ 	__webpack_require__.r = function (exports) {
            /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
              /** *** */ 		}
            /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
            /** *** */ 	};
          /** *** */
          /** *** */ 	// create a fake namespace object
          /** *** */ 	// mode & 1: value is a module id, require it
          /** *** */ 	// mode & 2: merge all properties of value into the ns
          /** *** */ 	// mode & 4: return value when already ns object
          /** *** */ 	// mode & 8|1: behave like require
          /** *** */ 	__webpack_require__.t = function (value, mode) {
            /** *** */ 		if (mode & 1) value = __webpack_require__(value);
            /** *** */ 		if (mode & 8) return value;
            /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /** *** */ 		const ns = Object.create(null);
            /** *** */ 		__webpack_require__.r(ns);
            /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
            /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
            /** *** */ 		return ns;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
          /** *** */ 	__webpack_require__.n = function (module) {
            /** *** */ 		const getter = module && module.__esModule
            /** *** */ 			? function getDefault() { return module.default; }
            /** *** */ 			: function getModuleExports() { return module; };
            /** *** */ 		__webpack_require__.d(getter, 'a', getter);
            /** *** */ 		return getter;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// Object.prototype.hasOwnProperty.call
          /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
          /** *** */
          /** *** */ 	// __webpack_public_path__
          /** *** */ 	__webpack_require__.p = '/dist/';
          /** *** */
          /** *** */
          /** *** */ 	// Load entry module and return exports
          /** *** */ 	return __webpack_require__(__webpack_require__.s = 45);
          /** *** */ }([
          /* 0 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('d940');
            /***/ }),
          /* 1 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('5924');
            /***/ }),
          /* 2 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8122');
            /***/ }),
          /* 3 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('d010');
            /***/ }),
          /* 4 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('6b7c');
            /***/ }),
          /* 5 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('e974');
            /***/ }),
          /* 6 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8bbf');
            /***/ }),
          /* 7 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('7f4d');
            /***/ }),
          /* 8 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('f3ad');
            /***/ }),
          /* 9 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('2bb5');
            /***/ }),
          /* 10 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('417f');
            /***/ }),
          /* 11 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('eedf');
            /***/ }),
          /* 12 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('4010');
            /***/ }),
          /* 13 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('5128');
            /***/ }),
          /* 14 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('0e15');
            /***/ }),
          /* 15 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('4897');
            /***/ }),
          /* 16 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('dcdc');
            /***/ }),
          /* 17 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('14e9');
            /***/ }),
          /* 18 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('a742');
            /***/ }),
          /* 19 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('d397');
            /***/ }),
          /* 20 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('d7d1');
            /***/ }),
          /* 21 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('5488');
            /***/ }),
          /* 22 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('12f2');
            /***/ }),
          /* 23 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('41f8');
            /***/ }),
          /* 24 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('92fa');
            /***/ }),
          /* 25 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('597f');
            /***/ }),
          /* 26 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('299c');
            /***/ }),
          /* 27 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('2a5e');
            /***/ }),
          /* 28 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('845f');
            /***/ }),
          /* 29 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8bbc');
            /***/ }),
          /* 30 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('e62d');
            /***/ }),
          /* 31 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('7fc1');
            /***/ }),
          /* 32 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('c56a');
            /***/ }),
          /* 33 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('c284');
            /***/ }),
          /* 34 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('e452');
            /***/ }),
          /* 35 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('9619');
            /***/ }),
          /* 36 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('4e4b');
            /***/ }),
          /* 37 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('e772');
            /***/ }),
          /* 38 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('c098');
            /***/ }),
          /* 39 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('722f');
            /***/ }),
          /* 40 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('a15e');
            /***/ }),
          /* 41 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('e450');
            /***/ }),
          /* 42 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('4726');
            /***/ }),
          /* 43 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('f494');
            /***/ }),
          /* 44 */
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('6ac9');
            /***/ }),
          /* 45 */
          /***/ (function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(46);
            /***/ }),
          /* 46 */
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/pagination/src/pager.vue?vue&type=template&id=7274f267&
            const pagervue_type_template_id_7274f267_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'ul',
                { staticClass: 'el-pager', on: { click: _vm.onPagerClick } },
                [
                  _vm.pageCount > 0
                    ? _c(
                      'li',
                      {
                        staticClass: 'number',
                        class: { active: _vm.currentPage === 1, disabled: _vm.disabled },
                      },
                      [_vm._v('1')],
                    )
                    : _vm._e(),
                  _vm.showPrevMore
                    ? _c('li', {
                      staticClass: 'el-icon more btn-quickprev',
                      class: [_vm.quickprevIconClass, { disabled: _vm.disabled }],
                      on: {
                        mouseenter($event) {
                          _vm.onMouseenter('left');
                        },
                        mouseleave($event) {
                          _vm.quickprevIconClass = 'el-icon-more';
                        },
                      },
                    })
                    : _vm._e(),
                  _vm._l(_vm.pagers, (pager) => _c(
                    'li',
                    {
                      key: pager,
                      staticClass: 'number',
                      class: { active: _vm.currentPage === pager, disabled: _vm.disabled },
                    },
                    [_vm._v(_vm._s(pager))],
                  )),
                  _vm.showNextMore
                    ? _c('li', {
                      staticClass: 'el-icon more btn-quicknext',
                      class: [_vm.quicknextIconClass, { disabled: _vm.disabled }],
                      on: {
                        mouseenter($event) {
                          _vm.onMouseenter('right');
                        },
                        mouseleave($event) {
                          _vm.quicknextIconClass = 'el-icon-more';
                        },
                      },
                    })
                    : _vm._e(),
                  _vm.pageCount > 1
                    ? _c(
                      'li',
                      {
                        staticClass: 'number',
                        class: {
                          active: _vm.currentPage === _vm.pageCount,
                          disabled: _vm.disabled,
                        },
                      },
                      [_vm._v(_vm._s(_vm.pageCount))],
                    )
                    : _vm._e(),
                ],
                2,
              );
            };
            const staticRenderFns = [];
            pagervue_type_template_id_7274f267_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/pagination/src/pager.vue?vue&type=template&id=7274f267&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/pagination/src/pager.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const pagervue_type_script_lang_js_ = ({
              name: 'ElPager',

              props: {
                currentPage: Number,

                pageCount: Number,

                pagerCount: Number,

                disabled: Boolean,
              },

              watch: {
                showPrevMore: function showPrevMore(val) {
                  if (!val) this.quickprevIconClass = 'el-icon-more';
                },
                showNextMore: function showNextMore(val) {
                  if (!val) this.quicknextIconClass = 'el-icon-more';
                },
              },

              methods: {
                onPagerClick: function onPagerClick(event) {
                  const { target } = event;
                  if (target.tagName === 'UL' || this.disabled) {
                    return;
                  }

                  let newPage = Number(event.target.textContent);
                  const { pageCount } = this;
                  const { currentPage } = this;
                  const pagerCountOffset = this.pagerCount - 2;

                  if (target.className.indexOf('more') !== -1) {
                    if (target.className.indexOf('quickprev') !== -1) {
                      newPage = currentPage - pagerCountOffset;
                    } else if (target.className.indexOf('quicknext') !== -1) {
                      newPage = currentPage + pagerCountOffset;
                    }
                  }

                  /* istanbul ignore if */
                  if (!isNaN(newPage)) {
                    if (newPage < 1) {
                      newPage = 1;
                    }

                    if (newPage > pageCount) {
                      newPage = pageCount;
                    }
                  }

                  if (newPage !== currentPage) {
                    this.$emit('change', newPage);
                  }
                },
                onMouseenter: function onMouseenter(direction) {
                  if (this.disabled) return;
                  if (direction === 'left') {
                    this.quickprevIconClass = 'el-icon-d-arrow-left';
                  } else {
                    this.quicknextIconClass = 'el-icon-d-arrow-right';
                  }
                },
              },

              computed: {
                pagers: function pagers() {
                  const { pagerCount } = this;
                  const halfPagerCount = (pagerCount - 1) / 2;

                  const currentPage = Number(this.currentPage);
                  const pageCount = Number(this.pageCount);

                  let showPrevMore = false;
                  let showNextMore = false;

                  if (pageCount > pagerCount) {
                    if (currentPage > pagerCount - halfPagerCount) {
                      showPrevMore = true;
                    }

                    if (currentPage < pageCount - halfPagerCount) {
                      showNextMore = true;
                    }
                  }

                  const array = [];

                  if (showPrevMore && !showNextMore) {
                    const startPage = pageCount - (pagerCount - 2);
                    for (let i = startPage; i < pageCount; i++) {
                      array.push(i);
                    }
                  } else if (!showPrevMore && showNextMore) {
                    for (let _i = 2; _i < pagerCount; _i++) {
                      array.push(_i);
                    }
                  } else if (showPrevMore && showNextMore) {
                    const offset = Math.floor(pagerCount / 2) - 1;
                    for (let _i2 = currentPage - offset; _i2 <= currentPage + offset; _i2++) {
                      array.push(_i2);
                    }
                  } else {
                    for (let _i3 = 2; _i3 < pageCount; _i3++) {
                      array.push(_i3);
                    }
                  }

                  this.showPrevMore = showPrevMore;
                  this.showNextMore = showNextMore;

                  return array;
                },
              },

              data: function data() {
                return {
                  current: null,
                  showPrevMore: false,
                  showNextMore: false,
                  quicknextIconClass: 'el-icon-more',
                  quickprevIconClass: 'el-icon-more',
                };
              },
            });
            // CONCATENATED MODULE: ./packages/pagination/src/pager.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_pagervue_type_script_lang_js_ = (pagervue_type_script_lang_js_);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
            /* globals __VUE_SSR_CONTEXT__ */

            // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
            // This module is a runtime utility for cleaner component module output and will
            // be included in the final webpack user bundle.

            function normalizeComponent(
              scriptExports,
              render,
              staticRenderFns,
              functionalTemplate,
              injectStyles,
              scopeId,
              moduleIdentifier, /* server only */
              shadowMode, /* vue-cli only */
            ) {
              // Vue.extend constructor export interop
              const options = typeof scriptExports === 'function'
                ? scriptExports.options
                : scriptExports;

              // render functions
              if (render) {
                options.render = render;
                options.staticRenderFns = staticRenderFns;
                options._compiled = true;
              }

              // functional template
              if (functionalTemplate) {
                options.functional = true;
              }

              // scopedId
              if (scopeId) {
                options._scopeId = `data-v-${scopeId}`;
              }

              let hook;
              if (moduleIdentifier) { // server build
                hook = function (context) {
                  // 2.3 injection
                  context = context // cached call
        || (this.$vnode && this.$vnode.ssrContext) // stateful
        || (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
                  // 2.2 with runInNewContext: true
                  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                    context = __VUE_SSR_CONTEXT__;
                  }
                  // inject component styles
                  if (injectStyles) {
                    injectStyles.call(this, context);
                  }
                  // register component module identifier for async chunk inferrence
                  if (context && context._registeredComponents) {
                    context._registeredComponents.add(moduleIdentifier);
                  }
                };
                // used by ssr in case component is cached and beforeCreate
                // never gets called
                options._ssrRegister = hook;
              } else if (injectStyles) {
                hook = shadowMode
                  ? function () { injectStyles.call(this, this.$root.$options.shadowRoot); }
                  : injectStyles;
              }

              if (hook) {
                if (options.functional) {
                  // for template-only hot-reload because in that case the render fn doesn't
                  // go through the normalizer
                  options._injectStyles = hook;
                  // register for functioal component in vue file
                  const originalRender = options.render;
                  options.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context);
                  };
                } else {
                  // inject component registration as beforeCreate hook
                  const existing = options.beforeCreate;
                  options.beforeCreate = existing
                    ? [].concat(existing, hook)
                    : [hook];
                }
              }

              return {
                exports: scriptExports,
                options,
              };
            }

            // CONCATENATED MODULE: ./packages/pagination/src/pager.vue

            /* normalize component */

            const component = normalizeComponent(
              src_pagervue_type_script_lang_js_,
              pagervue_type_template_id_7274f267_render,
              staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let api; }
            component.options.__file = 'packages/pagination/src/pager.vue';
            /* harmony default export */ const pager = (component.exports);
            // EXTERNAL MODULE: external "element-ui/lib/select"
            const select_ = __webpack_require__(36);
            const select_default = /* #__PURE__ */__webpack_require__.n(select_);

            // EXTERNAL MODULE: external "element-ui/lib/option"
            const option_ = __webpack_require__(37);
            const option_default = /* #__PURE__ */__webpack_require__.n(option_);

            // EXTERNAL MODULE: external "element-ui/lib/input"
            const input_ = __webpack_require__(8);
            const input_default = /* #__PURE__ */__webpack_require__.n(input_);

            // EXTERNAL MODULE: external "element-ui/lib/mixins/locale"
            const locale_ = __webpack_require__(4);
            const locale_default = /* #__PURE__ */__webpack_require__.n(locale_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/util"
            const util_ = __webpack_require__(2);

            // CONCATENATED MODULE: ./packages/pagination/src/pagination.js

            /* harmony default export */ const pagination = ({
              name: 'ElPagination',

              props: {
                pageSize: {
                  type: Number,
                  default: 10,
                },

                small: Boolean,

                total: Number,

                pageCount: Number,

                pagerCount: {
                  type: Number,
                  validator: function validator(value) {
                    return (value | 0) === value && value > 4 && value < 22 && value % 2 === 1;
                  },

                  default: 7,
                },

                currentPage: {
                  type: Number,
                  default: 1,
                },

                layout: {
                  default: 'prev, pager, next, jumper, ->, total',
                },

                pageSizes: {
                  type: Array,
                  default: function _default() {
                    return [10, 20, 30, 40, 50, 100];
                  },
                },

                popperClass: String,

                prevText: String,

                nextText: String,

                background: Boolean,

                disabled: Boolean,

                hideOnSinglePage: Boolean,
              },

              data: function data() {
                return {
                  internalCurrentPage: 1,
                  internalPageSize: 0,
                  lastEmittedPage: -1,
                  userChangePageSize: false,
                };
              },
              render: function render(h) {
                const { layout } = this;
                if (!layout) return null;
                if (this.hideOnSinglePage && (!this.internalPageCount || this.internalPageCount === 1)) return null;

                const template = h('div', {
                  class: ['el-pagination', {
                    'is-background': this.background,
                    'el-pagination--small': this.small,
                  }],
                });
                const TEMPLATE_MAP = {
                  prev: h('prev'),
                  jumper: h('jumper'),
                  pager: h('pager', {
                    attrs: {
                      currentPage: this.internalCurrentPage, pageCount: this.internalPageCount, pagerCount: this.pagerCount, disabled: this.disabled,
                    },
                    on: {
                      change: this.handleCurrentChange,
                    },
                  }),
                  next: h('next'),
                  sizes: h('sizes', {
                    attrs: { pageSizes: this.pageSizes },
                  }),
                  slot: h('slot', [this.$slots.default ? this.$slots.default : '']),
                  total: h('total'),
                };
                const components = layout.split(',').map((item) => item.trim());
                const rightWrapper = h('div', { class: 'el-pagination__rightwrapper' });
                let haveRightWrapper = false;

                template.children = template.children || [];
                rightWrapper.children = rightWrapper.children || [];
                components.forEach((compo) => {
                  if (compo === '->') {
                    haveRightWrapper = true;
                    return;
                  }

                  if (!haveRightWrapper) {
                    template.children.push(TEMPLATE_MAP[compo]);
                  } else {
                    rightWrapper.children.push(TEMPLATE_MAP[compo]);
                  }
                });

                if (haveRightWrapper) {
                  template.children.unshift(rightWrapper);
                }

                return template;
              },

              components: {
                Prev: {
                  render: function render(h) {
                    return h(
                      'button',
                      {
                        attrs: {
                          type: 'button',

                          disabled: this.$parent.disabled || this.$parent.internalCurrentPage <= 1,
                        },
                        class: 'btn-prev',
                        on: {
                          click: this.$parent.prev,
                        },
                      },
                      [this.$parent.prevText ? h('span', [this.$parent.prevText]) : h('i', { class: 'el-icon el-icon-arrow-left' })],
                    );
                  },
                },

                Next: {
                  render: function render(h) {
                    return h(
                      'button',
                      {
                        attrs: {
                          type: 'button',

                          disabled: this.$parent.disabled || this.$parent.internalCurrentPage === this.$parent.internalPageCount || this.$parent.internalPageCount === 0,
                        },
                        class: 'btn-next',
                        on: {
                          click: this.$parent.next,
                        },
                      },
                      [this.$parent.nextText ? h('span', [this.$parent.nextText]) : h('i', { class: 'el-icon el-icon-arrow-right' })],
                    );
                  },
                },

                Sizes: {
                  mixins: [locale_default.a],

                  props: {
                    pageSizes: Array,
                  },

                  watch: {
                    pageSizes: {
                      immediate: true,
                      handler: function handler(newVal, oldVal) {
                        if (Object(util_.valueEquals)(newVal, oldVal)) return;
                        if (Array.isArray(newVal)) {
                          this.$parent.internalPageSize = newVal.indexOf(this.$parent.pageSize) > -1 ? this.$parent.pageSize : this.pageSizes[0];
                        }
                      },
                    },
                  },

                  render: function render(h) {
                    const _this = this;

                    return h(
                      'span',
                      { class: 'el-pagination__sizes' },
                      [h(
                        'el-select',
                        {
                          attrs: {
                            value: this.$parent.internalPageSize,
                            popperClass: this.$parent.popperClass || '',
                            size: 'mini',

                            disabled: this.$parent.disabled,
                          },
                          on: {
                            input: this.handleChange,
                          },
                        },
                        [this.pageSizes.map((item) => h('el-option', {
                          attrs: {
                            value: item,
                            label: item + _this.t('el.pagination.pagesize'),
                          },
                        }))],
                      )],
                    );
                  },

                  components: {
                    ElSelect: select_default.a,
                    ElOption: option_default.a,
                  },

                  methods: {
                    handleChange: function handleChange(val) {
                      if (val !== this.$parent.internalPageSize) {
                        this.$parent.internalPageSize = val = parseInt(val, 10);
                        this.$parent.userChangePageSize = true;
                        this.$parent.$emit('update:pageSize', val);
                        this.$parent.$emit('size-change', val);
                      }
                    },
                  },
                },

                Jumper: {
                  mixins: [locale_default.a],

                  components: { ElInput: input_default.a },

                  data: function data() {
                    return {
                      userInput: null,
                    };
                  },

                  watch: {
                    '$parent.internalCurrentPage': function $parentInternalCurrentPage() {
                      this.userInput = null;
                    },
                  },

                  methods: {
                    handleKeyup: function handleKeyup(_ref) {
                      const { keyCode } = _ref;
                      const { target } = _ref;

                      // Chrome, Safari, Firefox triggers change event on Enter
                      // Hack for IE: https://github.com/ElemeFE/element/issues/11710
                      // Drop this method when we no longer supports IE
                      if (keyCode === 13) {
                        this.handleChange(target.value);
                      }
                    },
                    handleInput: function handleInput(value) {
                      this.userInput = value;
                    },
                    handleChange: function handleChange(value) {
                      this.$parent.internalCurrentPage = this.$parent.getValidCurrentPage(value);
                      this.$parent.emitChange();
                      this.userInput = null;
                    },
                  },

                  render: function render(h) {
                    return h(
                      'span',
                      { class: 'el-pagination__jump' },
                      [this.t('el.pagination.goto'), h('el-input', {
                        class: 'el-pagination__editor is-in-pagination',
                        attrs: {
                          min: 1,
                          max: this.$parent.internalPageCount,
                          value: this.userInput !== null ? this.userInput : this.$parent.internalCurrentPage,
                          type: 'number',
                          disabled: this.$parent.disabled,
                        },
                        nativeOn: {
                          keyup: this.handleKeyup,
                        },
                        on: {
                          input: this.handleInput,
                          change: this.handleChange,
                        },
                      }), this.t('el.pagination.pageClassifier')],
                    );
                  },
                },

                Total: {
                  mixins: [locale_default.a],

                  render: function render(h) {
                    return typeof this.$parent.total === 'number' ? h(
                      'span',
                      { class: 'el-pagination__total' },
                      [this.t('el.pagination.total', { total: this.$parent.total })],
                    ) : '';
                  },
                },

                Pager: pager,
              },

              methods: {
                handleCurrentChange: function handleCurrentChange(val) {
                  this.internalCurrentPage = this.getValidCurrentPage(val);
                  this.userChangePageSize = true;
                  this.emitChange();
                },
                prev: function prev() {
                  if (this.disabled) return;
                  const newVal = this.internalCurrentPage - 1;
                  this.internalCurrentPage = this.getValidCurrentPage(newVal);
                  this.$emit('prev-click', this.internalCurrentPage);
                  this.emitChange();
                },
                next: function next() {
                  if (this.disabled) return;
                  const newVal = this.internalCurrentPage + 1;
                  this.internalCurrentPage = this.getValidCurrentPage(newVal);
                  this.$emit('next-click', this.internalCurrentPage);
                  this.emitChange();
                },
                getValidCurrentPage: function getValidCurrentPage(value) {
                  value = parseInt(value, 10);

                  const havePageCount = typeof this.internalPageCount === 'number';

                  let resetValue = void 0;
                  if (!havePageCount) {
                    if (isNaN(value) || value < 1) resetValue = 1;
                  } else if (value < 1) {
                    resetValue = 1;
                  } else if (value > this.internalPageCount) {
                    resetValue = this.internalPageCount;
                  }

                  if (resetValue === undefined && isNaN(value)) {
                    resetValue = 1;
                  } else if (resetValue === 0) {
                    resetValue = 1;
                  }

                  return resetValue === undefined ? value : resetValue;
                },
                emitChange: function emitChange() {
                  const _this2 = this;

                  this.$nextTick(() => {
                    if (_this2.internalCurrentPage !== _this2.lastEmittedPage || _this2.userChangePageSize) {
                      _this2.$emit('current-change', _this2.internalCurrentPage);
                      _this2.lastEmittedPage = _this2.internalCurrentPage;
                      _this2.userChangePageSize = false;
                    }
                  });
                },
              },

              computed: {
                internalPageCount: function internalPageCount() {
                  if (typeof this.total === 'number') {
                    return Math.max(1, Math.ceil(this.total / this.internalPageSize));
                  } if (typeof this.pageCount === 'number') {
                    return Math.max(1, this.pageCount);
                  }
                  return null;
                },
              },

              watch: {
                currentPage: {
                  immediate: true,
                  handler: function handler(val) {
                    this.internalCurrentPage = this.getValidCurrentPage(val);
                  },
                },

                pageSize: {
                  immediate: true,
                  handler: function handler(val) {
                    this.internalPageSize = isNaN(val) ? 10 : val;
                  },
                },

                internalCurrentPage: {
                  immediate: true,
                  handler: function handler(newVal) {
                    this.$emit('update:currentPage', newVal);
                    this.lastEmittedPage = -1;
                  },
                },

                internalPageCount: function internalPageCount(newVal) {
                  /* istanbul ignore if */
                  const oldPage = this.internalCurrentPage;
                  if (newVal > 0 && oldPage === 0) {
                    this.internalCurrentPage = 1;
                  } else if (oldPage > newVal) {
                    this.internalCurrentPage = newVal === 0 ? 1 : newVal;
                    this.userChangePageSize && this.emitChange();
                  }
                  this.userChangePageSize = false;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/pagination/index.js

            /* istanbul ignore next */
            pagination.install = function (Vue) {
              Vue.component(pagination.name, pagination);
            };

            /* harmony default export */ const packages_pagination = (pagination);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/dialog/src/component.vue?vue&type=template&id=60140e62&
            const componentvue_type_template_id_60140e62_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                {
                  attrs: { name: 'dialog-fade' },
                  on: { 'after-enter': _vm.afterEnter, 'after-leave': _vm.afterLeave },
                },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.visible,
                          expression: 'visible',
                        },
                      ],
                      staticClass: 'el-dialog__wrapper',
                      on: {
                        click($event) {
                          if ($event.target !== $event.currentTarget) {
                            return null;
                          }
                          return _vm.handleWrapperClick($event);
                        },
                      },
                    },
                    [
                      _c(
                        'div',
                        {
                          key: _vm.key,
                          ref: 'dialog',
                          class: [
                            'el-dialog',
                            {
                              'is-fullscreen': _vm.fullscreen,
                              'el-dialog--center': _vm.center,
                            },
                            _vm.customClass,
                          ],
                          style: _vm.style,
                          attrs: {
                            role: 'dialog',
                            'aria-modal': 'true',
                            'aria-label': _vm.title || 'dialog',
                          },
                        },
                        [
                          _c(
                            'div',
                            { staticClass: 'el-dialog__header' },
                            [
                              _vm._t('title', [
                                _c('span', { staticClass: 'el-dialog__title' }, [
                                  _vm._v(_vm._s(_vm.title)),
                                ]),
                              ]),
                              _vm.showClose
                                ? _c(
                                  'button',
                                  {
                                    staticClass: 'el-dialog__headerbtn',
                                    attrs: { type: 'button', 'aria-label': 'Close' },
                                    on: { click: _vm.handleClose },
                                  },
                                  [
                                    _c('i', {
                                      staticClass:
                              'el-dialog__close el-icon el-icon-close',
                                    }),
                                  ],
                                )
                                : _vm._e(),
                            ],
                            2,
                          ),
                          _vm.rendered
                            ? _c(
                              'div',
                              { staticClass: 'el-dialog__body' },
                              [_vm._t('default')],
                              2,
                            )
                            : _vm._e(),
                          _vm.$slots.footer
                            ? _c(
                              'div',
                              { staticClass: 'el-dialog__footer' },
                              [_vm._t('footer')],
                              2,
                            )
                            : _vm._e(),
                        ],
                      ),
                    ],
                  ),
                ],
              );
            };
            const componentvue_type_template_id_60140e62_staticRenderFns = [];
            componentvue_type_template_id_60140e62_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/dialog/src/component.vue?vue&type=template&id=60140e62&

            // EXTERNAL MODULE: external "element-ui/lib/utils/popup"
            const popup_ = __webpack_require__(13);
            const popup_default = /* #__PURE__ */__webpack_require__.n(popup_);

            // EXTERNAL MODULE: external "element-ui/lib/mixins/migrating"
            const migrating_ = __webpack_require__(9);
            const migrating_default = /* #__PURE__ */__webpack_require__.n(migrating_);

            // EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"
            const emitter_ = __webpack_require__(3);
            const emitter_default = /* #__PURE__ */__webpack_require__.n(emitter_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/dialog/src/component.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const componentvue_type_script_lang_js_ = ({
              name: 'ElDialog',

              mixins: [popup_default.a, emitter_default.a, migrating_default.a],

              props: {
                title: {
                  type: String,
                  default: '',
                },

                modal: {
                  type: Boolean,
                  default: true,
                },

                modalAppendToBody: {
                  type: Boolean,
                  default: true,
                },

                appendToBody: {
                  type: Boolean,
                  default: false,
                },

                lockScroll: {
                  type: Boolean,
                  default: true,
                },

                closeOnClickModal: {
                  type: Boolean,
                  default: true,
                },

                closeOnPressEscape: {
                  type: Boolean,
                  default: true,
                },

                showClose: {
                  type: Boolean,
                  default: true,
                },

                width: String,

                fullscreen: Boolean,

                customClass: {
                  type: String,
                  default: '',
                },

                top: {
                  type: String,
                  default: '15vh',
                },
                beforeClose: Function,
                center: {
                  type: Boolean,
                  default: false,
                },

                destroyOnClose: Boolean,
              },

              data: function data() {
                return {
                  closed: false,
                  key: 0,
                };
              },

              watch: {
                visible: function visible(val) {
                  const _this = this;

                  if (val) {
                    this.closed = false;
                    this.$emit('open');
                    this.$el.addEventListener('scroll', this.updatePopper);
                    this.$nextTick(() => {
                      _this.$refs.dialog.scrollTop = 0;
                    });
                    if (this.appendToBody) {
                      document.body.appendChild(this.$el);
                    }
                  } else {
                    this.$el.removeEventListener('scroll', this.updatePopper);
                    if (!this.closed) this.$emit('close');
                    if (this.destroyOnClose) {
                      this.$nextTick(() => {
                        _this.key++;
                      });
                    }
                  }
                },
              },

              computed: {
                style: function style() {
                  const style = {};
                  if (!this.fullscreen) {
                    style.marginTop = this.top;
                    if (this.width) {
                      style.width = this.width;
                    }
                  }
                  return style;
                },
              },

              methods: {
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      size: 'size is removed.',
                    },
                  };
                },
                handleWrapperClick: function handleWrapperClick() {
                  if (!this.closeOnClickModal) return;
                  this.handleClose();
                },
                handleClose: function handleClose() {
                  if (typeof this.beforeClose === 'function') {
                    this.beforeClose(this.hide);
                  } else {
                    this.hide();
                  }
                },
                hide: function hide(cancel) {
                  if (cancel !== false) {
                    this.$emit('update:visible', false);
                    this.$emit('close');
                    this.closed = true;
                  }
                },
                updatePopper: function updatePopper() {
                  this.broadcast('ElSelectDropdown', 'updatePopper');
                  this.broadcast('ElDropdownMenu', 'updatePopper');
                },
                afterEnter: function afterEnter() {
                  this.$emit('opened');
                },
                afterLeave: function afterLeave() {
                  this.$emit('closed');
                },
              },

              mounted: function mounted() {
                if (this.visible) {
                  this.rendered = true;
                  this.open();
                  if (this.appendToBody) {
                    document.body.appendChild(this.$el);
                  }
                }
              },
              destroyed: function destroyed() {
                // if appendToBody is true, remove DOM node after destroy
                if (this.appendToBody && this.$el && this.$el.parentNode) {
                  this.$el.parentNode.removeChild(this.$el);
                }
              },
            });
            // CONCATENATED MODULE: ./packages/dialog/src/component.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_componentvue_type_script_lang_js_ = (componentvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/dialog/src/component.vue

            /* normalize component */

            const component_component = normalizeComponent(
              src_componentvue_type_script_lang_js_,
              componentvue_type_template_id_60140e62_render,
              componentvue_type_template_id_60140e62_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let component_api; }
            component_component.options.__file = 'packages/dialog/src/component.vue';
            /* harmony default export */ const src_component = (component_component.exports);
            // CONCATENATED MODULE: ./packages/dialog/index.js

            /* istanbul ignore next */
            src_component.install = function (Vue) {
              Vue.component(src_component.name, src_component);
            };

            /* harmony default export */ const dialog = (src_component);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/autocomplete/src/autocomplete.vue?vue&type=template&id=152f2ee6&
            const autocompletevue_type_template_id_152f2ee6_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  directives: [
                    {
                      name: 'clickoutside',
                      rawName: 'v-clickoutside',
                      value: _vm.close,
                      expression: 'close',
                    },
                  ],
                  staticClass: 'el-autocomplete',
                  attrs: {
                    'aria-haspopup': 'listbox',
                    role: 'combobox',
                    'aria-expanded': _vm.suggestionVisible,
                    'aria-owns': _vm.id,
                  },
                },
                [
                  _c(
                    'el-input',
                    _vm._b(
                      {
                        ref: 'input',
                        on: {
                          input: _vm.handleInput,
                          change: _vm.handleChange,
                          focus: _vm.handleFocus,
                          blur: _vm.handleBlur,
                          clear: _vm.handleClear,
                        },
                        nativeOn: {
                          keydown: [
                            function ($event) {
                              if (
                                !('button' in $event)
                    && _vm._k($event.keyCode, 'up', 38, $event.key, [
                      'Up',
                      'ArrowUp',
                    ])
                              ) {
                                return null;
                              }
                              $event.preventDefault();
                              _vm.highlight(_vm.highlightedIndex - 1);
                            },
                            function ($event) {
                              if (
                                !('button' in $event)
                    && _vm._k($event.keyCode, 'down', 40, $event.key, [
                      'Down',
                      'ArrowDown',
                    ])
                              ) {
                                return null;
                              }
                              $event.preventDefault();
                              _vm.highlight(_vm.highlightedIndex + 1);
                            },
                            function ($event) {
                              if (
                                !('button' in $event)
                    && _vm._k($event.keyCode, 'enter', 13, $event.key, 'Enter')
                              ) {
                                return null;
                              }
                              return _vm.handleKeyEnter($event);
                            },
                            function ($event) {
                              if (
                                !('button' in $event)
                    && _vm._k($event.keyCode, 'tab', 9, $event.key, 'Tab')
                              ) {
                                return null;
                              }
                              return _vm.close($event);
                            },
                          ],
                        },
                      },
                      'el-input',
                      [_vm.$props, _vm.$attrs],
                      false,
                    ),
                    [
                      _vm.$slots.prepend
                        ? _c('template', { slot: 'prepend' }, [_vm._t('prepend')], 2)
                        : _vm._e(),
                      _vm.$slots.append
                        ? _c('template', { slot: 'append' }, [_vm._t('append')], 2)
                        : _vm._e(),
                      _vm.$slots.prefix
                        ? _c('template', { slot: 'prefix' }, [_vm._t('prefix')], 2)
                        : _vm._e(),
                      _vm.$slots.suffix
                        ? _c('template', { slot: 'suffix' }, [_vm._t('suffix')], 2)
                        : _vm._e(),
                    ],
                    2,
                  ),
                  _c(
                    'el-autocomplete-suggestions',
                    {
                      ref: 'suggestions',
                      class: [_vm.popperClass ? _vm.popperClass : ''],
                      attrs: {
                        'visible-arrow': '',
                        'popper-options': _vm.popperOptions,
                        'append-to-body': _vm.popperAppendToBody,
                        placement: _vm.placement,
                        id: _vm.id,
                      },
                    },
                    _vm._l(_vm.suggestions, (item, index) => _c(
                      'li',
                      {
                        key: index,
                        class: { highlighted: _vm.highlightedIndex === index },
                        attrs: {
                          id: `${_vm.id}-item-${index}`,
                          role: 'option',
                          'aria-selected': _vm.highlightedIndex === index,
                        },
                        on: {
                          click($event) {
                            _vm.select(item);
                          },
                        },
                      },
                      [
                        _vm._t(
                          'default',
                          [
                            _vm._v(`\n        ${_vm._s(item[_vm.valueKey]) }\n      `),
                          ],
                          { item },
                        ),
                      ],
                      2,
                    )),
                    0,
                  ),
                ],
                1,
              );
            };
            const autocompletevue_type_template_id_152f2ee6_staticRenderFns = [];
            autocompletevue_type_template_id_152f2ee6_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete.vue?vue&type=template&id=152f2ee6&

            // EXTERNAL MODULE: external "throttle-debounce/debounce"
            const debounce_ = __webpack_require__(14);
            const debounce_default = /* #__PURE__ */__webpack_require__.n(debounce_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/clickoutside"
            const clickoutside_ = __webpack_require__(10);
            const clickoutside_default = /* #__PURE__ */__webpack_require__.n(clickoutside_);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/autocomplete/src/autocomplete-suggestions.vue?vue&type=template&id=cd10dcf0&
            const autocomplete_suggestionsvue_type_template_id_cd10dcf0_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                { attrs: { name: 'el-zoom-in-top' }, on: { 'after-leave': _vm.doDestroy } },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.showPopper,
                          expression: 'showPopper',
                        },
                      ],
                      staticClass: 'el-autocomplete-suggestion el-popper',
                      class: {
                        'is-loading': !_vm.parent.hideLoading && _vm.parent.loading,
                      },
                      style: { width: _vm.dropdownWidth },
                      attrs: { role: 'region' },
                    },
                    [
                      _c(
                        'el-scrollbar',
                        {
                          attrs: {
                            tag: 'ul',
                            'wrap-class': 'el-autocomplete-suggestion__wrap',
                            'view-class': 'el-autocomplete-suggestion__list',
                          },
                        },
                        [
                          !_vm.parent.hideLoading && _vm.parent.loading
                            ? _c('li', [_c('i', { staticClass: 'el-icon-loading' })])
                            : _vm._t('default'),
                        ],
                        2,
                      ),
                    ],
                    1,
                  ),
                ],
              );
            };
            const autocomplete_suggestionsvue_type_template_id_cd10dcf0_staticRenderFns = [];
            autocomplete_suggestionsvue_type_template_id_cd10dcf0_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete-suggestions.vue?vue&type=template&id=cd10dcf0&

            // EXTERNAL MODULE: external "element-ui/lib/utils/vue-popper"
            const vue_popper_ = __webpack_require__(5);
            const vue_popper_default = /* #__PURE__ */__webpack_require__.n(vue_popper_);

            // EXTERNAL MODULE: external "element-ui/lib/scrollbar"
            const scrollbar_ = __webpack_require__(17);
            const scrollbar_default = /* #__PURE__ */__webpack_require__.n(scrollbar_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/autocomplete/src/autocomplete-suggestions.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const autocomplete_suggestionsvue_type_script_lang_js_ = ({
              components: { ElScrollbar: scrollbar_default.a },
              mixins: [vue_popper_default.a, emitter_default.a],

              componentName: 'ElAutocompleteSuggestions',

              data: function data() {
                return {
                  parent: this.$parent,
                  dropdownWidth: '',
                };
              },

              props: {
                options: {
                  default: function _default() {
                    return {
                      gpuAcceleration: false,
                    };
                  },
                },
                id: String,
              },

              methods: {
                select: function select(item) {
                  this.dispatch('ElAutocomplete', 'item-click', item);
                },
              },

              updated: function updated() {
                const _this = this;

                this.$nextTick((_) => {
                  _this.popperJS && _this.updatePopper();
                });
              },
              mounted: function mounted() {
                this.$parent.popperElm = this.popperElm = this.$el;
                this.referenceElm = this.$parent.$refs.input.$refs.input || this.$parent.$refs.input.$refs.textarea;
                this.referenceList = this.$el.querySelector('.el-autocomplete-suggestion__list');
                this.referenceList.setAttribute('role', 'listbox');
                this.referenceList.setAttribute('id', this.id);
              },
              created: function created() {
                const _this2 = this;

                this.$on('visible', (val, inputWidth) => {
                  _this2.dropdownWidth = `${inputWidth}px`;
                  _this2.showPopper = val;
                });
              },
            });
            // CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete-suggestions.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_autocomplete_suggestionsvue_type_script_lang_js_ = (autocomplete_suggestionsvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete-suggestions.vue

            /* normalize component */

            const autocomplete_suggestions_component = normalizeComponent(
              src_autocomplete_suggestionsvue_type_script_lang_js_,
              autocomplete_suggestionsvue_type_template_id_cd10dcf0_render,
              autocomplete_suggestionsvue_type_template_id_cd10dcf0_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let autocomplete_suggestions_api; }
            autocomplete_suggestions_component.options.__file = 'packages/autocomplete/src/autocomplete-suggestions.vue';
            /* harmony default export */ const autocomplete_suggestions = (autocomplete_suggestions_component.exports);
            // EXTERNAL MODULE: external "element-ui/lib/mixins/focus"
            const focus_ = __webpack_require__(22);
            const focus_default = /* #__PURE__ */__webpack_require__.n(focus_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/autocomplete/src/autocomplete.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const autocompletevue_type_script_lang_js_ = ({
              name: 'ElAutocomplete',

              mixins: [emitter_default.a, focus_default()('input'), migrating_default.a],

              inheritAttrs: false,

              componentName: 'ElAutocomplete',

              components: {
                ElInput: input_default.a,
                ElAutocompleteSuggestions: autocomplete_suggestions,
              },

              directives: { Clickoutside: clickoutside_default.a },

              props: {
                valueKey: {
                  type: String,
                  default: 'value',
                },
                popperClass: String,
                popperOptions: Object,
                placeholder: String,
                clearable: {
                  type: Boolean,
                  default: false,
                },
                disabled: Boolean,
                name: String,
                size: String,
                value: String,
                maxlength: Number,
                minlength: Number,
                autofocus: Boolean,
                fetchSuggestions: Function,
                triggerOnFocus: {
                  type: Boolean,
                  default: true,
                },
                customItem: String,
                selectWhenUnmatched: {
                  type: Boolean,
                  default: false,
                },
                prefixIcon: String,
                suffixIcon: String,
                label: String,
                debounce: {
                  type: Number,
                  default: 300,
                },
                placement: {
                  type: String,
                  default: 'bottom-start',
                },
                hideLoading: Boolean,
                popperAppendToBody: {
                  type: Boolean,
                  default: true,
                },
                highlightFirstItem: {
                  type: Boolean,
                  default: false,
                },
              },
              data: function data() {
                return {
                  activated: false,
                  suggestions: [],
                  loading: false,
                  highlightedIndex: -1,
                  suggestionDisabled: false,
                };
              },

              computed: {
                suggestionVisible: function suggestionVisible() {
                  const { suggestions } = this;
                  const isValidData = Array.isArray(suggestions) && suggestions.length > 0;
                  return (isValidData || this.loading) && this.activated;
                },
                id: function id() {
                  return `el-autocomplete-${Object(util_.generateId)()}`;
                },
              },
              watch: {
                suggestionVisible: function suggestionVisible(val) {
                  const $input = this.getInput();
                  if ($input) {
                    this.broadcast('ElAutocompleteSuggestions', 'visible', [val, $input.offsetWidth]);
                  }
                },
              },
              methods: {
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      'custom-item': 'custom-item is removed, use scoped slot instead.',
                      props: 'props is removed, use value-key instead.',
                    },
                  };
                },
                getData: function getData(queryString) {
                  const _this = this;

                  if (this.suggestionDisabled) {
                    return;
                  }
                  this.loading = true;
                  this.fetchSuggestions(queryString, (suggestions) => {
                    _this.loading = false;
                    if (_this.suggestionDisabled) {
                      return;
                    }
                    if (Array.isArray(suggestions)) {
                      _this.suggestions = suggestions;
                      _this.highlightedIndex = _this.highlightFirstItem ? 0 : -1;
                    } else {
                      console.error('[Element Error][Autocomplete]autocomplete suggestions must be an array');
                    }
                  });
                },
                handleInput: function handleInput(value) {
                  this.$emit('input', value);
                  this.suggestionDisabled = false;
                  if (!this.triggerOnFocus && !value) {
                    this.suggestionDisabled = true;
                    this.suggestions = [];
                    return;
                  }
                  this.debouncedGetData(value);
                },
                handleChange: function handleChange(value) {
                  this.$emit('change', value);
                },
                handleFocus: function handleFocus(event) {
                  this.activated = true;
                  this.$emit('focus', event);
                  if (this.triggerOnFocus) {
                    this.debouncedGetData(this.value);
                  }
                },
                handleBlur: function handleBlur(event) {
                  this.$emit('blur', event);
                },
                handleClear: function handleClear() {
                  this.activated = false;
                  this.$emit('clear');
                },
                close: function close(e) {
                  this.activated = false;
                },
                handleKeyEnter: function handleKeyEnter(e) {
                  const _this2 = this;

                  if (this.suggestionVisible && this.highlightedIndex >= 0 && this.highlightedIndex < this.suggestions.length) {
                    e.preventDefault();
                    this.select(this.suggestions[this.highlightedIndex]);
                  } else if (this.selectWhenUnmatched) {
                    this.$emit('select', { value: this.value });
                    this.$nextTick((_) => {
                      _this2.suggestions = [];
                      _this2.highlightedIndex = -1;
                    });
                  }
                },
                select: function select(item) {
                  const _this3 = this;

                  this.$emit('input', item[this.valueKey]);
                  this.$emit('select', item);
                  this.$nextTick((_) => {
                    _this3.suggestions = [];
                    _this3.highlightedIndex = -1;
                  });
                },
                highlight: function highlight(index) {
                  if (!this.suggestionVisible || this.loading) {
                    return;
                  }
                  if (index < 0) {
                    this.highlightedIndex = -1;
                    return;
                  }
                  if (index >= this.suggestions.length) {
                    index = this.suggestions.length - 1;
                  }
                  const suggestion = this.$refs.suggestions.$el.querySelector('.el-autocomplete-suggestion__wrap');
                  const suggestionList = suggestion.querySelectorAll('.el-autocomplete-suggestion__list li');

                  const highlightItem = suggestionList[index];
                  const { scrollTop } = suggestion;
                  const { offsetTop } = highlightItem;

                  if (offsetTop + highlightItem.scrollHeight > scrollTop + suggestion.clientHeight) {
                    suggestion.scrollTop += highlightItem.scrollHeight;
                  }
                  if (offsetTop < scrollTop) {
                    suggestion.scrollTop -= highlightItem.scrollHeight;
                  }
                  this.highlightedIndex = index;
                  const $input = this.getInput();
                  $input.setAttribute('aria-activedescendant', `${this.id}-item-${this.highlightedIndex}`);
                },
                getInput: function getInput() {
                  return this.$refs.input.getInput();
                },
              },
              mounted: function mounted() {
                const _this4 = this;

                this.debouncedGetData = debounce_default()(this.debounce, this.getData);
                this.$on('item-click', (item) => {
                  _this4.select(item);
                });
                const $input = this.getInput();
                $input.setAttribute('role', 'textbox');
                $input.setAttribute('aria-autocomplete', 'list');
                $input.setAttribute('aria-controls', 'id');
                $input.setAttribute('aria-activedescendant', `${this.id}-item-${this.highlightedIndex}`);
              },
              beforeDestroy: function beforeDestroy() {
                this.$refs.suggestions.$destroy();
              },
            });
            // CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_autocompletevue_type_script_lang_js_ = (autocompletevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete.vue

            /* normalize component */

            const autocomplete_component = normalizeComponent(
              src_autocompletevue_type_script_lang_js_,
              autocompletevue_type_template_id_152f2ee6_render,
              autocompletevue_type_template_id_152f2ee6_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let autocomplete_api; }
            autocomplete_component.options.__file = 'packages/autocomplete/src/autocomplete.vue';
            /* harmony default export */ const autocomplete = (autocomplete_component.exports);
            // CONCATENATED MODULE: ./packages/autocomplete/index.js

            /* istanbul ignore next */
            autocomplete.install = function (Vue) {
              Vue.component(autocomplete.name, autocomplete);
            };

            /* harmony default export */ const packages_autocomplete = (autocomplete);
            // EXTERNAL MODULE: external "element-ui/lib/button"
            const button_ = __webpack_require__(11);
            const button_default = /* #__PURE__ */__webpack_require__.n(button_);

            // EXTERNAL MODULE: external "element-ui/lib/button-group"
            const button_group_ = __webpack_require__(28);
            const button_group_default = /* #__PURE__ */__webpack_require__.n(button_group_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown.vue?vue&type=script&lang=js&

            /* harmony default export */ const dropdownvue_type_script_lang_js_ = ({
              name: 'ElDropdown',

              componentName: 'ElDropdown',

              mixins: [emitter_default.a, migrating_default.a],

              directives: { Clickoutside: clickoutside_default.a },

              components: {
                ElButton: button_default.a,
                ElButtonGroup: button_group_default.a,
              },

              provide: function provide() {
                return {
                  dropdown: this,
                };
              },

              props: {
                trigger: {
                  type: String,
                  default: 'hover',
                },
                type: String,
                size: {
                  type: String,
                  default: '',
                },
                splitButton: Boolean,
                hideOnClick: {
                  type: Boolean,
                  default: true,
                },
                placement: {
                  type: String,
                  default: 'bottom-end',
                },
                visibleArrow: {
                  default: true,
                },
                showTimeout: {
                  type: Number,
                  default: 250,
                },
                hideTimeout: {
                  type: Number,
                  default: 150,
                },
                tabindex: {
                  type: Number,
                  default: 0,
                },
              },

              data: function data() {
                return {
                  timeout: null,
                  visible: false,
                  triggerElm: null,
                  menuItems: null,
                  menuItemsArray: null,
                  dropdownElm: null,
                  focusing: false,
                  listId: `dropdown-menu-${Object(util_.generateId)()}`,
                };
              },

              computed: {
                dropdownSize: function dropdownSize() {
                  return this.size || (this.$ELEMENT || {}).size;
                },
              },

              mounted: function mounted() {
                this.$on('menu-item-click', this.handleMenuItemClick);
              },

              watch: {
                visible: function visible(val) {
                  this.broadcast('ElDropdownMenu', 'visible', val);
                  this.$emit('visible-change', val);
                },
                focusing: function focusing(val) {
                  const selfDefine = this.$el.querySelector('.el-dropdown-selfdefine');
                  if (selfDefine) {
                    // 自定义
                    if (val) {
                      selfDefine.className += ' focusing';
                    } else {
                      selfDefine.className = selfDefine.className.replace('focusing', '');
                    }
                  }
                },
              },

              methods: {
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      'menu-align': 'menu-align is renamed to placement.',
                    },
                  };
                },
                show: function show() {
                  const _this = this;

                  if (this.triggerElm.disabled) return;
                  clearTimeout(this.timeout);
                  this.timeout = setTimeout(() => {
                    _this.visible = true;
                  }, this.trigger === 'click' ? 0 : this.showTimeout);
                },
                hide: function hide() {
                  const _this2 = this;

                  if (this.triggerElm.disabled) return;
                  this.removeTabindex();
                  if (this.tabindex >= 0) {
                    this.resetTabindex(this.triggerElm);
                  }
                  clearTimeout(this.timeout);
                  this.timeout = setTimeout(() => {
                    _this2.visible = false;
                  }, this.trigger === 'click' ? 0 : this.hideTimeout);
                },
                handleClick: function handleClick() {
                  if (this.triggerElm.disabled) return;
                  if (this.visible) {
                    this.hide();
                  } else {
                    this.show();
                  }
                },
                handleTriggerKeyDown: function handleTriggerKeyDown(ev) {
                  const { keyCode } = ev;
                  if ([38, 40].indexOf(keyCode) > -1) {
                    // up/down
                    this.removeTabindex();
                    this.resetTabindex(this.menuItems[0]);
                    this.menuItems[0].focus();
                    ev.preventDefault();
                    ev.stopPropagation();
                  } else if (keyCode === 13) {
                    // space enter选中
                    this.handleClick();
                  } else if ([9, 27].indexOf(keyCode) > -1) {
                    // tab || esc
                    this.hide();
                  }
                },
                handleItemKeyDown: function handleItemKeyDown(ev) {
                  const { keyCode } = ev;
                  const { target } = ev;
                  const currentIndex = this.menuItemsArray.indexOf(target);
                  const max = this.menuItemsArray.length - 1;
                  let nextIndex = void 0;
                  if ([38, 40].indexOf(keyCode) > -1) {
                    // up/down
                    if (keyCode === 38) {
                      // up
                      nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
                    } else {
                      // down
                      nextIndex = currentIndex < max ? currentIndex + 1 : max;
                    }
                    this.removeTabindex();
                    this.resetTabindex(this.menuItems[nextIndex]);
                    this.menuItems[nextIndex].focus();
                    ev.preventDefault();
                    ev.stopPropagation();
                  } else if (keyCode === 13) {
                    // enter选中
                    this.triggerElmFocus();
                    target.click();
                    if (this.hideOnClick) {
                      // click关闭
                      this.visible = false;
                    }
                  } else if ([9, 27].indexOf(keyCode) > -1) {
                    // tab // esc
                    this.hide();
                    this.triggerElmFocus();
                  }
                },
                resetTabindex: function resetTabindex(ele) {
                  // 下次tab时组件聚焦元素
                  this.removeTabindex();
                  ele.setAttribute('tabindex', '0'); // 下次期望的聚焦元素
                },
                removeTabindex: function removeTabindex() {
                  this.triggerElm.setAttribute('tabindex', '-1');
                  this.menuItemsArray.forEach((item) => {
                    item.setAttribute('tabindex', '-1');
                  });
                },
                initAria: function initAria() {
                  this.dropdownElm.setAttribute('id', this.listId);
                  this.triggerElm.setAttribute('aria-haspopup', 'list');
                  this.triggerElm.setAttribute('aria-controls', this.listId);

                  if (!this.splitButton) {
                    // 自定义
                    this.triggerElm.setAttribute('role', 'button');
                    this.triggerElm.setAttribute('tabindex', this.tabindex);
                    this.triggerElm.setAttribute('class', `${this.triggerElm.getAttribute('class') || ''} el-dropdown-selfdefine`); // 控制
                  }
                },
                initEvent: function initEvent() {
                  const _this3 = this;

                  const { trigger } = this;
                  const { show } = this;
                  const { hide } = this;
                  const { handleClick } = this;
                  const { splitButton } = this;
                  const { handleTriggerKeyDown } = this;
                  const { handleItemKeyDown } = this;

                  this.triggerElm = splitButton ? this.$refs.trigger.$el : this.$slots.default[0].elm;

                  const { dropdownElm } = this;

                  this.triggerElm.addEventListener('keydown', handleTriggerKeyDown); // triggerElm keydown
                  dropdownElm.addEventListener('keydown', handleItemKeyDown, true); // item keydown
                  // 控制自定义元素的样式
                  if (!splitButton) {
                    this.triggerElm.addEventListener('focus', () => {
                      _this3.focusing = true;
                    });
                    this.triggerElm.addEventListener('blur', () => {
                      _this3.focusing = false;
                    });
                    this.triggerElm.addEventListener('click', () => {
                      _this3.focusing = false;
                    });
                  }
                  if (trigger === 'hover') {
                    this.triggerElm.addEventListener('mouseenter', show);
                    this.triggerElm.addEventListener('mouseleave', hide);
                    dropdownElm.addEventListener('mouseenter', show);
                    dropdownElm.addEventListener('mouseleave', hide);
                  } else if (trigger === 'click') {
                    this.triggerElm.addEventListener('click', handleClick);
                  }
                },
                handleMenuItemClick: function handleMenuItemClick(command, instance) {
                  if (this.hideOnClick) {
                    this.visible = false;
                  }
                  this.$emit('command', command, instance);
                },
                triggerElmFocus: function triggerElmFocus() {
                  this.triggerElm.focus && this.triggerElm.focus();
                },
                initDomOperation: function initDomOperation() {
                  this.dropdownElm = this.popperElm;
                  this.menuItems = this.dropdownElm.querySelectorAll("[tabindex='-1']");
                  this.menuItemsArray = [].slice.call(this.menuItems);

                  this.initEvent();
                  this.initAria();
                },
              },

              render: function render(h) {
                const _this4 = this;

                const { hide } = this;
                const { splitButton } = this;
                const { type } = this;
                const { dropdownSize } = this;

                const handleMainButtonClick = function handleMainButtonClick(event) {
                  _this4.$emit('click', event);
                  hide();
                };

                const triggerElm = !splitButton ? this.$slots.default : h('el-button-group', [h(
                  'el-button',
                  {
                    attrs: { type, size: dropdownSize },
                    nativeOn: {
                      click: handleMainButtonClick,
                    },
                  },
                  [this.$slots.default],
                ), h(
                  'el-button',
                  {
                    ref: 'trigger',
                    attrs: { type, size: dropdownSize },
                    class: 'el-dropdown__caret-button',
                  },
                  [h('i', { class: 'el-dropdown__icon el-icon-arrow-down' })],
                )]);

                return h(
                  'div',
                  {
                    class: 'el-dropdown',
                    directives: [{
                      name: 'clickoutside',
                      value: hide,
                    }],
                  },
                  [triggerElm, this.$slots.dropdown],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/dropdown/src/dropdown.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_dropdownvue_type_script_lang_js_ = (dropdownvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/dropdown/src/dropdown.vue
            let dropdown_render; let
              dropdown_staticRenderFns;

            /* normalize component */

            const dropdown_component = normalizeComponent(
              src_dropdownvue_type_script_lang_js_,
              dropdown_render,
              dropdown_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let dropdown_api; }
            dropdown_component.options.__file = 'packages/dropdown/src/dropdown.vue';
            /* harmony default export */ const dropdown = (dropdown_component.exports);
            // CONCATENATED MODULE: ./packages/dropdown/index.js

            /* istanbul ignore next */
            dropdown.install = function (Vue) {
              Vue.component(dropdown.name, dropdown);
            };

            /* harmony default export */ const packages_dropdown = (dropdown);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown-menu.vue?vue&type=template&id=0da6b714&
            const dropdown_menuvue_type_template_id_0da6b714_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                { attrs: { name: 'el-zoom-in-top' }, on: { 'after-leave': _vm.doDestroy } },
                [
                  _c(
                    'ul',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.showPopper,
                          expression: 'showPopper',
                        },
                      ],
                      staticClass: 'el-dropdown-menu el-popper',
                      class: [_vm.size && `el-dropdown-menu--${_vm.size}`],
                    },
                    [_vm._t('default')],
                    2,
                  ),
                ],
              );
            };
            const dropdown_menuvue_type_template_id_0da6b714_staticRenderFns = [];
            dropdown_menuvue_type_template_id_0da6b714_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/dropdown/src/dropdown-menu.vue?vue&type=template&id=0da6b714&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown-menu.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const dropdown_menuvue_type_script_lang_js_ = ({
              name: 'ElDropdownMenu',

              componentName: 'ElDropdownMenu',

              mixins: [vue_popper_default.a],

              props: {
                visibleArrow: {
                  type: Boolean,
                  default: true,
                },
                arrowOffset: {
                  type: Number,
                  default: 0,
                },
              },

              data: function data() {
                return {
                  size: this.dropdown.dropdownSize,
                };
              },

              inject: ['dropdown'],

              created: function created() {
                const _this = this;

                this.$on('updatePopper', () => {
                  if (_this.showPopper) _this.updatePopper();
                });
                this.$on('visible', (val) => {
                  _this.showPopper = val;
                });
              },
              mounted: function mounted() {
                this.dropdown.popperElm = this.popperElm = this.$el;
                this.referenceElm = this.dropdown.$el;
                // compatible with 2.6 new v-slot syntax
                // issue link https://github.com/ElemeFE/element/issues/14345
                this.dropdown.initDomOperation();
              },

              watch: {
                'dropdown.placement': {
                  immediate: true,
                  handler: function handler(val) {
                    this.currentPlacement = val;
                  },
                },
              },
            });
            // CONCATENATED MODULE: ./packages/dropdown/src/dropdown-menu.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_dropdown_menuvue_type_script_lang_js_ = (dropdown_menuvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/dropdown/src/dropdown-menu.vue

            /* normalize component */

            const dropdown_menu_component = normalizeComponent(
              src_dropdown_menuvue_type_script_lang_js_,
              dropdown_menuvue_type_template_id_0da6b714_render,
              dropdown_menuvue_type_template_id_0da6b714_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let dropdown_menu_api; }
            dropdown_menu_component.options.__file = 'packages/dropdown/src/dropdown-menu.vue';
            /* harmony default export */ const dropdown_menu = (dropdown_menu_component.exports);
            // CONCATENATED MODULE: ./packages/dropdown-menu/index.js

            /* istanbul ignore next */
            dropdown_menu.install = function (Vue) {
              Vue.component(dropdown_menu.name, dropdown_menu);
            };

            /* harmony default export */ const packages_dropdown_menu = (dropdown_menu);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown-item.vue?vue&type=template&id=6359102a&
            const dropdown_itemvue_type_template_id_6359102a_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'li',
                {
                  staticClass: 'el-dropdown-menu__item',
                  class: {
                    'is-disabled': _vm.disabled,
                    'el-dropdown-menu__item--divided': _vm.divided,
                  },
                  attrs: {
                    'aria-disabled': _vm.disabled,
                    tabindex: _vm.disabled ? null : -1,
                  },
                  on: { click: _vm.handleClick },
                },
                [_vm.icon ? _c('i', { class: _vm.icon }) : _vm._e(), _vm._t('default')],
                2,
              );
            };
            const dropdown_itemvue_type_template_id_6359102a_staticRenderFns = [];
            dropdown_itemvue_type_template_id_6359102a_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/dropdown/src/dropdown-item.vue?vue&type=template&id=6359102a&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown-item.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const dropdown_itemvue_type_script_lang_js_ = ({
              name: 'ElDropdownItem',

              mixins: [emitter_default.a],

              props: {
                command: {},
                disabled: Boolean,
                divided: Boolean,
                icon: String,
              },

              methods: {
                handleClick: function handleClick(e) {
                  this.dispatch('ElDropdown', 'menu-item-click', [this.command, this]);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/dropdown/src/dropdown-item.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_dropdown_itemvue_type_script_lang_js_ = (dropdown_itemvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/dropdown/src/dropdown-item.vue

            /* normalize component */

            const dropdown_item_component = normalizeComponent(
              src_dropdown_itemvue_type_script_lang_js_,
              dropdown_itemvue_type_template_id_6359102a_render,
              dropdown_itemvue_type_template_id_6359102a_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let dropdown_item_api; }
            dropdown_item_component.options.__file = 'packages/dropdown/src/dropdown-item.vue';
            /* harmony default export */ const dropdown_item = (dropdown_item_component.exports);
            // CONCATENATED MODULE: ./packages/dropdown-item/index.js

            /* istanbul ignore next */
            dropdown_item.install = function (Vue) {
              Vue.component(dropdown_item.name, dropdown_item);
            };

            /* harmony default export */ const packages_dropdown_item = (dropdown_item);
            // CONCATENATED MODULE: ./src/utils/aria-utils.js
            var aria = aria || {};

            aria.Utils = aria.Utils || {};

            /**
 * @desc Set focus on descendant nodes until the first focusable element is
 *       found.
 * @param element
 *          DOM node for which to find the first focusable descendant.
 * @returns
 *  true if a focusable element is found and focus is set.
 */
            aria.Utils.focusFirstDescendant = function (element) {
              for (let i = 0; i < element.childNodes.length; i++) {
                const child = element.childNodes[i];
                if (aria.Utils.attemptFocus(child) || aria.Utils.focusFirstDescendant(child)) {
                  return true;
                }
              }
              return false;
            };

            /**
 * @desc Find the last descendant node that is focusable.
 * @param element
 *          DOM node for which to find the last focusable descendant.
 * @returns
 *  true if a focusable element is found and focus is set.
 */

            aria.Utils.focusLastDescendant = function (element) {
              for (let i = element.childNodes.length - 1; i >= 0; i--) {
                const child = element.childNodes[i];
                if (aria.Utils.attemptFocus(child) || aria.Utils.focusLastDescendant(child)) {
                  return true;
                }
              }
              return false;
            };

            /**
 * @desc Set Attempt to set focus on the current node.
 * @param element
 *          The node to attempt to focus on.
 * @returns
 *  true if element is focused.
 */
            aria.Utils.attemptFocus = function (element) {
              if (!aria.Utils.isFocusable(element)) {
                return false;
              }
              aria.Utils.IgnoreUtilFocusChanges = true;
              try {
                element.focus();
              } catch (e) {}
              aria.Utils.IgnoreUtilFocusChanges = false;
              return document.activeElement === element;
            };

            aria.Utils.isFocusable = function (element) {
              if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute('tabIndex') !== null) {
                return true;
              }

              if (element.disabled) {
                return false;
              }

              switch (element.nodeName) {
                case 'A':
                  return !!element.href && element.rel !== 'ignore';
                case 'INPUT':
                  return element.type !== 'hidden' && element.type !== 'file';
                case 'BUTTON':
                case 'SELECT':
                case 'TEXTAREA':
                  return true;
                default:
                  return false;
              }
            };

            /**
 * 触发一个事件
 * mouseenter, mouseleave, mouseover, keyup, change, click 等
 * @param  {Element} elm
 * @param  {String} name
 * @param  {*} opts
 */
            aria.Utils.triggerEvent = function (elm, name) {
              let eventName = void 0;

              if (/^mouse|click/.test(name)) {
                eventName = 'MouseEvents';
              } else if (/^key/.test(name)) {
                eventName = 'KeyboardEvent';
              } else {
                eventName = 'HTMLEvents';
              }
              const evt = document.createEvent(eventName);

              for (var _len = arguments.length, opts = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                opts[_key - 2] = arguments[_key];
              }

              evt.initEvent.apply(evt, [name].concat(opts));
              elm.dispatchEvent ? elm.dispatchEvent(evt) : elm.fireEvent(`on${name}`, evt);

              return elm;
            };

            aria.Utils.keys = {
              tab: 9,
              enter: 13,
              space: 32,
              left: 37,
              up: 38,
              right: 39,
              down: 40,
              esc: 27,
            };

            /* harmony default export */ const aria_utils = (aria.Utils);
            // CONCATENATED MODULE: ./src/utils/menu/aria-submenu.js

            const SubMenu = function SubMenu(parent, domNode) {
              this.domNode = domNode;
              this.parent = parent;
              this.subMenuItems = [];
              this.subIndex = 0;
              this.init();
            };

            SubMenu.prototype.init = function () {
              this.subMenuItems = this.domNode.querySelectorAll('li');
              this.addListeners();
            };

            SubMenu.prototype.gotoSubIndex = function (idx) {
              if (idx === this.subMenuItems.length) {
                idx = 0;
              } else if (idx < 0) {
                idx = this.subMenuItems.length - 1;
              }
              this.subMenuItems[idx].focus();
              this.subIndex = idx;
            };

            SubMenu.prototype.addListeners = function () {
              const _this = this;

              const { keys } = aria_utils;
              const parentNode = this.parent.domNode;
              Array.prototype.forEach.call(this.subMenuItems, (el) => {
                el.addEventListener('keydown', (event) => {
                  let prevDef = false;
                  switch (event.keyCode) {
                    case keys.down:
                      _this.gotoSubIndex(_this.subIndex + 1);
                      prevDef = true;
                      break;
                    case keys.up:
                      _this.gotoSubIndex(_this.subIndex - 1);
                      prevDef = true;
                      break;
                    case keys.tab:
                      aria_utils.triggerEvent(parentNode, 'mouseleave');
                      break;
                    case keys.enter:
                    case keys.space:
                      prevDef = true;
                      event.currentTarget.click();
                      break;
                  }
                  if (prevDef) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                  return false;
                });
              });
            };

            /* harmony default export */ const aria_submenu = (SubMenu);
            // CONCATENATED MODULE: ./src/utils/menu/aria-menuitem.js

            const MenuItem = function MenuItem(domNode) {
              this.domNode = domNode;
              this.submenu = null;
              this.init();
            };

            MenuItem.prototype.init = function () {
              this.domNode.setAttribute('tabindex', '0');
              const menuChild = this.domNode.querySelector('.el-menu');
              if (menuChild) {
                this.submenu = new aria_submenu(this, menuChild);
              }
              this.addListeners();
            };

            MenuItem.prototype.addListeners = function () {
              const _this = this;

              const { keys } = aria_utils;
              this.domNode.addEventListener('keydown', (event) => {
                let prevDef = false;
                switch (event.keyCode) {
                  case keys.down:
                    aria_utils.triggerEvent(event.currentTarget, 'mouseenter');
                    _this.submenu && _this.submenu.gotoSubIndex(0);
                    prevDef = true;
                    break;
                  case keys.up:
                    aria_utils.triggerEvent(event.currentTarget, 'mouseenter');
                    _this.submenu && _this.submenu.gotoSubIndex(_this.submenu.subMenuItems.length - 1);
                    prevDef = true;
                    break;
                  case keys.tab:
                    aria_utils.triggerEvent(event.currentTarget, 'mouseleave');
                    break;
                  case keys.enter:
                  case keys.space:
                    prevDef = true;
                    event.currentTarget.click();
                    break;
                }
                if (prevDef) {
                  event.preventDefault();
                }
              });
            };

            /* harmony default export */ const aria_menuitem = (MenuItem);
            // CONCATENATED MODULE: ./src/utils/menu/aria-menubar.js

            const Menu = function Menu(domNode) {
              this.domNode = domNode;
              this.init();
            };

            Menu.prototype.init = function () {
              const menuChildren = this.domNode.childNodes;
              [].filter.call(menuChildren, (child) => child.nodeType === 1).forEach((child) => {
    new aria_menuitem(child); // eslint-disable-line
              });
            };
            /* harmony default export */ const aria_menubar = (Menu);
            // EXTERNAL MODULE: external "element-ui/lib/utils/dom"
            const dom_ = __webpack_require__(1);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu.vue?vue&type=script&lang=js&

            /* harmony default export */ const menuvue_type_script_lang_js_ = ({
              name: 'ElMenu',

              render: function render(h) {
                const component = h(
                  'ul',
                  {
                    attrs: {
                      role: 'menubar',
                    },
                    key: +this.collapse,
                    style: { backgroundColor: this.backgroundColor || '' },
                    class: {
                      'el-menu--horizontal': this.mode === 'horizontal',
                      'el-menu--collapse': this.collapse,
                      'el-menu': true,
                    },
                  },
                  [this.$slots.default],
                );

                if (this.collapseTransition) {
                  return h('el-menu-collapse-transition', [component]);
                }
                return component;
              },

              componentName: 'ElMenu',

              mixins: [emitter_default.a, migrating_default.a],

              provide: function provide() {
                return {
                  rootMenu: this,
                };
              },

              components: {
                'el-menu-collapse-transition': {
                  functional: true,
                  render: function render(createElement, context) {
                    const data = {
                      props: {
                        mode: 'out-in',
                      },
                      on: {
                        beforeEnter: function beforeEnter(el) {
                          el.style.opacity = 0.2;
                        },
                        enter: function enter(el) {
                          Object(dom_.addClass)(el, 'el-opacity-transition');
                          el.style.opacity = 1;
                        },
                        afterEnter: function afterEnter(el) {
                          Object(dom_.removeClass)(el, 'el-opacity-transition');
                          el.style.opacity = '';
                        },
                        beforeLeave: function beforeLeave(el) {
                          if (!el.dataset) el.dataset = {};

                          if (Object(dom_.hasClass)(el, 'el-menu--collapse')) {
                            Object(dom_.removeClass)(el, 'el-menu--collapse');
                            el.dataset.oldOverflow = el.style.overflow;
                            el.dataset.scrollWidth = el.clientWidth;
                            Object(dom_.addClass)(el, 'el-menu--collapse');
                          } else {
                            Object(dom_.addClass)(el, 'el-menu--collapse');
                            el.dataset.oldOverflow = el.style.overflow;
                            el.dataset.scrollWidth = el.clientWidth;
                            Object(dom_.removeClass)(el, 'el-menu--collapse');
                          }

                          el.style.width = `${el.scrollWidth}px`;
                          el.style.overflow = 'hidden';
                        },
                        leave: function leave(el) {
                          Object(dom_.addClass)(el, 'horizontal-collapse-transition');
                          el.style.width = `${el.dataset.scrollWidth}px`;
                        },
                      },
                    };
                    return createElement('transition', data, context.children);
                  },
                },
              },

              props: {
                mode: {
                  type: String,
                  default: 'vertical',
                },
                defaultActive: {
                  type: String,
                  default: '',
                },
                defaultOpeneds: Array,
                uniqueOpened: Boolean,
                router: Boolean,
                menuTrigger: {
                  type: String,
                  default: 'hover',
                },
                collapse: Boolean,
                backgroundColor: String,
                textColor: String,
                activeTextColor: String,
                collapseTransition: {
                  type: Boolean,
                  default: true,
                },
              },
              data: function data() {
                return {
                  activeIndex: this.defaultActive,
                  openedMenus: this.defaultOpeneds && !this.collapse ? this.defaultOpeneds.slice(0) : [],
                  items: {},
                  submenus: {},
                };
              },

              computed: {
                hoverBackground: function hoverBackground() {
                  return this.backgroundColor ? this.mixColor(this.backgroundColor, 0.2) : '';
                },
                isMenuPopup: function isMenuPopup() {
                  return this.mode === 'horizontal' || this.mode === 'vertical' && this.collapse;
                },
              },
              watch: {
                defaultActive: function defaultActive(value) {
                  if (!this.items[value]) {
                    this.activeIndex = null;
                  }
                  this.updateActiveIndex(value);
                },
                defaultOpeneds: function defaultOpeneds(value) {
                  if (!this.collapse) {
                    this.openedMenus = value;
                  }
                },
                collapse: function collapse(value) {
                  if (value) this.openedMenus = [];
                  this.broadcast('ElSubmenu', 'toggle-collapse', value);
                },
              },
              methods: {
                updateActiveIndex: function updateActiveIndex(val) {
                  const item = this.items[val] || this.items[this.activeIndex] || this.items[this.defaultActive];
                  if (item) {
                    this.activeIndex = item.index;
                    this.initOpenedMenu();
                  } else {
                    this.activeIndex = null;
                  }
                },
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      theme: 'theme is removed.',
                    },
                  };
                },
                getColorChannels: function getColorChannels(color) {
                  color = color.replace('#', '');
                  if (/^[0-9a-fA-F]{3}$/.test(color)) {
                    color = color.split('');
                    for (let i = 2; i >= 0; i--) {
                      color.splice(i, 0, color[i]);
                    }
                    color = color.join('');
                  }
                  if (/^[0-9a-fA-F]{6}$/.test(color)) {
                    return {
                      red: parseInt(color.slice(0, 2), 16),
                      green: parseInt(color.slice(2, 4), 16),
                      blue: parseInt(color.slice(4, 6), 16),
                    };
                  }
                  return {
                    red: 255,
                    green: 255,
                    blue: 255,
                  };
                },
                mixColor: function mixColor(color, percent) {
                  const _getColorChannels = this.getColorChannels(color);
                  let { red } = _getColorChannels;
                  let { green } = _getColorChannels;
                  let { blue } = _getColorChannels;

                  if (percent > 0) {
                    // shade given color
                    red *= 1 - percent;
                    green *= 1 - percent;
                    blue *= 1 - percent;
                  } else {
                    // tint given color
                    red += (255 - red) * percent;
                    green += (255 - green) * percent;
                    blue += (255 - blue) * percent;
                  }
                  return `rgb(${Math.round(red)}, ${Math.round(green)}, ${Math.round(blue)})`;
                },
                addItem: function addItem(item) {
                  this.$set(this.items, item.index, item);
                },
                removeItem: function removeItem(item) {
                  delete this.items[item.index];
                },
                addSubmenu: function addSubmenu(item) {
                  this.$set(this.submenus, item.index, item);
                },
                removeSubmenu: function removeSubmenu(item) {
                  delete this.submenus[item.index];
                },
                openMenu: function openMenu(index, indexPath) {
                  const { openedMenus } = this;
                  if (openedMenus.indexOf(index) !== -1) return;
                  // 将不在该菜单路径下的其余菜单收起
                  // collapse all menu that are not under current menu item
                  if (this.uniqueOpened) {
                    this.openedMenus = openedMenus.filter((index) => indexPath.indexOf(index) !== -1);
                  }
                  this.openedMenus.push(index);
                },
                closeMenu: function closeMenu(index) {
                  const i = this.openedMenus.indexOf(index);
                  if (i !== -1) {
                    this.openedMenus.splice(i, 1);
                  }
                },
                handleSubmenuClick: function handleSubmenuClick(submenu) {
                  const { index } = submenu;
                  const { indexPath } = submenu;

                  const isOpened = this.openedMenus.indexOf(index) !== -1;

                  if (isOpened) {
                    this.closeMenu(index);
                    this.$emit('close', index, indexPath);
                  } else {
                    this.openMenu(index, indexPath);
                    this.$emit('open', index, indexPath);
                  }
                },
                handleItemClick: function handleItemClick(item) {
                  const _this = this;

                  const { index } = item;
                  const { indexPath } = item;

                  const oldActiveIndex = this.activeIndex;
                  const hasIndex = item.index !== null;

                  if (hasIndex) {
                    this.activeIndex = item.index;
                  }

                  this.$emit('select', index, indexPath, item);

                  if (this.mode === 'horizontal' || this.collapse) {
                    this.openedMenus = [];
                  }

                  if (this.router && hasIndex) {
                    this.routeToItem(item, (error) => {
                      _this.activeIndex = oldActiveIndex;
                      if (error) {
                        // vue-router 3.1.0+ push/replace cause NavigationDuplicated error
                        // https://github.com/ElemeFE/element/issues/17044
                        if (error.name === 'NavigationDuplicated') return;
                        console.error(error);
                      }
                    });
                  }
                },

                // 初始化展开菜单
                // initialize opened menu
                initOpenedMenu: function initOpenedMenu() {
                  const _this2 = this;

                  const index = this.activeIndex;
                  const activeItem = this.items[index];
                  if (!activeItem || this.mode === 'horizontal' || this.collapse) return;

                  const { indexPath } = activeItem;

                  // 展开该菜单项的路径上所有子菜单
                  // expand all submenus of the menu item
                  indexPath.forEach((index) => {
                    const submenu = _this2.submenus[index];
                    submenu && _this2.openMenu(index, submenu.indexPath);
                  });
                },
                routeToItem: function routeToItem(item, onError) {
                  const route = item.route || item.index;
                  try {
                    this.$router.push(route, () => {}, onError);
                  } catch (e) {
                    console.error(e);
                  }
                },
                open: function open(index) {
                  const _this3 = this;

                  const { indexPath } = this.submenus[index.toString()];

                  indexPath.forEach((i) => _this3.openMenu(i, indexPath));
                },
                close: function close(index) {
                  this.closeMenu(index);
                },
              },
              mounted: function mounted() {
                this.initOpenedMenu();
                this.$on('item-click', this.handleItemClick);
                this.$on('submenu-click', this.handleSubmenuClick);
                if (this.mode === 'horizontal') {
      new aria_menubar(this.$el); // eslint-disable-line
                }
                this.$watch('items', this.updateActiveIndex);
              },
            });
            // CONCATENATED MODULE: ./packages/menu/src/menu.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_menuvue_type_script_lang_js_ = (menuvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/menu/src/menu.vue
            let menu_render; let
              menu_staticRenderFns;

            /* normalize component */

            const menu_component = normalizeComponent(
              src_menuvue_type_script_lang_js_,
              menu_render,
              menu_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let menu_api; }
            menu_component.options.__file = 'packages/menu/src/menu.vue';
            /* harmony default export */ const src_menu = (menu_component.exports);
            // CONCATENATED MODULE: ./packages/menu/index.js

            /* istanbul ignore next */
            src_menu.install = function (Vue) {
              Vue.component(src_menu.name, src_menu);
            };

            /* harmony default export */ const packages_menu = (src_menu);
            // EXTERNAL MODULE: external "element-ui/lib/transitions/collapse-transition"
            const collapse_transition_ = __webpack_require__(21);
            const collapse_transition_default = /* #__PURE__ */__webpack_require__.n(collapse_transition_);

            // CONCATENATED MODULE: ./packages/menu/src/menu-mixin.js
            /* harmony default export */ const menu_mixin = ({
              inject: ['rootMenu'],
              computed: {
                indexPath: function indexPath() {
                  const path = [this.index];
                  let parent = this.$parent;
                  while (parent.$options.componentName !== 'ElMenu') {
                    if (parent.index) {
                      path.unshift(parent.index);
                    }
                    parent = parent.$parent;
                  }
                  return path;
                },
                parentMenu: function parentMenu() {
                  let parent = this.$parent;
                  while (parent && ['ElMenu', 'ElSubmenu'].indexOf(parent.$options.componentName) === -1) {
                    parent = parent.$parent;
                  }
                  return parent;
                },
                paddingStyle: function paddingStyle() {
                  if (this.rootMenu.mode !== 'vertical') return {};

                  let padding = 20;
                  let parent = this.$parent;

                  if (this.rootMenu.collapse) {
                    padding = 20;
                  } else {
                    while (parent && parent.$options.componentName !== 'ElMenu') {
                      if (parent.$options.componentName === 'ElSubmenu') {
                        padding += 20;
                      }
                      parent = parent.$parent;
                    }
                  }
                  return { paddingLeft: `${padding}px` };
                },
              },
            });
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/submenu.vue?vue&type=script&lang=js&

            const poperMixins = {
              props: {
                transformOrigin: {
                  type: [Boolean, String],
                  default: false,
                },
                offset: vue_popper_default.a.props.offset,
                boundariesPadding: vue_popper_default.a.props.boundariesPadding,
                popperOptions: vue_popper_default.a.props.popperOptions,
              },
              data: vue_popper_default.a.data,
              methods: vue_popper_default.a.methods,
              beforeDestroy: vue_popper_default.a.beforeDestroy,
              deactivated: vue_popper_default.a.deactivated,
            };

            /* harmony default export */ const submenuvue_type_script_lang_js_ = ({
              name: 'ElSubmenu',

              componentName: 'ElSubmenu',

              mixins: [menu_mixin, emitter_default.a, poperMixins],

              components: { ElCollapseTransition: collapse_transition_default.a },

              props: {
                index: {
                  type: String,
                  required: true,
                },
                showTimeout: {
                  type: Number,
                  default: 300,
                },
                hideTimeout: {
                  type: Number,
                  default: 300,
                },
                popperClass: String,
                disabled: Boolean,
                popperAppendToBody: {
                  type: Boolean,
                  default: undefined,
                },
              },

              data: function data() {
                return {
                  popperJS: null,
                  timeout: null,
                  items: {},
                  submenus: {},
                  mouseInChild: false,
                };
              },

              watch: {
                opened: function opened(val) {
                  const _this = this;

                  if (this.isMenuPopup) {
                    this.$nextTick((_) => {
                      _this.updatePopper();
                    });
                  }
                },
              },
              computed: {
                // popper option
                appendToBody: function appendToBody() {
                  return this.popperAppendToBody === undefined ? this.isFirstLevel : this.popperAppendToBody;
                },
                menuTransitionName: function menuTransitionName() {
                  return this.rootMenu.collapse ? 'el-zoom-in-left' : 'el-zoom-in-top';
                },
                opened: function opened() {
                  return this.rootMenu.openedMenus.indexOf(this.index) > -1;
                },
                active: function active() {
                  let isActive = false;
                  const { submenus } = this;
                  const { items } = this;

                  Object.keys(items).forEach((index) => {
                    if (items[index].active) {
                      isActive = true;
                    }
                  });

                  Object.keys(submenus).forEach((index) => {
                    if (submenus[index].active) {
                      isActive = true;
                    }
                  });

                  return isActive;
                },
                hoverBackground: function hoverBackground() {
                  return this.rootMenu.hoverBackground;
                },
                backgroundColor: function backgroundColor() {
                  return this.rootMenu.backgroundColor || '';
                },
                activeTextColor: function activeTextColor() {
                  return this.rootMenu.activeTextColor || '';
                },
                textColor: function textColor() {
                  return this.rootMenu.textColor || '';
                },
                mode: function mode() {
                  return this.rootMenu.mode;
                },
                isMenuPopup: function isMenuPopup() {
                  return this.rootMenu.isMenuPopup;
                },
                titleStyle: function titleStyle() {
                  if (this.mode !== 'horizontal') {
                    return {
                      color: this.textColor,
                    };
                  }
                  return {
                    borderBottomColor: this.active ? this.rootMenu.activeTextColor ? this.activeTextColor : '' : 'transparent',
                    color: this.active ? this.activeTextColor : this.textColor,
                  };
                },
                isFirstLevel: function isFirstLevel() {
                  let isFirstLevel = true;
                  let parent = this.$parent;
                  while (parent && parent !== this.rootMenu) {
                    if (['ElSubmenu', 'ElMenuItemGroup'].indexOf(parent.$options.componentName) > -1) {
                      isFirstLevel = false;
                      break;
                    } else {
                      parent = parent.$parent;
                    }
                  }
                  return isFirstLevel;
                },
              },
              methods: {
                handleCollapseToggle: function handleCollapseToggle(value) {
                  if (value) {
                    this.initPopper();
                  } else {
                    this.doDestroy();
                  }
                },
                addItem: function addItem(item) {
                  this.$set(this.items, item.index, item);
                },
                removeItem: function removeItem(item) {
                  delete this.items[item.index];
                },
                addSubmenu: function addSubmenu(item) {
                  this.$set(this.submenus, item.index, item);
                },
                removeSubmenu: function removeSubmenu(item) {
                  delete this.submenus[item.index];
                },
                handleClick: function handleClick() {
                  const { rootMenu } = this;
                  const { disabled } = this;

                  if (rootMenu.menuTrigger === 'hover' && rootMenu.mode === 'horizontal' || rootMenu.collapse && rootMenu.mode === 'vertical' || disabled) {
                    return;
                  }
                  this.dispatch('ElMenu', 'submenu-click', this);
                },
                handleMouseenter: function handleMouseenter(event) {
                  const _this2 = this;

                  const showTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.showTimeout;

                  if (!('ActiveXObject' in window) && event.type === 'focus' && !event.relatedTarget) {
                    return;
                  }
                  const { rootMenu } = this;
                  const { disabled } = this;

                  if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical' || disabled) {
                    return;
                  }
                  this.dispatch('ElSubmenu', 'mouse-enter-child');
                  clearTimeout(this.timeout);
                  this.timeout = setTimeout(() => {
                    _this2.rootMenu.openMenu(_this2.index, _this2.indexPath);
                  }, showTimeout);

                  if (this.appendToBody) {
                    this.$parent.$el.dispatchEvent(new MouseEvent('mouseenter'));
                  }
                },
                handleMouseleave: function handleMouseleave() {
                  const _this3 = this;

                  const deepDispatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                  const { rootMenu } = this;

                  if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical') {
                    return;
                  }
                  this.dispatch('ElSubmenu', 'mouse-leave-child');
                  clearTimeout(this.timeout);
                  this.timeout = setTimeout(() => {
                    !_this3.mouseInChild && _this3.rootMenu.closeMenu(_this3.index);
                  }, this.hideTimeout);

                  if (this.appendToBody && deepDispatch) {
                    if (this.$parent.$options.name === 'ElSubmenu') {
                      this.$parent.handleMouseleave(true);
                    }
                  }
                },
                handleTitleMouseenter: function handleTitleMouseenter() {
                  if (this.mode === 'horizontal' && !this.rootMenu.backgroundColor) return;
                  const title = this.$refs['submenu-title'];
                  title && (title.style.backgroundColor = this.rootMenu.hoverBackground);
                },
                handleTitleMouseleave: function handleTitleMouseleave() {
                  if (this.mode === 'horizontal' && !this.rootMenu.backgroundColor) return;
                  const title = this.$refs['submenu-title'];
                  title && (title.style.backgroundColor = this.rootMenu.backgroundColor || '');
                },
                updatePlacement: function updatePlacement() {
                  this.currentPlacement = this.mode === 'horizontal' && this.isFirstLevel ? 'bottom-start' : 'right-start';
                },
                initPopper: function initPopper() {
                  this.referenceElm = this.$el;
                  this.popperElm = this.$refs.menu;
                  this.updatePlacement();
                },
              },
              created: function created() {
                const _this4 = this;

                this.$on('toggle-collapse', this.handleCollapseToggle);
                this.$on('mouse-enter-child', () => {
                  _this4.mouseInChild = true;
                  clearTimeout(_this4.timeout);
                });
                this.$on('mouse-leave-child', () => {
                  _this4.mouseInChild = false;
                  clearTimeout(_this4.timeout);
                });
              },
              mounted: function mounted() {
                this.parentMenu.addSubmenu(this);
                this.rootMenu.addSubmenu(this);
                this.initPopper();
              },
              beforeDestroy: function beforeDestroy() {
                this.parentMenu.removeSubmenu(this);
                this.rootMenu.removeSubmenu(this);
              },
              render: function render(h) {
                const _this5 = this;

                const { active } = this;
                const { opened } = this;
                const { paddingStyle } = this;
                const { titleStyle } = this;
                const { backgroundColor } = this;
                const { rootMenu } = this;
                const { currentPlacement } = this;
                const { menuTransitionName } = this;
                const { mode } = this;
                const { disabled } = this;
                const { popperClass } = this;
                const { $slots } = this;
                const { isFirstLevel } = this;

                const popupMenu = h(
                  'transition',
                  {
                    attrs: { name: menuTransitionName },
                  },
                  [h(
                    'div',
                    {
                      ref: 'menu',
                      directives: [{
                        name: 'show',
                        value: opened,
                      }],

                      class: [`el-menu--${mode}`, popperClass],
                      on: {
                        mouseenter: function mouseenter($event) {
                          return _this5.handleMouseenter($event, 100);
                        },
                        mouseleave: function mouseleave() {
                          return _this5.handleMouseleave(true);
                        },
                        focus: function focus($event) {
                          return _this5.handleMouseenter($event, 100);
                        },
                      },
                    },
                    [h(
                      'ul',
                      {
                        attrs: {
                          role: 'menu',
                        },
                        class: ['el-menu el-menu--popup', `el-menu--popup-${currentPlacement}`],
                        style: { backgroundColor: rootMenu.backgroundColor || '' },
                      },
                      [$slots.default],
                    )],
                  )],
                );

                const inlineMenu = h('el-collapse-transition', [h(
                  'ul',
                  {
                    attrs: {
                      role: 'menu',
                    },
                    class: 'el-menu el-menu--inline',
                    directives: [{
                      name: 'show',
                      value: opened,
                    }],

                    style: { backgroundColor: rootMenu.backgroundColor || '' },
                  },
                  [$slots.default],
                )]);

                const submenuTitleIcon = rootMenu.mode === 'horizontal' && isFirstLevel || rootMenu.mode === 'vertical' && !rootMenu.collapse ? 'el-icon-arrow-down' : 'el-icon-arrow-right';

                return h(
                  'li',
                  {
                    class: {
                      'el-submenu': true,
                      'is-active': active,
                      'is-opened': opened,
                      'is-disabled': disabled,
                    },
                    attrs: {
                      role: 'menuitem',
                      'aria-haspopup': 'true',
                      'aria-expanded': opened,
                    },
                    on: {
                      mouseenter: this.handleMouseenter,
                      mouseleave: function mouseleave() {
                        return _this5.handleMouseleave(false);
                      },
                      focus: this.handleMouseenter,
                    },
                  },
                  [h(
                    'div',
                    {
                      class: 'el-submenu__title',
                      ref: 'submenu-title',
                      on: {
                        click: this.handleClick,
                        mouseenter: this.handleTitleMouseenter,
                        mouseleave: this.handleTitleMouseleave,
                      },

                      style: [paddingStyle, titleStyle, { backgroundColor }],
                    },
                    [$slots.title, h('i', { class: ['el-submenu__icon-arrow', submenuTitleIcon] })],
                  ), this.isMenuPopup ? popupMenu : inlineMenu],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/menu/src/submenu.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_submenuvue_type_script_lang_js_ = (submenuvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/menu/src/submenu.vue
            let submenu_render; let
              submenu_staticRenderFns;

            /* normalize component */

            const submenu_component = normalizeComponent(
              src_submenuvue_type_script_lang_js_,
              submenu_render,
              submenu_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let submenu_api; }
            submenu_component.options.__file = 'packages/menu/src/submenu.vue';
            /* harmony default export */ const submenu = (submenu_component.exports);
            // CONCATENATED MODULE: ./packages/submenu/index.js

            /* istanbul ignore next */
            submenu.install = function (Vue) {
              Vue.component(submenu.name, submenu);
            };

            /* harmony default export */ const packages_submenu = (submenu);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu-item.vue?vue&type=template&id=2a5dbfea&
            const menu_itemvue_type_template_id_2a5dbfea_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'li',
                {
                  staticClass: 'el-menu-item',
                  class: {
                    'is-active': _vm.active,
                    'is-disabled': _vm.disabled,
                  },
                  style: [
                    _vm.paddingStyle,
                    _vm.itemStyle,
                    { backgroundColor: _vm.backgroundColor },
                  ],
                  attrs: { role: 'menuitem', tabindex: '-1' },
                  on: {
                    click: _vm.handleClick,
                    mouseenter: _vm.onMouseEnter,
                    focus: _vm.onMouseEnter,
                    blur: _vm.onMouseLeave,
                    mouseleave: _vm.onMouseLeave,
                  },
                },
                [
                  _vm.parentMenu.$options.componentName === 'ElMenu'
      && _vm.rootMenu.collapse
      && _vm.$slots.title
                    ? _c('el-tooltip', { attrs: { effect: 'dark', placement: 'right' } }, [
                      _c(
                        'div',
                        { attrs: { slot: 'content' }, slot: 'content' },
                        [_vm._t('title')],
                        2,
                      ),
                      _c(
                        'div',
                        {
                          staticStyle: {
                            position: 'absolute',
                            left: '0',
                            top: '0',
                            height: '100%',
                            width: '100%',
                            display: 'inline-block',
                            'box-sizing': 'border-box',
                            padding: '0 20px',
                          },
                        },
                        [_vm._t('default')],
                        2,
                      ),
                    ])
                    : [_vm._t('default'), _vm._t('title')],
                ],
                2,
              );
            };
            const menu_itemvue_type_template_id_2a5dbfea_staticRenderFns = [];
            menu_itemvue_type_template_id_2a5dbfea_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/menu/src/menu-item.vue?vue&type=template&id=2a5dbfea&

            // EXTERNAL MODULE: external "element-ui/lib/tooltip"
            const tooltip_ = __webpack_require__(26);
            const tooltip_default = /* #__PURE__ */__webpack_require__.n(tooltip_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu-item.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const menu_itemvue_type_script_lang_js_ = ({
              name: 'ElMenuItem',

              componentName: 'ElMenuItem',

              mixins: [menu_mixin, emitter_default.a],

              components: { ElTooltip: tooltip_default.a },

              props: {
                index: {
                  default: null,
                  validator: function validator(val) {
                    return typeof val === 'string' || val === null;
                  },
                },
                route: [String, Object],
                disabled: Boolean,
              },
              computed: {
                active: function active() {
                  return this.index === this.rootMenu.activeIndex;
                },
                hoverBackground: function hoverBackground() {
                  return this.rootMenu.hoverBackground;
                },
                backgroundColor: function backgroundColor() {
                  return this.rootMenu.backgroundColor || '';
                },
                activeTextColor: function activeTextColor() {
                  return this.rootMenu.activeTextColor || '';
                },
                textColor: function textColor() {
                  return this.rootMenu.textColor || '';
                },
                mode: function mode() {
                  return this.rootMenu.mode;
                },
                itemStyle: function itemStyle() {
                  const style = {
                    color: this.active ? this.activeTextColor : this.textColor,
                  };
                  if (this.mode === 'horizontal' && !this.isNested) {
                    style.borderBottomColor = this.active ? this.rootMenu.activeTextColor ? this.activeTextColor : '' : 'transparent';
                  }
                  return style;
                },
                isNested: function isNested() {
                  return this.parentMenu !== this.rootMenu;
                },
              },
              methods: {
                onMouseEnter: function onMouseEnter() {
                  if (this.mode === 'horizontal' && !this.rootMenu.backgroundColor) return;
                  this.$el.style.backgroundColor = this.hoverBackground;
                },
                onMouseLeave: function onMouseLeave() {
                  if (this.mode === 'horizontal' && !this.rootMenu.backgroundColor) return;
                  this.$el.style.backgroundColor = this.backgroundColor;
                },
                handleClick: function handleClick() {
                  if (!this.disabled) {
                    this.dispatch('ElMenu', 'item-click', this);
                    this.$emit('click', this);
                  }
                },
              },
              mounted: function mounted() {
                this.parentMenu.addItem(this);
                this.rootMenu.addItem(this);
              },
              beforeDestroy: function beforeDestroy() {
                this.parentMenu.removeItem(this);
                this.rootMenu.removeItem(this);
              },
            });
            // CONCATENATED MODULE: ./packages/menu/src/menu-item.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_menu_itemvue_type_script_lang_js_ = (menu_itemvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/menu/src/menu-item.vue

            /* normalize component */

            const menu_item_component = normalizeComponent(
              src_menu_itemvue_type_script_lang_js_,
              menu_itemvue_type_template_id_2a5dbfea_render,
              menu_itemvue_type_template_id_2a5dbfea_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let menu_item_api; }
            menu_item_component.options.__file = 'packages/menu/src/menu-item.vue';
            /* harmony default export */ const menu_item = (menu_item_component.exports);
            // CONCATENATED MODULE: ./packages/menu-item/index.js

            /* istanbul ignore next */
            menu_item.install = function (Vue) {
              Vue.component(menu_item.name, menu_item);
            };

            /* harmony default export */ const packages_menu_item = (menu_item);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu-item-group.vue?vue&type=template&id=543b7bdc&
            const menu_item_groupvue_type_template_id_543b7bdc_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('li', { staticClass: 'el-menu-item-group' }, [
                _c(
                  'div',
                  {
                    staticClass: 'el-menu-item-group__title',
                    style: { paddingLeft: `${_vm.levelPadding}px` },
                  },
                  [!_vm.$slots.title ? [_vm._v(_vm._s(_vm.title))] : _vm._t('title')],
                  2,
                ),
                _c('ul', [_vm._t('default')], 2),
              ]);
            };
            const menu_item_groupvue_type_template_id_543b7bdc_staticRenderFns = [];
            menu_item_groupvue_type_template_id_543b7bdc_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/menu/src/menu-item-group.vue?vue&type=template&id=543b7bdc&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu-item-group.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const menu_item_groupvue_type_script_lang_js_ = ({
              name: 'ElMenuItemGroup',

              componentName: 'ElMenuItemGroup',

              inject: ['rootMenu'],
              props: {
                title: {
                  type: String,
                },
              },
              data: function data() {
                return {
                  paddingLeft: 20,
                };
              },

              computed: {
                levelPadding: function levelPadding() {
                  let padding = 20;
                  let parent = this.$parent;
                  if (this.rootMenu.collapse) return 20;
                  while (parent && parent.$options.componentName !== 'ElMenu') {
                    if (parent.$options.componentName === 'ElSubmenu') {
                      padding += 20;
                    }
                    parent = parent.$parent;
                  }
                  return padding;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/menu/src/menu-item-group.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_menu_item_groupvue_type_script_lang_js_ = (menu_item_groupvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/menu/src/menu-item-group.vue

            /* normalize component */

            const menu_item_group_component = normalizeComponent(
              src_menu_item_groupvue_type_script_lang_js_,
              menu_item_groupvue_type_template_id_543b7bdc_render,
              menu_item_groupvue_type_template_id_543b7bdc_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let menu_item_group_api; }
            menu_item_group_component.options.__file = 'packages/menu/src/menu-item-group.vue';
            /* harmony default export */ const menu_item_group = (menu_item_group_component.exports);
            // CONCATENATED MODULE: ./packages/menu-item-group/index.js

            /* istanbul ignore next */
            menu_item_group.install = function (Vue) {
              Vue.component(menu_item_group.name, menu_item_group);
            };

            /* harmony default export */ const packages_menu_item_group = (menu_item_group);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/input/src/input.vue?vue&type=template&id=343dd774&
            const inputvue_type_template_id_343dd774_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  class: [
                    _vm.type === 'textarea' ? 'el-textarea' : 'el-input',
                    _vm.inputSize ? `el-input--${_vm.inputSize}` : '',
                    {
                      'is-disabled': _vm.inputDisabled,
                      'is-exceed': _vm.inputExceed,
                      'el-input-group': _vm.$slots.prepend || _vm.$slots.append,
                      'el-input-group--append': _vm.$slots.append,
                      'el-input-group--prepend': _vm.$slots.prepend,
                      'el-input--prefix': _vm.$slots.prefix || _vm.prefixIcon,
                      'el-input--suffix':
            _vm.$slots.suffix
            || _vm.suffixIcon
            || _vm.clearable
            || _vm.showPassword,
                    },
                  ],
                  on: {
                    mouseenter($event) {
                      _vm.hovering = true;
                    },
                    mouseleave($event) {
                      _vm.hovering = false;
                    },
                  },
                },
                [
                  _vm.type !== 'textarea'
                    ? [
                      _vm.$slots.prepend
                        ? _c(
                          'div',
                          { staticClass: 'el-input-group__prepend' },
                          [_vm._t('prepend')],
                          2,
                        )
                        : _vm._e(),
                      _vm.type !== 'textarea'
                        ? _c(
                          'input',
                          _vm._b(
                            {
                              ref: 'input',
                              staticClass: 'el-input__inner',
                              attrs: {
                                tabindex: _vm.tabindex,
                                type: _vm.showPassword
                                  ? _vm.passwordVisible
                                    ? 'text'
                                    : 'password'
                                  : _vm.type,
                                disabled: _vm.inputDisabled,
                                readonly: _vm.readonly,
                                autocomplete: _vm.autoComplete || _vm.autocomplete,
                                'aria-label': _vm.label,
                              },
                              on: {
                                compositionstart: _vm.handleCompositionStart,
                                compositionupdate: _vm.handleCompositionUpdate,
                                compositionend: _vm.handleCompositionEnd,
                                input: _vm.handleInput,
                                focus: _vm.handleFocus,
                                blur: _vm.handleBlur,
                                change: _vm.handleChange,
                              },
                            },
                            'input',
                            _vm.$attrs,
                            false,
                          ),
                        )
                        : _vm._e(),
                      _vm.$slots.prefix || _vm.prefixIcon
                        ? _c(
                          'span',
                          { staticClass: 'el-input__prefix' },
                          [
                            _vm._t('prefix'),
                            _vm.prefixIcon
                              ? _c('i', {
                                staticClass: 'el-input__icon',
                                class: _vm.prefixIcon,
                              })
                              : _vm._e(),
                          ],
                          2,
                        )
                        : _vm._e(),
                      _vm.getSuffixVisible()
                        ? _c('span', { staticClass: 'el-input__suffix' }, [
                          _c(
                            'span',
                            { staticClass: 'el-input__suffix-inner' },
                            [
                              !_vm.showClear
                      || !_vm.showPwdVisible
                      || !_vm.isWordLimitVisible
                                ? [
                                  _vm._t('suffix'),
                                  _vm.suffixIcon
                                    ? _c('i', {
                                      staticClass: 'el-input__icon',
                                      class: _vm.suffixIcon,
                                    })
                                    : _vm._e(),
                                ]
                                : _vm._e(),
                              _vm.showClear
                                ? _c('i', {
                                  staticClass:
                              'el-input__icon el-icon-circle-close el-input__clear',
                                  on: {
                                    mousedown($event) {
                                      $event.preventDefault();
                                    },
                                    click: _vm.clear,
                                  },
                                })
                                : _vm._e(),
                              _vm.showPwdVisible
                                ? _c('i', {
                                  staticClass:
                              'el-input__icon el-icon-view el-input__clear',
                                  on: { click: _vm.handlePasswordVisible },
                                })
                                : _vm._e(),
                              _vm.isWordLimitVisible
                                ? _c('span', { staticClass: 'el-input__count' }, [
                                  _c(
                                    'span',
                                    { staticClass: 'el-input__count-inner' },
                                    [
                                      _vm._v(
                                        `\n            ${
                                          _vm._s(_vm.textLength)
                                        }/${
                                          _vm._s(_vm.upperLimit)
                                        }\n          `,
                                      ),
                                    ],
                                  ),
                                ])
                                : _vm._e(),
                            ],
                            2,
                          ),
                          _vm.validateState
                            ? _c('i', {
                              staticClass: 'el-input__icon',
                              class: ['el-input__validateIcon', _vm.validateIcon],
                            })
                            : _vm._e(),
                        ])
                        : _vm._e(),
                      _vm.$slots.append
                        ? _c(
                          'div',
                          { staticClass: 'el-input-group__append' },
                          [_vm._t('append')],
                          2,
                        )
                        : _vm._e(),
                    ]
                    : _c(
                      'textarea',
                      _vm._b(
                        {
                          ref: 'textarea',
                          staticClass: 'el-textarea__inner',
                          style: _vm.textareaStyle,
                          attrs: {
                            tabindex: _vm.tabindex,
                            disabled: _vm.inputDisabled,
                            readonly: _vm.readonly,
                            autocomplete: _vm.autoComplete || _vm.autocomplete,
                            'aria-label': _vm.label,
                          },
                          on: {
                            compositionstart: _vm.handleCompositionStart,
                            compositionupdate: _vm.handleCompositionUpdate,
                            compositionend: _vm.handleCompositionEnd,
                            input: _vm.handleInput,
                            focus: _vm.handleFocus,
                            blur: _vm.handleBlur,
                            change: _vm.handleChange,
                          },
                        },
                        'textarea',
                        _vm.$attrs,
                        false,
                      ),
                    ),
                  _vm.isWordLimitVisible && _vm.type === 'textarea'
                    ? _c('span', { staticClass: 'el-input__count' }, [
                      _vm._v(`${_vm._s(_vm.textLength)}/${_vm._s(_vm.upperLimit)}`),
                    ])
                    : _vm._e(),
                ],
                2,
              );
            };
            const inputvue_type_template_id_343dd774_staticRenderFns = [];
            inputvue_type_template_id_343dd774_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/input/src/input.vue?vue&type=template&id=343dd774&

            // CONCATENATED MODULE: ./packages/input/src/calcTextareaHeight.js
            let hiddenTextarea = void 0;

            const HIDDEN_STYLE = '\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n';

            const CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

            function calculateNodeStyling(targetElement) {
              const style = window.getComputedStyle(targetElement);

              const boxSizing = style.getPropertyValue('box-sizing');

              const paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));

              const borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));

              const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(';');

              return {
                contextStyle, paddingSize, borderSize, boxSizing,
              };
            }

            function calcTextareaHeight(targetElement) {
              const minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
              const maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

              if (!hiddenTextarea) {
                hiddenTextarea = document.createElement('textarea');
                document.body.appendChild(hiddenTextarea);
              }

              const _calculateNodeStyling = calculateNodeStyling(targetElement);
              const { paddingSize } = _calculateNodeStyling;
              const { borderSize } = _calculateNodeStyling;
              const { boxSizing } = _calculateNodeStyling;
              const { contextStyle } = _calculateNodeStyling;

              hiddenTextarea.setAttribute('style', `${contextStyle};${HIDDEN_STYLE}`);
              hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';

              let height = hiddenTextarea.scrollHeight;
              const result = {};

              if (boxSizing === 'border-box') {
                height += borderSize;
              } else if (boxSizing === 'content-box') {
                height -= paddingSize;
              }

              hiddenTextarea.value = '';
              const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

              if (minRows !== null) {
                let minHeight = singleRowHeight * minRows;
                if (boxSizing === 'border-box') {
                  minHeight = minHeight + paddingSize + borderSize;
                }
                height = Math.max(minHeight, height);
                result.minHeight = `${minHeight}px`;
              }
              if (maxRows !== null) {
                let maxHeight = singleRowHeight * maxRows;
                if (boxSizing === 'border-box') {
                  maxHeight = maxHeight + paddingSize + borderSize;
                }
                height = Math.min(maxHeight, height);
              }
              result.height = `${height}px`;
              hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
              hiddenTextarea = null;
              return result;
            }
            // EXTERNAL MODULE: external "element-ui/lib/utils/merge"
            const merge_ = __webpack_require__(7);
            const merge_default = /* #__PURE__ */__webpack_require__.n(merge_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/shared"
            const shared_ = __webpack_require__(19);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/input/src/input.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const inputvue_type_script_lang_js_ = ({
              name: 'ElInput',

              componentName: 'ElInput',

              mixins: [emitter_default.a, migrating_default.a],

              inheritAttrs: false,

              inject: {
                elForm: {
                  default: '',
                },
                elFormItem: {
                  default: '',
                },
              },

              data: function data() {
                return {
                  textareaCalcStyle: {},
                  hovering: false,
                  focused: false,
                  isComposing: false,
                  passwordVisible: false,
                };
              },

              props: {
                value: [String, Number],
                size: String,
                resize: String,
                form: String,
                disabled: Boolean,
                readonly: Boolean,
                type: {
                  type: String,
                  default: 'text',
                },
                autosize: {
                  type: [Boolean, Object],
                  default: false,
                },
                autocomplete: {
                  type: String,
                  default: 'off',
                },
                /** @Deprecated in next major version */
                autoComplete: {
                  type: String,
                  validator: function validator(val) {
                    false && false;
                    return true;
                  },
                },
                validateEvent: {
                  type: Boolean,
                  default: true,
                },
                suffixIcon: String,
                prefixIcon: String,
                label: String,
                clearable: {
                  type: Boolean,
                  default: false,
                },
                showPassword: {
                  type: Boolean,
                  default: false,
                },
                showWordLimit: {
                  type: Boolean,
                  default: false,
                },
                tabindex: String,
              },

              computed: {
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                validateState: function validateState() {
                  return this.elFormItem ? this.elFormItem.validateState : '';
                },
                needStatusIcon: function needStatusIcon() {
                  return this.elForm ? this.elForm.statusIcon : false;
                },
                validateIcon: function validateIcon() {
                  return {
                    validating: 'el-icon-loading',
                    success: 'el-icon-circle-check',
                    error: 'el-icon-circle-close',
                  }[this.validateState];
                },
                textareaStyle: function textareaStyle() {
                  return merge_default()({}, this.textareaCalcStyle, { resize: this.resize });
                },
                inputSize: function inputSize() {
                  return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
                inputDisabled: function inputDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
                nativeInputValue: function nativeInputValue() {
                  return this.value === null || this.value === undefined ? '' : String(this.value);
                },
                showClear: function showClear() {
                  return this.clearable && !this.inputDisabled && !this.readonly && this.nativeInputValue && (this.focused || this.hovering);
                },
                showPwdVisible: function showPwdVisible() {
                  return this.showPassword && !this.inputDisabled && !this.readonly && (!!this.nativeInputValue || this.focused);
                },
                isWordLimitVisible: function isWordLimitVisible() {
                  return this.showWordLimit && this.$attrs.maxlength && (this.type === 'text' || this.type === 'textarea') && !this.inputDisabled && !this.readonly && !this.showPassword;
                },
                upperLimit: function upperLimit() {
                  return this.$attrs.maxlength;
                },
                textLength: function textLength() {
                  if (typeof this.value === 'number') {
                    return String(this.value).length;
                  }

                  return (this.value || '').length;
                },
                inputExceed: function inputExceed() {
                  // show exceed style if length of initial value greater then maxlength
                  return this.isWordLimitVisible && this.textLength > this.upperLimit;
                },
              },

              watch: {
                value: function value(val) {
                  this.$nextTick(this.resizeTextarea);
                  if (this.validateEvent) {
                    this.dispatch('ElFormItem', 'el.form.change', [val]);
                  }
                },

                // native input value is set explicitly
                // do not use v-model / :value in template
                // see: https://github.com/ElemeFE/element/issues/14521
                nativeInputValue: function nativeInputValue() {
                  this.setNativeInputValue();
                },

                // when change between <input> and <textarea>,
                // update DOM dependent value and styles
                // https://github.com/ElemeFE/element/issues/14857
                type: function type() {
                  const _this = this;

                  this.$nextTick(() => {
                    _this.setNativeInputValue();
                    _this.resizeTextarea();
                    _this.updateIconOffset();
                  });
                },
              },

              methods: {
                focus: function focus() {
                  this.getInput().focus();
                },
                blur: function blur() {
                  this.getInput().blur();
                },
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      icon: 'icon is removed, use suffix-icon / prefix-icon instead.',
                      'on-icon-click': 'on-icon-click is removed.',
                    },
                    events: {
                      click: 'click is removed.',
                    },
                  };
                },
                handleBlur: function handleBlur(event) {
                  this.focused = false;
                  this.$emit('blur', event);
                  if (this.validateEvent) {
                    this.dispatch('ElFormItem', 'el.form.blur', [this.value]);
                  }
                },
                select: function select() {
                  this.getInput().select();
                },
                resizeTextarea: function resizeTextarea() {
                  if (this.$isServer) return;
                  const { autosize } = this;
                  const { type } = this;

                  if (type !== 'textarea') return;
                  if (!autosize) {
                    this.textareaCalcStyle = {
                      minHeight: calcTextareaHeight(this.$refs.textarea).minHeight,
                    };
                    return;
                  }
                  const { minRows } = autosize;
                  const { maxRows } = autosize;

                  this.textareaCalcStyle = calcTextareaHeight(this.$refs.textarea, minRows, maxRows);
                },
                setNativeInputValue: function setNativeInputValue() {
                  const input = this.getInput();
                  if (!input) return;
                  if (input.value === this.nativeInputValue) return;
                  input.value = this.nativeInputValue;
                },
                handleFocus: function handleFocus(event) {
                  this.focused = true;
                  this.$emit('focus', event);
                },
                handleCompositionStart: function handleCompositionStart() {
                  this.isComposing = true;
                },
                handleCompositionUpdate: function handleCompositionUpdate(event) {
                  const text = event.target.value;
                  const lastCharacter = text[text.length - 1] || '';
                  this.isComposing = !Object(shared_.isKorean)(lastCharacter);
                },
                handleCompositionEnd: function handleCompositionEnd(event) {
                  if (this.isComposing) {
                    this.isComposing = false;
                    this.handleInput(event);
                  }
                },
                handleInput: function handleInput(event) {
                  // should not emit input during composition
                  // see: https://github.com/ElemeFE/element/issues/10516
                  if (this.isComposing) return;

                  // hack for https://github.com/ElemeFE/element/issues/8548
                  // should remove the following line when we don't support IE
                  if (event.target.value === this.nativeInputValue) return;

                  this.$emit('input', event.target.value);

                  // ensure native input value is controlled
                  // see: https://github.com/ElemeFE/element/issues/12850
                  this.$nextTick(this.setNativeInputValue);
                },
                handleChange: function handleChange(event) {
                  this.$emit('change', event.target.value);
                },
                calcIconOffset: function calcIconOffset(place) {
                  const elList = [].slice.call(this.$el.querySelectorAll(`.el-input__${place}`) || []);
                  if (!elList.length) return;
                  let el = null;
                  for (let i = 0; i < elList.length; i++) {
                    if (elList[i].parentNode === this.$el) {
                      el = elList[i];
                      break;
                    }
                  }
                  if (!el) return;
                  const pendantMap = {
                    suffix: 'append',
                    prefix: 'prepend',
                  };

                  const pendant = pendantMap[place];
                  if (this.$slots[pendant]) {
                    el.style.transform = `translateX(${place === 'suffix' ? '-' : ''}${this.$el.querySelector(`.el-input-group__${pendant}`).offsetWidth}px)`;
                  } else {
                    el.removeAttribute('style');
                  }
                },
                updateIconOffset: function updateIconOffset() {
                  this.calcIconOffset('prefix');
                  this.calcIconOffset('suffix');
                },
                clear: function clear() {
                  this.$emit('input', '');
                  this.$emit('change', '');
                  this.$emit('clear');
                },
                handlePasswordVisible: function handlePasswordVisible() {
                  this.passwordVisible = !this.passwordVisible;
                  this.focus();
                },
                getInput: function getInput() {
                  return this.$refs.input || this.$refs.textarea;
                },
                getSuffixVisible: function getSuffixVisible() {
                  return this.$slots.suffix || this.suffixIcon || this.showClear || this.showPassword || this.isWordLimitVisible || this.validateState && this.needStatusIcon;
                },
              },

              created: function created() {
                this.$on('inputSelect', this.select);
              },
              mounted: function mounted() {
                this.setNativeInputValue();
                this.resizeTextarea();
                this.updateIconOffset();
              },
              updated: function updated() {
                this.$nextTick(this.updateIconOffset);
              },
            });
            // CONCATENATED MODULE: ./packages/input/src/input.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_inputvue_type_script_lang_js_ = (inputvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/input/src/input.vue

            /* normalize component */

            const input_component = normalizeComponent(
              src_inputvue_type_script_lang_js_,
              inputvue_type_template_id_343dd774_render,
              inputvue_type_template_id_343dd774_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let input_api; }
            input_component.options.__file = 'packages/input/src/input.vue';
            /* harmony default export */ const src_input = (input_component.exports);
            // CONCATENATED MODULE: ./packages/input/index.js

            /* istanbul ignore next */
            src_input.install = function (Vue) {
              Vue.component(src_input.name, src_input);
            };

            /* harmony default export */ const packages_input = (src_input);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/input-number/src/input-number.vue?vue&type=template&id=42f8cf66&
            const input_numbervue_type_template_id_42f8cf66_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  class: [
                    'el-input-number',
                    _vm.inputNumberSize ? `el-input-number--${_vm.inputNumberSize}` : '',
                    { 'is-disabled': _vm.inputNumberDisabled },
                    { 'is-without-controls': !_vm.controls },
                    { 'is-controls-right': _vm.controlsAtRight },
                  ],
                  on: {
                    dragstart($event) {
                      $event.preventDefault();
                    },
                  },
                },
                [
                  _vm.controls
                    ? _c(
                      'span',
                      {
                        directives: [
                          {
                            name: 'repeat-click',
                            rawName: 'v-repeat-click',
                            value: _vm.decrease,
                            expression: 'decrease',
                          },
                        ],
                        staticClass: 'el-input-number__decrease',
                        class: { 'is-disabled': _vm.minDisabled },
                        attrs: { role: 'button' },
                        on: {
                          keydown($event) {
                            if (
                              !('button' in $event)
                    && _vm._k($event.keyCode, 'enter', 13, $event.key, 'Enter')
                            ) {
                              return null;
                            }
                            return _vm.decrease($event);
                          },
                        },
                      },
                      [
                        _c('i', {
                          class:
                  `el-icon-${_vm.controlsAtRight ? 'arrow-down' : 'minus'}`,
                        }),
                      ],
                    )
                    : _vm._e(),
                  _vm.controls
                    ? _c(
                      'span',
                      {
                        directives: [
                          {
                            name: 'repeat-click',
                            rawName: 'v-repeat-click',
                            value: _vm.increase,
                            expression: 'increase',
                          },
                        ],
                        staticClass: 'el-input-number__increase',
                        class: { 'is-disabled': _vm.maxDisabled },
                        attrs: { role: 'button' },
                        on: {
                          keydown($event) {
                            if (
                              !('button' in $event)
                    && _vm._k($event.keyCode, 'enter', 13, $event.key, 'Enter')
                            ) {
                              return null;
                            }
                            return _vm.increase($event);
                          },
                        },
                      },
                      [
                        _c('i', {
                          class: `el-icon-${_vm.controlsAtRight ? 'arrow-up' : 'plus'}`,
                        }),
                      ],
                    )
                    : _vm._e(),
                  _c('el-input', {
                    ref: 'input',
                    attrs: {
                      value: _vm.displayValue,
                      placeholder: _vm.placeholder,
                      disabled: _vm.inputNumberDisabled,
                      size: _vm.inputNumberSize,
                      max: _vm.max,
                      min: _vm.min,
                      name: _vm.name,
                      label: _vm.label,
                    },
                    on: {
                      blur: _vm.handleBlur,
                      focus: _vm.handleFocus,
                      input: _vm.handleInput,
                      change: _vm.handleInputChange,
                    },
                    nativeOn: {
                      keydown: [
                        function ($event) {
                          if (
                            !('button' in $event)
                && _vm._k($event.keyCode, 'up', 38, $event.key, ['Up', 'ArrowUp'])
                          ) {
                            return null;
                          }
                          $event.preventDefault();
                          return _vm.increase($event);
                        },
                        function ($event) {
                          if (
                            !('button' in $event)
                && _vm._k($event.keyCode, 'down', 40, $event.key, [
                  'Down',
                  'ArrowDown',
                ])
                          ) {
                            return null;
                          }
                          $event.preventDefault();
                          return _vm.decrease($event);
                        },
                      ],
                    },
                  }),
                ],
                1,
              );
            };
            const input_numbervue_type_template_id_42f8cf66_staticRenderFns = [];
            input_numbervue_type_template_id_42f8cf66_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/input-number/src/input-number.vue?vue&type=template&id=42f8cf66&

            // CONCATENATED MODULE: ./src/directives/repeat-click.js

            /* harmony default export */ const repeat_click = ({
              bind: function bind(el, binding, vnode) {
                let interval = null;
                let startTime = void 0;
                const handler = function handler() {
                  return vnode.context[binding.expression].apply();
                };
                const clear = function clear() {
                  if (Date.now() - startTime < 100) {
                    handler();
                  }
                  clearInterval(interval);
                  interval = null;
                };

                Object(dom_.on)(el, 'mousedown', (e) => {
                  if (e.button !== 0) return;
                  startTime = Date.now();
                  Object(dom_.once)(document, 'mouseup', clear);
                  clearInterval(interval);
                  interval = setInterval(handler, 100);
                });
              },
            });
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/input-number/src/input-number.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const input_numbervue_type_script_lang_js_ = ({
              name: 'ElInputNumber',
              mixins: [focus_default()('input')],
              inject: {
                elForm: {
                  default: '',
                },
                elFormItem: {
                  default: '',
                },
              },
              directives: {
                repeatClick: repeat_click,
              },
              components: {
                ElInput: input_default.a,
              },
              props: {
                step: {
                  type: Number,
                  default: 1,
                },
                stepStrictly: {
                  type: Boolean,
                  default: false,
                },
                max: {
                  type: Number,
                  default: Infinity,
                },
                min: {
                  type: Number,
                  default: -Infinity,
                },
                value: {},
                disabled: Boolean,
                size: String,
                controls: {
                  type: Boolean,
                  default: true,
                },
                controlsPosition: {
                  type: String,
                  default: '',
                },
                name: String,
                label: String,
                placeholder: String,
                precision: {
                  type: Number,
                  validator: function validator(val) {
                    return val >= 0 && val === parseInt(val, 10);
                  },
                },
              },
              data: function data() {
                return {
                  currentValue: 0,
                  userInput: null,
                };
              },

              watch: {
                value: {
                  immediate: true,
                  handler: function handler(value) {
                    let newVal = value === undefined ? value : Number(value);
                    if (newVal !== undefined) {
                      if (isNaN(newVal)) {
                        return;
                      }

                      if (this.stepStrictly) {
                        const stepPrecision = this.getPrecision(this.step);
                        const precisionFactor = Math.pow(10, stepPrecision);
                        newVal = Math.round(newVal / this.step) * precisionFactor * this.step / precisionFactor;
                      }

                      if (this.precision !== undefined) {
                        newVal = this.toPrecision(newVal, this.precision);
                      }
                    }
                    if (newVal >= this.max) newVal = this.max;
                    if (newVal <= this.min) newVal = this.min;
                    this.currentValue = newVal;
                    this.userInput = null;
                    this.$emit('input', newVal);
                  },
                },
              },
              computed: {
                minDisabled: function minDisabled() {
                  return this._decrease(this.value, this.step) < this.min;
                },
                maxDisabled: function maxDisabled() {
                  return this._increase(this.value, this.step) > this.max;
                },
                numPrecision: function numPrecision() {
                  const { value } = this;
                  let { step } = this;
                  let { getPrecision } = this;
                  let { precision } = this;

                  const stepPrecision = getPrecision(step);
                  if (precision !== undefined) {
                    if (stepPrecision > precision) {
                      console.warn('[Element Warn][InputNumber]precision should not be less than the decimal places of step');
                    }
                    return precision;
                  }
                  return Math.max(getPrecision(value), stepPrecision);
                },
                controlsAtRight: function controlsAtRight() {
                  return this.controls && this.controlsPosition === 'right';
                },
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                inputNumberSize: function inputNumberSize() {
                  return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
                inputNumberDisabled: function inputNumberDisabled() {
                  return this.disabled || !!(this.elForm || {}).disabled;
                },
                displayValue: function displayValue() {
                  if (this.userInput !== null) {
                    return this.userInput;
                  }

                  let { currentValue } = this;

                  if (typeof currentValue === 'number') {
                    if (this.stepStrictly) {
                      const stepPrecision = this.getPrecision(this.step);
                      const precisionFactor = Math.pow(10, stepPrecision);
                      currentValue = Math.round(currentValue / this.step) * precisionFactor * this.step / precisionFactor;
                    }

                    if (this.precision !== undefined) {
                      currentValue = currentValue.toFixed(this.precision);
                    }
                  }

                  return currentValue;
                },
              },
              methods: {
                toPrecision: function toPrecision(num, precision) {
                  if (precision === undefined) precision = this.numPrecision;
                  return parseFloat(Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision));
                },
                getPrecision: function getPrecision(value) {
                  if (value === undefined) return 0;
                  const valueString = value.toString();
                  const dotPosition = valueString.indexOf('.');
                  let precision = 0;
                  if (dotPosition !== -1) {
                    precision = valueString.length - dotPosition - 1;
                  }
                  return precision;
                },
                _increase: function _increase(val, step) {
                  if (typeof val !== 'number' && val !== undefined) return this.currentValue;

                  const precisionFactor = Math.pow(10, this.numPrecision);
                  // Solve the accuracy problem of JS decimal calculation by converting the value to integer.
                  return this.toPrecision((precisionFactor * val + precisionFactor * step) / precisionFactor);
                },
                _decrease: function _decrease(val, step) {
                  if (typeof val !== 'number' && val !== undefined) return this.currentValue;

                  const precisionFactor = Math.pow(10, this.numPrecision);

                  return this.toPrecision((precisionFactor * val - precisionFactor * step) / precisionFactor);
                },
                increase: function increase() {
                  if (this.inputNumberDisabled || this.maxDisabled) return;
                  const value = this.value || 0;
                  const newVal = this._increase(value, this.step);
                  this.setCurrentValue(newVal);
                },
                decrease: function decrease() {
                  if (this.inputNumberDisabled || this.minDisabled) return;
                  const value = this.value || 0;
                  const newVal = this._decrease(value, this.step);
                  this.setCurrentValue(newVal);
                },
                handleBlur: function handleBlur(event) {
                  this.$emit('blur', event);
                },
                handleFocus: function handleFocus(event) {
                  this.$emit('focus', event);
                },
                setCurrentValue: function setCurrentValue(newVal) {
                  const oldVal = this.currentValue;
                  if (typeof newVal === 'number' && this.precision !== undefined) {
                    newVal = this.toPrecision(newVal, this.precision);
                  }
                  if (newVal >= this.max) newVal = this.max;
                  if (newVal <= this.min) newVal = this.min;
                  if (oldVal === newVal) return;
                  this.userInput = null;
                  this.$emit('input', newVal);
                  this.$emit('change', newVal, oldVal);
                  this.currentValue = newVal;
                },
                handleInput: function handleInput(value) {
                  this.userInput = value;
                },
                handleInputChange: function handleInputChange(value) {
                  const newVal = value === '' ? undefined : Number(value);
                  if (!isNaN(newVal) || value === '') {
                    this.setCurrentValue(newVal);
                  }
                  this.userInput = null;
                },
                select: function select() {
                  this.$refs.input.select();
                },
              },
              mounted: function mounted() {
                const innerInput = this.$refs.input.$refs.input;
                innerInput.setAttribute('role', 'spinbutton');
                innerInput.setAttribute('aria-valuemax', this.max);
                innerInput.setAttribute('aria-valuemin', this.min);
                innerInput.setAttribute('aria-valuenow', this.currentValue);
                innerInput.setAttribute('aria-disabled', this.inputNumberDisabled);
              },
              updated: function updated() {
                if (!this.$refs || !this.$refs.input) return;
                const innerInput = this.$refs.input.$refs.input;
                innerInput.setAttribute('aria-valuenow', this.currentValue);
              },
            });
            // CONCATENATED MODULE: ./packages/input-number/src/input-number.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_input_numbervue_type_script_lang_js_ = (input_numbervue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/input-number/src/input-number.vue

            /* normalize component */

            const input_number_component = normalizeComponent(
              src_input_numbervue_type_script_lang_js_,
              input_numbervue_type_template_id_42f8cf66_render,
              input_numbervue_type_template_id_42f8cf66_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let input_number_api; }
            input_number_component.options.__file = 'packages/input-number/src/input-number.vue';
            /* harmony default export */ const input_number = (input_number_component.exports);
            // CONCATENATED MODULE: ./packages/input-number/index.js

            /* istanbul ignore next */
            input_number.install = function (Vue) {
              Vue.component(input_number.name, input_number);
            };

            /* harmony default export */ const packages_input_number = (input_number);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio.vue?vue&type=template&id=69cd6268&
            const radiovue_type_template_id_69cd6268_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'label',
                {
                  staticClass: 'el-radio',
                  class: [
                    _vm.border && _vm.radioSize ? `el-radio--${_vm.radioSize}` : '',
                    { 'is-disabled': _vm.isDisabled },
                    { 'is-focus': _vm.focus },
                    { 'is-bordered': _vm.border },
                    { 'is-checked': _vm.model === _vm.label },
                  ],
                  attrs: {
                    role: 'radio',
                    'aria-checked': _vm.model === _vm.label,
                    'aria-disabled': _vm.isDisabled,
                    tabindex: _vm.tabIndex,
                  },
                  on: {
                    keydown($event) {
                      if (
                        !('button' in $event)
            && _vm._k($event.keyCode, 'space', 32, $event.key, [' ', 'Spacebar'])
                      ) {
                        return null;
                      }
                      $event.stopPropagation();
                      $event.preventDefault();
                      _vm.model = _vm.isDisabled ? _vm.model : _vm.label;
                    },
                  },
                },
                [
                  _c(
                    'span',
                    {
                      staticClass: 'el-radio__input',
                      class: {
                        'is-disabled': _vm.isDisabled,
                        'is-checked': _vm.model === _vm.label,
                      },
                    },
                    [
                      _c('span', { staticClass: 'el-radio__inner' }),
                      _c('input', {
                        directives: [
                          {
                            name: 'model',
                            rawName: 'v-model',
                            value: _vm.model,
                            expression: 'model',
                          },
                        ],
                        ref: 'radio',
                        staticClass: 'el-radio__original',
                        attrs: {
                          type: 'radio',
                          'aria-hidden': 'true',
                          name: _vm.name,
                          disabled: _vm.isDisabled,
                          tabindex: '-1',
                        },
                        domProps: {
                          value: _vm.label,
                          checked: _vm._q(_vm.model, _vm.label),
                        },
                        on: {
                          focus($event) {
                            _vm.focus = true;
                          },
                          blur($event) {
                            _vm.focus = false;
                          },
                          change: [
                            function ($event) {
                              _vm.model = _vm.label;
                            },
                            _vm.handleChange,
                          ],
                        },
                      }),
                    ],
                  ),
                  _c(
                    'span',
                    {
                      staticClass: 'el-radio__label',
                      on: {
                        keydown($event) {
                          $event.stopPropagation();
                        },
                      },
                    },
                    [
                      _vm._t('default'),
                      !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e(),
                    ],
                    2,
                  ),
                ],
              );
            };
            const radiovue_type_template_id_69cd6268_staticRenderFns = [];
            radiovue_type_template_id_69cd6268_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/radio/src/radio.vue?vue&type=template&id=69cd6268&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const radiovue_type_script_lang_js_ = ({
              name: 'ElRadio',

              mixins: [emitter_default.a],

              inject: {
                elForm: {
                  default: '',
                },

                elFormItem: {
                  default: '',
                },
              },

              componentName: 'ElRadio',

              props: {
                value: {},
                label: {},
                disabled: Boolean,
                name: String,
                border: Boolean,
                size: String,
              },

              data: function data() {
                return {
                  focus: false,
                };
              },

              computed: {
                isGroup: function isGroup() {
                  let parent = this.$parent;
                  while (parent) {
                    if (parent.$options.componentName !== 'ElRadioGroup') {
                      parent = parent.$parent;
                    } else {
                      this._radioGroup = parent;
                      return true;
                    }
                  }
                  return false;
                },

                model: {
                  get: function get() {
                    return this.isGroup ? this._radioGroup.value : this.value;
                  },
                  set: function set(val) {
                    if (this.isGroup) {
                      this.dispatch('ElRadioGroup', 'input', [val]);
                    } else {
                      this.$emit('input', val);
                    }
                    this.$refs.radio && (this.$refs.radio.checked = this.model === this.label);
                  },
                },
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                radioSize: function radioSize() {
                  const temRadioSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                  return this.isGroup ? this._radioGroup.radioGroupSize || temRadioSize : temRadioSize;
                },
                isDisabled: function isDisabled() {
                  return this.isGroup ? this._radioGroup.disabled || this.disabled || (this.elForm || {}).disabled : this.disabled || (this.elForm || {}).disabled;
                },
                tabIndex: function tabIndex() {
                  return this.isDisabled || this.isGroup && this.model !== this.label ? -1 : 0;
                },
              },

              methods: {
                handleChange: function handleChange() {
                  const _this = this;

                  this.$nextTick(() => {
                    _this.$emit('change', _this.model);
                    _this.isGroup && _this.dispatch('ElRadioGroup', 'handleChange', _this.model);
                  });
                },
              },
            });
            // CONCATENATED MODULE: ./packages/radio/src/radio.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_radiovue_type_script_lang_js_ = (radiovue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/radio/src/radio.vue

            /* normalize component */

            const radio_component = normalizeComponent(
              src_radiovue_type_script_lang_js_,
              radiovue_type_template_id_69cd6268_render,
              radiovue_type_template_id_69cd6268_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let radio_api; }
            radio_component.options.__file = 'packages/radio/src/radio.vue';
            /* harmony default export */ const src_radio = (radio_component.exports);
            // CONCATENATED MODULE: ./packages/radio/index.js

            /* istanbul ignore next */
            src_radio.install = function (Vue) {
              Vue.component(src_radio.name, src_radio);
            };

            /* harmony default export */ const packages_radio = (src_radio);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio-group.vue?vue&type=template&id=818a704c&
            const radio_groupvue_type_template_id_818a704c_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                _vm._elTag,
                {
                  tag: 'component',
                  staticClass: 'el-radio-group',
                  attrs: { role: 'radiogroup' },
                  on: { keydown: _vm.handleKeydown },
                },
                [_vm._t('default')],
                2,
              );
            };
            const radio_groupvue_type_template_id_818a704c_staticRenderFns = [];
            radio_groupvue_type_template_id_818a704c_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/radio/src/radio-group.vue?vue&type=template&id=818a704c&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio-group.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const keyCode = Object.freeze({
              LEFT: 37,
              UP: 38,
              RIGHT: 39,
              DOWN: 40,
            });
            /* harmony default export */ const radio_groupvue_type_script_lang_js_ = ({
              name: 'ElRadioGroup',

              componentName: 'ElRadioGroup',

              inject: {
                elFormItem: {
                  default: '',
                },
              },

              mixins: [emitter_default.a],

              props: {
                value: {},
                size: String,
                fill: String,
                textColor: String,
                disabled: Boolean,
              },

              computed: {
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                _elTag: function _elTag() {
                  return (this.$vnode.data || {}).tag || 'div';
                },
                radioGroupSize: function radioGroupSize() {
                  return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
              },

              created: function created() {
                const _this = this;

                this.$on('handleChange', (value) => {
                  _this.$emit('change', value);
                });
              },
              mounted: function mounted() {
                // 当radioGroup没有默认选项时，第一个可以选中Tab导航
                const radios = this.$el.querySelectorAll('[type=radio]');
                const firstLabel = this.$el.querySelectorAll('[role=radio]')[0];
                if (![].some.call(radios, (radio) => radio.checked) && firstLabel) {
                  firstLabel.tabIndex = 0;
                }
              },

              methods: {
                handleKeydown: function handleKeydown(e) {
                  // 左右上下按键 可以在radio组内切换不同选项
                  const { target } = e;
                  const className = target.nodeName === 'INPUT' ? '[type=radio]' : '[role=radio]';
                  const radios = this.$el.querySelectorAll(className);
                  const { length } = radios;
                  const index = [].indexOf.call(radios, target);
                  const roleRadios = this.$el.querySelectorAll('[role=radio]');
                  switch (e.keyCode) {
                    case keyCode.LEFT:
                    case keyCode.UP:
                      e.stopPropagation();
                      e.preventDefault();
                      if (index === 0) {
                        roleRadios[length - 1].click();
                        roleRadios[length - 1].focus();
                      } else {
                        roleRadios[index - 1].click();
                        roleRadios[index - 1].focus();
                      }
                      break;
                    case keyCode.RIGHT:
                    case keyCode.DOWN:
                      if (index === length - 1) {
                        e.stopPropagation();
                        e.preventDefault();
                        roleRadios[0].click();
                        roleRadios[0].focus();
                      } else {
                        roleRadios[index + 1].click();
                        roleRadios[index + 1].focus();
                      }
                      break;
                    default:
                      break;
                  }
                },
              },
              watch: {
                value: function value(_value) {
                  this.dispatch('ElFormItem', 'el.form.change', [this.value]);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/radio/src/radio-group.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_radio_groupvue_type_script_lang_js_ = (radio_groupvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/radio/src/radio-group.vue

            /* normalize component */

            const radio_group_component = normalizeComponent(
              src_radio_groupvue_type_script_lang_js_,
              radio_groupvue_type_template_id_818a704c_render,
              radio_groupvue_type_template_id_818a704c_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let radio_group_api; }
            radio_group_component.options.__file = 'packages/radio/src/radio-group.vue';
            /* harmony default export */ const radio_group = (radio_group_component.exports);
            // CONCATENATED MODULE: ./packages/radio-group/index.js

            /* istanbul ignore next */
            radio_group.install = function (Vue) {
              Vue.component(radio_group.name, radio_group);
            };

            /* harmony default export */ const packages_radio_group = (radio_group);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio-button.vue?vue&type=template&id=18a77a32&
            const radio_buttonvue_type_template_id_18a77a32_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'label',
                {
                  staticClass: 'el-radio-button',
                  class: [
                    _vm.size ? `el-radio-button--${_vm.size}` : '',
                    { 'is-active': _vm.value === _vm.label },
                    { 'is-disabled': _vm.isDisabled },
                    { 'is-focus': _vm.focus },
                  ],
                  attrs: {
                    role: 'radio',
                    'aria-checked': _vm.value === _vm.label,
                    'aria-disabled': _vm.isDisabled,
                    tabindex: _vm.tabIndex,
                  },
                  on: {
                    keydown($event) {
                      if (
                        !('button' in $event)
            && _vm._k($event.keyCode, 'space', 32, $event.key, [' ', 'Spacebar'])
                      ) {
                        return null;
                      }
                      $event.stopPropagation();
                      $event.preventDefault();
                      _vm.value = _vm.isDisabled ? _vm.value : _vm.label;
                    },
                  },
                },
                [
                  _c('input', {
                    directives: [
                      {
                        name: 'model',
                        rawName: 'v-model',
                        value: _vm.value,
                        expression: 'value',
                      },
                    ],
                    staticClass: 'el-radio-button__orig-radio',
                    attrs: {
                      type: 'radio',
                      name: _vm.name,
                      disabled: _vm.isDisabled,
                      tabindex: '-1',
                    },
                    domProps: { value: _vm.label, checked: _vm._q(_vm.value, _vm.label) },
                    on: {
                      change: [
                        function ($event) {
                          _vm.value = _vm.label;
                        },
                        _vm.handleChange,
                      ],
                      focus($event) {
                        _vm.focus = true;
                      },
                      blur($event) {
                        _vm.focus = false;
                      },
                    },
                  }),
                  _c(
                    'span',
                    {
                      staticClass: 'el-radio-button__inner',
                      style: _vm.value === _vm.label ? _vm.activeStyle : null,
                      on: {
                        keydown($event) {
                          $event.stopPropagation();
                        },
                      },
                    },
                    [
                      _vm._t('default'),
                      !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e(),
                    ],
                    2,
                  ),
                ],
              );
            };
            const radio_buttonvue_type_template_id_18a77a32_staticRenderFns = [];
            radio_buttonvue_type_template_id_18a77a32_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/radio/src/radio-button.vue?vue&type=template&id=18a77a32&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio-button.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const radio_buttonvue_type_script_lang_js_ = ({
              name: 'ElRadioButton',

              mixins: [emitter_default.a],

              inject: {
                elForm: {
                  default: '',
                },
                elFormItem: {
                  default: '',
                },
              },

              props: {
                label: {},
                disabled: Boolean,
                name: String,
              },
              data: function data() {
                return {
                  focus: false,
                };
              },

              computed: {
                value: {
                  get: function get() {
                    return this._radioGroup.value;
                  },
                  set: function set(value) {
                    this._radioGroup.$emit('input', value);
                  },
                },
                _radioGroup: function _radioGroup() {
                  let parent = this.$parent;
                  while (parent) {
                    if (parent.$options.componentName !== 'ElRadioGroup') {
                      parent = parent.$parent;
                    } else {
                      return parent;
                    }
                  }
                  return false;
                },
                activeStyle: function activeStyle() {
                  return {
                    backgroundColor: this._radioGroup.fill || '',
                    borderColor: this._radioGroup.fill || '',
                    boxShadow: this._radioGroup.fill ? `-1px 0 0 0 ${this._radioGroup.fill}` : '',
                    color: this._radioGroup.textColor || '',
                  };
                },
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                size: function size() {
                  return this._radioGroup.radioGroupSize || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
                isDisabled: function isDisabled() {
                  return this.disabled || this._radioGroup.disabled || (this.elForm || {}).disabled;
                },
                tabIndex: function tabIndex() {
                  return this.isDisabled || this._radioGroup && this.value !== this.label ? -1 : 0;
                },
              },

              methods: {
                handleChange: function handleChange() {
                  const _this = this;

                  this.$nextTick(() => {
                    _this.dispatch('ElRadioGroup', 'handleChange', _this.value);
                  });
                },
              },
            });
            // CONCATENATED MODULE: ./packages/radio/src/radio-button.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_radio_buttonvue_type_script_lang_js_ = (radio_buttonvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/radio/src/radio-button.vue

            /* normalize component */

            const radio_button_component = normalizeComponent(
              src_radio_buttonvue_type_script_lang_js_,
              radio_buttonvue_type_template_id_18a77a32_render,
              radio_buttonvue_type_template_id_18a77a32_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let radio_button_api; }
            radio_button_component.options.__file = 'packages/radio/src/radio-button.vue';
            /* harmony default export */ const radio_button = (radio_button_component.exports);
            // CONCATENATED MODULE: ./packages/radio-button/index.js

            /* istanbul ignore next */
            radio_button.install = function (Vue) {
              Vue.component(radio_button.name, radio_button);
            };

            /* harmony default export */ const packages_radio_button = (radio_button);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox.vue?vue&type=template&id=d0387074&
            const checkboxvue_type_template_id_d0387074_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'label',
                {
                  staticClass: 'el-checkbox',
                  class: [
                    _vm.border && _vm.checkboxSize
                      ? `el-checkbox--${_vm.checkboxSize}`
                      : '',
                    { 'is-disabled': _vm.isDisabled },
                    { 'is-bordered': _vm.border },
                    { 'is-checked': _vm.isChecked },
                  ],
                  attrs: { id: _vm.id },
                },
                [
                  _c(
                    'span',
                    {
                      staticClass: 'el-checkbox__input',
                      class: {
                        'is-disabled': _vm.isDisabled,
                        'is-checked': _vm.isChecked,
                        'is-indeterminate': _vm.indeterminate,
                        'is-focus': _vm.focus,
                      },
                      attrs: {
                        tabindex: _vm.indeterminate ? 0 : false,
                        role: _vm.indeterminate ? 'checkbox' : false,
                        'aria-checked': _vm.indeterminate ? 'mixed' : false,
                      },
                    },
                    [
                      _c('span', { staticClass: 'el-checkbox__inner' }),
                      _vm.trueLabel || _vm.falseLabel
                        ? _c('input', {
                          directives: [
                            {
                              name: 'model',
                              rawName: 'v-model',
                              value: _vm.model,
                              expression: 'model',
                            },
                          ],
                          staticClass: 'el-checkbox__original',
                          attrs: {
                            type: 'checkbox',
                            'aria-hidden': _vm.indeterminate ? 'true' : 'false',
                            name: _vm.name,
                            disabled: _vm.isDisabled,
                            'true-value': _vm.trueLabel,
                            'false-value': _vm.falseLabel,
                          },
                          domProps: {
                            checked: Array.isArray(_vm.model)
                              ? _vm._i(_vm.model, null) > -1
                              : _vm._q(_vm.model, _vm.trueLabel),
                          },
                          on: {
                            change: [
                              function ($event) {
                                const $$a = _vm.model;
                                const $$el = $event.target;
                                const $$c = $$el.checked ? _vm.trueLabel : _vm.falseLabel;
                                if (Array.isArray($$a)) {
                                  const $$v = null;
                                  const $$i = _vm._i($$a, $$v);
                                  if ($$el.checked) {
                                    $$i < 0 && (_vm.model = $$a.concat([$$v]));
                                  } else {
                                    $$i > -1
                            && (_vm.model = $$a
                              .slice(0, $$i)
                              .concat($$a.slice($$i + 1)));
                                  }
                                } else {
                                  _vm.model = $$c;
                                }
                              },
                              _vm.handleChange,
                            ],
                            focus($event) {
                              _vm.focus = true;
                            },
                            blur($event) {
                              _vm.focus = false;
                            },
                          },
                        })
                        : _c('input', {
                          directives: [
                            {
                              name: 'model',
                              rawName: 'v-model',
                              value: _vm.model,
                              expression: 'model',
                            },
                          ],
                          staticClass: 'el-checkbox__original',
                          attrs: {
                            type: 'checkbox',
                            'aria-hidden': _vm.indeterminate ? 'true' : 'false',
                            disabled: _vm.isDisabled,
                            name: _vm.name,
                          },
                          domProps: {
                            value: _vm.label,
                            checked: Array.isArray(_vm.model)
                              ? _vm._i(_vm.model, _vm.label) > -1
                              : _vm.model,
                          },
                          on: {
                            change: [
                              function ($event) {
                                const $$a = _vm.model;
                                const $$el = $event.target;
                                const $$c = !!$$el.checked;
                                if (Array.isArray($$a)) {
                                  const $$v = _vm.label;
                                  const $$i = _vm._i($$a, $$v);
                                  if ($$el.checked) {
                                    $$i < 0 && (_vm.model = $$a.concat([$$v]));
                                  } else {
                                    $$i > -1
                            && (_vm.model = $$a
                              .slice(0, $$i)
                              .concat($$a.slice($$i + 1)));
                                  }
                                } else {
                                  _vm.model = $$c;
                                }
                              },
                              _vm.handleChange,
                            ],
                            focus($event) {
                              _vm.focus = true;
                            },
                            blur($event) {
                              _vm.focus = false;
                            },
                          },
                        }),
                    ],
                  ),
                  _vm.$slots.default || _vm.label
                    ? _c(
                      'span',
                      { staticClass: 'el-checkbox__label' },
                      [
                        _vm._t('default'),
                        !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e(),
                      ],
                      2,
                    )
                    : _vm._e(),
                ],
              );
            };
            const checkboxvue_type_template_id_d0387074_staticRenderFns = [];
            checkboxvue_type_template_id_d0387074_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue?vue&type=template&id=d0387074&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const checkboxvue_type_script_lang_js_ = ({
              name: 'ElCheckbox',

              mixins: [emitter_default.a],

              inject: {
                elForm: {
                  default: '',
                },
                elFormItem: {
                  default: '',
                },
              },

              componentName: 'ElCheckbox',

              data: function data() {
                return {
                  selfModel: false,
                  focus: false,
                  isLimitExceeded: false,
                };
              },

              computed: {
                model: {
                  get: function get() {
                    return this.isGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
                  },
                  set: function set(val) {
                    if (this.isGroup) {
                      this.isLimitExceeded = false;
                      this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (this.isLimitExceeded = true);

                      this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (this.isLimitExceeded = true);

                      this.isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
                    } else {
                      this.$emit('input', val);
                      this.selfModel = val;
                    }
                  },
                },

                isChecked: function isChecked() {
                  if ({}.toString.call(this.model) === '[object Boolean]') {
                    return this.model;
                  } if (Array.isArray(this.model)) {
                    return this.model.indexOf(this.label) > -1;
                  } if (this.model !== null && this.model !== undefined) {
                    return this.model === this.trueLabel;
                  }
                },
                isGroup: function isGroup() {
                  let parent = this.$parent;
                  while (parent) {
                    if (parent.$options.componentName !== 'ElCheckboxGroup') {
                      parent = parent.$parent;
                    } else {
                      this._checkboxGroup = parent;
                      return true;
                    }
                  }
                  return false;
                },
                store: function store() {
                  return this._checkboxGroup ? this._checkboxGroup.value : this.value;
                },

                /* used to make the isDisabled judgment under max/min props */
                isLimitDisabled: function isLimitDisabled() {
                  const { _checkboxGroup } = this;
                  const { max } = _checkboxGroup;
                  const { min } = _checkboxGroup;

                  return !!(max || min) && this.model.length >= max && !this.isChecked || this.model.length <= min && this.isChecked;
                },
                isDisabled: function isDisabled() {
                  return this.isGroup ? this._checkboxGroup.disabled || this.disabled || (this.elForm || {}).disabled || this.isLimitDisabled : this.disabled || (this.elForm || {}).disabled;
                },
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                checkboxSize: function checkboxSize() {
                  const temCheckboxSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                  return this.isGroup ? this._checkboxGroup.checkboxGroupSize || temCheckboxSize : temCheckboxSize;
                },
              },

              props: {
                value: {},
                label: {},
                indeterminate: Boolean,
                disabled: Boolean,
                checked: Boolean,
                name: String,
                trueLabel: [String, Number],
                falseLabel: [String, Number],
                id: String, /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系 */
                controls: String, /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系 */
                border: Boolean,
                size: String,
              },

              methods: {
                addToStore: function addToStore() {
                  if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
                    this.model.push(this.label);
                  } else {
                    this.model = this.trueLabel || true;
                  }
                },
                handleChange: function handleChange(ev) {
                  const _this = this;

                  if (this.isLimitExceeded) return;
                  let value = void 0;
                  if (ev.target.checked) {
                    value = this.trueLabel === undefined ? true : this.trueLabel;
                  } else {
                    value = this.falseLabel === undefined ? false : this.falseLabel;
                  }
                  this.$emit('change', value, ev);
                  this.$nextTick(() => {
                    if (_this.isGroup) {
                      _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
                    }
                  });
                },
              },

              created: function created() {
                this.checked && this.addToStore();
              },
              mounted: function mounted() {
                // 为indeterminate元素 添加aria-controls 属性
                if (this.indeterminate) {
                  this.$el.setAttribute('aria-controls', this.controls);
                }
              },

              watch: {
                value: function value(_value) {
                  this.dispatch('ElFormItem', 'el.form.change', _value);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_checkboxvue_type_script_lang_js_ = (checkboxvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue

            /* normalize component */

            const checkbox_component = normalizeComponent(
              src_checkboxvue_type_script_lang_js_,
              checkboxvue_type_template_id_d0387074_render,
              checkboxvue_type_template_id_d0387074_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let checkbox_api; }
            checkbox_component.options.__file = 'packages/checkbox/src/checkbox.vue';
            /* harmony default export */ const src_checkbox = (checkbox_component.exports);
            // CONCATENATED MODULE: ./packages/checkbox/index.js

            /* istanbul ignore next */
            src_checkbox.install = function (Vue) {
              Vue.component(src_checkbox.name, src_checkbox);
            };

            /* harmony default export */ const packages_checkbox = (src_checkbox);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-button.vue?vue&type=template&id=478e906e&
            const checkbox_buttonvue_type_template_id_478e906e_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'label',
                {
                  staticClass: 'el-checkbox-button',
                  class: [
                    _vm.size ? `el-checkbox-button--${_vm.size}` : '',
                    { 'is-disabled': _vm.isDisabled },
                    { 'is-checked': _vm.isChecked },
                    { 'is-focus': _vm.focus },
                  ],
                  attrs: {
                    role: 'checkbox',
                    'aria-checked': _vm.isChecked,
                    'aria-disabled': _vm.isDisabled,
                  },
                },
                [
                  _vm.trueLabel || _vm.falseLabel
                    ? _c('input', {
                      directives: [
                        {
                          name: 'model',
                          rawName: 'v-model',
                          value: _vm.model,
                          expression: 'model',
                        },
                      ],
                      staticClass: 'el-checkbox-button__original',
                      attrs: {
                        type: 'checkbox',
                        name: _vm.name,
                        disabled: _vm.isDisabled,
                        'true-value': _vm.trueLabel,
                        'false-value': _vm.falseLabel,
                      },
                      domProps: {
                        checked: Array.isArray(_vm.model)
                          ? _vm._i(_vm.model, null) > -1
                          : _vm._q(_vm.model, _vm.trueLabel),
                      },
                      on: {
                        change: [
                          function ($event) {
                            const $$a = _vm.model;
                            const $$el = $event.target;
                            const $$c = $$el.checked ? _vm.trueLabel : _vm.falseLabel;
                            if (Array.isArray($$a)) {
                              const $$v = null;
                              const $$i = _vm._i($$a, $$v);
                              if ($$el.checked) {
                                $$i < 0 && (_vm.model = $$a.concat([$$v]));
                              } else {
                                $$i > -1
                        && (_vm.model = $$a
                          .slice(0, $$i)
                          .concat($$a.slice($$i + 1)));
                              }
                            } else {
                              _vm.model = $$c;
                            }
                          },
                          _vm.handleChange,
                        ],
                        focus($event) {
                          _vm.focus = true;
                        },
                        blur($event) {
                          _vm.focus = false;
                        },
                      },
                    })
                    : _c('input', {
                      directives: [
                        {
                          name: 'model',
                          rawName: 'v-model',
                          value: _vm.model,
                          expression: 'model',
                        },
                      ],
                      staticClass: 'el-checkbox-button__original',
                      attrs: {
                        type: 'checkbox',
                        name: _vm.name,
                        disabled: _vm.isDisabled,
                      },
                      domProps: {
                        value: _vm.label,
                        checked: Array.isArray(_vm.model)
                          ? _vm._i(_vm.model, _vm.label) > -1
                          : _vm.model,
                      },
                      on: {
                        change: [
                          function ($event) {
                            const $$a = _vm.model;
                            const $$el = $event.target;
                            const $$c = !!$$el.checked;
                            if (Array.isArray($$a)) {
                              const $$v = _vm.label;
                              const $$i = _vm._i($$a, $$v);
                              if ($$el.checked) {
                                $$i < 0 && (_vm.model = $$a.concat([$$v]));
                              } else {
                                $$i > -1
                        && (_vm.model = $$a
                          .slice(0, $$i)
                          .concat($$a.slice($$i + 1)));
                              }
                            } else {
                              _vm.model = $$c;
                            }
                          },
                          _vm.handleChange,
                        ],
                        focus($event) {
                          _vm.focus = true;
                        },
                        blur($event) {
                          _vm.focus = false;
                        },
                      },
                    }),
                  _vm.$slots.default || _vm.label
                    ? _c(
                      'span',
                      {
                        staticClass: 'el-checkbox-button__inner',
                        style: _vm.isChecked ? _vm.activeStyle : null,
                      },
                      [_vm._t('default', [_vm._v(_vm._s(_vm.label))])],
                      2,
                    )
                    : _vm._e(),
                ],
              );
            };
            const checkbox_buttonvue_type_template_id_478e906e_staticRenderFns = [];
            checkbox_buttonvue_type_template_id_478e906e_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-button.vue?vue&type=template&id=478e906e&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-button.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const checkbox_buttonvue_type_script_lang_js_ = ({
              name: 'ElCheckboxButton',

              mixins: [emitter_default.a],

              inject: {
                elForm: {
                  default: '',
                },
                elFormItem: {
                  default: '',
                },
              },

              data: function data() {
                return {
                  selfModel: false,
                  focus: false,
                  isLimitExceeded: false,
                };
              },

              props: {
                value: {},
                label: {},
                disabled: Boolean,
                checked: Boolean,
                name: String,
                trueLabel: [String, Number],
                falseLabel: [String, Number],
              },
              computed: {
                model: {
                  get: function get() {
                    return this._checkboxGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
                  },
                  set: function set(val) {
                    if (this._checkboxGroup) {
                      this.isLimitExceeded = false;
                      this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (this.isLimitExceeded = true);

                      this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (this.isLimitExceeded = true);

                      this.isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
                    } else if (this.value !== undefined) {
                      this.$emit('input', val);
                    } else {
                      this.selfModel = val;
                    }
                  },
                },

                isChecked: function isChecked() {
                  if ({}.toString.call(this.model) === '[object Boolean]') {
                    return this.model;
                  } if (Array.isArray(this.model)) {
                    return this.model.indexOf(this.label) > -1;
                  } if (this.model !== null && this.model !== undefined) {
                    return this.model === this.trueLabel;
                  }
                },
                _checkboxGroup: function _checkboxGroup() {
                  let parent = this.$parent;
                  while (parent) {
                    if (parent.$options.componentName !== 'ElCheckboxGroup') {
                      parent = parent.$parent;
                    } else {
                      return parent;
                    }
                  }
                  return false;
                },
                store: function store() {
                  return this._checkboxGroup ? this._checkboxGroup.value : this.value;
                },
                activeStyle: function activeStyle() {
                  return {
                    backgroundColor: this._checkboxGroup.fill || '',
                    borderColor: this._checkboxGroup.fill || '',
                    color: this._checkboxGroup.textColor || '',
                    'box-shadow': `-1px 0 0 0 ${this._checkboxGroup.fill}`,

                  };
                },
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                size: function size() {
                  return this._checkboxGroup.checkboxGroupSize || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },

                /* used to make the isDisabled judgment under max/min props */
                isLimitDisabled: function isLimitDisabled() {
                  const _checkboxGroup2 = this._checkboxGroup;
                  const { max } = _checkboxGroup2;
                  const { min } = _checkboxGroup2;

                  return !!(max || min) && this.model.length >= max && !this.isChecked || this.model.length <= min && this.isChecked;
                },
                isDisabled: function isDisabled() {
                  return this._checkboxGroup ? this._checkboxGroup.disabled || this.disabled || (this.elForm || {}).disabled || this.isLimitDisabled : this.disabled || (this.elForm || {}).disabled;
                },
              },
              methods: {
                addToStore: function addToStore() {
                  if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
                    this.model.push(this.label);
                  } else {
                    this.model = this.trueLabel || true;
                  }
                },
                handleChange: function handleChange(ev) {
                  const _this = this;

                  if (this.isLimitExceeded) return;
                  let value = void 0;
                  if (ev.target.checked) {
                    value = this.trueLabel === undefined ? true : this.trueLabel;
                  } else {
                    value = this.falseLabel === undefined ? false : this.falseLabel;
                  }
                  this.$emit('change', value, ev);
                  this.$nextTick(() => {
                    if (_this._checkboxGroup) {
                      _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
                    }
                  });
                },
              },

              created: function created() {
                this.checked && this.addToStore();
              },
            });
            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-button.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_checkbox_buttonvue_type_script_lang_js_ = (checkbox_buttonvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-button.vue

            /* normalize component */

            const checkbox_button_component = normalizeComponent(
              src_checkbox_buttonvue_type_script_lang_js_,
              checkbox_buttonvue_type_template_id_478e906e_render,
              checkbox_buttonvue_type_template_id_478e906e_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let checkbox_button_api; }
            checkbox_button_component.options.__file = 'packages/checkbox/src/checkbox-button.vue';
            /* harmony default export */ const checkbox_button = (checkbox_button_component.exports);
            // CONCATENATED MODULE: ./packages/checkbox-button/index.js

            /* istanbul ignore next */
            checkbox_button.install = function (Vue) {
              Vue.component(checkbox_button.name, checkbox_button);
            };

            /* harmony default export */ const packages_checkbox_button = (checkbox_button);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-group.vue?vue&type=template&id=7289a290&
            const checkbox_groupvue_type_template_id_7289a290_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-checkbox-group',
                  attrs: { role: 'group', 'aria-label': 'checkbox-group' },
                },
                [_vm._t('default')],
                2,
              );
            };
            const checkbox_groupvue_type_template_id_7289a290_staticRenderFns = [];
            checkbox_groupvue_type_template_id_7289a290_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue?vue&type=template&id=7289a290&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-group.vue?vue&type=script&lang=js&

            /* harmony default export */ const checkbox_groupvue_type_script_lang_js_ = ({
              name: 'ElCheckboxGroup',

              componentName: 'ElCheckboxGroup',

              mixins: [emitter_default.a],

              inject: {
                elFormItem: {
                  default: '',
                },
              },

              props: {
                value: {},
                disabled: Boolean,
                min: Number,
                max: Number,
                size: String,
                fill: String,
                textColor: String,
              },

              computed: {
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                checkboxGroupSize: function checkboxGroupSize() {
                  return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
              },

              watch: {
                value: function value(_value) {
                  this.dispatch('ElFormItem', 'el.form.change', [_value]);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_checkbox_groupvue_type_script_lang_js_ = (checkbox_groupvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue

            /* normalize component */

            const checkbox_group_component = normalizeComponent(
              src_checkbox_groupvue_type_script_lang_js_,
              checkbox_groupvue_type_template_id_7289a290_render,
              checkbox_groupvue_type_template_id_7289a290_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let checkbox_group_api; }
            checkbox_group_component.options.__file = 'packages/checkbox/src/checkbox-group.vue';
            /* harmony default export */ const checkbox_group = (checkbox_group_component.exports);
            // CONCATENATED MODULE: ./packages/checkbox-group/index.js

            /* istanbul ignore next */
            checkbox_group.install = function (Vue) {
              Vue.component(checkbox_group.name, checkbox_group);
            };

            /* harmony default export */ const packages_checkbox_group = (checkbox_group);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/switch/src/component.vue?vue&type=template&id=2dcd8fbb&
            const componentvue_type_template_id_2dcd8fbb_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-switch',
                  class: { 'is-disabled': _vm.switchDisabled, 'is-checked': _vm.checked },
                  attrs: {
                    role: 'switch',
                    'aria-checked': _vm.checked,
                    'aria-disabled': _vm.switchDisabled,
                  },
                  on: {
                    click($event) {
                      $event.preventDefault();
                      return _vm.switchValue($event);
                    },
                  },
                },
                [
                  _c('input', {
                    ref: 'input',
                    staticClass: 'el-switch__input',
                    attrs: {
                      type: 'checkbox',
                      id: _vm.id,
                      name: _vm.name,
                      'true-value': _vm.activeValue,
                      'false-value': _vm.inactiveValue,
                      disabled: _vm.switchDisabled,
                    },
                    on: {
                      change: _vm.handleChange,
                      keydown($event) {
                        if (
                          !('button' in $event)
              && _vm._k($event.keyCode, 'enter', 13, $event.key, 'Enter')
                        ) {
                          return null;
                        }
                        return _vm.switchValue($event);
                      },
                    },
                  }),
                  _vm.inactiveIconClass || _vm.inactiveText
                    ? _c(
                      'span',
                      {
                        class: [
                          'el-switch__label',
                          'el-switch__label--left',
                          !_vm.checked ? 'is-active' : '',
                        ],
                      },
                      [
                        _vm.inactiveIconClass
                          ? _c('i', { class: [_vm.inactiveIconClass] })
                          : _vm._e(),
                        !_vm.inactiveIconClass && _vm.inactiveText
                          ? _c('span', { attrs: { 'aria-hidden': _vm.checked } }, [
                            _vm._v(_vm._s(_vm.inactiveText)),
                          ])
                          : _vm._e(),
                      ],
                    )
                    : _vm._e(),
                  _c('span', {
                    ref: 'core',
                    staticClass: 'el-switch__core',
                    style: { width: `${_vm.coreWidth}px` },
                  }),
                  _vm.activeIconClass || _vm.activeText
                    ? _c(
                      'span',
                      {
                        class: [
                          'el-switch__label',
                          'el-switch__label--right',
                          _vm.checked ? 'is-active' : '',
                        ],
                      },
                      [
                        _vm.activeIconClass
                          ? _c('i', { class: [_vm.activeIconClass] })
                          : _vm._e(),
                        !_vm.activeIconClass && _vm.activeText
                          ? _c('span', { attrs: { 'aria-hidden': !_vm.checked } }, [
                            _vm._v(_vm._s(_vm.activeText)),
                          ])
                          : _vm._e(),
                      ],
                    )
                    : _vm._e(),
                ],
              );
            };
            const componentvue_type_template_id_2dcd8fbb_staticRenderFns = [];
            componentvue_type_template_id_2dcd8fbb_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/switch/src/component.vue?vue&type=template&id=2dcd8fbb&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/switch/src/component.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const switch_src_componentvue_type_script_lang_js_ = ({
              name: 'ElSwitch',
              mixins: [focus_default()('input'), migrating_default.a, emitter_default.a],
              inject: {
                elForm: {
                  default: '',
                },
              },
              props: {
                value: {
                  type: [Boolean, String, Number],
                  default: false,
                },
                disabled: {
                  type: Boolean,
                  default: false,
                },
                width: {
                  type: Number,
                  default: 40,
                },
                activeIconClass: {
                  type: String,
                  default: '',
                },
                inactiveIconClass: {
                  type: String,
                  default: '',
                },
                activeText: String,
                inactiveText: String,
                activeColor: {
                  type: String,
                  default: '',
                },
                inactiveColor: {
                  type: String,
                  default: '',
                },
                activeValue: {
                  type: [Boolean, String, Number],
                  default: true,
                },
                inactiveValue: {
                  type: [Boolean, String, Number],
                  default: false,
                },
                name: {
                  type: String,
                  default: '',
                },
                validateEvent: {
                  type: Boolean,
                  default: true,
                },
                id: String,
              },
              data: function data() {
                return {
                  coreWidth: this.width,
                };
              },
              created: function created() {
                if (!~[this.activeValue, this.inactiveValue].indexOf(this.value)) {
                  this.$emit('input', this.inactiveValue);
                }
              },

              computed: {
                checked: function checked() {
                  return this.value === this.activeValue;
                },
                switchDisabled: function switchDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
              },
              watch: {
                checked: function checked() {
                  this.$refs.input.checked = this.checked;
                  if (this.activeColor || this.inactiveColor) {
                    this.setBackgroundColor();
                  }
                  if (this.validateEvent) {
                    this.dispatch('ElFormItem', 'el.form.change', [this.value]);
                  }
                },
              },
              methods: {
                handleChange: function handleChange(event) {
                  const _this = this;

                  const val = this.checked ? this.inactiveValue : this.activeValue;
                  this.$emit('input', val);
                  this.$emit('change', val);
                  this.$nextTick(() => {
                    // set input's checked property
                    // in case parent refuses to change component's value
                    _this.$refs.input.checked = _this.checked;
                  });
                },
                setBackgroundColor: function setBackgroundColor() {
                  const newColor = this.checked ? this.activeColor : this.inactiveColor;
                  this.$refs.core.style.borderColor = newColor;
                  this.$refs.core.style.backgroundColor = newColor;
                },
                switchValue: function switchValue() {
                  !this.switchDisabled && this.handleChange();
                },
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      'on-color': 'on-color is renamed to active-color.',
                      'off-color': 'off-color is renamed to inactive-color.',
                      'on-text': 'on-text is renamed to active-text.',
                      'off-text': 'off-text is renamed to inactive-text.',
                      'on-value': 'on-value is renamed to active-value.',
                      'off-value': 'off-value is renamed to inactive-value.',
                      'on-icon-class': 'on-icon-class is renamed to active-icon-class.',
                      'off-icon-class': 'off-icon-class is renamed to inactive-icon-class.',
                    },
                  };
                },
              },
              mounted: function mounted() {
                /* istanbul ignore if */
                this.coreWidth = this.width || 40;
                if (this.activeColor || this.inactiveColor) {
                  this.setBackgroundColor();
                }
                this.$refs.input.checked = this.checked;
              },
            });
            // CONCATENATED MODULE: ./packages/switch/src/component.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_switch_src_componentvue_type_script_lang_js_ = (switch_src_componentvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/switch/src/component.vue

            /* normalize component */

            const src_component_component = normalizeComponent(
              packages_switch_src_componentvue_type_script_lang_js_,
              componentvue_type_template_id_2dcd8fbb_render,
              componentvue_type_template_id_2dcd8fbb_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let src_component_api; }
            src_component_component.options.__file = 'packages/switch/src/component.vue';
            /* harmony default export */ const switch_src_component = (src_component_component.exports);
            // CONCATENATED MODULE: ./packages/switch/index.js

            /* istanbul ignore next */
            switch_src_component.install = function (Vue) {
              Vue.component(switch_src_component.name, switch_src_component);
            };

            /* harmony default export */ const packages_switch = (switch_src_component);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select.vue?vue&type=template&id=0e4aade6&
            const selectvue_type_template_id_0e4aade6_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  directives: [
                    {
                      name: 'clickoutside',
                      rawName: 'v-clickoutside',
                      value: _vm.handleClose,
                      expression: 'handleClose',
                    },
                  ],
                  staticClass: 'el-select',
                  class: [_vm.selectSize ? `el-select--${_vm.selectSize}` : ''],
                  on: {
                    click($event) {
                      $event.stopPropagation();
                      return _vm.toggleMenu($event);
                    },
                  },
                },
                [
                  _vm.multiple
                    ? _c(
                      'div',
                      {
                        ref: 'tags',
                        staticClass: 'el-select__tags',
                        style: { 'max-width': `${_vm.inputWidth - 32}px`, width: '100%' },
                      },
                      [
                        _vm.collapseTags && _vm.selected.length
                          ? _c(
                            'span',
                            [
                              _c(
                                'el-tag',
                                {
                                  attrs: {
                                    closable: !_vm.selectDisabled,
                                    size: _vm.collapseTagSize,
                                    hit: _vm.selected[0].hitState,
                                    type: 'info',
                                    'disable-transitions': '',
                                  },
                                  on: {
                                    close($event) {
                                      _vm.deleteTag($event, _vm.selected[0]);
                                    },
                                  },
                                },
                                [
                                  _c('span', { staticClass: 'el-select__tags-text' }, [
                                    _vm._v(_vm._s(_vm.selected[0].currentLabel)),
                                  ]),
                                ],
                              ),
                              _vm.selected.length > 1
                                ? _c(
                                  'el-tag',
                                  {
                                    attrs: {
                                      closable: false,
                                      size: _vm.collapseTagSize,
                                      type: 'info',
                                      'disable-transitions': '',
                                    },
                                  },
                                  [
                                    _c(
                                      'span',
                                      { staticClass: 'el-select__tags-text' },
                                      [_vm._v(`+ ${_vm._s(_vm.selected.length - 1)}`)],
                                    ),
                                  ],
                                )
                                : _vm._e(),
                            ],
                            1,
                          )
                          : _vm._e(),
                        !_vm.collapseTags
                          ? _c(
                            'transition-group',
                            { on: { 'after-leave': _vm.resetInputHeight } },
                            _vm._l(_vm.selected, (item) => _c(
                              'el-tag',
                              {
                                key: _vm.getValueKey(item),
                                attrs: {
                                  closable: !_vm.selectDisabled,
                                  size: _vm.collapseTagSize,
                                  hit: item.hitState,
                                  type: 'info',
                                  'disable-transitions': '',
                                },
                                on: {
                                  close($event) {
                                    _vm.deleteTag($event, item);
                                  },
                                },
                              },
                              [
                                _c('span', { staticClass: 'el-select__tags-text' }, [
                                  _vm._v(_vm._s(item.currentLabel)),
                                ]),
                              ],
                            )),
                            1,
                          )
                          : _vm._e(),
                        _vm.filterable
                          ? _c('input', {
                            directives: [
                              {
                                name: 'model',
                                rawName: 'v-model',
                                value: _vm.query,
                                expression: 'query',
                              },
                            ],
                            ref: 'input',
                            staticClass: 'el-select__input',
                            class: [_vm.selectSize ? `is-${_vm.selectSize}` : ''],
                            style: {
                              'flex-grow': '1',
                              width: `${_vm.inputLength / (_vm.inputWidth - 32)}%`,
                              'max-width': `${_vm.inputWidth - 42}px`,
                            },
                            attrs: {
                              type: 'text',
                              disabled: _vm.selectDisabled,
                              autocomplete: _vm.autoComplete || _vm.autocomplete,
                            },
                            domProps: { value: _vm.query },
                            on: {
                              focus: _vm.handleFocus,
                              blur($event) {
                                _vm.softFocus = false;
                              },
                              keyup: _vm.managePlaceholder,
                              keydown: [
                                _vm.resetInputState,
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k($event.keyCode, 'down', 40, $event.key, [
                              'Down',
                              'ArrowDown',
                            ])
                                  ) {
                                    return null;
                                  }
                                  $event.preventDefault();
                                  _vm.navigateOptions('next');
                                },
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k($event.keyCode, 'up', 38, $event.key, [
                              'Up',
                              'ArrowUp',
                            ])
                                  ) {
                                    return null;
                                  }
                                  $event.preventDefault();
                                  _vm.navigateOptions('prev');
                                },
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k(
                              $event.keyCode,
                              'enter',
                              13,
                              $event.key,
                              'Enter',
                            )
                                  ) {
                                    return null;
                                  }
                                  $event.preventDefault();
                                  return _vm.selectOption($event);
                                },
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k($event.keyCode, 'esc', 27, $event.key, [
                              'Esc',
                              'Escape',
                            ])
                                  ) {
                                    return null;
                                  }
                                  $event.stopPropagation();
                                  $event.preventDefault();
                                  _vm.visible = false;
                                },
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k(
                              $event.keyCode,
                              'delete',
                              [8, 46],
                              $event.key,
                              ['Backspace', 'Delete', 'Del'],
                            )
                                  ) {
                                    return null;
                                  }
                                  return _vm.deletePrevTag($event);
                                },
                                function ($event) {
                                  if (
                                    !('button' in $event)
                            && _vm._k($event.keyCode, 'tab', 9, $event.key, 'Tab')
                                  ) {
                                    return null;
                                  }
                                  _vm.visible = false;
                                },
                              ],
                              compositionstart: _vm.handleComposition,
                              compositionupdate: _vm.handleComposition,
                              compositionend: _vm.handleComposition,
                              input: [
                                function ($event) {
                                  if ($event.target.composing) {
                                    return;
                                  }
                                  _vm.query = $event.target.value;
                                },
                                _vm.debouncedQueryChange,
                              ],
                            },
                          })
                          : _vm._e(),
                      ],
                      1,
                    )
                    : _vm._e(),
                  _c(
                    'el-input',
                    {
                      ref: 'reference',
                      class: { 'is-focus': _vm.visible },
                      attrs: {
                        type: 'text',
                        placeholder: _vm.currentPlaceholder,
                        name: _vm.name,
                        id: _vm.id,
                        autocomplete: _vm.autoComplete || _vm.autocomplete,
                        size: _vm.selectSize,
                        disabled: _vm.selectDisabled,
                        readonly: _vm.readonly,
                        'validate-event': false,
                        tabindex: _vm.multiple && _vm.filterable ? '-1' : null,
                      },
                      on: { focus: _vm.handleFocus, blur: _vm.handleBlur },
                      nativeOn: {
                        keyup($event) {
                          return _vm.debouncedOnInputChange($event);
                        },
                        keydown: [
                          function ($event) {
                            if (
                              !('button' in $event)
                  && _vm._k($event.keyCode, 'down', 40, $event.key, [
                    'Down',
                    'ArrowDown',
                  ])
                            ) {
                              return null;
                            }
                            $event.stopPropagation();
                            $event.preventDefault();
                            _vm.navigateOptions('next');
                          },
                          function ($event) {
                            if (
                              !('button' in $event)
                  && _vm._k($event.keyCode, 'up', 38, $event.key, [
                    'Up',
                    'ArrowUp',
                  ])
                            ) {
                              return null;
                            }
                            $event.stopPropagation();
                            $event.preventDefault();
                            _vm.navigateOptions('prev');
                          },
                          function ($event) {
                            if (
                              !('button' in $event)
                  && _vm._k($event.keyCode, 'enter', 13, $event.key, 'Enter')
                            ) {
                              return null;
                            }
                            $event.preventDefault();
                            return _vm.selectOption($event);
                          },
                          function ($event) {
                            if (
                              !('button' in $event)
                  && _vm._k($event.keyCode, 'esc', 27, $event.key, [
                    'Esc',
                    'Escape',
                  ])
                            ) {
                              return null;
                            }
                            $event.stopPropagation();
                            $event.preventDefault();
                            _vm.visible = false;
                          },
                          function ($event) {
                            if (
                              !('button' in $event)
                  && _vm._k($event.keyCode, 'tab', 9, $event.key, 'Tab')
                            ) {
                              return null;
                            }
                            _vm.visible = false;
                          },
                        ],
                        paste($event) {
                          return _vm.debouncedOnInputChange($event);
                        },
                        mouseenter($event) {
                          _vm.inputHovering = true;
                        },
                        mouseleave($event) {
                          _vm.inputHovering = false;
                        },
                      },
                      model: {
                        value: _vm.selectedLabel,
                        callback($$v) {
                          _vm.selectedLabel = $$v;
                        },
                        expression: 'selectedLabel',
                      },
                    },
                    [
                      _vm.$slots.prefix
                        ? _c('template', { slot: 'prefix' }, [_vm._t('prefix')], 2)
                        : _vm._e(),
                      _c('template', { slot: 'suffix' }, [
                        _c('i', {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: !_vm.showClose,
                              expression: '!showClose',
                            },
                          ],
                          class: [
                            'el-select__caret',
                            'el-input__icon',
                            `el-icon-${_vm.iconClass}`,
                          ],
                        }),
                        _vm.showClose
                          ? _c('i', {
                            staticClass:
                    'el-select__caret el-input__icon el-icon-circle-close',
                            on: { click: _vm.handleClearClick },
                          })
                          : _vm._e(),
                      ]),
                    ],
                    2,
                  ),
                  _c(
                    'transition',
                    {
                      attrs: { name: 'el-zoom-in-top' },
                      on: {
                        'before-enter': _vm.handleMenuEnter,
                        'after-leave': _vm.doDestroy,
                      },
                    },
                    [
                      _c(
                        'el-select-menu',
                        {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: _vm.visible && _vm.emptyText !== false,
                              expression: 'visible && emptyText !== false',
                            },
                          ],
                          ref: 'popper',
                          attrs: { 'append-to-body': _vm.popperAppendToBody },
                        },
                        [
                          _c(
                            'el-scrollbar',
                            {
                              directives: [
                                {
                                  name: 'show',
                                  rawName: 'v-show',
                                  value: _vm.options.length > 0 && !_vm.loading,
                                  expression: 'options.length > 0 && !loading',
                                },
                              ],
                              ref: 'scrollbar',
                              class: {
                                'is-empty':
                      !_vm.allowCreate
                      && _vm.query
                      && _vm.filteredOptionsCount === 0,
                              },
                              attrs: {
                                tag: 'ul',
                                'wrap-class': 'el-select-dropdown__wrap',
                                'view-class': 'el-select-dropdown__list',
                              },
                            },
                            [
                              _vm.showNewOption
                                ? _c('el-option', {
                                  attrs: { value: _vm.query, created: '' },
                                })
                                : _vm._e(),
                              _vm._t('default'),
                            ],
                            2,
                          ),
                          _vm.emptyText
              && (!_vm.allowCreate
                || _vm.loading
                || (_vm.allowCreate && _vm.options.length === 0))
                            ? [
                              _vm.$slots.empty
                                ? _vm._t('empty')
                                : _c('p', { staticClass: 'el-select-dropdown__empty' }, [
                                  _vm._v(
                                    `\n          ${
                                      _vm._s(_vm.emptyText)
                                    }\n        `,
                                  ),
                                ]),
                            ]
                            : _vm._e(),
                        ],
                        2,
                      ),
                    ],
                    1,
                  ),
                ],
                1,
              );
            };
            const selectvue_type_template_id_0e4aade6_staticRenderFns = [];
            selectvue_type_template_id_0e4aade6_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/select/src/select.vue?vue&type=template&id=0e4aade6&

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select-dropdown.vue?vue&type=template&id=06828748&
            const select_dropdownvue_type_template_id_06828748_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-select-dropdown el-popper',
                  class: [{ 'is-multiple': _vm.$parent.multiple }, _vm.popperClass],
                  style: { minWidth: _vm.minWidth },
                },
                [_vm._t('default')],
                2,
              );
            };
            const select_dropdownvue_type_template_id_06828748_staticRenderFns = [];
            select_dropdownvue_type_template_id_06828748_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/select/src/select-dropdown.vue?vue&type=template&id=06828748&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select-dropdown.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const select_dropdownvue_type_script_lang_js_ = ({
              name: 'ElSelectDropdown',

              componentName: 'ElSelectDropdown',

              mixins: [vue_popper_default.a],

              props: {
                placement: {
                  default: 'bottom-start',
                },

                boundariesPadding: {
                  default: 0,
                },

                popperOptions: {
                  default: function _default() {
                    return {
                      gpuAcceleration: false,
                    };
                  },
                },

                visibleArrow: {
                  default: true,
                },

                appendToBody: {
                  type: Boolean,
                  default: true,
                },
              },

              data: function data() {
                return {
                  minWidth: '',
                };
              },

              computed: {
                popperClass: function popperClass() {
                  return this.$parent.popperClass;
                },
              },

              watch: {
                '$parent.inputWidth': function $parentInputWidth() {
                  this.minWidth = `${this.$parent.$el.getBoundingClientRect().width}px`;
                },
              },

              mounted: function mounted() {
                const _this = this;

                this.referenceElm = this.$parent.$refs.reference.$el;
                this.$parent.popperElm = this.popperElm = this.$el;
                this.$on('updatePopper', () => {
                  if (_this.$parent.visible) _this.updatePopper();
                });
                this.$on('destroyPopper', this.destroyPopper);
              },
            });
            // CONCATENATED MODULE: ./packages/select/src/select-dropdown.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_select_dropdownvue_type_script_lang_js_ = (select_dropdownvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/select/src/select-dropdown.vue

            /* normalize component */

            const select_dropdown_component = normalizeComponent(
              src_select_dropdownvue_type_script_lang_js_,
              select_dropdownvue_type_template_id_06828748_render,
              select_dropdownvue_type_template_id_06828748_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let select_dropdown_api; }
            select_dropdown_component.options.__file = 'packages/select/src/select-dropdown.vue';
            /* harmony default export */ const select_dropdown = (select_dropdown_component.exports);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option.vue?vue&type=template&id=7a44c642&
            const optionvue_type_template_id_7a44c642_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'li',
                {
                  directives: [
                    {
                      name: 'show',
                      rawName: 'v-show',
                      value: _vm.visible,
                      expression: 'visible',
                    },
                  ],
                  staticClass: 'el-select-dropdown__item',
                  class: {
                    selected: _vm.itemSelected,
                    'is-disabled': _vm.disabled || _vm.groupDisabled || _vm.limitReached,
                    hover: _vm.hover,
                  },
                  on: {
                    mouseenter: _vm.hoverItem,
                    click($event) {
                      $event.stopPropagation();
                      return _vm.selectOptionClick($event);
                    },
                  },
                },
                [_vm._t('default', [_c('span', [_vm._v(_vm._s(_vm.currentLabel))])])],
                2,
              );
            };
            const optionvue_type_template_id_7a44c642_staticRenderFns = [];
            optionvue_type_template_id_7a44c642_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/select/src/option.vue?vue&type=template&id=7a44c642&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option.vue?vue&type=script&lang=js&
            const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const optionvue_type_script_lang_js_ = ({
              mixins: [emitter_default.a],

              name: 'ElOption',

              componentName: 'ElOption',

              inject: ['select'],

              props: {
                value: {
                  required: true,
                },
                label: [String, Number],
                created: Boolean,
                disabled: {
                  type: Boolean,
                  default: false,
                },
              },

              data: function data() {
                return {
                  index: -1,
                  groupDisabled: false,
                  visible: true,
                  hitState: false,
                  hover: false,
                };
              },

              computed: {
                isObject: function isObject() {
                  return Object.prototype.toString.call(this.value).toLowerCase() === '[object object]';
                },
                currentLabel: function currentLabel() {
                  return this.label || (this.isObject ? '' : this.value);
                },
                currentValue: function currentValue() {
                  return this.value || this.label || '';
                },
                itemSelected: function itemSelected() {
                  if (!this.select.multiple) {
                    return this.isEqual(this.value, this.select.value);
                  }
                  return this.contains(this.select.value, this.value);
                },
                limitReached: function limitReached() {
                  if (this.select.multiple) {
                    return !this.itemSelected && (this.select.value || []).length >= this.select.multipleLimit && this.select.multipleLimit > 0;
                  }
                  return false;
                },
              },

              watch: {
                currentLabel: function currentLabel() {
                  if (!this.created && !this.select.remote) this.dispatch('ElSelect', 'setSelected');
                },
                value: function value(val, oldVal) {
                  const _select = this.select;
                  const { remote } = _select;
                  const { valueKey } = _select;

                  if (!this.created && !remote) {
                    if (valueKey && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && (typeof oldVal === 'undefined' ? 'undefined' : _typeof(oldVal)) === 'object' && val[valueKey] === oldVal[valueKey]) {
                      return;
                    }
                    this.dispatch('ElSelect', 'setSelected');
                  }
                },
              },

              methods: {
                isEqual: function isEqual(a, b) {
                  if (!this.isObject) {
                    return a === b;
                  }
                  const { valueKey } = this.select;
                  return Object(util_.getValueByPath)(a, valueKey) === Object(util_.getValueByPath)(b, valueKey);
                },
                contains: function contains() {
                  const arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                  const target = arguments[1];

                  if (!this.isObject) {
                    return arr && arr.indexOf(target) > -1;
                  }
                  const { valueKey } = this.select;
                  return arr && arr.some((item) => Object(util_.getValueByPath)(item, valueKey) === Object(util_.getValueByPath)(target, valueKey));
                },
                handleGroupDisabled: function handleGroupDisabled(val) {
                  this.groupDisabled = val;
                },
                hoverItem: function hoverItem() {
                  if (!this.disabled && !this.groupDisabled) {
                    this.select.hoverIndex = this.select.options.indexOf(this);
                  }
                },
                selectOptionClick: function selectOptionClick() {
                  if (this.disabled !== true && this.groupDisabled !== true) {
                    this.dispatch('ElSelect', 'handleOptionClick', [this, true]);
                  }
                },
                queryChange: function queryChange(query) {
                  this.visible = new RegExp(Object(util_.escapeRegexpString)(query), 'i').test(this.currentLabel) || this.created;
                  if (!this.visible) {
                    this.select.filteredOptionsCount--;
                  }
                },
              },

              created: function created() {
                this.select.options.push(this);
                this.select.cachedOptions.push(this);
                this.select.optionsCount++;
                this.select.filteredOptionsCount++;

                this.$on('queryChange', this.queryChange);
                this.$on('handleGroupDisabled', this.handleGroupDisabled);
              },
              beforeDestroy: function beforeDestroy() {
                const _select2 = this.select;
                const { selected } = _select2;
                const { multiple } = _select2;

                const selectedOptions = multiple ? selected : [selected];
                const index = this.select.cachedOptions.indexOf(this);
                const selectedIndex = selectedOptions.indexOf(this);

                // if option is not selected, remove it from cache
                if (index > -1 && selectedIndex < 0) {
                  this.select.cachedOptions.splice(index, 1);
                }
                this.select.onOptionDestroy(this.select.options.indexOf(this));
              },
            });
            // CONCATENATED MODULE: ./packages/select/src/option.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_optionvue_type_script_lang_js_ = (optionvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/select/src/option.vue

            /* normalize component */

            const option_component = normalizeComponent(
              src_optionvue_type_script_lang_js_,
              optionvue_type_template_id_7a44c642_render,
              optionvue_type_template_id_7a44c642_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let option_api; }
            option_component.options.__file = 'packages/select/src/option.vue';
            /* harmony default export */ const src_option = (option_component.exports);
            // EXTERNAL MODULE: external "element-ui/lib/tag"
            const tag_ = __webpack_require__(29);
            const tag_default = /* #__PURE__ */__webpack_require__.n(tag_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/resize-event"
            const resize_event_ = __webpack_require__(12);

            // EXTERNAL MODULE: external "element-ui/lib/utils/scroll-into-view"
            const scroll_into_view_ = __webpack_require__(27);
            const scroll_into_view_default = /* #__PURE__ */__webpack_require__.n(scroll_into_view_);

            // CONCATENATED MODULE: ./packages/select/src/navigation-mixin.js
            /* harmony default export */ const navigation_mixin = ({
              data: function data() {
                return {
                  hoverOption: -1,
                };
              },

              computed: {
                optionsAllDisabled: function optionsAllDisabled() {
                  return this.options.filter((option) => option.visible).every((option) => option.disabled);
                },
              },

              watch: {
                hoverIndex: function hoverIndex(val) {
                  const _this = this;

                  if (typeof val === 'number' && val > -1) {
                    this.hoverOption = this.options[val] || {};
                  }
                  this.options.forEach((option) => {
                    option.hover = _this.hoverOption === option;
                  });
                },
              },

              methods: {
                navigateOptions: function navigateOptions(direction) {
                  const _this2 = this;

                  if (!this.visible) {
                    this.visible = true;
                    return;
                  }
                  if (this.options.length === 0 || this.filteredOptionsCount === 0) return;
                  if (!this.optionsAllDisabled) {
                    if (direction === 'next') {
                      this.hoverIndex++;
                      if (this.hoverIndex === this.options.length) {
                        this.hoverIndex = 0;
                      }
                    } else if (direction === 'prev') {
                      this.hoverIndex--;
                      if (this.hoverIndex < 0) {
                        this.hoverIndex = this.options.length - 1;
                      }
                    }
                    const option = this.options[this.hoverIndex];
                    if (option.disabled === true || option.groupDisabled === true || !option.visible) {
                      this.navigateOptions(direction);
                    }
                    this.$nextTick(() => _this2.scrollToOption(_this2.hoverOption));
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const selectvue_type_script_lang_js_ = ({
              mixins: [emitter_default.a, locale_default.a, focus_default()('reference'), navigation_mixin],

              name: 'ElSelect',

              componentName: 'ElSelect',

              inject: {
                elForm: {
                  default: '',
                },

                elFormItem: {
                  default: '',
                },
              },

              provide: function provide() {
                return {
                  select: this,
                };
              },

              computed: {
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                readonly: function readonly() {
                  return !this.filterable || this.multiple || !Object(util_.isIE)() && !Object(util_.isEdge)() && !this.visible;
                },
                showClose: function showClose() {
                  const hasValue = this.multiple ? Array.isArray(this.value) && this.value.length > 0 : this.value !== undefined && this.value !== null && this.value !== '';
                  const criteria = this.clearable && !this.selectDisabled && this.inputHovering && hasValue;
                  return criteria;
                },
                iconClass: function iconClass() {
                  return this.remote && this.filterable ? '' : this.visible ? 'arrow-up is-reverse' : 'arrow-up';
                },
                debounce: function debounce() {
                  return this.remote ? 300 : 0;
                },
                emptyText: function emptyText() {
                  if (this.loading) {
                    return this.loadingText || this.t('el.select.loading');
                  }
                  if (this.remote && this.query === '' && this.options.length === 0) return false;
                  if (this.filterable && this.query && this.options.length > 0 && this.filteredOptionsCount === 0) {
                    return this.noMatchText || this.t('el.select.noMatch');
                  }
                  if (this.options.length === 0) {
                    return this.noDataText || this.t('el.select.noData');
                  }

                  return null;
                },
                showNewOption: function showNewOption() {
                  const _this = this;

                  const hasExistingOption = this.options.filter((option) => !option.created).some((option) => option.currentLabel === _this.query);
                  return this.filterable && this.allowCreate && this.query !== '' && !hasExistingOption;
                },
                selectSize: function selectSize() {
                  return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
                selectDisabled: function selectDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
                collapseTagSize: function collapseTagSize() {
                  return ['small', 'mini'].indexOf(this.selectSize) > -1 ? 'mini' : 'small';
                },
                propPlaceholder: function propPlaceholder() {
                  return typeof this.placeholder !== 'undefined' ? this.placeholder : this.t('el.select.placeholder');
                },
              },

              components: {
                ElInput: input_default.a,
                ElSelectMenu: select_dropdown,
                ElOption: src_option,
                ElTag: tag_default.a,
                ElScrollbar: scrollbar_default.a,
              },

              directives: { Clickoutside: clickoutside_default.a },

              props: {
                name: String,
                id: String,
                value: {
                  required: true,
                },
                autocomplete: {
                  type: String,
                  default: 'off',
                },
                /** @Deprecated in next major version */
                autoComplete: {
                  type: String,
                  validator: function validator(val) {
                    false && false;
                    return true;
                  },
                },
                automaticDropdown: Boolean,
                size: String,
                disabled: Boolean,
                clearable: Boolean,
                filterable: Boolean,
                allowCreate: Boolean,
                loading: Boolean,
                popperClass: String,
                remote: Boolean,
                loadingText: String,
                noMatchText: String,
                noDataText: String,
                remoteMethod: Function,
                filterMethod: Function,
                multiple: Boolean,
                multipleLimit: {
                  type: Number,
                  default: 0,
                },
                placeholder: {
                  type: String,
                  required: false,
                },
                defaultFirstOption: Boolean,
                reserveKeyword: Boolean,
                valueKey: {
                  type: String,
                  default: 'value',
                },
                collapseTags: Boolean,
                popperAppendToBody: {
                  type: Boolean,
                  default: true,
                },
              },

              data: function data() {
                return {
                  options: [],
                  cachedOptions: [],
                  createdLabel: null,
                  createdSelected: false,
                  selected: this.multiple ? [] : {},
                  inputLength: 20,
                  inputWidth: 0,
                  initialInputHeight: 0,
                  cachedPlaceHolder: '',
                  optionsCount: 0,
                  filteredOptionsCount: 0,
                  visible: false,
                  softFocus: false,
                  selectedLabel: '',
                  hoverIndex: -1,
                  query: '',
                  previousQuery: null,
                  inputHovering: false,
                  currentPlaceholder: '',
                  menuVisibleOnFocus: false,
                  isOnComposition: false,
                  isSilentBlur: false,
                };
              },

              watch: {
                selectDisabled: function selectDisabled() {
                  const _this2 = this;

                  this.$nextTick(() => {
                    _this2.resetInputHeight();
                  });
                },
                propPlaceholder: function propPlaceholder(val) {
                  this.cachedPlaceHolder = this.currentPlaceholder = val;
                },
                value: function value(val, oldVal) {
                  if (this.multiple) {
                    this.resetInputHeight();
                    if (val && val.length > 0 || this.$refs.input && this.query !== '') {
                      this.currentPlaceholder = '';
                    } else {
                      this.currentPlaceholder = this.cachedPlaceHolder;
                    }
                    if (this.filterable && !this.reserveKeyword) {
                      this.query = '';
                      this.handleQueryChange(this.query);
                    }
                  }
                  this.setSelected();
                  if (this.filterable && !this.multiple) {
                    this.inputLength = 20;
                  }
                  if (!Object(util_.valueEquals)(val, oldVal)) {
                    this.dispatch('ElFormItem', 'el.form.change', val);
                  }
                },
                visible: function visible(val) {
                  const _this3 = this;

                  if (!val) {
                    this.broadcast('ElSelectDropdown', 'destroyPopper');
                    if (this.$refs.input) {
                      this.$refs.input.blur();
                    }
                    this.query = '';
                    this.previousQuery = null;
                    this.selectedLabel = '';
                    this.inputLength = 20;
                    this.menuVisibleOnFocus = false;
                    this.resetHoverIndex();
                    this.$nextTick(() => {
                      if (_this3.$refs.input && _this3.$refs.input.value === '' && _this3.selected.length === 0) {
                        _this3.currentPlaceholder = _this3.cachedPlaceHolder;
                      }
                    });
                    if (!this.multiple) {
                      if (this.selected) {
                        if (this.filterable && this.allowCreate && this.createdSelected && this.createdLabel) {
                          this.selectedLabel = this.createdLabel;
                        } else {
                          this.selectedLabel = this.selected.currentLabel;
                        }
                        if (this.filterable) this.query = this.selectedLabel;
                      }

                      if (this.filterable) {
                        this.currentPlaceholder = this.cachedPlaceHolder;
                      }
                    }
                  } else {
                    this.broadcast('ElSelectDropdown', 'updatePopper');
                    if (this.filterable) {
                      this.query = this.remote ? '' : this.selectedLabel;
                      this.handleQueryChange(this.query);
                      if (this.multiple) {
                        this.$refs.input.focus();
                      } else {
                        if (!this.remote) {
                          this.broadcast('ElOption', 'queryChange', '');
                          this.broadcast('ElOptionGroup', 'queryChange');
                        }

                        if (this.selectedLabel) {
                          this.currentPlaceholder = this.selectedLabel;
                          this.selectedLabel = '';
                        }
                      }
                    }
                  }
                  this.$emit('visible-change', val);
                },
                options: function options() {
                  const _this4 = this;

                  if (this.$isServer) return;
                  this.$nextTick(() => {
                    _this4.broadcast('ElSelectDropdown', 'updatePopper');
                  });
                  if (this.multiple) {
                    this.resetInputHeight();
                  }
                  const inputs = this.$el.querySelectorAll('input');
                  if ([].indexOf.call(inputs, document.activeElement) === -1) {
                    this.setSelected();
                  }
                  if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
                    this.checkDefaultFirstOption();
                  }
                },
              },

              methods: {
                handleComposition: function handleComposition(event) {
                  const _this5 = this;

                  const text = event.target.value;
                  if (event.type === 'compositionend') {
                    this.isOnComposition = false;
                    this.$nextTick((_) => _this5.handleQueryChange(text));
                  } else {
                    const lastCharacter = text[text.length - 1] || '';
                    this.isOnComposition = !Object(shared_.isKorean)(lastCharacter);
                  }
                },
                handleQueryChange: function handleQueryChange(val) {
                  const _this6 = this;

                  if (this.previousQuery === val || this.isOnComposition) return;
                  if (this.previousQuery === null && (typeof this.filterMethod === 'function' || typeof this.remoteMethod === 'function')) {
                    this.previousQuery = val;
                    return;
                  }
                  this.previousQuery = val;
                  this.$nextTick(() => {
                    if (_this6.visible) _this6.broadcast('ElSelectDropdown', 'updatePopper');
                  });
                  this.hoverIndex = -1;
                  if (this.multiple && this.filterable) {
                    this.$nextTick(() => {
                      const length = _this6.$refs.input.value.length * 15 + 20;
                      _this6.inputLength = _this6.collapseTags ? Math.min(50, length) : length;
                      _this6.managePlaceholder();
                      _this6.resetInputHeight();
                    });
                  }
                  if (this.remote && typeof this.remoteMethod === 'function') {
                    this.hoverIndex = -1;
                    this.remoteMethod(val);
                  } else if (typeof this.filterMethod === 'function') {
                    this.filterMethod(val);
                    this.broadcast('ElOptionGroup', 'queryChange');
                  } else {
                    this.filteredOptionsCount = this.optionsCount;
                    this.broadcast('ElOption', 'queryChange', val);
                    this.broadcast('ElOptionGroup', 'queryChange');
                  }
                  if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
                    this.checkDefaultFirstOption();
                  }
                },
                scrollToOption: function scrollToOption(option) {
                  const target = Array.isArray(option) && option[0] ? option[0].$el : option.$el;
                  if (this.$refs.popper && target) {
                    const menu = this.$refs.popper.$el.querySelector('.el-select-dropdown__wrap');
                    scroll_into_view_default()(menu, target);
                  }
                  this.$refs.scrollbar && this.$refs.scrollbar.handleScroll();
                },
                handleMenuEnter: function handleMenuEnter() {
                  const _this7 = this;

                  this.$nextTick(() => _this7.scrollToOption(_this7.selected));
                },
                emitChange: function emitChange(val) {
                  if (!Object(util_.valueEquals)(this.value, val)) {
                    this.$emit('change', val);
                  }
                },
                getOption: function getOption(value) {
                  let option = void 0;
                  const isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
                  const isNull = Object.prototype.toString.call(value).toLowerCase() === '[object null]';
                  const isUndefined = Object.prototype.toString.call(value).toLowerCase() === '[object undefined]';

                  for (let i = this.cachedOptions.length - 1; i >= 0; i--) {
                    const cachedOption = this.cachedOptions[i];
                    const isEqual = isObject ? Object(util_.getValueByPath)(cachedOption.value, this.valueKey) === Object(util_.getValueByPath)(value, this.valueKey) : cachedOption.value === value;
                    if (isEqual) {
                      option = cachedOption;
                      break;
                    }
                  }
                  if (option) return option;
                  const label = !isObject && !isNull && !isUndefined ? value : '';
                  const newOption = {
                    value,
                    currentLabel: label,
                  };
                  if (this.multiple) {
                    newOption.hitState = false;
                  }
                  return newOption;
                },
                setSelected: function setSelected() {
                  const _this8 = this;

                  if (!this.multiple) {
                    const option = this.getOption(this.value);
                    if (option.created) {
                      this.createdLabel = option.currentLabel;
                      this.createdSelected = true;
                    } else {
                      this.createdSelected = false;
                    }
                    this.selectedLabel = option.currentLabel;
                    this.selected = option;
                    if (this.filterable) this.query = this.selectedLabel;
                    return;
                  }
                  const result = [];
                  if (Array.isArray(this.value)) {
                    this.value.forEach((value) => {
                      result.push(_this8.getOption(value));
                    });
                  }
                  this.selected = result;
                  this.$nextTick(() => {
                    _this8.resetInputHeight();
                  });
                },
                handleFocus: function handleFocus(event) {
                  if (!this.softFocus) {
                    if (this.automaticDropdown || this.filterable) {
                      this.visible = true;
                      if (this.filterable) {
                        this.menuVisibleOnFocus = true;
                      }
                    }
                    this.$emit('focus', event);
                  } else {
                    this.softFocus = false;
                  }
                },
                blur: function blur() {
                  this.visible = false;
                  this.$refs.reference.blur();
                },
                handleBlur: function handleBlur(event) {
                  const _this9 = this;

                  setTimeout(() => {
                    if (_this9.isSilentBlur) {
                      _this9.isSilentBlur = false;
                    } else {
                      _this9.$emit('blur', event);
                    }
                  }, 50);
                  this.softFocus = false;
                },
                handleClearClick: function handleClearClick(event) {
                  this.deleteSelected(event);
                },
                doDestroy: function doDestroy() {
                  this.$refs.popper && this.$refs.popper.doDestroy();
                },
                handleClose: function handleClose() {
                  this.visible = false;
                },
                toggleLastOptionHitState: function toggleLastOptionHitState(hit) {
                  if (!Array.isArray(this.selected)) return;
                  const option = this.selected[this.selected.length - 1];
                  if (!option) return;

                  if (hit === true || hit === false) {
                    option.hitState = hit;
                    return hit;
                  }

                  option.hitState = !option.hitState;
                  return option.hitState;
                },
                deletePrevTag: function deletePrevTag(e) {
                  if (e.target.value.length <= 0 && !this.toggleLastOptionHitState()) {
                    const value = this.value.slice();
                    value.pop();
                    this.$emit('input', value);
                    this.emitChange(value);
                  }
                },
                managePlaceholder: function managePlaceholder() {
                  if (this.currentPlaceholder !== '') {
                    this.currentPlaceholder = this.$refs.input.value ? '' : this.cachedPlaceHolder;
                  }
                },
                resetInputState: function resetInputState(e) {
                  if (e.keyCode !== 8) this.toggleLastOptionHitState(false);
                  this.inputLength = this.$refs.input.value.length * 15 + 20;
                  this.resetInputHeight();
                },
                resetInputHeight: function resetInputHeight() {
                  const _this10 = this;

                  if (this.collapseTags && !this.filterable) return;
                  this.$nextTick(() => {
                    if (!_this10.$refs.reference) return;
                    const inputChildNodes = _this10.$refs.reference.$el.childNodes;
                    const input = [].filter.call(inputChildNodes, (item) => item.tagName === 'INPUT')[0];
                    const { tags } = _this10.$refs;
                    const sizeInMap = _this10.initialInputHeight || 40;
                    input.style.height = _this10.selected.length === 0 ? `${sizeInMap}px` : `${Math.max(tags ? tags.clientHeight + (tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)}px`;
                    if (_this10.visible && _this10.emptyText !== false) {
                      _this10.broadcast('ElSelectDropdown', 'updatePopper');
                    }
                  });
                },
                resetHoverIndex: function resetHoverIndex() {
                  const _this11 = this;

                  setTimeout(() => {
                    if (!_this11.multiple) {
                      _this11.hoverIndex = _this11.options.indexOf(_this11.selected);
                    } else if (_this11.selected.length > 0) {
                      _this11.hoverIndex = Math.min.apply(null, _this11.selected.map((item) => _this11.options.indexOf(item)));
                    } else {
                      _this11.hoverIndex = -1;
                    }
                  }, 300);
                },
                handleOptionSelect: function handleOptionSelect(option, byClick) {
                  const _this12 = this;

                  if (this.multiple) {
                    const value = (this.value || []).slice();
                    const optionIndex = this.getValueIndex(value, option.value);
                    if (optionIndex > -1) {
                      value.splice(optionIndex, 1);
                    } else if (this.multipleLimit <= 0 || value.length < this.multipleLimit) {
                      value.push(option.value);
                    }
                    this.$emit('input', value);
                    this.emitChange(value);
                    if (option.created) {
                      this.query = '';
                      this.handleQueryChange('');
                      this.inputLength = 20;
                    }
                    if (this.filterable) this.$refs.input.focus();
                  } else {
                    this.$emit('input', option.value);
                    this.emitChange(option.value);
                    this.visible = false;
                  }
                  this.isSilentBlur = byClick;
                  this.setSoftFocus();
                  if (this.visible) return;
                  this.$nextTick(() => {
                    _this12.scrollToOption(option);
                  });
                },
                setSoftFocus: function setSoftFocus() {
                  this.softFocus = true;
                  const input = this.$refs.input || this.$refs.reference;
                  if (input) {
                    input.focus();
                  }
                },
                getValueIndex: function getValueIndex() {
                  const arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                  const value = arguments[1];

                  const isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
                  if (!isObject) {
                    return arr.indexOf(value);
                  }
                  const { valueKey } = this;
                  let index = -1;
                  arr.some((item, i) => {
                    if (Object(util_.getValueByPath)(item, valueKey) === Object(util_.getValueByPath)(value, valueKey)) {
                      index = i;
                      return true;
                    }
                    return false;
                  });
                  return index;
                },
                toggleMenu: function toggleMenu() {
                  if (!this.selectDisabled) {
                    if (this.menuVisibleOnFocus) {
                      this.menuVisibleOnFocus = false;
                    } else {
                      this.visible = !this.visible;
                    }
                    if (this.visible) {
                      (this.$refs.input || this.$refs.reference).focus();
                    }
                  }
                },
                selectOption: function selectOption() {
                  if (!this.visible) {
                    this.toggleMenu();
                  } else if (this.options[this.hoverIndex]) {
                    this.handleOptionSelect(this.options[this.hoverIndex]);
                  }
                },
                deleteSelected: function deleteSelected(event) {
                  event.stopPropagation();
                  const value = this.multiple ? [] : '';
                  this.$emit('input', value);
                  this.emitChange(value);
                  this.visible = false;
                  this.$emit('clear');
                },
                deleteTag: function deleteTag(event, tag) {
                  const index = this.selected.indexOf(tag);
                  if (index > -1 && !this.selectDisabled) {
                    const value = this.value.slice();
                    value.splice(index, 1);
                    this.$emit('input', value);
                    this.emitChange(value);
                    this.$emit('remove-tag', tag.value);
                  }
                  event.stopPropagation();
                },
                onInputChange: function onInputChange() {
                  if (this.filterable && this.query !== this.selectedLabel) {
                    this.query = this.selectedLabel;
                    this.handleQueryChange(this.query);
                  }
                },
                onOptionDestroy: function onOptionDestroy(index) {
                  if (index > -1) {
                    this.optionsCount--;
                    this.filteredOptionsCount--;
                    this.options.splice(index, 1);
                  }
                },
                resetInputWidth: function resetInputWidth() {
                  this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
                },
                handleResize: function handleResize() {
                  this.resetInputWidth();
                  if (this.multiple) this.resetInputHeight();
                },
                checkDefaultFirstOption: function checkDefaultFirstOption() {
                  this.hoverIndex = -1;
                  // highlight the created option
                  let hasCreated = false;
                  for (let i = this.options.length - 1; i >= 0; i--) {
                    if (this.options[i].created) {
                      hasCreated = true;
                      this.hoverIndex = i;
                      break;
                    }
                  }
                  if (hasCreated) return;
                  for (let _i = 0; _i !== this.options.length; ++_i) {
                    const option = this.options[_i];
                    if (this.query) {
                      // highlight first options that passes the filter
                      if (!option.disabled && !option.groupDisabled && option.visible) {
                        this.hoverIndex = _i;
                        break;
                      }
                    } else {
                      // highlight currently selected option
                      if (option.itemSelected) {
                        this.hoverIndex = _i;
                        break;
                      }
                    }
                  }
                },
                getValueKey: function getValueKey(item) {
                  if (Object.prototype.toString.call(item.value).toLowerCase() !== '[object object]') {
                    return item.value;
                  }
                  return Object(util_.getValueByPath)(item.value, this.valueKey);
                },
              },

              created: function created() {
                const _this13 = this;

                this.cachedPlaceHolder = this.currentPlaceholder = this.propPlaceholder;
                if (this.multiple && !Array.isArray(this.value)) {
                  this.$emit('input', []);
                }
                if (!this.multiple && Array.isArray(this.value)) {
                  this.$emit('input', '');
                }

                this.debouncedOnInputChange = debounce_default()(this.debounce, () => {
                  _this13.onInputChange();
                });

                this.debouncedQueryChange = debounce_default()(this.debounce, (e) => {
                  _this13.handleQueryChange(e.target.value);
                });

                this.$on('handleOptionClick', this.handleOptionSelect);
                this.$on('setSelected', this.setSelected);
              },
              mounted: function mounted() {
                const _this14 = this;

                if (this.multiple && Array.isArray(this.value) && this.value.length > 0) {
                  this.currentPlaceholder = '';
                }
                Object(resize_event_.addResizeListener)(this.$el, this.handleResize);

                const { reference } = this.$refs;
                if (reference && reference.$el) {
                  const sizeMap = {
                    medium: 36,
                    small: 32,
                    mini: 28,
                  };
                  const input = reference.$el.querySelector('input');
                  this.initialInputHeight = input.getBoundingClientRect().height || sizeMap[this.selectSize];
                }
                if (this.remote && this.multiple) {
                  this.resetInputHeight();
                }
                this.$nextTick(() => {
                  if (reference && reference.$el) {
                    _this14.inputWidth = reference.$el.getBoundingClientRect().width;
                  }
                });
                this.setSelected();
              },
              beforeDestroy: function beforeDestroy() {
                if (this.$el && this.handleResize) Object(resize_event_.removeResizeListener)(this.$el, this.handleResize);
              },
            });
            // CONCATENATED MODULE: ./packages/select/src/select.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_selectvue_type_script_lang_js_ = (selectvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/select/src/select.vue

            /* normalize component */

            const select_component = normalizeComponent(
              src_selectvue_type_script_lang_js_,
              selectvue_type_template_id_0e4aade6_render,
              selectvue_type_template_id_0e4aade6_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let select_api; }
            select_component.options.__file = 'packages/select/src/select.vue';
            /* harmony default export */ const src_select = (select_component.exports);
            // CONCATENATED MODULE: ./packages/select/index.js

            /* istanbul ignore next */
            src_select.install = function (Vue) {
              Vue.component(src_select.name, src_select);
            };

            /* harmony default export */ const packages_select = (src_select);
            // CONCATENATED MODULE: ./packages/option/index.js

            /* istanbul ignore next */
            src_option.install = function (Vue) {
              Vue.component(src_option.name, src_option);
            };

            /* harmony default export */ const packages_option = (src_option);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option-group.vue?vue&type=template&id=6685e5de&
            const option_groupvue_type_template_id_6685e5de_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'ul',
                {
                  directives: [
                    {
                      name: 'show',
                      rawName: 'v-show',
                      value: _vm.visible,
                      expression: 'visible',
                    },
                  ],
                  staticClass: 'el-select-group__wrap',
                },
                [
                  _c('li', { staticClass: 'el-select-group__title' }, [
                    _vm._v(_vm._s(_vm.label)),
                  ]),
                  _c('li', [
                    _c('ul', { staticClass: 'el-select-group' }, [_vm._t('default')], 2),
                  ]),
                ],
              );
            };
            const option_groupvue_type_template_id_6685e5de_staticRenderFns = [];
            option_groupvue_type_template_id_6685e5de_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/select/src/option-group.vue?vue&type=template&id=6685e5de&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option-group.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const option_groupvue_type_script_lang_js_ = ({
              mixins: [emitter_default.a],

              name: 'ElOptionGroup',

              componentName: 'ElOptionGroup',

              props: {
                label: String,
                disabled: {
                  type: Boolean,
                  default: false,
                },
              },

              data: function data() {
                return {
                  visible: true,
                };
              },

              watch: {
                disabled: function disabled(val) {
                  this.broadcast('ElOption', 'handleGroupDisabled', val);
                },
              },

              methods: {
                queryChange: function queryChange() {
                  this.visible = this.$children && Array.isArray(this.$children) && this.$children.some((option) => option.visible === true);
                },
              },

              created: function created() {
                this.$on('queryChange', this.queryChange);
              },
              mounted: function mounted() {
                if (this.disabled) {
                  this.broadcast('ElOption', 'handleGroupDisabled', this.disabled);
                }
              },
            });
            // CONCATENATED MODULE: ./packages/select/src/option-group.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_option_groupvue_type_script_lang_js_ = (option_groupvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/select/src/option-group.vue

            /* normalize component */

            const option_group_component = normalizeComponent(
              src_option_groupvue_type_script_lang_js_,
              option_groupvue_type_template_id_6685e5de_render,
              option_groupvue_type_template_id_6685e5de_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let option_group_api; }
            option_group_component.options.__file = 'packages/select/src/option-group.vue';
            /* harmony default export */ const option_group = (option_group_component.exports);
            // CONCATENATED MODULE: ./packages/option-group/index.js

            /* istanbul ignore next */
            option_group.install = function (Vue) {
              Vue.component(option_group.name, option_group);
            };

            /* harmony default export */ const packages_option_group = (option_group);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button.vue?vue&type=template&id=ca859fb4&
            const buttonvue_type_template_id_ca859fb4_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'button',
                {
                  staticClass: 'el-button',
                  class: [
                    _vm.type ? `el-button--${_vm.type}` : '',
                    _vm.buttonSize ? `el-button--${_vm.buttonSize}` : '',
                    {
                      'is-disabled': _vm.buttonDisabled,
                      'is-loading': _vm.loading,
                      'is-plain': _vm.plain,
                      'is-round': _vm.round,
                      'is-circle': _vm.circle,
                    },
                  ],
                  attrs: {
                    disabled: _vm.buttonDisabled || _vm.loading,
                    autofocus: _vm.autofocus,
                    type: _vm.nativeType,
                  },
                  on: { click: _vm.handleClick },
                },
                [
                  _vm.loading ? _c('i', { staticClass: 'el-icon-loading' }) : _vm._e(),
                  _vm.icon && !_vm.loading ? _c('i', { class: _vm.icon }) : _vm._e(),
                  _vm.$slots.default ? _c('span', [_vm._t('default')], 2) : _vm._e(),
                ],
              );
            };
            const buttonvue_type_template_id_ca859fb4_staticRenderFns = [];
            buttonvue_type_template_id_ca859fb4_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/button/src/button.vue?vue&type=template&id=ca859fb4&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const buttonvue_type_script_lang_js_ = ({
              name: 'ElButton',

              inject: {
                elForm: {
                  default: '',
                },
                elFormItem: {
                  default: '',
                },
              },

              props: {
                type: {
                  type: String,
                  default: 'default',
                },
                size: String,
                icon: {
                  type: String,
                  default: '',
                },
                nativeType: {
                  type: String,
                  default: 'button',
                },
                loading: Boolean,
                disabled: Boolean,
                plain: Boolean,
                autofocus: Boolean,
                round: Boolean,
                circle: Boolean,
              },

              computed: {
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                buttonSize: function buttonSize() {
                  return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
                buttonDisabled: function buttonDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
              },

              methods: {
                handleClick: function handleClick(evt) {
                  this.$emit('click', evt);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/button/src/button.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_buttonvue_type_script_lang_js_ = (buttonvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/button/src/button.vue

            /* normalize component */

            const button_component = normalizeComponent(
              src_buttonvue_type_script_lang_js_,
              buttonvue_type_template_id_ca859fb4_render,
              buttonvue_type_template_id_ca859fb4_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let button_api; }
            button_component.options.__file = 'packages/button/src/button.vue';
            /* harmony default export */ const src_button = (button_component.exports);
            // CONCATENATED MODULE: ./packages/button/index.js

            /* istanbul ignore next */
            src_button.install = function (Vue) {
              Vue.component(src_button.name, src_button);
            };

            /* harmony default export */ const packages_button = (src_button);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button-group.vue?vue&type=template&id=3d8661d0&
            const button_groupvue_type_template_id_3d8661d0_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('div', { staticClass: 'el-button-group' }, [_vm._t('default')], 2);
            };
            const button_groupvue_type_template_id_3d8661d0_staticRenderFns = [];
            button_groupvue_type_template_id_3d8661d0_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/button/src/button-group.vue?vue&type=template&id=3d8661d0&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button-group.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //

            /* harmony default export */ const button_groupvue_type_script_lang_js_ = ({
              name: 'ElButtonGroup',
            });
            // CONCATENATED MODULE: ./packages/button/src/button-group.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_button_groupvue_type_script_lang_js_ = (button_groupvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/button/src/button-group.vue

            /* normalize component */

            const button_group_component = normalizeComponent(
              src_button_groupvue_type_script_lang_js_,
              button_groupvue_type_template_id_3d8661d0_render,
              button_groupvue_type_template_id_3d8661d0_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let button_group_api; }
            button_group_component.options.__file = 'packages/button/src/button-group.vue';
            /* harmony default export */ const button_group = (button_group_component.exports);
            // CONCATENATED MODULE: ./packages/button-group/index.js

            /* istanbul ignore next */
            button_group.install = function (Vue) {
              Vue.component(button_group.name, button_group);
            };

            /* harmony default export */ const packages_button_group = (button_group);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/table.vue?vue&type=template&id=493fe34e&
            const tablevue_type_template_id_493fe34e_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-table',
                  class: [
                    {
                      'el-table--fit': _vm.fit,
                      'el-table--striped': _vm.stripe,
                      'el-table--border': _vm.border || _vm.isGroup,
                      'el-table--hidden': _vm.isHidden,
                      'el-table--group': _vm.isGroup,
                      'el-table--fluid-height': _vm.maxHeight,
                      'el-table--scrollable-x': _vm.layout.scrollX,
                      'el-table--scrollable-y': _vm.layout.scrollY,
                      'el-table--enable-row-hover': !_vm.store.states.isComplex,
                      'el-table--enable-row-transition':
            (_vm.store.states.data || []).length !== 0
            && (_vm.store.states.data || []).length < 100,
                    },
                    _vm.tableSize ? `el-table--${_vm.tableSize}` : '',
                  ],
                  on: {
                    mouseleave($event) {
                      _vm.handleMouseLeave($event);
                    },
                  },
                },
                [
                  _c(
                    'div',
                    { ref: 'hiddenColumns', staticClass: 'hidden-columns' },
                    [_vm._t('default')],
                    2,
                  ),
                  _vm.showHeader
                    ? _c(
                      'div',
                      {
                        directives: [
                          {
                            name: 'mousewheel',
                            rawName: 'v-mousewheel',
                            value: _vm.handleHeaderFooterMousewheel,
                            expression: 'handleHeaderFooterMousewheel',
                          },
                        ],
                        ref: 'headerWrapper',
                        staticClass: 'el-table__header-wrapper',
                      },
                      [
                        _c('table-header', {
                          ref: 'tableHeader',
                          style: {
                            width: _vm.layout.bodyWidth ? `${_vm.layout.bodyWidth}px` : '',
                          },
                          attrs: {
                            store: _vm.store,
                            border: _vm.border,
                            'default-sort': _vm.defaultSort,
                          },
                        }),
                      ],
                      1,
                    )
                    : _vm._e(),
                  _c(
                    'div',
                    {
                      ref: 'bodyWrapper',
                      staticClass: 'el-table__body-wrapper',
                      class: [
                        _vm.layout.scrollX
                          ? `is-scrolling-${_vm.scrollPosition}`
                          : 'is-scrolling-none',
                      ],
                      style: [_vm.bodyHeight],
                    },
                    [
                      _c('table-body', {
                        style: {
                          width: _vm.bodyWidth,
                        },
                        attrs: {
                          context: _vm.context,
                          store: _vm.store,
                          stripe: _vm.stripe,
                          'row-class-name': _vm.rowClassName,
                          'row-style': _vm.rowStyle,
                          highlight: _vm.highlightCurrentRow,
                        },
                      }),
                      !_vm.data || _vm.data.length === 0
                        ? _c(
                          'div',
                          {
                            ref: 'emptyBlock',
                            staticClass: 'el-table__empty-block',
                            style: _vm.emptyBlockStyle,
                          },
                          [
                            _c(
                              'span',
                              { staticClass: 'el-table__empty-text' },
                              [
                                _vm._t('empty', [
                                  _vm._v(
                                    _vm._s(_vm.emptyText || _vm.t('el.table.emptyText')),
                                  ),
                                ]),
                              ],
                              2,
                            ),
                          ],
                        )
                        : _vm._e(),
                      _vm.$slots.append
                        ? _c(
                          'div',
                          {
                            ref: 'appendWrapper',
                            staticClass: 'el-table__append-wrapper',
                          },
                          [_vm._t('append')],
                          2,
                        )
                        : _vm._e(),
                    ],
                    1,
                  ),
                  _vm.showSummary
                    ? _c(
                      'div',
                      {
                        directives: [
                          {
                            name: 'show',
                            rawName: 'v-show',
                            value: _vm.data && _vm.data.length > 0,
                            expression: 'data && data.length > 0',
                          },
                          {
                            name: 'mousewheel',
                            rawName: 'v-mousewheel',
                            value: _vm.handleHeaderFooterMousewheel,
                            expression: 'handleHeaderFooterMousewheel',
                          },
                        ],
                        ref: 'footerWrapper',
                        staticClass: 'el-table__footer-wrapper',
                      },
                      [
                        _c('table-footer', {
                          style: {
                            width: _vm.layout.bodyWidth ? `${_vm.layout.bodyWidth}px` : '',
                          },
                          attrs: {
                            store: _vm.store,
                            border: _vm.border,
                            'sum-text': _vm.sumText || _vm.t('el.table.sumText'),
                            'summary-method': _vm.summaryMethod,
                            'default-sort': _vm.defaultSort,
                          },
                        }),
                      ],
                      1,
                    )
                    : _vm._e(),
                  _vm.fixedColumns.length > 0
                    ? _c(
                      'div',
                      {
                        directives: [
                          {
                            name: 'mousewheel',
                            rawName: 'v-mousewheel',
                            value: _vm.handleFixedMousewheel,
                            expression: 'handleFixedMousewheel',
                          },
                        ],
                        ref: 'fixedWrapper',
                        staticClass: 'el-table__fixed',
                        style: [
                          {
                            width: _vm.layout.fixedWidth
                              ? `${_vm.layout.fixedWidth}px`
                              : '',
                          },
                          _vm.fixedHeight,
                        ],
                      },
                      [
                        _vm.showHeader
                          ? _c(
                            'div',
                            {
                              ref: 'fixedHeaderWrapper',
                              staticClass: 'el-table__fixed-header-wrapper',
                            },
                            [
                              _c('table-header', {
                                ref: 'fixedTableHeader',
                                style: {
                                  width: _vm.bodyWidth,
                                },
                                attrs: {
                                  fixed: 'left',
                                  border: _vm.border,
                                  store: _vm.store,
                                },
                              }),
                            ],
                            1,
                          )
                          : _vm._e(),
                        _c(
                          'div',
                          {
                            ref: 'fixedBodyWrapper',
                            staticClass: 'el-table__fixed-body-wrapper',
                            style: [
                              {
                                top: `${_vm.layout.headerHeight}px`,
                              },
                              _vm.fixedBodyHeight,
                            ],
                          },
                          [
                            _c('table-body', {
                              style: {
                                width: _vm.bodyWidth,
                              },
                              attrs: {
                                fixed: 'left',
                                store: _vm.store,
                                stripe: _vm.stripe,
                                highlight: _vm.highlightCurrentRow,
                                'row-class-name': _vm.rowClassName,
                                'row-style': _vm.rowStyle,
                              },
                            }),
                            _vm.$slots.append
                              ? _c('div', {
                                staticClass: 'el-table__append-gutter',
                                style: { height: `${_vm.layout.appendHeight}px` },
                              })
                              : _vm._e(),
                          ],
                          1,
                        ),
                        _vm.showSummary
                          ? _c(
                            'div',
                            {
                              directives: [
                                {
                                  name: 'show',
                                  rawName: 'v-show',
                                  value: _vm.data && _vm.data.length > 0,
                                  expression: 'data && data.length > 0',
                                },
                              ],
                              ref: 'fixedFooterWrapper',
                              staticClass: 'el-table__fixed-footer-wrapper',
                            },
                            [
                              _c('table-footer', {
                                style: {
                                  width: _vm.bodyWidth,
                                },
                                attrs: {
                                  fixed: 'left',
                                  border: _vm.border,
                                  'sum-text': _vm.sumText || _vm.t('el.table.sumText'),
                                  'summary-method': _vm.summaryMethod,
                                  store: _vm.store,
                                },
                              }),
                            ],
                            1,
                          )
                          : _vm._e(),
                      ],
                    )
                    : _vm._e(),
                  _vm.rightFixedColumns.length > 0
                    ? _c(
                      'div',
                      {
                        directives: [
                          {
                            name: 'mousewheel',
                            rawName: 'v-mousewheel',
                            value: _vm.handleFixedMousewheel,
                            expression: 'handleFixedMousewheel',
                          },
                        ],
                        ref: 'rightFixedWrapper',
                        staticClass: 'el-table__fixed-right',
                        style: [
                          {
                            width: _vm.layout.rightFixedWidth
                              ? `${_vm.layout.rightFixedWidth}px`
                              : '',
                            right: _vm.layout.scrollY
                              ? `${_vm.border
                                ? _vm.layout.gutterWidth
                                : _vm.layout.gutterWidth || 0}px`
                              : '',
                          },
                          _vm.fixedHeight,
                        ],
                      },
                      [
                        _vm.showHeader
                          ? _c(
                            'div',
                            {
                              ref: 'rightFixedHeaderWrapper',
                              staticClass: 'el-table__fixed-header-wrapper',
                            },
                            [
                              _c('table-header', {
                                ref: 'rightFixedTableHeader',
                                style: {
                                  width: _vm.bodyWidth,
                                },
                                attrs: {
                                  fixed: 'right',
                                  border: _vm.border,
                                  store: _vm.store,
                                },
                              }),
                            ],
                            1,
                          )
                          : _vm._e(),
                        _c(
                          'div',
                          {
                            ref: 'rightFixedBodyWrapper',
                            staticClass: 'el-table__fixed-body-wrapper',
                            style: [
                              {
                                top: `${_vm.layout.headerHeight}px`,
                              },
                              _vm.fixedBodyHeight,
                            ],
                          },
                          [
                            _c('table-body', {
                              style: {
                                width: _vm.bodyWidth,
                              },
                              attrs: {
                                fixed: 'right',
                                store: _vm.store,
                                stripe: _vm.stripe,
                                'row-class-name': _vm.rowClassName,
                                'row-style': _vm.rowStyle,
                                highlight: _vm.highlightCurrentRow,
                              },
                            }),
                            _vm.$slots.append
                              ? _c('div', {
                                staticClass: 'el-table__append-gutter',
                                style: { height: `${_vm.layout.appendHeight}px` },
                              })
                              : _vm._e(),
                          ],
                          1,
                        ),
                        _vm.showSummary
                          ? _c(
                            'div',
                            {
                              directives: [
                                {
                                  name: 'show',
                                  rawName: 'v-show',
                                  value: _vm.data && _vm.data.length > 0,
                                  expression: 'data && data.length > 0',
                                },
                              ],
                              ref: 'rightFixedFooterWrapper',
                              staticClass: 'el-table__fixed-footer-wrapper',
                            },
                            [
                              _c('table-footer', {
                                style: {
                                  width: _vm.bodyWidth,
                                },
                                attrs: {
                                  fixed: 'right',
                                  border: _vm.border,
                                  'sum-text': _vm.sumText || _vm.t('el.table.sumText'),
                                  'summary-method': _vm.summaryMethod,
                                  store: _vm.store,
                                },
                              }),
                            ],
                            1,
                          )
                          : _vm._e(),
                      ],
                    )
                    : _vm._e(),
                  _vm.rightFixedColumns.length > 0
                    ? _c('div', {
                      ref: 'rightFixedPatch',
                      staticClass: 'el-table__fixed-right-patch',
                      style: {
                        width: _vm.layout.scrollY ? `${_vm.layout.gutterWidth}px` : '0',
                        height: `${_vm.layout.headerHeight}px`,
                      },
                    })
                    : _vm._e(),
                  _c('div', {
                    directives: [
                      {
                        name: 'show',
                        rawName: 'v-show',
                        value: _vm.resizeProxyVisible,
                        expression: 'resizeProxyVisible',
                      },
                    ],
                    ref: 'resizeProxy',
                    staticClass: 'el-table__column-resize-proxy',
                  }),
                ],
              );
            };
            const tablevue_type_template_id_493fe34e_staticRenderFns = [];
            tablevue_type_template_id_493fe34e_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/table/src/table.vue?vue&type=template&id=493fe34e&

            // EXTERNAL MODULE: external "element-ui/lib/checkbox"
            const checkbox_ = __webpack_require__(16);
            const checkbox_default = /* #__PURE__ */__webpack_require__.n(checkbox_);

            // EXTERNAL MODULE: external "throttle-debounce"
            const external_throttle_debounce_ = __webpack_require__(35);

            // EXTERNAL MODULE: external "normalize-wheel"
            const external_normalize_wheel_ = __webpack_require__(38);
            const external_normalize_wheel_default = /* #__PURE__ */__webpack_require__.n(external_normalize_wheel_);

            // CONCATENATED MODULE: ./src/directives/mousewheel.js

            const isFirefox = typeof navigator !== 'undefined' && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

            const mousewheel_mousewheel = function mousewheel(element, callback) {
              if (element && element.addEventListener) {
                element.addEventListener(isFirefox ? 'DOMMouseScroll' : 'mousewheel', function (event) {
                  const normalized = external_normalize_wheel_default()(event);
                  callback && callback.apply(this, [event, normalized]);
                });
              }
            };

            /* harmony default export */ const directives_mousewheel = ({
              bind: function bind(el, binding) {
                mousewheel_mousewheel(el, binding.value);
              },
            });
            // EXTERNAL MODULE: external "vue"
            const external_vue_ = __webpack_require__(6);
            const external_vue_default = /* #__PURE__ */__webpack_require__.n(external_vue_);

            // CONCATENATED MODULE: ./packages/table/src/util.js
            const util_typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

            const getCell = function getCell(event) {
              let cell = event.target;

              while (cell && cell.tagName.toUpperCase() !== 'HTML') {
                if (cell.tagName.toUpperCase() === 'TD') {
                  return cell;
                }
                cell = cell.parentNode;
              }

              return null;
            };

            const util_isObject = function isObject(obj) {
              return obj !== null && (typeof obj === 'undefined' ? 'undefined' : util_typeof(obj)) === 'object';
            };

            const util_orderBy = function orderBy(array, sortKey, reverse, sortMethod, sortBy) {
              if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
                return array;
              }
              if (typeof reverse === 'string') {
                reverse = reverse === 'descending' ? -1 : 1;
              } else {
                reverse = reverse && reverse < 0 ? -1 : 1;
              }
              const getKey = sortMethod ? null : function (value, index) {
                if (sortBy) {
                  if (!Array.isArray(sortBy)) {
                    sortBy = [sortBy];
                  }
                  return sortBy.map((by) => {
                    if (typeof by === 'string') {
                      return Object(util_.getValueByPath)(value, by);
                    }
                    return by(value, index, array);
                  });
                }
                if (sortKey !== '$key') {
                  if (util_isObject(value) && '$value' in value) value = value.$value;
                }
                return [util_isObject(value) ? Object(util_.getValueByPath)(value, sortKey) : value];
              };
              const compare = function compare(a, b) {
                if (sortMethod) {
                  return sortMethod(a.value, b.value);
                }
                for (let i = 0, len = a.key.length; i < len; i++) {
                  if (a.key[i] < b.key[i]) {
                    return -1;
                  }
                  if (a.key[i] > b.key[i]) {
                    return 1;
                  }
                }
                return 0;
              };
              return array.map((value, index) => ({
                value,
                index,
                key: getKey ? getKey(value, index) : null,
              })).sort((a, b) => {
                let order = compare(a, b);
                if (!order) {
                  // make stable https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
                  order = a.index - b.index;
                }
                return order * reverse;
              }).map((item) => item.value);
            };

            const getColumnById = function getColumnById(table, columnId) {
              let column = null;
              table.columns.forEach((item) => {
                if (item.id === columnId) {
                  column = item;
                }
              });
              return column;
            };

            const getColumnByKey = function getColumnByKey(table, columnKey) {
              let column = null;
              for (let i = 0; i < table.columns.length; i++) {
                const item = table.columns[i];
                if (item.columnKey === columnKey) {
                  column = item;
                  break;
                }
              }
              return column;
            };

            const getColumnByCell = function getColumnByCell(table, cell) {
              const matches = (cell.className || '').match(/el-table_[^\s]+/gm);
              if (matches) {
                return getColumnById(table, matches[0]);
              }
              return null;
            };

            const getRowIdentity = function getRowIdentity(row, rowKey) {
              if (!row) throw new Error('row is required when get row identity');
              if (typeof rowKey === 'string') {
                if (rowKey.indexOf('.') < 0) {
                  return row[rowKey];
                }
                const key = rowKey.split('.');
                let current = row;
                for (let i = 0; i < key.length; i++) {
                  current = current[key[i]];
                }
                return current;
              } if (typeof rowKey === 'function') {
                return rowKey.call(null, row);
              }
            };

            const getKeysMap = function getKeysMap(array, rowKey) {
              const arrayMap = {};
              (array || []).forEach((row, index) => {
                arrayMap[getRowIdentity(row, rowKey)] = { row, index };
              });
              return arrayMap;
            };

            function hasOwn(obj, key) {
              return Object.prototype.hasOwnProperty.call(obj, key);
            }

            function mergeOptions(defaults, config) {
              const options = {};
              let key = void 0;
              for (key in defaults) {
                options[key] = defaults[key];
              }
              for (key in config) {
                if (hasOwn(config, key)) {
                  const value = config[key];
                  if (typeof value !== 'undefined') {
                    options[key] = value;
                  }
                }
              }
              return options;
            }

            function parseWidth(width) {
              if (width !== undefined) {
                width = parseInt(width, 10);
                if (isNaN(width)) {
                  width = null;
                }
              }
              return width;
            }

            function parseMinWidth(minWidth) {
              if (typeof minWidth !== 'undefined') {
                minWidth = parseWidth(minWidth);
                if (isNaN(minWidth)) {
                  minWidth = 80;
                }
              }
              return minWidth;
            }

            function parseHeight(height) {
              if (typeof height === 'number') {
                return height;
              }
              if (typeof height === 'string') {
                if (/^\d+(?:px)?$/.test(height)) {
                  return parseInt(height, 10);
                }
                return height;
              }
              return null;
            }

            // https://github.com/reduxjs/redux/blob/master/src/compose.js
            function compose() {
              for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
                funcs[_key] = arguments[_key];
              }

              if (funcs.length === 0) {
                return function (arg) {
                  return arg;
                };
              }
              if (funcs.length === 1) {
                return funcs[0];
              }
              return funcs.reduce((a, b) => function () {
                return a(b.apply(undefined, arguments));
              });
            }

            function toggleRowStatus(statusArr, row, newVal) {
              let changed = false;
              const index = statusArr.indexOf(row);
              const included = index !== -1;

              const addRow = function addRow() {
                statusArr.push(row);
                changed = true;
              };
              const removeRow = function removeRow() {
                statusArr.splice(index, 1);
                changed = true;
              };

              if (typeof newVal === 'boolean') {
                if (newVal && !included) {
                  addRow();
                } else if (!newVal && included) {
                  removeRow();
                }
              } else if (included) {
                removeRow();
              } else {
                addRow();
              }
              return changed;
            }

            function walkTreeNode(root, cb) {
              const childrenKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'children';
              const lazyKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'hasChildren';

              const isNil = function isNil(array) {
                return !(Array.isArray(array) && array.length);
              };

              function _walker(parent, children, level) {
                cb(parent, children, level);
                children.forEach((item) => {
                  if (item[lazyKey]) {
                    cb(item, null, level + 1);
                    return;
                  }
                  const children = item[childrenKey];
                  if (!isNil(children)) {
                    _walker(item, children, level + 1);
                  }
                });
              }

              root.forEach((item) => {
                if (item[lazyKey]) {
                  cb(item, null, 0);
                  return;
                }
                const children = item[childrenKey];
                if (!isNil(children)) {
                  _walker(item, children, 0);
                }
              });
            }
            // CONCATENATED MODULE: ./packages/table/src/store/expand.js

            /* harmony default export */ const expand = ({
              data: function data() {
                return {
                  states: {
                    defaultExpandAll: false,
                    expandRows: [],
                  },
                };
              },

              methods: {
                updateExpandRows: function updateExpandRows() {
                  const _states = this.states;
                  const _states$data = _states.data;
                  const data = _states$data === undefined ? [] : _states$data;
                  const { rowKey } = _states;
                  const { defaultExpandAll } = _states;
                  const { expandRows } = _states;

                  if (defaultExpandAll) {
                    this.states.expandRows = data.slice();
                  } else if (rowKey) {
                    // TODO：这里的代码可以优化
                    const expandRowsMap = getKeysMap(expandRows, rowKey);
                    this.states.expandRows = data.reduce((prev, row) => {
                      const rowId = getRowIdentity(row, rowKey);
                      const rowInfo = expandRowsMap[rowId];
                      if (rowInfo) {
                        prev.push(row);
                      }
                      return prev;
                    }, []);
                  } else {
                    this.states.expandRows = [];
                  }
                },
                toggleRowExpansion: function toggleRowExpansion(row, expanded) {
                  const changed = toggleRowStatus(this.states.expandRows, row, expanded);
                  if (changed) {
                    this.table.$emit('expand-change', row, this.states.expandRows.slice());
                    this.scheduleLayout();
                  }
                },
                setExpandRowKeys: function setExpandRowKeys(rowKeys) {
                  this.assertRowKey();
                  // TODO：这里的代码可以优化
                  const _states2 = this.states;
                  const { data } = _states2;
                  const { rowKey } = _states2;

                  const keysMap = getKeysMap(data, rowKey);
                  this.states.expandRows = rowKeys.reduce((prev, cur) => {
                    const info = keysMap[cur];
                    if (info) {
                      prev.push(info.row);
                    }
                    return prev;
                  }, []);
                },
                isRowExpanded: function isRowExpanded(row) {
                  const _states3 = this.states;
                  const _states3$expandRows = _states3.expandRows;
                  const expandRows = _states3$expandRows === undefined ? [] : _states3$expandRows;
                  const { rowKey } = _states3;

                  if (rowKey) {
                    const expandMap = getKeysMap(expandRows, rowKey);
                    return !!expandMap[getRowIdentity(row, rowKey)];
                  }
                  return expandRows.indexOf(row) !== -1;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/table/src/store/current.js

            /* harmony default export */ const current = ({
              data: function data() {
                return {
                  states: {
                    // 不可响应的，设置 currentRowKey 时，data 不一定存在，也许无法算出正确的 currentRow
                    // 把该值缓存一下，当用户点击修改 currentRow 时，把该值重置为 null
                    _currentRowKey: null,
                    currentRow: null,
                  },
                };
              },

              methods: {
                setCurrentRowKey: function setCurrentRowKey(key) {
                  this.assertRowKey();
                  this.states._currentRowKey = key;
                  this.setCurrentRowByKey(key);
                },
                restoreCurrentRowKey: function restoreCurrentRowKey() {
                  this.states._currentRowKey = null;
                },
                setCurrentRowByKey: function setCurrentRowByKey(key) {
                  const { states } = this;
                  const _states$data = states.data;
                  const data = _states$data === undefined ? [] : _states$data;
                  const { rowKey } = states;

                  let currentRow = null;
                  if (rowKey) {
                    currentRow = Object(util_.arrayFind)(data, (item) => getRowIdentity(item, rowKey) === key);
                  }
                  states.currentRow = currentRow;
                },
                updateCurrentRow: function updateCurrentRow(currentRow) {
                  const { states } = this;
                  const { table } = this;

                  const oldCurrentRow = states.currentRow;
                  if (currentRow && currentRow !== oldCurrentRow) {
                    states.currentRow = currentRow;
                    table.$emit('current-change', currentRow, oldCurrentRow);
                    return;
                  }
                  if (!currentRow && oldCurrentRow) {
                    states.currentRow = null;
                    table.$emit('current-change', null, oldCurrentRow);
                  }
                },
                updateCurrentRowData: function updateCurrentRowData() {
                  const { states } = this;
                  const { table } = this;
                  const { rowKey } = states;
                  const { _currentRowKey } = states;
                  // data 为 null 时，解构时的默认值会被忽略

                  const data = states.data || [];
                  const oldCurrentRow = states.currentRow;

                  // 当 currentRow 不在 data 中时尝试更新数据
                  if (data.indexOf(oldCurrentRow) === -1 && oldCurrentRow) {
                    if (rowKey) {
                      const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
                      this.setCurrentRowByKey(currentRowKey);
                    } else {
                      states.currentRow = null;
                    }
                    if (states.currentRow === null) {
                      table.$emit('current-change', null, oldCurrentRow);
                    }
                  } else if (_currentRowKey) {
                    // 把初始时下设置的 rowKey 转化成 rowData
                    this.setCurrentRowByKey(_currentRowKey);
                    this.restoreCurrentRowKey();
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/table/src/store/tree.js
            const _extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            /* harmony default export */ const tree = ({
              data: function data() {
                return {
                  states: {
                    // defaultExpandAll 存在于 expand.js 中，这里不重复添加
                    // 在展开行中，expandRowKeys 会被转化成 expandRows，expandRowKeys 这个属性只是记录了 TreeTable 行的展开
                    // TODO: 拆分为独立的 TreeTable，统一用法
                    expandRowKeys: [],
                    treeData: {},
                    indent: 16,
                    lazy: false,
                    lazyTreeNodeMap: {},
                    lazyColumnIdentifier: 'hasChildren',
                    childrenColumnName: 'children',
                  },
                };
              },

              computed: {
                // 嵌入型的数据，watch 无法是检测到变化 https://github.com/ElemeFE/element/issues/14998
                // TODO: 使用 computed 解决该问题，是否会造成性能问题？
                // @return { id: { level, children } }
                normalizedData: function normalizedData() {
                  if (!this.states.rowKey) return {};
                  const data = this.states.data || [];
                  return this.normalize(data);
                },

                // @return { id: { children } }
                // 针对懒加载的情形，不处理嵌套数据
                normalizedLazyNode: function normalizedLazyNode() {
                  const _states = this.states;
                  const { rowKey } = _states;
                  const { lazyTreeNodeMap } = _states;
                  const { lazyColumnIdentifier } = _states;

                  const keys = Object.keys(lazyTreeNodeMap);
                  const res = {};
                  if (!keys.length) return res;
                  keys.forEach((key) => {
                    if (lazyTreeNodeMap[key].length) {
                      const item = { children: [] };
                      lazyTreeNodeMap[key].forEach((row) => {
                        const currentRowKey = getRowIdentity(row, rowKey);
                        item.children.push(currentRowKey);
                        if (row[lazyColumnIdentifier] && !res[currentRowKey]) {
                          res[currentRowKey] = { children: [] };
                        }
                      });
                      res[key] = item;
                    }
                  });
                  return res;
                },
              },

              watch: {
                normalizedData: 'updateTreeData',
                normalizedLazyNode: 'updateTreeData',
              },

              methods: {
                normalize: function normalize(data) {
                  const _states2 = this.states;
                  const { childrenColumnName } = _states2;
                  const { lazyColumnIdentifier } = _states2;
                  const { rowKey } = _states2;
                  const { lazy } = _states2;

                  const res = {};
                  walkTreeNode(data, (parent, children, level) => {
                    const parentId = getRowIdentity(parent, rowKey);
                    if (Array.isArray(children)) {
                      res[parentId] = {
                        children: children.map((row) => getRowIdentity(row, rowKey)),
                        level,
                      };
                    } else if (lazy) {
                      // 当 children 不存在且 lazy 为 true，该节点即为懒加载的节点
                      res[parentId] = {
                        children: [],
                        lazy: true,
                        level,
                      };
                    }
                  }, childrenColumnName, lazyColumnIdentifier);
                  return res;
                },
                updateTreeData: function updateTreeData() {
                  const nested = this.normalizedData;
                  const { normalizedLazyNode } = this;
                  const keys = Object.keys(nested);
                  const newTreeData = {};
                  if (keys.length) {
                    const _states3 = this.states;
                    const oldTreeData = _states3.treeData;
                    const { defaultExpandAll } = _states3;
                    const { expandRowKeys } = _states3;
                    const { lazy } = _states3;

                    const rootLazyRowKeys = [];
                    const getExpanded = function getExpanded(oldValue, key) {
                      const included = defaultExpandAll || expandRowKeys && expandRowKeys.indexOf(key) !== -1;
                      return !!(oldValue && oldValue.expanded || included);
                    };
                    // 合并 expanded 与 display，确保数据刷新后，状态不变
                    keys.forEach((key) => {
                      const oldValue = oldTreeData[key];
                      const newValue = { ...nested[key] };
                      newValue.expanded = getExpanded(oldValue, key);
                      if (newValue.lazy) {
                        const _ref = oldValue || {};
                        const _ref$loaded = _ref.loaded;
                        const loaded = _ref$loaded === undefined ? false : _ref$loaded;
                        const _ref$loading = _ref.loading;
                        const loading = _ref$loading === undefined ? false : _ref$loading;

                        newValue.loaded = !!loaded;
                        newValue.loading = !!loading;
                        rootLazyRowKeys.push(key);
                      }
                      newTreeData[key] = newValue;
                    });
                    // 根据懒加载数据更新 treeData
                    const lazyKeys = Object.keys(normalizedLazyNode);
                    if (lazy && lazyKeys.length && rootLazyRowKeys.length) {
                      lazyKeys.forEach((key) => {
                        const oldValue = oldTreeData[key];
                        const lazyNodeChildren = normalizedLazyNode[key].children;
                        if (rootLazyRowKeys.indexOf(key) !== -1) {
                          // 懒加载的 root 节点，更新一下原有的数据，原来的 children 一定是空数组
                          if (newTreeData[key].children.length !== 0) {
                            throw new Error('[ElTable]children must be an empty array.');
                          }
                          newTreeData[key].children = lazyNodeChildren;
                        } else {
                          const _ref2 = oldValue || {};
                          const _ref2$loaded = _ref2.loaded;
                          const loaded = _ref2$loaded === undefined ? false : _ref2$loaded;
                          const _ref2$loading = _ref2.loading;
                          const loading = _ref2$loading === undefined ? false : _ref2$loading;

                          newTreeData[key] = {
                            lazy: true,
                            loaded: !!loaded,
                            loading: !!loading,
                            expanded: getExpanded(oldValue, key),
                            children: lazyNodeChildren,
                            level: '',
                          };
                        }
                      });
                    }
                  }
                  this.states.treeData = newTreeData;
                  this.updateTableScrollY();
                },
                updateTreeExpandKeys: function updateTreeExpandKeys(value) {
                  this.states.expandRowKeys = value;
                  this.updateTreeData();
                },
                toggleTreeExpansion: function toggleTreeExpansion(row, expanded) {
                  this.assertRowKey();

                  const _states4 = this.states;
                  const { rowKey } = _states4;
                  const { treeData } = _states4;

                  const id = getRowIdentity(row, rowKey);
                  const data = id && treeData[id];
                  if (id && data && 'expanded' in data) {
                    const oldExpanded = data.expanded;
                    expanded = typeof expanded === 'undefined' ? !data.expanded : expanded;
                    treeData[id].expanded = expanded;
                    if (oldExpanded !== expanded) {
                      this.table.$emit('expand-change', row, expanded);
                    }
                    this.updateTableScrollY();
                  }
                },
                loadOrToggle: function loadOrToggle(row) {
                  this.assertRowKey();
                  const _states5 = this.states;
                  const { lazy } = _states5;
                  const { treeData } = _states5;
                  const { rowKey } = _states5;

                  const id = getRowIdentity(row, rowKey);
                  const data = treeData[id];
                  if (lazy && data && 'loaded' in data && !data.loaded) {
                    this.loadData(row, id, data);
                  } else {
                    this.toggleTreeExpansion(row);
                  }
                },
                loadData: function loadData(row, key, treeNode) {
                  const _this = this;

                  const { load } = this.table;
                  const _states6 = this.states;
                  const { lazyTreeNodeMap } = _states6;
                  const { treeData } = _states6;

                  if (load && !treeData[key].loaded) {
                    treeData[key].loading = true;
                    load(row, treeNode, (data) => {
                      if (!Array.isArray(data)) {
                        throw new Error('[ElTable] data must be an array');
                      }
                      treeData[key].loading = false;
                      treeData[key].loaded = true;
                      treeData[key].expanded = true;
                      if (data.length) {
                        _this.$set(lazyTreeNodeMap, key, data);
                      }
                      _this.table.$emit('expand-change', row, true);
                    });
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/table/src/store/watcher.js

            const watcher_sortData = function sortData(data, states) {
              const { sortingColumn } = states;
              if (!sortingColumn || typeof sortingColumn.sortable === 'string') {
                return data;
              }
              return util_orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
            };

            const doFlattenColumns = function doFlattenColumns(columns) {
              const result = [];
              columns.forEach((column) => {
                if (column.children) {
                  result.push.apply(result, doFlattenColumns(column.children));
                } else {
                  result.push(column);
                }
              });
              return result;
            };

            /* harmony default export */ const watcher = (external_vue_default.a.extend({
              data: function data() {
                return {
                  states: {
                    // 3.0 版本后要求必须设置该属性
                    rowKey: null,

                    // 渲染的数据来源，是对 table 中的 data 过滤排序后的结果
                    data: [],

                    // 是否包含固定列
                    isComplex: false,

                    // 列
                    _columns: [], // 不可响应的
                    originColumns: [],
                    columns: [],
                    fixedColumns: [],
                    rightFixedColumns: [],
                    leafColumns: [],
                    fixedLeafColumns: [],
                    rightFixedLeafColumns: [],
                    leafColumnsLength: 0,
                    fixedLeafColumnsLength: 0,
                    rightFixedLeafColumnsLength: 0,

                    // 选择
                    isAllSelected: false,
                    selection: [],
                    reserveSelection: false,
                    selectOnIndeterminate: false,
                    selectable: null,

                    // 过滤
                    filters: {}, // 不可响应的
                    filteredData: null,

                    // 排序
                    sortingColumn: null,
                    sortProp: null,
                    sortOrder: null,

                    hoverRow: null,
                  },
                };
              },

              mixins: [expand, current, tree],

              methods: {
                // 检查 rowKey 是否存在
                assertRowKey: function assertRowKey() {
                  const { rowKey } = this.states;
                  if (!rowKey) throw new Error('[ElTable] prop row-key is required');
                },

                // 更新列
                updateColumns: function updateColumns() {
                  const { states } = this;
                  const _columns = states._columns || [];
                  states.fixedColumns = _columns.filter((column) => column.fixed === true || column.fixed === 'left');
                  states.rightFixedColumns = _columns.filter((column) => column.fixed === 'right');

                  if (states.fixedColumns.length > 0 && _columns[0] && _columns[0].type === 'selection' && !_columns[0].fixed) {
                    _columns[0].fixed = true;
                    states.fixedColumns.unshift(_columns[0]);
                  }

                  const notFixedColumns = _columns.filter((column) => !column.fixed);
                  states.originColumns = [].concat(states.fixedColumns).concat(notFixedColumns).concat(states.rightFixedColumns);

                  const leafColumns = doFlattenColumns(notFixedColumns);
                  const fixedLeafColumns = doFlattenColumns(states.fixedColumns);
                  const rightFixedLeafColumns = doFlattenColumns(states.rightFixedColumns);

                  states.leafColumnsLength = leafColumns.length;
                  states.fixedLeafColumnsLength = fixedLeafColumns.length;
                  states.rightFixedLeafColumnsLength = rightFixedLeafColumns.length;

                  states.columns = [].concat(fixedLeafColumns).concat(leafColumns).concat(rightFixedLeafColumns);
                  states.isComplex = states.fixedColumns.length > 0 || states.rightFixedColumns.length > 0;
                },

                // 更新 DOM
                scheduleLayout: function scheduleLayout(needUpdateColumns) {
                  if (needUpdateColumns) {
                    this.updateColumns();
                  }
                  this.table.debouncedUpdateLayout();
                },

                // 选择
                isSelected: function isSelected(row) {
                  const _states$selection = this.states.selection;
                  const selection = _states$selection === undefined ? [] : _states$selection;

                  return selection.indexOf(row) > -1;
                },
                clearSelection: function clearSelection() {
                  const { states } = this;
                  states.isAllSelected = false;
                  const oldSelection = states.selection;
                  if (oldSelection.length) {
                    states.selection = [];
                    this.table.$emit('selection-change', []);
                  }
                },
                cleanSelection: function cleanSelection() {
                  const { states } = this;
                  const { data } = states;
                  const { rowKey } = states;
                  const { selection } = states;

                  let deleted = void 0;
                  if (rowKey) {
                    deleted = [];
                    const selectedMap = getKeysMap(selection, rowKey);
                    const dataMap = getKeysMap(data, rowKey);
                    for (const key in selectedMap) {
                      if (selectedMap.hasOwnProperty(key) && !dataMap[key]) {
                        deleted.push(selectedMap[key].row);
                      }
                    }
                  } else {
                    deleted = selection.filter((item) => data.indexOf(item) === -1);
                  }
                  if (deleted.length) {
                    const newSelection = selection.filter((item) => deleted.indexOf(item) === -1);
                    states.selection = newSelection;
                    this.table.$emit('selection-change', newSelection.slice());
                  }
                },
                toggleRowSelection: function toggleRowSelection(row, selected) {
                  const emitChange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

                  const changed = toggleRowStatus(this.states.selection, row, selected);
                  if (changed) {
                    const newSelection = (this.states.selection || []).slice();
                    // 调用 API 修改选中值，不触发 select 事件
                    if (emitChange) {
                      this.table.$emit('select', newSelection, row);
                    }
                    this.table.$emit('selection-change', newSelection);
                  }
                },
                _toggleAllSelection: function _toggleAllSelection() {
                  const { states } = this;
                  const _states$data = states.data;
                  const data = _states$data === undefined ? [] : _states$data;
                  const { selection } = states;
                  // when only some rows are selected (but not all), select or deselect all of them
                  // depending on the value of selectOnIndeterminate

                  const value = states.selectOnIndeterminate ? !states.isAllSelected : !(states.isAllSelected || selection.length);
                  states.isAllSelected = value;

                  let selectionChanged = false;
                  data.forEach((row, index) => {
                    if (states.selectable) {
                      if (states.selectable.call(null, row, index) && toggleRowStatus(selection, row, value)) {
                        selectionChanged = true;
                      }
                    } else if (toggleRowStatus(selection, row, value)) {
                      selectionChanged = true;
                    }
                  });

                  if (selectionChanged) {
                    this.table.$emit('selection-change', selection ? selection.slice() : []);
                  }
                  this.table.$emit('select-all', selection);
                },
                updateSelectionByRowKey: function updateSelectionByRowKey() {
                  const { states } = this;
                  const { selection } = states;
                  const { rowKey } = states;
                  const { data } = states;

                  const selectedMap = getKeysMap(selection, rowKey);
                  data.forEach((row) => {
                    const rowId = getRowIdentity(row, rowKey);
                    const rowInfo = selectedMap[rowId];
                    if (rowInfo) {
                      selection[rowInfo.index] = row;
                    }
                  });
                },
                updateAllSelected: function updateAllSelected() {
                  const { states } = this;
                  const { selection } = states;
                  const { rowKey } = states;
                  const { selectable } = states;
                  // data 为 null 时，解构时的默认值会被忽略

                  const data = states.data || [];
                  if (data.length === 0) {
                    states.isAllSelected = false;
                    return;
                  }

                  let selectedMap = void 0;
                  if (rowKey) {
                    selectedMap = getKeysMap(selection, rowKey);
                  }
                  const isSelected = function isSelected(row) {
                    if (selectedMap) {
                      return !!selectedMap[getRowIdentity(row, rowKey)];
                    }
                    return selection.indexOf(row) !== -1;
                  };
                  let isAllSelected = true;
                  let selectedCount = 0;
                  for (let i = 0, j = data.length; i < j; i++) {
                    const item = data[i];
                    const isRowSelectable = selectable && selectable.call(null, item, i);
                    if (!isSelected(item)) {
                      if (!selectable || isRowSelectable) {
                        isAllSelected = false;
                        break;
                      }
                    } else {
                      selectedCount++;
                    }
                  }

                  if (selectedCount === 0) isAllSelected = false;
                  states.isAllSelected = isAllSelected;
                },

                // 过滤与排序
                updateFilters: function updateFilters(columns, values) {
                  if (!Array.isArray(columns)) {
                    columns = [columns];
                  }
                  const { states } = this;
                  const filters = {};
                  columns.forEach((col) => {
                    states.filters[col.id] = values;
                    filters[col.columnKey || col.id] = values;
                  });

                  return filters;
                },
                updateSort: function updateSort(column, prop, order) {
                  if (this.states.sortingColumn && this.states.sortingColumn !== column) {
                    this.states.sortingColumn.order = null;
                  }
                  this.states.sortingColumn = column;
                  this.states.sortProp = prop;
                  this.states.sortOrder = order;
                },
                execFilter: function execFilter() {
                  const _this = this;

                  const { states } = this;
                  const { _data } = states;
                  const { filters } = states;

                  let data = _data;

                  Object.keys(filters).forEach((columnId) => {
                    const values = states.filters[columnId];
                    if (!values || values.length === 0) return;
                    const column = getColumnById(_this.states, columnId);
                    if (column && column.filterMethod) {
                      data = data.filter((row) => values.some((value) => column.filterMethod.call(null, value, row, column)));
                    }
                  });

                  states.filteredData = data;
                },
                execSort: function execSort() {
                  const { states } = this;
                  states.data = watcher_sortData(states.filteredData, states);
                },

                // 根据 filters 与 sort 去过滤 data
                execQuery: function execQuery(ignore) {
                  if (!(ignore && ignore.filter)) {
                    this.execFilter();
                  }
                  this.execSort();
                },
                clearFilter: function clearFilter(columnKeys) {
                  const { states } = this;
                  const _table$$refs = this.table.$refs;
                  const { tableHeader } = _table$$refs;
                  const { fixedTableHeader } = _table$$refs;
                  const { rightFixedTableHeader } = _table$$refs;

                  let panels = {};
                  if (tableHeader) panels = merge_default()(panels, tableHeader.filterPanels);
                  if (fixedTableHeader) panels = merge_default()(panels, fixedTableHeader.filterPanels);
                  if (rightFixedTableHeader) panels = merge_default()(panels, rightFixedTableHeader.filterPanels);

                  const keys = Object.keys(panels);
                  if (!keys.length) return;

                  if (typeof columnKeys === 'string') {
                    columnKeys = [columnKeys];
                  }

                  if (Array.isArray(columnKeys)) {
                    const columns = columnKeys.map((key) => getColumnByKey(states, key));
                    keys.forEach((key) => {
                      const column = columns.find((col) => col.id === key);
                      if (column) {
                        // TODO: 优化这里的代码
                        panels[key].filteredValue = [];
                      }
                    });
                    this.commit('filterChange', {
                      column: columns,
                      values: [],
                      silent: true,
                      multi: true,
                    });
                  } else {
                    keys.forEach((key) => {
                      // TODO: 优化这里的代码
                      panels[key].filteredValue = [];
                    });

                    states.filters = {};
                    this.commit('filterChange', {
                      column: {},
                      values: [],
                      silent: true,
                    });
                  }
                },
                clearSort: function clearSort() {
                  const { states } = this;
                  if (!states.sortingColumn) return;

                  this.updateSort(null, null, null);
                  this.commit('changeSortCondition', {
                    silent: true,
                  });
                },

                // 适配层，expand-row-keys 在 Expand 与 TreeTable 中都有使用
                setExpandRowKeysAdapter: function setExpandRowKeysAdapter(val) {
                  // 这里会触发额外的计算，但为了兼容性，暂时这么做
                  this.setExpandRowKeys(val);
                  this.updateTreeExpandKeys(val);
                },

                // 展开行与 TreeTable 都要使用
                toggleRowExpansionAdapter: function toggleRowExpansionAdapter(row, expanded) {
                  const hasExpandColumn = this.states.columns.some((_ref) => {
                    const { type } = _ref;
                    return type === 'expand';
                  });
                  if (hasExpandColumn) {
                    this.toggleRowExpansion(row, expanded);
                  } else {
                    this.toggleTreeExpansion(row, expanded);
                  }
                },
              },
            }));
            // CONCATENATED MODULE: ./packages/table/src/store/index.js

            watcher.prototype.mutations = {
              setData: function setData(states, data) {
                const dataInstanceChanged = states._data !== data;
                states._data = data;

                this.execQuery();
                // 数据变化，更新部分数据。
                // 没有使用 computed，而是手动更新部分数据 https://github.com/vuejs/vue/issues/6660#issuecomment-331417140
                this.updateCurrentRowData();
                this.updateExpandRows();
                if (states.reserveSelection) {
                  this.assertRowKey();
                  this.updateSelectionByRowKey();
                } else if (dataInstanceChanged) {
                  this.clearSelection();
                } else {
                  this.cleanSelection();
                }
                this.updateAllSelected();

                this.updateTableScrollY();
              },
              insertColumn: function insertColumn(states, column, index, parent) {
                let array = states._columns;
                if (parent) {
                  array = parent.children;
                  if (!array) array = parent.children = [];
                }

                if (typeof index !== 'undefined') {
                  array.splice(index, 0, column);
                } else {
                  array.push(column);
                }

                if (column.type === 'selection') {
                  states.selectable = column.selectable;
                  states.reserveSelection = column.reserveSelection;
                }

                if (this.table.$ready) {
                  this.updateColumns(); // hack for dynamics insert column
                  this.scheduleLayout();
                }
              },
              removeColumn: function removeColumn(states, column, parent) {
                let array = states._columns;
                if (parent) {
                  array = parent.children;
                  if (!array) array = parent.children = [];
                }
                if (array) {
                  array.splice(array.indexOf(column), 1);
                }

                if (this.table.$ready) {
                  this.updateColumns(); // hack for dynamics remove column
                  this.scheduleLayout();
                }
              },
              sort: function sort(states, options) {
                const { prop } = options;
                const { order } = options;
                const { init } = options;

                if (prop) {
                  const column = Object(util_.arrayFind)(states.columns, (column) => column.property === prop);
                  if (column) {
                    column.order = order;
                    this.updateSort(column, prop, order);
                    this.commit('changeSortCondition', { init });
                  }
                }
              },
              changeSortCondition: function changeSortCondition(states, options) {
                // 修复 pr https://github.com/ElemeFE/element/pull/15012 导致的 bug
                const column = states.sortingColumn;
                const prop = states.sortProp;
                const order = states.sortOrder;

                if (order === null) {
                  states.sortingColumn = null;
                  states.sortProp = null;
                }
                const ingore = { filter: true };
                this.execQuery(ingore);

                if (!options || !(options.silent || options.init)) {
                  this.table.$emit('sort-change', {
                    column,
                    prop,
                    order,
                  });
                }

                this.updateTableScrollY();
              },
              filterChange: function filterChange(states, options) {
                const { column } = options;
                const { values } = options;
                const { silent } = options;

                const newFilters = this.updateFilters(column, values);

                this.execQuery();

                if (!silent) {
                  this.table.$emit('filter-change', newFilters);
                }

                this.updateTableScrollY();
              },
              toggleAllSelection: function toggleAllSelection() {
                this.toggleAllSelection();
              },
              rowSelectedChanged: function rowSelectedChanged(states, row) {
                this.toggleRowSelection(row);
                this.updateAllSelected();
              },
              setHoverRow: function setHoverRow(states, row) {
                states.hoverRow = row;
              },
              setCurrentRow: function setCurrentRow(states, row) {
                this.updateCurrentRow(row);
              },
            };

            watcher.prototype.commit = function (name) {
              const { mutations } = this;
              if (mutations[name]) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }

                mutations[name].apply(this, [this.states].concat(args));
              } else {
                throw new Error(`Action not found: ${name}`);
              }
            };

            watcher.prototype.updateTableScrollY = function () {
              external_vue_default.a.nextTick(this.table.updateScrollY);
            };

            /* harmony default export */ const src_store = (watcher);
            // CONCATENATED MODULE: ./packages/table/src/store/helper.js

            function createStore(table) {
              const initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

              if (!table) {
                throw new Error('Table is required.');
              }

              const store = new src_store();
              store.table = table;
              // fix https://github.com/ElemeFE/element/issues/14075
              // related pr https://github.com/ElemeFE/element/pull/14146
              store.toggleAllSelection = debounce_default()(10, store._toggleAllSelection);
              Object.keys(initialState).forEach((key) => {
                store.states[key] = initialState[key];
              });
              return store;
            }

            function mapStates(mapper) {
              const res = {};
              Object.keys(mapper).forEach((key) => {
                const value = mapper[key];
                let fn = void 0;
                if (typeof value === 'string') {
                  fn = function fn() {
                    return this.store.states[value];
                  };
                } else if (typeof value === 'function') {
                  fn = function fn() {
                    return value.call(this, this.store.states);
                  };
                } else {
                  console.error('invalid value type');
                }
                if (fn) {
                  res[key] = fn;
                }
              });
              return res;
            }
            // EXTERNAL MODULE: external "element-ui/lib/utils/scrollbar-width"
            const scrollbar_width_ = __webpack_require__(30);
            const scrollbar_width_default = /* #__PURE__ */__webpack_require__.n(scrollbar_width_);

            // CONCATENATED MODULE: ./packages/table/src/table-layout.js
            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

            const table_layout_TableLayout = (function () {
              function TableLayout(options) {
                _classCallCheck(this, TableLayout);

                this.observers = [];
                this.table = null;
                this.store = null;
                this.columns = null;
                this.fit = true;
                this.showHeader = true;

                this.height = null;
                this.scrollX = false;
                this.scrollY = false;
                this.bodyWidth = null;
                this.fixedWidth = null;
                this.rightFixedWidth = null;
                this.tableHeight = null;
                this.headerHeight = 44; // Table Header Height
                this.appendHeight = 0; // Append Slot Height
                this.footerHeight = 44; // Table Footer Height
                this.viewportHeight = null; // Table Height - Scroll Bar Height
                this.bodyHeight = null; // Table Height - Table Header Height
                this.fixedBodyHeight = null; // Table Height - Table Header Height - Scroll Bar Height
                this.gutterWidth = scrollbar_width_default()();

                for (const name in options) {
                  if (options.hasOwnProperty(name)) {
                    this[name] = options[name];
                  }
                }

                if (!this.table) {
                  throw new Error('table is required for Table Layout');
                }
                if (!this.store) {
                  throw new Error('store is required for Table Layout');
                }
              }

              TableLayout.prototype.updateScrollY = function updateScrollY() {
                const { height } = this;
                if (height === null) return false;
                const { bodyWrapper } = this.table;
                if (this.table.$el && bodyWrapper) {
                  const body = bodyWrapper.querySelector('.el-table__body');
                  const prevScrollY = this.scrollY;
                  const scrollY = body.offsetHeight > this.bodyHeight;
                  this.scrollY = scrollY;
                  return prevScrollY !== scrollY;
                }
                return false;
              };

              TableLayout.prototype.setHeight = function setHeight(value) {
                const _this = this;

                const prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'height';

                if (external_vue_default.a.prototype.$isServer) return;
                const el = this.table.$el;
                value = parseHeight(value);
                this.height = value;

                if (!el && (value || value === 0)) {
                  return external_vue_default.a.nextTick(() => _this.setHeight(value, prop));
                }

                if (typeof value === 'number') {
                  el.style[prop] = `${value}px`;
                  this.updateElsHeight();
                } else if (typeof value === 'string') {
                  el.style[prop] = value;
                  this.updateElsHeight();
                }
              };

              TableLayout.prototype.setMaxHeight = function setMaxHeight(value) {
                this.setHeight(value, 'max-height');
              };

              TableLayout.prototype.getFlattenColumns = function getFlattenColumns() {
                const flattenColumns = [];
                const { columns } = this.table;
                columns.forEach((column) => {
                  if (column.isColumnGroup) {
                    flattenColumns.push.apply(flattenColumns, column.columns);
                  } else {
                    flattenColumns.push(column);
                  }
                });

                return flattenColumns;
              };

              TableLayout.prototype.updateElsHeight = function updateElsHeight() {
                const _this2 = this;

                if (!this.table.$ready) {
                  return external_vue_default.a.nextTick(() => _this2.updateElsHeight());
                }
                const _table$$refs = this.table.$refs;
                const { headerWrapper } = _table$$refs;
                const { appendWrapper } = _table$$refs;
                const { footerWrapper } = _table$$refs;

                this.appendHeight = appendWrapper ? appendWrapper.offsetHeight : 0;

                if (this.showHeader && !headerWrapper) return;

                // fix issue (https://github.com/ElemeFE/element/pull/16956)
                const headerTrElm = headerWrapper ? headerWrapper.querySelector('.el-table__header tr') : null;
                const noneHeader = this.headerDisplayNone(headerTrElm);

                const headerHeight = this.headerHeight = !this.showHeader ? 0 : headerWrapper.offsetHeight;
                if (this.showHeader && !noneHeader && headerWrapper.offsetWidth > 0 && (this.table.columns || []).length > 0 && headerHeight < 2) {
                  return external_vue_default.a.nextTick(() => _this2.updateElsHeight());
                }
                const tableHeight = this.tableHeight = this.table.$el.clientHeight;
                const footerHeight = this.footerHeight = footerWrapper ? footerWrapper.offsetHeight : 0;
                if (this.height !== null) {
                  this.bodyHeight = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
                }
                this.fixedBodyHeight = this.scrollX ? this.bodyHeight - this.gutterWidth : this.bodyHeight;

                const noData = !(this.store.states.data && this.store.states.data.length);
                this.viewportHeight = this.scrollX ? tableHeight - (noData ? 0 : this.gutterWidth) : tableHeight;

                this.updateScrollY();
                this.notifyObservers('scrollable');
              };

              TableLayout.prototype.headerDisplayNone = function headerDisplayNone(elm) {
                if (!elm) return true;
                let headerChild = elm;
                while (headerChild.tagName !== 'DIV') {
                  if (getComputedStyle(headerChild).display === 'none') {
                    return true;
                  }
                  headerChild = headerChild.parentElement;
                }
                return false;
              };

              TableLayout.prototype.updateColumnsWidth = function updateColumnsWidth() {
                if (external_vue_default.a.prototype.$isServer) return;
                const { fit } = this;
                const bodyWidth = this.table.$el.clientWidth;
                let bodyMinWidth = 0;

                const flattenColumns = this.getFlattenColumns();
                const flexColumns = flattenColumns.filter((column) => typeof column.width !== 'number');

                flattenColumns.forEach((column) => {
                  // Clean those columns whose width changed from flex to unflex
                  if (typeof column.width === 'number' && column.realWidth) column.realWidth = null;
                });

                if (flexColumns.length > 0 && fit) {
                  flattenColumns.forEach((column) => {
                    bodyMinWidth += column.width || column.minWidth || 80;
                  });

                  const scrollYWidth = this.scrollY ? this.gutterWidth : 0;

                  if (bodyMinWidth <= bodyWidth - scrollYWidth) {
                    // DON'T HAVE SCROLL BAR
                    this.scrollX = false;

                    const totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth;

                    if (flexColumns.length === 1) {
                      flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth;
                    } else {
                      const allColumnsWidth = flexColumns.reduce((prev, column) => prev + (column.minWidth || 80), 0);
                      const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
                      let noneFirstWidth = 0;

                      flexColumns.forEach((column, index) => {
                        if (index === 0) return;
                        const flexWidth = Math.floor((column.minWidth || 80) * flexWidthPerPixel);
                        noneFirstWidth += flexWidth;
                        column.realWidth = (column.minWidth || 80) + flexWidth;
                      });

                      flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
                    }
                  } else {
                    // HAVE HORIZONTAL SCROLL BAR
                    this.scrollX = true;
                    flexColumns.forEach((column) => {
                      column.realWidth = column.minWidth;
                    });
                  }

                  this.bodyWidth = Math.max(bodyMinWidth, bodyWidth);
                  this.table.resizeState.width = this.bodyWidth;
                } else {
                  flattenColumns.forEach((column) => {
                    if (!column.width && !column.minWidth) {
                      column.realWidth = 80;
                    } else {
                      column.realWidth = column.width || column.minWidth;
                    }

                    bodyMinWidth += column.realWidth;
                  });
                  this.scrollX = bodyMinWidth > bodyWidth;

                  this.bodyWidth = bodyMinWidth;
                }

                const { fixedColumns } = this.store.states;

                if (fixedColumns.length > 0) {
                  let fixedWidth = 0;
                  fixedColumns.forEach((column) => {
                    fixedWidth += column.realWidth || column.width;
                  });

                  this.fixedWidth = fixedWidth;
                }

                const { rightFixedColumns } = this.store.states;
                if (rightFixedColumns.length > 0) {
                  let rightFixedWidth = 0;
                  rightFixedColumns.forEach((column) => {
                    rightFixedWidth += column.realWidth || column.width;
                  });

                  this.rightFixedWidth = rightFixedWidth;
                }

                this.notifyObservers('columns');
              };

              TableLayout.prototype.addObserver = function addObserver(observer) {
                this.observers.push(observer);
              };

              TableLayout.prototype.removeObserver = function removeObserver(observer) {
                const index = this.observers.indexOf(observer);
                if (index !== -1) {
                  this.observers.splice(index, 1);
                }
              };

              TableLayout.prototype.notifyObservers = function notifyObservers(event) {
                const _this3 = this;

                const { observers } = this;
                observers.forEach((observer) => {
                  switch (event) {
                    case 'columns':
                      observer.onColumnsChange(_this3);
                      break;
                    case 'scrollable':
                      observer.onScrollableChange(_this3);
                      break;
                    default:
                      throw new Error(`Table Layout don't have event ${event}.`);
                  }
                });
              };

              return TableLayout;
            }());

            /* harmony default export */ const table_layout = (table_layout_TableLayout);
            // CONCATENATED MODULE: ./packages/table/src/layout-observer.js
            /* harmony default export */ const layout_observer = ({
              created: function created() {
                this.tableLayout.addObserver(this);
              },
              destroyed: function destroyed() {
                this.tableLayout.removeObserver(this);
              },

              computed: {
                tableLayout: function tableLayout() {
                  let { layout } = this;
                  if (!layout && this.table) {
                    layout = this.table.layout;
                  }
                  if (!layout) {
                    throw new Error('Can not find table layout.');
                  }
                  return layout;
                },
              },

              mounted: function mounted() {
                this.onColumnsChange(this.tableLayout);
                this.onScrollableChange(this.tableLayout);
              },
              updated: function updated() {
                if (this.__updated__) return;
                this.onColumnsChange(this.tableLayout);
                this.onScrollableChange(this.tableLayout);
                this.__updated__ = true;
              },

              methods: {
                onColumnsChange: function onColumnsChange(layout) {
                  const cols = this.$el.querySelectorAll('colgroup > col');
                  if (!cols.length) return;
                  const flattenColumns = layout.getFlattenColumns();
                  const columnsMap = {};
                  flattenColumns.forEach((column) => {
                    columnsMap[column.id] = column;
                  });
                  for (let i = 0, j = cols.length; i < j; i++) {
                    const col = cols[i];
                    const name = col.getAttribute('name');
                    const column = columnsMap[name];
                    if (column) {
                      col.setAttribute('width', column.realWidth || column.width);
                    }
                  }
                },
                onScrollableChange: function onScrollableChange(layout) {
                  const cols = this.$el.querySelectorAll('colgroup > col[name=gutter]');
                  for (let i = 0, j = cols.length; i < j; i++) {
                    const col = cols[i];
                    col.setAttribute('width', layout.scrollY ? layout.gutterWidth : '0');
                  }
                  const ths = this.$el.querySelectorAll('th.gutter');
                  for (let _i = 0, _j = ths.length; _i < _j; _i++) {
                    const th = ths[_i];
                    th.style.width = layout.scrollY ? `${layout.gutterWidth}px` : '0';
                    th.style.display = layout.scrollY ? '' : 'none';
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/table/src/table-body.js
            const table_body_typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

            const table_body_extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            /* harmony default export */ const table_body = ({
              name: 'ElTableBody',

              mixins: [layout_observer],

              components: {
                ElCheckbox: checkbox_default.a,
                ElTooltip: tooltip_default.a,
              },

              props: {
                store: {
                  required: true,
                },
                stripe: Boolean,
                context: {},
                rowClassName: [String, Function],
                rowStyle: [Object, Function],
                fixed: String,
                highlight: Boolean,
              },

              render: function render(h) {
                const _this = this;

                const data = this.data || [];
                return h(
                  'table',
                  {
                    class: 'el-table__body',
                    attrs: {
                      cellspacing: '0',
                      cellpadding: '0',
                      border: '0',
                    },
                  },
                  [h('colgroup', [this.columns.map((column) => h('col', {
                    attrs: { name: column.id },
                    key: column.id,
                  }))]), h('tbody', [data.reduce((acc, row) => acc.concat(_this.wrappedRowRender(row, acc.length)), []), h('el-tooltip', {
                    attrs: { effect: this.table.tooltipEffect, placement: 'top', content: this.tooltipContent },
                    ref: 'tooltip',
                  })])],
                );
              },

              computed: {
                table: function table() {
                  return this.$parent;
                },
                ...mapStates({
                  data: 'data',
                  columns: 'columns',
                  treeIndent: 'indent',
                  leftFixedLeafCount: 'fixedLeafColumnsLength',
                  rightFixedLeafCount: 'rightFixedLeafColumnsLength',
                  columnsCount: function columnsCount(states) {
                    return states.columns.length;
                  },
                  leftFixedCount: function leftFixedCount(states) {
                    return states.fixedColumns.length;
                  },
                  rightFixedCount: function rightFixedCount(states) {
                    return states.rightFixedColumns.length;
                  },
                  hasExpandColumn: function hasExpandColumn(states) {
                    return states.columns.some((_ref) => {
                      let { type } = _ref;
                      return type === 'expand';
                    });
                  },
                }),
                firstDefaultColumnIndex: function firstDefaultColumnIndex() {
                  return Object(util_.arrayFindIndex)(this.columns, (_ref2) => {
                    let { type } = _ref2;
                    return type === 'default';
                  });
                },
              },

              watch: {
                // don't trigger getter of currentRow in getCellClass. see https://jsfiddle.net/oe2b4hqt/
                // update DOM manually. see https://github.com/ElemeFE/element/pull/13954/files#diff-9b450c00d0a9dec0ffad5a3176972e40
                'store.states.hoverRow': function storeStatesHoverRow(newVal, oldVal) {
                  const _this2 = this;

                  if (!this.store.states.isComplex || this.$isServer) return;
                  let raf = window.requestAnimationFrame;
                  if (!raf) {
                    raf = function raf(fn) {
                      return setTimeout(fn, 16);
                    };
                  }
                  raf(() => {
                    const rows = _this2.$el.querySelectorAll('.el-table__row');
                    const oldRow = rows[oldVal];
                    const newRow = rows[newVal];
                    if (oldRow) {
                      Object(dom_.removeClass)(oldRow, 'hover-row');
                    }
                    if (newRow) {
                      Object(dom_.addClass)(newRow, 'hover-row');
                    }
                  });
                },
              },

              data: function data() {
                return {
                  tooltipContent: '',
                };
              },
              created: function created() {
                this.activateTooltip = debounce_default()(50, (tooltip) => tooltip.handleShowPopper());
              },

              methods: {
                getKeyOfRow: function getKeyOfRow(row, index) {
                  const { rowKey } = this.table;
                  if (rowKey) {
                    return getRowIdentity(row, rowKey);
                  }
                  return index;
                },
                isColumnHidden: function isColumnHidden(index) {
                  if (this.fixed === true || this.fixed === 'left') {
                    return index >= this.leftFixedLeafCount;
                  } if (this.fixed === 'right') {
                    return index < this.columnsCount - this.rightFixedLeafCount;
                  }
                  return index < this.leftFixedLeafCount || index >= this.columnsCount - this.rightFixedLeafCount;
                },
                getSpan: function getSpan(row, column, rowIndex, columnIndex) {
                  let rowspan = 1;
                  let colspan = 1;
                  const fn = this.table.spanMethod;
                  if (typeof fn === 'function') {
                    const result = fn({
                      row,
                      column,
                      rowIndex,
                      columnIndex,
                    });
                    if (Array.isArray(result)) {
                      rowspan = result[0];
                      colspan = result[1];
                    } else if ((typeof result === 'undefined' ? 'undefined' : table_body_typeof(result)) === 'object') {
                      rowspan = result.rowspan;
                      colspan = result.colspan;
                    }
                  }
                  return { rowspan, colspan };
                },
                getRowStyle: function getRowStyle(row, rowIndex) {
                  const { rowStyle } = this.table;
                  if (typeof rowStyle === 'function') {
                    return rowStyle.call(null, {
                      row,
                      rowIndex,
                    });
                  }
                  return rowStyle || null;
                },
                getRowClass: function getRowClass(row, rowIndex) {
                  const classes = ['el-table__row'];
                  if (this.table.highlightCurrentRow && row === this.store.states.currentRow) {
                    classes.push('current-row');
                  }

                  if (this.stripe && rowIndex % 2 === 1) {
                    classes.push('el-table__row--striped');
                  }
                  const { rowClassName } = this.table;
                  if (typeof rowClassName === 'string') {
                    classes.push(rowClassName);
                  } else if (typeof rowClassName === 'function') {
                    classes.push(rowClassName.call(null, {
                      row,
                      rowIndex,
                    }));
                  }

                  if (this.store.states.expandRows.indexOf(row) > -1) {
                    classes.push('expanded');
                  }

                  return classes;
                },
                getCellStyle: function getCellStyle(rowIndex, columnIndex, row, column) {
                  const { cellStyle } = this.table;
                  if (typeof cellStyle === 'function') {
                    return cellStyle.call(null, {
                      rowIndex,
                      columnIndex,
                      row,
                      column,
                    });
                  }
                  return cellStyle;
                },
                getCellClass: function getCellClass(rowIndex, columnIndex, row, column) {
                  const classes = [column.id, column.align, column.className];

                  if (this.isColumnHidden(columnIndex)) {
                    classes.push('is-hidden');
                  }

                  const { cellClassName } = this.table;
                  if (typeof cellClassName === 'string') {
                    classes.push(cellClassName);
                  } else if (typeof cellClassName === 'function') {
                    classes.push(cellClassName.call(null, {
                      rowIndex,
                      columnIndex,
                      row,
                      column,
                    }));
                  }

                  return classes.join(' ');
                },
                getColspanRealWidth: function getColspanRealWidth(columns, colspan, index) {
                  if (colspan < 1) {
                    return columns[index].realWidth;
                  }
                  const widthArr = columns.map((_ref3) => {
                    const { realWidth } = _ref3;
                    return realWidth;
                  }).slice(index, index + colspan);
                  return widthArr.reduce((acc, width) => acc + width, -1);
                },
                handleCellMouseEnter: function handleCellMouseEnter(event, row) {
                  const { table } = this;
                  const cell = getCell(event);

                  if (cell) {
                    const column = getColumnByCell(table, cell);
                    const hoverState = table.hoverState = { cell, column, row };
                    table.$emit('cell-mouse-enter', hoverState.row, hoverState.column, hoverState.cell, event);
                  }

                  // 判断是否text-overflow, 如果是就显示tooltip
                  const cellChild = event.target.querySelector('.cell');
                  if (!(Object(dom_.hasClass)(cellChild, 'el-tooltip') && cellChild.childNodes.length)) {
                    return;
                  }
                  // use range width instead of scrollWidth to determine whether the text is overflowing
                  // to address a potential FireFox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1074543#c3
                  const range = document.createRange();
                  range.setStart(cellChild, 0);
                  range.setEnd(cellChild, cellChild.childNodes.length);
                  const rangeWidth = range.getBoundingClientRect().width;
                  const padding = (parseInt(Object(dom_.getStyle)(cellChild, 'paddingLeft'), 10) || 0) + (parseInt(Object(dom_.getStyle)(cellChild, 'paddingRight'), 10) || 0);
                  if ((rangeWidth + padding > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) && this.$refs.tooltip) {
                    const { tooltip } = this.$refs;
                    // TODO 会引起整个 Table 的重新渲染，需要优化
                    this.tooltipContent = cell.innerText || cell.textContent;
                    tooltip.referenceElm = cell;
                    tooltip.$refs.popper && (tooltip.$refs.popper.style.display = 'none');
                    tooltip.doDestroy();
                    tooltip.setExpectedState(true);
                    this.activateTooltip(tooltip);
                  }
                },
                handleCellMouseLeave: function handleCellMouseLeave(event) {
                  const { tooltip } = this.$refs;
                  if (tooltip) {
                    tooltip.setExpectedState(false);
                    tooltip.handleClosePopper();
                  }
                  const cell = getCell(event);
                  if (!cell) return;

                  const oldHoverState = this.table.hoverState || {};
                  this.table.$emit('cell-mouse-leave', oldHoverState.row, oldHoverState.column, oldHoverState.cell, event);
                },

                handleMouseEnter: debounce_default()(30, function (index) {
                  this.store.commit('setHoverRow', index);
                }),

                handleMouseLeave: debounce_default()(30, function () {
                  this.store.commit('setHoverRow', null);
                }),

                handleContextMenu: function handleContextMenu(event, row) {
                  this.handleEvent(event, row, 'contextmenu');
                },
                handleDoubleClick: function handleDoubleClick(event, row) {
                  this.handleEvent(event, row, 'dblclick');
                },
                handleClick: function handleClick(event, row) {
                  this.store.commit('setCurrentRow', row);
                  this.handleEvent(event, row, 'click');
                },
                handleEvent: function handleEvent(event, row, name) {
                  const { table } = this;
                  const cell = getCell(event);
                  let column = void 0;
                  if (cell) {
                    column = getColumnByCell(table, cell);
                    if (column) {
                      table.$emit(`cell-${name}`, row, column, cell, event);
                    }
                  }
                  table.$emit(`row-${name}`, row, column, event);
                },
                rowRender: function rowRender(row, $index, treeRowData) {
                  const _this3 = this;

                  const h = this.$createElement;
                  const { treeIndent } = this;
                  const { columns } = this;
                  const { firstDefaultColumnIndex } = this;

                  const columnsHidden = columns.map((column, index) => _this3.isColumnHidden(index));
                  const rowClasses = this.getRowClass(row, $index);
                  let display = true;
                  if (treeRowData) {
                    rowClasses.push(`el-table__row--level-${treeRowData.level}`);
                    display = treeRowData.display;
                  }
                  // 指令 v-show 会覆盖 row-style 中 display
                  // 使用 :style 代替 v-show https://github.com/ElemeFE/element/issues/16995
                  const displayStyle = display ? null : {
                    display: 'none',
                  };
                  return h(
                    'tr',
                    {
                      style: [displayStyle, this.getRowStyle(row, $index)],
                      class: rowClasses,
                      key: this.getKeyOfRow(row, $index),
                      on: {
                        dblclick: function dblclick($event) {
                          return _this3.handleDoubleClick($event, row);
                        },
                        click: function click($event) {
                          return _this3.handleClick($event, row);
                        },
                        contextmenu: function contextmenu($event) {
                          return _this3.handleContextMenu($event, row);
                        },
                        mouseenter: function mouseenter(_) {
                          return _this3.handleMouseEnter($index);
                        },
                        mouseleave: this.handleMouseLeave,
                      },
                    },
                    [columns.map((column, cellIndex) => {
                      const _getSpan = _this3.getSpan(row, column, $index, cellIndex);
                      const { rowspan } = _getSpan;
                      const { colspan } = _getSpan;

                      if (!rowspan || !colspan) {
                        return null;
                      }
                      const columnData = { ...column };
                      columnData.realWidth = _this3.getColspanRealWidth(columns, colspan, cellIndex);
                      const data = {
                        store: _this3.store,
                        _self: _this3.context || _this3.table.$vnode.context,
                        column: columnData,
                        row,
                        $index,
                      };
                      if (cellIndex === firstDefaultColumnIndex && treeRowData) {
                        data.treeNode = {
                          indent: treeRowData.level * treeIndent,
                          level: treeRowData.level,
                        };
                        if (typeof treeRowData.expanded === 'boolean') {
                          data.treeNode.expanded = treeRowData.expanded;
                          // 表明是懒加载
                          if ('loading' in treeRowData) {
                            data.treeNode.loading = treeRowData.loading;
                          }
                          if ('noLazyChildren' in treeRowData) {
                            data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
                          }
                        }
                      }
                      return h(
                        'td',
                        {
                          style: _this3.getCellStyle($index, cellIndex, row, column),
                          class: _this3.getCellClass($index, cellIndex, row, column),
                          attrs: {
                            rowspan,
                            colspan,
                          },
                          on: {
                            mouseenter: function mouseenter($event) {
                              return _this3.handleCellMouseEnter($event, row);
                            },
                            mouseleave: _this3.handleCellMouseLeave,
                          },
                        },
                        [column.renderCell.call(_this3._renderProxy, _this3.$createElement, data, columnsHidden[cellIndex])],
                      );
                    })],
                  );
                },
                wrappedRowRender: function wrappedRowRender(row, $index) {
                  const _this4 = this;

                  const h = this.$createElement;

                  const { store } = this;
                  const { isRowExpanded } = store;
                  var {assertRowKey} = store;
                  const _store$states = store.states;
                  let { treeData } = _store$states;
                  let { lazyTreeNodeMap } = _store$states;
                  let { childrenColumnName } = _store$states;
                  let { rowKey } = _store$states;

                  if (this.hasExpandColumn && isRowExpanded(row)) {
                    const { renderExpanded } = this.table;
                    const tr = this.rowRender(row, $index);
                    if (!renderExpanded) {
                      console.error('[Element Error]renderExpanded is required.');
                      return tr;
                    }
                    // 使用二维数组，避免修改 $index
                    return [[tr, h(
                      'tr',
                      { key: `expanded-row__${tr.key}` },
                      [h(
                        'td',
                        {
                          attrs: { colspan: this.columnsCount },
                          class: 'el-table__expanded-cell',
                        },
                        [renderExpanded(this.$createElement, { row, $index, store: this.store })],
                      )],
                    )]];
                  } if (Object.keys(treeData).length) {
                    assertRowKey();
                    // TreeTable 时，rowKey 必须由用户设定，不使用 getKeyOfRow 计算
                    // 在调用 rowRender 函数时，仍然会计算 rowKey，不太好的操作
                    const key = getRowIdentity(row, rowKey);
                    let cur = treeData[key];
                    let treeRowData = null;
                    if (cur) {
                      treeRowData = {
                        expanded: cur.expanded,
                        level: cur.level,
                        display: true,
                      };
                      if (typeof cur.lazy === 'boolean') {
                        if (typeof cur.loaded === 'boolean' && cur.loaded) {
                          treeRowData.noLazyChildren = !(cur.children && cur.children.length);
                        }
                        treeRowData.loading = cur.loading;
                      }
                    }
                    const tmp = [this.rowRender(row, $index, treeRowData)];
                    // 渲染嵌套数据
                    if (cur) {
                      // currentRow 记录的是 index，所以还需主动增加 TreeTable 的 index
                      let i = 0;
                      const traverse = function traverse(children, parent) {
                        if (!(children && children.length && parent)) return;
                        children.forEach((node) => {
                          // 父节点的 display 状态影响子节点的显示状态
                          let innerTreeRowData = {
                            display: parent.display && parent.expanded,
                            level: parent.level + 1,
                          };
                          let childKey = getRowIdentity(node, rowKey);
                          if (childKey === undefined || childKey === null) {
                            throw new Error('for nested data item, row-key is required.');
                          }
                          cur = { ...treeData[childKey] };
                          // 对于当前节点，分成有无子节点两种情况。
                          // 如果包含子节点的，设置 expanded 属性。
                          // 对于它子节点的 display 属性由它本身的 expanded 与 display 共同决定。
                          if (cur) {
                            innerTreeRowData.expanded = cur.expanded;
                            // 懒加载的某些节点，level 未知
                            cur.level = cur.level || innerTreeRowData.level;
                            cur.display = !!(cur.expanded && innerTreeRowData.display);
                            if (typeof cur.lazy === 'boolean') {
                              if (typeof cur.loaded === 'boolean' && cur.loaded) {
                                innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                              }
                              innerTreeRowData.loading = cur.loading;
                            }
                          }
                          i++;
                          tmp.push(_this4.rowRender(node, $index + i, innerTreeRowData));
                          if (cur) {
                            let _nodes = lazyTreeNodeMap[childKey] || node[childrenColumnName];
                            traverse(_nodes, cur);
                          }
                        });
                      };
                      // 对于 root 节点，display 一定为 true
                      cur.display = true;
                      const nodes = lazyTreeNodeMap[key] || row[childrenColumnName];
                      traverse(nodes, cur);
                    }
                    return tmp;
                  }
                  return this.rowRender(row, $index);
                },
              },
            });
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/filter-panel.vue?vue&type=template&id=7f2c919f&
            const filter_panelvue_type_template_id_7f2c919f_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('transition', { attrs: { name: 'el-zoom-in-top' } }, [
                _vm.multiple
                  ? _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'clickoutside',
                          rawName: 'v-clickoutside',
                          value: _vm.handleOutsideClick,
                          expression: 'handleOutsideClick',
                        },
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.showPopper,
                          expression: 'showPopper',
                        },
                      ],
                      staticClass: 'el-table-filter',
                    },
                    [
                      _c(
                        'div',
                        { staticClass: 'el-table-filter__content' },
                        [
                          _c(
                            'el-scrollbar',
                            { attrs: { 'wrap-class': 'el-table-filter__wrap' } },
                            [
                              _c(
                                'el-checkbox-group',
                                {
                                  staticClass: 'el-table-filter__checkbox-group',
                                  model: {
                                    value: _vm.filteredValue,
                                    callback($$v) {
                                      _vm.filteredValue = $$v;
                                    },
                                    expression: 'filteredValue',
                                  },
                                },
                                _vm._l(_vm.filters, (filter) => _c(
                                  'el-checkbox',
                                  { key: filter.value, attrs: { label: filter.value } },
                                  [_vm._v(_vm._s(filter.text))],
                                )),
                                1,
                              ),
                            ],
                            1,
                          ),
                        ],
                        1,
                      ),
                      _c('div', { staticClass: 'el-table-filter__bottom' }, [
                        _c(
                          'button',
                          {
                            class: { 'is-disabled': _vm.filteredValue.length === 0 },
                            attrs: { disabled: _vm.filteredValue.length === 0 },
                            on: { click: _vm.handleConfirm },
                          },
                          [_vm._v(_vm._s(_vm.t('el.table.confirmFilter')))],
                        ),
                        _c('button', { on: { click: _vm.handleReset } }, [
                          _vm._v(_vm._s(_vm.t('el.table.resetFilter'))),
                        ]),
                      ]),
                    ],
                  )
                  : _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'clickoutside',
                          rawName: 'v-clickoutside',
                          value: _vm.handleOutsideClick,
                          expression: 'handleOutsideClick',
                        },
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.showPopper,
                          expression: 'showPopper',
                        },
                      ],
                      staticClass: 'el-table-filter',
                    },
                    [
                      _c(
                        'ul',
                        { staticClass: 'el-table-filter__list' },
                        [
                          _c(
                            'li',
                            {
                              staticClass: 'el-table-filter__list-item',
                              class: {
                                'is-active':
                        _vm.filterValue === undefined
                        || _vm.filterValue === null,
                              },
                              on: {
                                click($event) {
                                  _vm.handleSelect(null);
                                },
                              },
                            },
                            [_vm._v(_vm._s(_vm.t('el.table.clearFilter')))],
                          ),
                          _vm._l(_vm.filters, (filter) => _c(
                            'li',
                            {
                              key: filter.value,
                              staticClass: 'el-table-filter__list-item',
                              class: { 'is-active': _vm.isActive(filter) },
                              attrs: { label: filter.value },
                              on: {
                                click($event) {
                                  _vm.handleSelect(filter.value);
                                },
                              },
                            },
                            [_vm._v(_vm._s(filter.text))],
                          )),
                        ],
                        2,
                      ),
                    ],
                  ),
              ]);
            };
            const filter_panelvue_type_template_id_7f2c919f_staticRenderFns = [];
            filter_panelvue_type_template_id_7f2c919f_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/table/src/filter-panel.vue?vue&type=template&id=7f2c919f&

            // CONCATENATED MODULE: ./packages/table/src/dropdown.js

            const dropdowns = [];

            !external_vue_default.a.prototype.$isServer && document.addEventListener('click', (event) => {
              dropdowns.forEach((dropdown) => {
                const { target } = event;
                if (!dropdown || !dropdown.$el) return;
                if (target === dropdown.$el || dropdown.$el.contains(target)) {
                  return;
                }
                dropdown.handleOutsideClick && dropdown.handleOutsideClick(event);
              });
            });

            /* harmony default export */ const src_dropdown = ({
              open: function open(instance) {
                if (instance) {
                  dropdowns.push(instance);
                }
              },
              close: function close(instance) {
                const index = dropdowns.indexOf(instance);
                if (index !== -1) {
                  dropdowns.splice(instance, 1);
                }
              },
            });
            // EXTERNAL MODULE: external "element-ui/lib/checkbox-group"
            const checkbox_group_ = __webpack_require__(31);
            const checkbox_group_default = /* #__PURE__ */__webpack_require__.n(checkbox_group_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/filter-panel.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const filter_panelvue_type_script_lang_js_ = ({
              name: 'ElTableFilterPanel',

              mixins: [vue_popper_default.a, locale_default.a],

              directives: {
                Clickoutside: clickoutside_default.a,
              },

              components: {
                ElCheckbox: checkbox_default.a,
                ElCheckboxGroup: checkbox_group_default.a,
                ElScrollbar: scrollbar_default.a,
              },

              props: {
                placement: {
                  type: String,
                  default: 'bottom-end',
                },
              },

              methods: {
                isActive: function isActive(filter) {
                  return filter.value === this.filterValue;
                },
                handleOutsideClick: function handleOutsideClick() {
                  const _this = this;

                  setTimeout(() => {
                    _this.showPopper = false;
                  }, 16);
                },
                handleConfirm: function handleConfirm() {
                  this.confirmFilter(this.filteredValue);
                  this.handleOutsideClick();
                },
                handleReset: function handleReset() {
                  this.filteredValue = [];
                  this.confirmFilter(this.filteredValue);
                  this.handleOutsideClick();
                },
                handleSelect: function handleSelect(filterValue) {
                  this.filterValue = filterValue;

                  if (typeof filterValue !== 'undefined' && filterValue !== null) {
                    this.confirmFilter(this.filteredValue);
                  } else {
                    this.confirmFilter([]);
                  }

                  this.handleOutsideClick();
                },
                confirmFilter: function confirmFilter(filteredValue) {
                  this.table.store.commit('filterChange', {
                    column: this.column,
                    values: filteredValue,
                  });
                  this.table.store.updateAllSelected();
                },
              },

              data: function data() {
                return {
                  table: null,
                  cell: null,
                  column: null,
                };
              },

              computed: {
                filters: function filters() {
                  return this.column && this.column.filters;
                },

                filterValue: {
                  get: function get() {
                    return (this.column.filteredValue || [])[0];
                  },
                  set: function set(value) {
                    if (this.filteredValue) {
                      if (typeof value !== 'undefined' && value !== null) {
                        this.filteredValue.splice(0, 1, value);
                      } else {
                        this.filteredValue.splice(0, 1);
                      }
                    }
                  },
                },

                filteredValue: {
                  get: function get() {
                    if (this.column) {
                      return this.column.filteredValue || [];
                    }
                    return [];
                  },
                  set: function set(value) {
                    if (this.column) {
                      this.column.filteredValue = value;
                    }
                  },
                },

                multiple: function multiple() {
                  if (this.column) {
                    return this.column.filterMultiple;
                  }
                  return true;
                },
              },

              mounted: function mounted() {
                const _this2 = this;

                this.popperElm = this.$el;
                this.referenceElm = this.cell;
                this.table.bodyWrapper.addEventListener('scroll', () => {
                  _this2.updatePopper();
                });

                this.$watch('showPopper', (value) => {
                  if (_this2.column) _this2.column.filterOpened = value;
                  if (value) {
                    src_dropdown.open(_this2);
                  } else {
                    src_dropdown.close(_this2);
                  }
                });
              },

              watch: {
                showPopper: function showPopper(val) {
                  if (val === true && parseInt(this.popperJS._popper.style.zIndex, 10) < popup_.PopupManager.zIndex) {
                    this.popperJS._popper.style.zIndex = popup_.PopupManager.nextZIndex();
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/table/src/filter-panel.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_filter_panelvue_type_script_lang_js_ = (filter_panelvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/table/src/filter-panel.vue

            /* normalize component */

            const filter_panel_component = normalizeComponent(
              src_filter_panelvue_type_script_lang_js_,
              filter_panelvue_type_template_id_7f2c919f_render,
              filter_panelvue_type_template_id_7f2c919f_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let filter_panel_api; }
            filter_panel_component.options.__file = 'packages/table/src/filter-panel.vue';
            /* harmony default export */ const filter_panel = (filter_panel_component.exports);
            // CONCATENATED MODULE: ./packages/table/src/table-header.js
            const table_header_extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            const getAllColumns = function getAllColumns(columns) {
              const result = [];
              columns.forEach((column) => {
                if (column.children) {
                  result.push(column);
                  result.push.apply(result, getAllColumns(column.children));
                } else {
                  result.push(column);
                }
              });
              return result;
            };

            const convertToRows = function convertToRows(originColumns) {
              let maxLevel = 1;
              const traverse = function traverse(column, parent) {
                if (parent) {
                  column.level = parent.level + 1;
                  if (maxLevel < column.level) {
                    maxLevel = column.level;
                  }
                }
                if (column.children) {
                  let colSpan = 0;
                  column.children.forEach((subColumn) => {
                    traverse(subColumn, column);
                    colSpan += subColumn.colSpan;
                  });
                  column.colSpan = colSpan;
                } else {
                  column.colSpan = 1;
                }
              };

              originColumns.forEach((column) => {
                column.level = 1;
                traverse(column);
              });

              const rows = [];
              for (let i = 0; i < maxLevel; i++) {
                rows.push([]);
              }

              const allColumns = getAllColumns(originColumns);

              allColumns.forEach((column) => {
                if (!column.children) {
                  column.rowSpan = maxLevel - column.level + 1;
                } else {
                  column.rowSpan = 1;
                }
                rows[column.level - 1].push(column);
              });

              return rows;
            };

            /* harmony default export */ const table_header = ({
              name: 'ElTableHeader',

              mixins: [layout_observer],

              render: function render(h) {
                const _this = this;

                const { originColumns } = this.store.states;
                const columnRows = convertToRows(originColumns, this.columns);
                // 是否拥有多级表头
                const isGroup = columnRows.length > 1;
                if (isGroup) this.$parent.isGroup = true;
                return h(
                  'table',
                  {
                    class: 'el-table__header',
                    attrs: {
                      cellspacing: '0',
                      cellpadding: '0',
                      border: '0',
                    },
                  },
                  [h('colgroup', [this.columns.map((column) => h('col', {
                    attrs: { name: column.id },
                    key: column.id,
                  })), this.hasGutter ? h('col', {
                    attrs: { name: 'gutter' },
                  }) : '']), h(
                    'thead',
                    { class: [{ 'is-group': isGroup, 'has-gutter': this.hasGutter }] },
                    [this._l(columnRows, (columns, rowIndex) => h(
                      'tr',
                      {
                        style: _this.getHeaderRowStyle(rowIndex),
                        class: _this.getHeaderRowClass(rowIndex),
                      },
                      [columns.map((column, cellIndex) => h(
                        'th',
                        {
                          attrs: {
                            colspan: column.colSpan,
                            rowspan: column.rowSpan,
                          },
                          on: {
                            'mousemove': function mousemove($event) {
                              return _this.handleMouseMove($event, column);
                            },
                            'mouseout': _this.handleMouseOut,
                            'mousedown': function mousedown($event) {
                              return _this.handleMouseDown($event, column);
                            },
                            'click': function click($event) {
                              return _this.handleHeaderClick($event, column);
                            },
                            'contextmenu': function contextmenu($event) {
                              return _this.handleHeaderContextMenu($event, column);
                            },
                          },

                          style: _this.getHeaderCellStyle(rowIndex, cellIndex, columns, column),
                          'class': _this.getHeaderCellClass(rowIndex, cellIndex, columns, column),
                          key: column.id 
},
                        [h(
                          'div',
                          { class: ['cell', column.filteredValue && column.filteredValue.length > 0 ? 'highlight' : '', column.labelClassName] },
                          [column.renderHeader ? column.renderHeader.call(_this._renderProxy, h, {
 column, $index: cellIndex, store: _this.store, _self: _this.$parent.$vnode.context 
}) : column.label, column.sortable ? h(
                            'span',
                            {
                              'class': 'caret-wrapper',
                              on: {
                                'click': function click($event) {
                                  return _this.handleSortClick($event, column);
                                },
                              },
                            },
                            [h('i', {
 class: 'sort-caret ascending',
                              on: {
                                'click': function click($event) {
                                  return _this.handleSortClick($event, column, 'ascending');
                                },
                              },
                            }), h('i', {
 class: 'sort-caret descending',
                              on: {
                                'click': function click($event) {
                                  return _this.handleSortClick($event, column, 'descending');
                                },
                              },
                            })],
                          ) : '', column.filterable ? h(
                            'span',
                            {
                              'class': 'el-table__column-filter-trigger',
                              on: {
                                'click': function click($event) {
                                  return _this.handleFilterClick($event, column);
                                },
                              },
                            },
                            [h('i', { class: ['el-icon-arrow-down', column.filterOpened ? 'el-icon-arrow-up' : ''] })],
                          ) : ''],
                        )],
                      )), _this.hasGutter ? h('th', { class: 'gutter' }) : ''],
                    ))],
                  )],
                );
              },

              props: {
                fixed: String,
                store: {
                  required: true,
                },
                border: Boolean,
                defaultSort: {
                  type: Object,
                  default: function _default() {
                    return {
                      prop: '',
                      order: '',
                    };
                  },
                },
              },

              components: {
                ElCheckbox: checkbox_default.a,
              },

              computed: {
                table: function table() {
                  return this.$parent;
                },
                hasGutter: function hasGutter() {
                  return !this.fixed && this.tableLayout.gutterWidth;
                },
                ...mapStates({
                  columns: 'columns',
                  isAllSelected: 'isAllSelected',
                  leftFixedLeafCount: 'fixedLeafColumnsLength',
                  rightFixedLeafCount: 'rightFixedLeafColumnsLength',
                  columnsCount: function columnsCount(states) {
                    return states.columns.length;
                  },
                  leftFixedCount: function leftFixedCount(states) {
                    return states.fixedColumns.length;
                  },
                  rightFixedCount: function rightFixedCount(states) {
                    return states.rightFixedColumns.length;
                  },
                }),
              },

              created: function created() {
                this.filterPanels = {};
              },
              mounted: function mounted() {
                const _this2 = this;

                // nextTick 是有必要的 https://github.com/ElemeFE/element/pull/11311
                this.$nextTick(() => {
                  const _defaultSort = _this2.defaultSort;
                  const { prop } = _defaultSort;
                  const { order } = _defaultSort;

                  const init = true;
                  _this2.store.commit('sort', { prop, order, init });
                });
              },
              beforeDestroy: function beforeDestroy() {
                const panels = this.filterPanels;
                for (const prop in panels) {
                  if (panels.hasOwnProperty(prop) && panels[prop]) {
                    panels[prop].$destroy(true);
                  }
                }
              },

              methods: {
                isCellHidden: function isCellHidden(index, columns) {
                  let start = 0;
                  for (let i = 0; i < index; i++) {
                    start += columns[i].colSpan;
                  }
                  const after = start + columns[index].colSpan - 1;
                  if (this.fixed === true || this.fixed === 'left') {
                    return after >= this.leftFixedLeafCount;
                  } if (this.fixed === 'right') {
                    return start < this.columnsCount - this.rightFixedLeafCount;
                  }
                  return after < this.leftFixedLeafCount || start >= this.columnsCount - this.rightFixedLeafCount;
                },
                getHeaderRowStyle: function getHeaderRowStyle(rowIndex) {
                  const { headerRowStyle } = this.table;
                  if (typeof headerRowStyle === 'function') {
                    return headerRowStyle.call(null, { rowIndex });
                  }
                  return headerRowStyle;
                },
                getHeaderRowClass: function getHeaderRowClass(rowIndex) {
                  const classes = [];

                  const { headerRowClassName } = this.table;
                  if (typeof headerRowClassName === 'string') {
                    classes.push(headerRowClassName);
                  } else if (typeof headerRowClassName === 'function') {
                    classes.push(headerRowClassName.call(null, { rowIndex }));
                  }

                  return classes.join(' ');
                },
                getHeaderCellStyle: function getHeaderCellStyle(rowIndex, columnIndex, row, column) {
                  const { headerCellStyle } = this.table;
                  if (typeof headerCellStyle === 'function') {
                    return headerCellStyle.call(null, {
                      rowIndex,
                      columnIndex,
                      row,
                      column,
                    });
                  }
                  return headerCellStyle;
                },
                getHeaderCellClass: function getHeaderCellClass(rowIndex, columnIndex, row, column) {
                  const classes = [column.id, column.order, column.headerAlign, column.className, column.labelClassName];

                  if (rowIndex === 0 && this.isCellHidden(columnIndex, row)) {
                    classes.push('is-hidden');
                  }

                  if (!column.children) {
                    classes.push('is-leaf');
                  }

                  if (column.sortable) {
                    classes.push('is-sortable');
                  }

                  const { headerCellClassName } = this.table;
                  if (typeof headerCellClassName === 'string') {
                    classes.push(headerCellClassName);
                  } else if (typeof headerCellClassName === 'function') {
                    classes.push(headerCellClassName.call(null, {
                      rowIndex,
                      columnIndex,
                      row,
                      column,
                    }));
                  }

                  return classes.join(' ');
                },
                toggleAllSelection: function toggleAllSelection(event) {
                  event.stopPropagation();
                  this.store.commit('toggleAllSelection');
                },
                handleFilterClick: function handleFilterClick(event, column) {
                  event.stopPropagation();
                  const { target } = event;
                  let cell = target.tagName === 'TH' ? target : target.parentNode;
                  if (Object(dom_.hasClass)(cell, 'noclick')) return;
                  cell = cell.querySelector('.el-table__column-filter-trigger') || cell;
                  const table = this.$parent;

                  let filterPanel = this.filterPanels[column.id];

                  if (filterPanel && column.filterOpened) {
                    filterPanel.showPopper = false;
                    return;
                  }

                  if (!filterPanel) {
                    filterPanel = new external_vue_default.a(filter_panel);
                    this.filterPanels[column.id] = filterPanel;
                    if (column.filterPlacement) {
                      filterPanel.placement = column.filterPlacement;
                    }
                    filterPanel.table = table;
                    filterPanel.cell = cell;
                    filterPanel.column = column;
                    !this.$isServer && filterPanel.$mount(document.createElement('div'));
                  }

                  setTimeout(() => {
                    filterPanel.showPopper = true;
                  }, 16);
                },
                handleHeaderClick: function handleHeaderClick(event, column) {
                  if (!column.filters && column.sortable) {
                    this.handleSortClick(event, column);
                  } else if (column.filterable && !column.sortable) {
                    this.handleFilterClick(event, column);
                  }

                  this.$parent.$emit('header-click', column, event);
                },
                handleHeaderContextMenu: function handleHeaderContextMenu(event, column) {
                  this.$parent.$emit('header-contextmenu', column, event);
                },
                handleMouseDown: function handleMouseDown(event, column) {
                  const _this3 = this;

                  if (this.$isServer) return;
                  if (column.children && column.children.length > 0) return;
                  /* istanbul ignore if */
                  if (this.draggingColumn && this.border) {
                    this.dragging = true;

                    this.$parent.resizeProxyVisible = true;

                    const table = this.$parent;
                    const tableEl = table.$el;
                    const tableLeft = tableEl.getBoundingClientRect().left;
                    const columnEl = this.$el.querySelector(`th.${column.id}`);
                    const columnRect = columnEl.getBoundingClientRect();
                    const minLeft = columnRect.left - tableLeft + 30;

                    Object(dom_.addClass)(columnEl, 'noclick');

                    this.dragState = {
                      startMouseLeft: event.clientX,
                      startLeft: columnRect.right - tableLeft,
                      startColumnLeft: columnRect.left - tableLeft,
                      tableLeft,
                    };

                    const { resizeProxy } = table.$refs;
                    resizeProxy.style.left = `${this.dragState.startLeft}px`;

                    document.onselectstart = function () {
                      return false;
                    };
                    document.ondragstart = function () {
                      return false;
                    };

                    const handleMouseMove = function handleMouseMove(event) {
                      const deltaLeft = event.clientX - _this3.dragState.startMouseLeft;
                      const proxyLeft = _this3.dragState.startLeft + deltaLeft;

                      resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
                    };

                    const handleMouseUp = function handleMouseUp() {
                      if (_this3.dragging) {
                        const _dragState = _this3.dragState;
                        const { startColumnLeft } = _dragState;
                        const { startLeft } = _dragState;

                        const finalLeft = parseInt(resizeProxy.style.left, 10);
                        const columnWidth = finalLeft - startColumnLeft;
                        column.width = column.realWidth = columnWidth;
                        table.$emit('header-dragend', column.width, startLeft - startColumnLeft, column, event);

                        _this3.store.scheduleLayout();

                        document.body.style.cursor = '';
                        _this3.dragging = false;
                        _this3.draggingColumn = null;
                        _this3.dragState = {};

                        table.resizeProxyVisible = false;
                      }

                      document.removeEventListener('mousemove', handleMouseMove);
                      document.removeEventListener('mouseup', handleMouseUp);
                      document.onselectstart = null;
                      document.ondragstart = null;

                      setTimeout(() => {
                        Object(dom_.removeClass)(columnEl, 'noclick');
                      }, 0);
                    };

                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                  }
                },
                handleMouseMove: function handleMouseMove(event, column) {
                  if (column.children && column.children.length > 0) return;
                  let { target } = event;
                  while (target && target.tagName !== 'TH') {
                    target = target.parentNode;
                  }

                  if (!column || !column.resizable) return;

                  if (!this.dragging && this.border) {
                    const rect = target.getBoundingClientRect();

                    const bodyStyle = document.body.style;
                    if (rect.width > 12 && rect.right - event.pageX < 8) {
                      bodyStyle.cursor = 'col-resize';
                      if (Object(dom_.hasClass)(target, 'is-sortable')) {
                        target.style.cursor = 'col-resize';
                      }
                      this.draggingColumn = column;
                    } else if (!this.dragging) {
                      bodyStyle.cursor = '';
                      if (Object(dom_.hasClass)(target, 'is-sortable')) {
                        target.style.cursor = 'pointer';
                      }
                      this.draggingColumn = null;
                    }
                  }
                },
                handleMouseOut: function handleMouseOut() {
                  if (this.$isServer) return;
                  document.body.style.cursor = '';
                },
                toggleOrder: function toggleOrder(_ref) {
                  const { order } = _ref;
                  const { sortOrders } = _ref;

                  if (order === '') return sortOrders[0];
                  const index = sortOrders.indexOf(order || null);
                  return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
                },
                handleSortClick: function handleSortClick(event, column, givenOrder) {
                  event.stopPropagation();
                  const order = column.order === givenOrder ? null : givenOrder || this.toggleOrder(column);

                  let { target } = event;
                  while (target && target.tagName !== 'TH') {
                    target = target.parentNode;
                  }

                  if (target && target.tagName === 'TH') {
                    if (Object(dom_.hasClass)(target, 'noclick')) {
                      Object(dom_.removeClass)(target, 'noclick');
                      return;
                    }
                  }

                  if (!column.sortable) return;

                  const { states } = this.store;
                  let { sortProp } = states;
                  let sortOrder = void 0;
                  const { sortingColumn } = states;

                  if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
                    if (sortingColumn) {
                      sortingColumn.order = null;
                    }
                    states.sortingColumn = column;
                    sortProp = column.property;
                  }

                  if (!order) {
                    sortOrder = column.order = null;
                  } else {
                    sortOrder = column.order = order;
                  }

                  states.sortProp = sortProp;
                  states.sortOrder = sortOrder;

                  this.store.commit('changeSortCondition');
                },
              },

              data: function data() {
                return {
                  draggingColumn: null,
                  dragging: false,
                  dragState: {},
                };
              },
            });
            // CONCATENATED MODULE: ./packages/table/src/table-footer.js
            const table_footer_extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            /* harmony default export */ const table_footer = ({
              name: 'ElTableFooter',

              mixins: [layout_observer],

              render: function render(h) {
                const _this = this;

                let sums = [];
                if (this.summaryMethod) {
                  sums = this.summaryMethod({ columns: this.columns, data: this.store.states.data });
                } else {
                  this.columns.forEach((column, index) => {
                    if (index === 0) {
                      sums[index] = _this.sumText;
                      return;
                    }
                    const values = _this.store.states.data.map((item) => Number(item[column.property]));
                    const precisions = [];
                    let notNumber = true;
                    values.forEach((value) => {
                      if (!isNaN(value)) {
                        notNumber = false;
                        const decimal = (`${value}`).split('.')[1];
                        precisions.push(decimal ? decimal.length : 0);
                      }
                    });
                    const precision = Math.max.apply(null, precisions);
                    if (!notNumber) {
                      sums[index] = values.reduce((prev, curr) => {
                        let value = Number(curr);
                        if (!isNaN(value)) {
                          return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
                        }
                        return prev;
                      }, 0);
                    } else {
                      sums[index] = '';
                    }
                  });
                }

                return h(
                  'table',
                  {
                    class: 'el-table__footer',
                    attrs: {
                      cellspacing: '0',
                      cellpadding: '0',
                      border: '0',
                    },
                  },
                  [h('colgroup', [this.columns.map((column) => h('col', {
                    attrs: { name: column.id },
                    key: column.id,
                  })), this.hasGutter ? h('col', {
                    attrs: { name: 'gutter' },
                  }) : '']), h(
                    'tbody',
                    { class: [{ 'has-gutter': this.hasGutter }] },
                    [h('tr', [this.columns.map((column, cellIndex) => h(
                      'td',
                      {
                        key: cellIndex,
                        attrs: {
                          colspan: column.colSpan,
                          rowspan: column.rowSpan,
                        },
                        class: _this.getRowClasses(column, cellIndex),
                      },
                      [h(
                        'div',
                        { class: ['cell', column.labelClassName] },
                        [sums[cellIndex]],
                      )],
                    )), this.hasGutter ? h('th', { class: 'gutter' }) : ''])],
                  )],
                );
              },

              props: {
                fixed: String,
                store: {
                  required: true,
                },
                summaryMethod: Function,
                sumText: String,
                border: Boolean,
                defaultSort: {
                  type: Object,
                  default: function _default() {
                    return {
                      prop: '',
                      order: '',
                    };
                  },
                },
              },

              computed: {
                table: function table() {
                  return this.$parent;
                },
                hasGutter: function hasGutter() {
                  return !this.fixed && this.tableLayout.gutterWidth;
                },
                ...mapStates({
                  columns: 'columns',
                  isAllSelected: 'isAllSelected',
                  leftFixedLeafCount: 'fixedLeafColumnsLength',
                  rightFixedLeafCount: 'rightFixedLeafColumnsLength',
                  columnsCount: function columnsCount(states) {
                    return states.columns.length;
                  },
                  leftFixedCount: function leftFixedCount(states) {
                    return states.fixedColumns.length;
                  },
                  rightFixedCount: function rightFixedCount(states) {
                    return states.rightFixedColumns.length;
                  },
                }),
              },

              methods: {
                isCellHidden: function isCellHidden(index, columns, column) {
                  if (this.fixed === true || this.fixed === 'left') {
                    return index >= this.leftFixedLeafCount;
                  } if (this.fixed === 'right') {
                    let before = 0;
                    for (let i = 0; i < index; i++) {
                      before += columns[i].colSpan;
                    }
                    return before < this.columnsCount - this.rightFixedLeafCount;
                  } if (!this.fixed && column.fixed) {
                    // hide cell when footer instance is not fixed and column is fixed
                    return true;
                  }
                  return index < this.leftFixedCount || index >= this.columnsCount - this.rightFixedCount;
                },
                getRowClasses: function getRowClasses(column, cellIndex) {
                  const classes = [column.id, column.align, column.labelClassName];
                  if (column.className) {
                    classes.push(column.className);
                  }
                  if (this.isCellHidden(cellIndex, this.columns, column)) {
                    classes.push('is-hidden');
                  }
                  if (!column.children) {
                    classes.push('is-leaf');
                  }
                  return classes;
                },
              },
            });
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/table.vue?vue&type=script&lang=js&
            const tablevue_type_script_lang_js_extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            let tableIdSeed = 1;

            /* harmony default export */ const tablevue_type_script_lang_js_ = ({
              name: 'ElTable',

              mixins: [locale_default.a, migrating_default.a],

              directives: {
                Mousewheel: directives_mousewheel,
              },

              props: {
                data: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },

                size: String,

                width: [String, Number],

                height: [String, Number],

                maxHeight: [String, Number],

                fit: {
                  type: Boolean,
                  default: true,
                },

                stripe: Boolean,

                border: Boolean,

                rowKey: [String, Function],

                context: {},

                showHeader: {
                  type: Boolean,
                  default: true,
                },

                showSummary: Boolean,

                sumText: String,

                summaryMethod: Function,

                rowClassName: [String, Function],

                rowStyle: [Object, Function],

                cellClassName: [String, Function],

                cellStyle: [Object, Function],

                headerRowClassName: [String, Function],

                headerRowStyle: [Object, Function],

                headerCellClassName: [String, Function],

                headerCellStyle: [Object, Function],

                highlightCurrentRow: Boolean,

                currentRowKey: [String, Number],

                emptyText: String,

                expandRowKeys: Array,

                defaultExpandAll: Boolean,

                defaultSort: Object,

                tooltipEffect: String,

                spanMethod: Function,

                selectOnIndeterminate: {
                  type: Boolean,
                  default: true,
                },

                indent: {
                  type: Number,
                  default: 16,
                },

                treeProps: {
                  type: Object,
                  default: function _default() {
                    return {
                      hasChildren: 'hasChildren',
                      children: 'children',
                    };
                  },
                },

                lazy: Boolean,

                load: Function,
              },

              components: {
                TableHeader: table_header,
                TableFooter: table_footer,
                TableBody: table_body,
                ElCheckbox: checkbox_default.a,
              },

              methods: {
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    events: {
                      expand: 'expand is renamed to expand-change',
                    },
                  };
                },
                setCurrentRow: function setCurrentRow(row) {
                  this.store.commit('setCurrentRow', row);
                },
                toggleRowSelection: function toggleRowSelection(row, selected) {
                  this.store.toggleRowSelection(row, selected, false);
                  this.store.updateAllSelected();
                },
                toggleRowExpansion: function toggleRowExpansion(row, expanded) {
                  this.store.toggleRowExpansionAdapter(row, expanded);
                },
                clearSelection: function clearSelection() {
                  this.store.clearSelection();
                },
                clearFilter: function clearFilter(columnKeys) {
                  this.store.clearFilter(columnKeys);
                },
                clearSort: function clearSort() {
                  this.store.clearSort();
                },
                handleMouseLeave: function handleMouseLeave() {
                  this.store.commit('setHoverRow', null);
                  if (this.hoverState) this.hoverState = null;
                },
                updateScrollY: function updateScrollY() {
                  const changed = this.layout.updateScrollY();
                  if (changed) {
                    this.layout.notifyObservers('scrollable');
                    this.layout.updateColumnsWidth();
                  }
                },
                handleFixedMousewheel: function handleFixedMousewheel(event, data) {
                  const { bodyWrapper } = this;
                  if (Math.abs(data.spinY) > 0) {
                    const currentScrollTop = bodyWrapper.scrollTop;
                    if (data.pixelY < 0 && currentScrollTop !== 0) {
                      event.preventDefault();
                    }
                    if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
                      event.preventDefault();
                    }
                    bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
                  } else {
                    bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
                  }
                },
                handleHeaderFooterMousewheel: function handleHeaderFooterMousewheel(event, data) {
                  const { pixelX } = data;
                  const { pixelY } = data;

                  if (Math.abs(pixelX) >= Math.abs(pixelY)) {
                    this.bodyWrapper.scrollLeft += data.pixelX / 5;
                  }
                },

                // TODO 使用 CSS transform
                syncPostion: Object(external_throttle_debounce_.throttle)(20, function () {
                  const _bodyWrapper = this.bodyWrapper;
                  const { scrollLeft } = _bodyWrapper;
                  const { scrollTop } = _bodyWrapper;
                  const { offsetWidth } = _bodyWrapper;
                  const { scrollWidth } = _bodyWrapper;
                  const _$refs = this.$refs;
                  const { headerWrapper } = _$refs;
                  const { footerWrapper } = _$refs;
                  const { fixedBodyWrapper } = _$refs;
                  const { rightFixedBodyWrapper } = _$refs;

                  if (headerWrapper) headerWrapper.scrollLeft = scrollLeft;
                  if (footerWrapper) footerWrapper.scrollLeft = scrollLeft;
                  if (fixedBodyWrapper) fixedBodyWrapper.scrollTop = scrollTop;
                  if (rightFixedBodyWrapper) rightFixedBodyWrapper.scrollTop = scrollTop;
                  const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
                  if (scrollLeft >= maxScrollLeftPosition) {
                    this.scrollPosition = 'right';
                  } else if (scrollLeft === 0) {
                    this.scrollPosition = 'left';
                  } else {
                    this.scrollPosition = 'middle';
                  }
                }),

                bindEvents: function bindEvents() {
                  this.bodyWrapper.addEventListener('scroll', this.syncPostion, { passive: true });
                  if (this.fit) {
                    Object(resize_event_.addResizeListener)(this.$el, this.resizeListener);
                  }
                },
                unbindEvents: function unbindEvents() {
                  this.bodyWrapper.removeEventListener('scroll', this.syncPostion, { passive: true });
                  if (this.fit) {
                    Object(resize_event_.removeResizeListener)(this.$el, this.resizeListener);
                  }
                },
                resizeListener: function resizeListener() {
                  if (!this.$ready) return;
                  let shouldUpdateLayout = false;
                  const el = this.$el;
                  const _resizeState = this.resizeState;
                  const oldWidth = _resizeState.width;
                  const oldHeight = _resizeState.height;

                  const width = el.offsetWidth;
                  if (oldWidth !== width) {
                    shouldUpdateLayout = true;
                  }

                  const height = el.offsetHeight;
                  if ((this.height || this.shouldUpdateHeight) && oldHeight !== height) {
                    shouldUpdateLayout = true;
                  }

                  if (shouldUpdateLayout) {
                    this.resizeState.width = width;
                    this.resizeState.height = height;
                    this.doLayout();
                  }
                },
                doLayout: function doLayout() {
                  if (this.shouldUpdateHeight) {
                    this.layout.updateElsHeight();
                  }
                  this.layout.updateColumnsWidth();
                },
                sort: function sort(prop, order) {
                  this.store.commit('sort', { prop, order });
                },
                toggleAllSelection: function toggleAllSelection() {
                  this.store.commit('toggleAllSelection');
                },
              },

              computed: {
                tableSize: function tableSize() {
                  return this.size || (this.$ELEMENT || {}).size;
                },
                bodyWrapper: function bodyWrapper() {
                  return this.$refs.bodyWrapper;
                },
                shouldUpdateHeight: function shouldUpdateHeight() {
                  return this.height || this.maxHeight || this.fixedColumns.length > 0 || this.rightFixedColumns.length > 0;
                },
                bodyWidth: function bodyWidth() {
                  const _layout = this.layout;
                  let { bodyWidth } = _layout;
                  let { scrollY } = _layout;
                  let { gutterWidth } = _layout;

                  return bodyWidth ? `${bodyWidth - (scrollY ? gutterWidth : 0)}px` : '';
                },
                bodyHeight: function bodyHeight() {
                  let _layout2 = this.layout;
                  let _layout2$headerHeight = _layout2.headerHeight;
                  let headerHeight = _layout2$headerHeight === undefined ? 0 : _layout2$headerHeight;
                  let { bodyHeight } = _layout2;
                  let _layout2$footerHeight = _layout2.footerHeight;
                  let footerHeight = _layout2$footerHeight === undefined ? 0 : _layout2$footerHeight;

                  if (this.height) {
                    return {
                      height: bodyHeight ? `${bodyHeight}px` : '',
                    };
                  } if (this.maxHeight) {
                    let maxHeight = parseHeight(this.maxHeight);
                    if (typeof maxHeight === 'number') {
                      return {
                        'max-height': `${maxHeight - footerHeight - (this.showHeader ? headerHeight : 0)}px`,
                      };
                    }
                  }
                  return {};
                },
                fixedBodyHeight: function fixedBodyHeight() {
                  if (this.height) {
                    return {
                      height: this.layout.fixedBodyHeight ? `${this.layout.fixedBodyHeight}px` : '',
                    };
                  } if (this.maxHeight) {
                    let maxHeight = parseHeight(this.maxHeight);
                    if (typeof maxHeight === 'number') {
                      maxHeight = this.layout.scrollX ? maxHeight - this.layout.gutterWidth : maxHeight;
                      if (this.showHeader) {
                        maxHeight -= this.layout.headerHeight;
                      }
                      maxHeight -= this.layout.footerHeight;
                      return {
                        'max-height': `${maxHeight}px`,
                      };
                    }
                  }
                  return {};
                },
                fixedHeight: function fixedHeight() {
                  if (this.maxHeight) {
                    if (this.showSummary) {
                      return {
                        bottom: 0,
                      };
                    }
                    return {
                      bottom: this.layout.scrollX && this.data.length ? `${this.layout.gutterWidth}px` : '',
                    };
                  }
                  if (this.showSummary) {
                    return {
                      height: this.layout.tableHeight ? `${this.layout.tableHeight}px` : '',
                    };
                  }
                  return {
                    height: this.layout.viewportHeight ? `${this.layout.viewportHeight}px` : '',
                  };
                },
                emptyBlockStyle: function emptyBlockStyle() {
                  if (this.data && this.data.length) return null;
                  let height = '100%';
                  if (this.layout.appendHeight) {
                    height = `calc(100% - ${this.layout.appendHeight}px)`;
                  }
                  return {
                    width: this.bodyWidth,
                    height,
                  };
                },
                ...mapStates({
                  selection: 'selection',
                  columns: 'columns',
                  tableData: 'data',
                  fixedColumns: 'fixedColumns',
                  rightFixedColumns: 'rightFixedColumns',
                }),
              },

              watch: {
                height: {
                  immediate: true,
                  handler: function handler(value) {
                    this.layout.setHeight(value);
                  },
                },

                maxHeight: {
                  immediate: true,
                  handler: function handler(value) {
                    this.layout.setMaxHeight(value);
                  },
                },

                currentRowKey: {
                  immediate: true,
                  handler: function handler(value) {
                    if (!this.rowKey) return;
                    this.store.setCurrentRowKey(value);
                  },
                },

                data: {
                  immediate: true,
                  handler: function handler(value) {
                    this.store.commit('setData', value);
                  },
                },

                expandRowKeys: {
                  immediate: true,
                  handler: function handler(newVal) {
                    if (newVal) {
                      this.store.setExpandRowKeysAdapter(newVal);
                    }
                  },
                },
              },

              created: function created() {
                const _this = this;

                this.tableId = `el-table_${tableIdSeed++}`;
                this.debouncedUpdateLayout = Object(external_throttle_debounce_.debounce)(50, () => _this.doLayout());
              },
              mounted: function mounted() {
                const _this2 = this;

                this.bindEvents();
                this.store.updateColumns();
                this.doLayout();

                this.resizeState = {
                  width: this.$el.offsetWidth,
                  height: this.$el.offsetHeight,
                };

                // init filters
                this.store.states.columns.forEach((column) => {
                  if (column.filteredValue && column.filteredValue.length) {
                    _this2.store.commit('filterChange', {
                      column,
                      values: column.filteredValue,
                      silent: true,
                    });
                  }
                });

                this.$ready = true;
              },
              destroyed: function destroyed() {
                this.unbindEvents();
              },
              data: function data() {
                const _treeProps = this.treeProps;
                const _treeProps$hasChildre = _treeProps.hasChildren;
                const hasChildren = _treeProps$hasChildre === undefined ? 'hasChildren' : _treeProps$hasChildre;
                const _treeProps$children = _treeProps.children;
                const children = _treeProps$children === undefined ? 'children' : _treeProps$children;

                this.store = createStore(this, {
                  rowKey: this.rowKey,
                  defaultExpandAll: this.defaultExpandAll,
                  selectOnIndeterminate: this.selectOnIndeterminate,
                  // TreeTable 的相关配置
                  indent: this.indent,
                  lazy: this.lazy,
                  lazyColumnIdentifier: hasChildren,
                  childrenColumnName: children,
                });
                const layout = new table_layout({
                  store: this.store,
                  table: this,
                  fit: this.fit,
                  showHeader: this.showHeader,
                });
                return {
                  layout,
                  isHidden: false,
                  renderExpanded: null,
                  resizeProxyVisible: false,
                  resizeState: {
                    width: null,
                    height: null,
                  },
                  // 是否拥有多级表头
                  isGroup: false,
                  scrollPosition: 'left',
                };
              },
            });
            // CONCATENATED MODULE: ./packages/table/src/table.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_tablevue_type_script_lang_js_ = (tablevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/table/src/table.vue

            /* normalize component */

            const table_component = normalizeComponent(
              src_tablevue_type_script_lang_js_,
              tablevue_type_template_id_493fe34e_render,
              tablevue_type_template_id_493fe34e_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let table_api; }
            table_component.options.__file = 'packages/table/src/table.vue';
            /* harmony default export */ const src_table = (table_component.exports);
            // CONCATENATED MODULE: ./packages/table/index.js

            /* istanbul ignore next */
            src_table.install = function (Vue) {
              Vue.component(src_table.name, src_table);
            };

            /* harmony default export */ const packages_table = (src_table);
            // CONCATENATED MODULE: ./packages/table/src/config.js

            const cellStarts = {
              default: {
                order: '',
              },
              selection: {
                width: 48,
                minWidth: 48,
                realWidth: 48,
                order: '',
                className: 'el-table-column--selection',
              },
              expand: {
                width: 48,
                minWidth: 48,
                realWidth: 48,
                order: '',
              },
              index: {
                width: 48,
                minWidth: 48,
                realWidth: 48,
                order: '',
              },
            };

            // 这些选项不应该被覆盖
            const cellForced = {
              selection: {
                renderHeader: function renderHeader(h, _ref) {
                  const { store } = _ref;

                  return h('el-checkbox', {
                    attrs: {
                      disabled: store.states.data && store.states.data.length === 0,
                      indeterminate: store.states.selection.length > 0 && !this.isAllSelected,

                      value: this.isAllSelected,
                    },
                    nativeOn: {
                      click: this.toggleAllSelection,
                    },
                  });
                },
                renderCell: function renderCell(h, _ref2) {
                  const { row } = _ref2;
                  const { column } = _ref2;
                  const { store } = _ref2;
                  const { $index } = _ref2;

                  return h('el-checkbox', {
                    nativeOn: {
                      click: function click(event) {
                        return event.stopPropagation();
                      },
                    },
                    attrs: {
                      value: store.isSelected(row),
                      disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
                    },
                    on: {
                      input: function input() {
                        store.commit('rowSelectedChanged', row);
                      },
                    },
                  });
                },
                sortable: false,
                resizable: false,
              },
              index: {
                renderHeader: function renderHeader(h, _ref3) {
                  const { column } = _ref3;

                  return column.label || '#';
                },
                renderCell: function renderCell(h, _ref4) {
                  const { $index } = _ref4;
                  const { column } = _ref4;

                  let i = $index + 1;
                  const { index } = column;

                  if (typeof index === 'number') {
                    i = $index + index;
                  } else if (typeof index === 'function') {
                    i = index($index);
                  }

                  return h('div', [i]);
                },
                sortable: false,
              },
              expand: {
                renderHeader: function renderHeader(h, _ref5) {
                  const { column } = _ref5;

                  return column.label || '';
                },
                renderCell: function renderCell(h, _ref6) {
                  const { row } = _ref6;
                  const { store } = _ref6;

                  const classes = ['el-table__expand-icon'];
                  if (store.states.expandRows.indexOf(row) > -1) {
                    classes.push('el-table__expand-icon--expanded');
                  }
                  const callback = function callback(e) {
                    e.stopPropagation();
                    store.toggleRowExpansion(row);
                  };
                  return h(
                    'div',
                    {
                      class: classes,
                      on: {
                        click: callback,
                      },
                    },
                    [h('i', { class: 'el-icon el-icon-arrow-right' })],
                  );
                },
                sortable: false,
                resizable: false,
                className: 'el-table__expand-column',
              },
            };

            function defaultRenderCell(h, _ref7) {
              const { row } = _ref7;
              const { column } = _ref7;
              const { $index } = _ref7;

              const { property } = column;
              const value = property && Object(util_.getPropByPath)(row, property).v;
              if (column && column.formatter) {
                return column.formatter(row, column, value, $index);
              }
              return value;
            }

            function treeCellPrefix(h, _ref8) {
              const { row } = _ref8;
              const { treeNode } = _ref8;
              const { store } = _ref8;

              if (!treeNode) return null;
              const ele = [];
              const callback = function callback(e) {
                e.stopPropagation();
                store.loadOrToggle(row);
              };
              if (treeNode.indent) {
                ele.push(h('span', { class: 'el-table__indent', style: { 'padding-left': `${treeNode.indent}px` } }));
              }
              if (typeof treeNode.expanded === 'boolean' && !treeNode.noLazyChildren) {
                const expandClasses = ['el-table__expand-icon', treeNode.expanded ? 'el-table__expand-icon--expanded' : ''];
                let iconClasses = ['el-icon-arrow-right'];
                if (treeNode.loading) {
                  iconClasses = ['el-icon-loading'];
                }
                ele.push(h(
                  'div',
                  {
                    class: expandClasses,
                    on: {
                      click: callback,
                    },
                  },
                  [h('i', { class: iconClasses })],
                ));
              } else {
                ele.push(h('span', { class: 'el-table__placeholder' }));
              }
              return ele;
            }
            // CONCATENATED MODULE: ./packages/table/src/table-column.js
            const table_column_extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            let columnIdSeed = 1;

            /* harmony default export */ const table_column = ({
              name: 'ElTableColumn',

              props: {
                type: {
                  type: String,
                  default: 'default',
                },
                label: String,
                className: String,
                labelClassName: String,
                property: String,
                prop: String,
                width: {},
                minWidth: {},
                renderHeader: Function,
                sortable: {
                  type: [Boolean, String],
                  default: false,
                },
                sortMethod: Function,
                sortBy: [String, Function, Array],
                resizable: {
                  type: Boolean,
                  default: true,
                },
                columnKey: String,
                align: String,
                headerAlign: String,
                showTooltipWhenOverflow: Boolean,
                showOverflowTooltip: Boolean,
                fixed: [Boolean, String],
                formatter: Function,
                selectable: Function,
                reserveSelection: Boolean,
                filterMethod: Function,
                filteredValue: Array,
                filters: Array,
                filterPlacement: String,
                filterMultiple: {
                  type: Boolean,
                  default: true,
                },
                index: [Number, Function],
                sortOrders: {
                  type: Array,
                  default: function _default() {
                    return ['ascending', 'descending', null];
                  },
                  validator: function validator(val) {
                    return val.every((order) => ['ascending', 'descending', null].indexOf(order) > -1);
                  },
                },
              },

              data: function data() {
                return {
                  isSubColumn: false,
                  columns: [],
                };
              },

              computed: {
                owner: function owner() {
                  let parent = this.$parent;
                  while (parent && !parent.tableId) {
                    parent = parent.$parent;
                  }
                  return parent;
                },
                columnOrTableParent: function columnOrTableParent() {
                  let parent = this.$parent;
                  while (parent && !parent.tableId && !parent.columnId) {
                    parent = parent.$parent;
                  }
                  return parent;
                },
                realWidth: function realWidth() {
                  return parseWidth(this.width);
                },
                realMinWidth: function realMinWidth() {
                  return parseMinWidth(this.minWidth);
                },
                realAlign: function realAlign() {
                  return this.align ? `is-${this.align}` : null;
                },
                realHeaderAlign: function realHeaderAlign() {
                  return this.headerAlign ? `is-${this.headerAlign}` : this.realAlign;
                },
              },

              methods: {
                getPropsData: function getPropsData() {
                  const _this = this;

                  for (var _len = arguments.length, props = Array(_len), _key = 0; _key < _len; _key++) {
                    props[_key] = arguments[_key];
                  }

                  return props.reduce((prev, cur) => {
                    if (Array.isArray(cur)) {
                      cur.forEach((key) => {
                        prev[key] = _this[key];
                      });
                    }
                    return prev;
                  }, {});
                },
                getColumnElIndex: function getColumnElIndex(children, child) {
                  return [].indexOf.call(children, child);
                },
                setColumnWidth: function setColumnWidth(column) {
                  if (this.realWidth) {
                    column.width = this.realWidth;
                  }
                  if (this.realMinWidth) {
                    column.minWidth = this.realMinWidth;
                  }
                  if (!column.minWidth) {
                    column.minWidth = 80;
                  }
                  column.realWidth = column.width === undefined ? column.minWidth : column.width;
                  return column;
                },
                setColumnForcedProps: function setColumnForcedProps(column) {
                  // 对于特定类型的 column，某些属性不允许设置
                  const { type } = column;
                  const source = cellForced[type] || {};
                  Object.keys(source).forEach((prop) => {
                    const value = source[prop];
                    if (value !== undefined) {
                      column[prop] = prop === 'className' ? `${column[prop]} ${value}` : value;
                    }
                  });
                  return column;
                },
                setColumnRenders: function setColumnRenders(column) {
                  const _this2 = this;

                  const h = this.$createElement;

                  // renderHeader 属性不推荐使用。
                  if (this.renderHeader) {
                    console.warn('[Element Warn][TableColumn]Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.');
                  } else if (column.type !== 'selection') {
                    column.renderHeader = function (h, scope) {
                      const renderHeader = _this2.$scopedSlots.header;
                      return renderHeader ? renderHeader(scope) : column.label;
                    };
                  }

                  let originRenderCell = column.renderCell;
                  // TODO: 这里的实现调整
                  if (column.type === 'expand') {
                    // 对于展开行，renderCell 不允许配置的。在上一步中已经设置过，这里需要简单封装一下。
                    column.renderCell = function (h, data) {
                      return h(
                        'div',
                        { class: 'cell' },
                        [originRenderCell(h, data)],
                      );
                    };
                    this.owner.renderExpanded = function (h, data) {
                      return _this2.$scopedSlots.default ? _this2.$scopedSlots.default(data) : _this2.$slots.default;
                    };
                  } else {
                    originRenderCell = originRenderCell || defaultRenderCell;
                    // 对 renderCell 进行包装
                    column.renderCell = function (h, data) {
                      let children = null;
                      if (_this2.$scopedSlots.default) {
                        children = _this2.$scopedSlots.default(data);
                      } else {
                        children = originRenderCell(h, data);
                      }
                      const prefix = treeCellPrefix(h, data);
                      const props = {
                        class: 'cell',
                        style: {},
                      };
                      if (column.showOverflowTooltip) {
                        props.class += ' el-tooltip';
                        props.style = { width: `${(data.column.realWidth || data.column.width) - 1}px` };
                      }
                      return h(
                        'div',
                        props,
                        [prefix, children],
                      );
                    };
                  }
                  return column;
                },
                registerNormalWatchers: function registerNormalWatchers() {
                  const _this3 = this;

                  const props = ['label', 'property', 'filters', 'filterMultiple', 'sortable', 'index', 'formatter', 'className', 'labelClassName', 'showOverflowTooltip'];
                  // 一些属性具有别名
                  const aliases = {
                    prop: 'property',
                    realAlign: 'align',
                    realHeaderAlign: 'headerAlign',
                    realWidth: 'width',
                  };
                  const allAliases = props.reduce((prev, cur) => {
                    prev[cur] = cur;
                    return prev;
                  }, aliases);

                  Object.keys(allAliases).forEach((key) => {
                    const columnKey = aliases[key];

                    _this3.$watch(key, (newVal) => {
                      _this3.columnConfig[columnKey] = newVal;
                    });
                  });
                },
                registerComplexWatchers: function registerComplexWatchers() {
                  const _this4 = this;

                  const props = ['fixed'];
                  const aliases = {
                    realWidth: 'width',
                    realMinWidth: 'minWidth',
                  };
                  const allAliases = props.reduce((prev, cur) => {
                    prev[cur] = cur;
                    return prev;
                  }, aliases);

                  Object.keys(allAliases).forEach((key) => {
                    const columnKey = aliases[key];

                    _this4.$watch(key, (newVal) => {
                      _this4.columnConfig[columnKey] = newVal;
                      const updateColumns = columnKey === 'fixed';
                      _this4.owner.store.scheduleLayout(updateColumns);
                    });
                  });
                },
              },

              components: {
                ElCheckbox: checkbox_default.a,
              },

              beforeCreate: function beforeCreate() {
                this.row = {};
                this.column = {};
                this.$index = 0;
                this.columnId = '';
              },
              created: function created() {
                const parent = this.columnOrTableParent;
                this.isSubColumn = this.owner !== parent;
                this.columnId = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;

                const type = this.type || 'default';
                const sortable = this.sortable === '' ? true : this.sortable;
                const defaults = {
                  ...cellStarts[type],
                  id: this.columnId,
                  type,
                  property: this.prop || this.property,
                  align: this.realAlign,
                  headerAlign: this.realHeaderAlign,
                  showOverflowTooltip: this.showOverflowTooltip || this.showTooltipWhenOverflow,
                  // filter 相关属性
                  filterable: this.filters || this.filterMethod,
                  filteredValue: [],
                  filterPlacement: '',
                  isColumnGroup: false,
                  filterOpened: false,
                  // sort 相关属性
                  sortable,
                  // index 列
                  index: this.index,
                };

                const basicProps = ['columnKey', 'label', 'className', 'labelClassName', 'type', 'renderHeader', 'formatter', 'fixed', 'resizable'];
                const sortProps = ['sortMethod', 'sortBy', 'sortOrders'];
                const selectProps = ['selectable', 'reserveSelection'];
                const filterProps = ['filterMethod', 'filters', 'filterMultiple', 'filterOpened', 'filteredValue', 'filterPlacement'];

                let column = this.getPropsData(basicProps, sortProps, selectProps, filterProps);
                column = mergeOptions(defaults, column);

                // 注意 compose 中函数执行的顺序是从右到左
                const chains = compose(this.setColumnRenders, this.setColumnWidth, this.setColumnForcedProps);
                column = chains(column);

                this.columnConfig = column;

                // 注册 watcher
                this.registerNormalWatchers();
                this.registerComplexWatchers();
              },
              mounted: function mounted() {
                const { owner } = this;
                const parent = this.columnOrTableParent;
                const children = this.isSubColumn ? parent.$el.children : parent.$refs.hiddenColumns.children;
                const columnIndex = this.getColumnElIndex(children, this.$el);

                owner.store.commit('insertColumn', this.columnConfig, columnIndex, this.isSubColumn ? parent.columnConfig : null);
              },
              destroyed: function destroyed() {
                if (!this.$parent) return;
                const parent = this.$parent;
                this.owner.store.commit('removeColumn', this.columnConfig, this.isSubColumn ? parent.columnConfig : null);
              },
              render: function render(h) {
                // slots 也要渲染，需要计算合并表头
                return h('div', this.$slots.default);
              },
            });
            // CONCATENATED MODULE: ./packages/table-column/index.js

            /* istanbul ignore next */
            table_column.install = function (Vue) {
              Vue.component(table_column.name, table_column);
            };

            /* harmony default export */ const packages_table_column = (table_column);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/picker.vue?vue&type=template&id=79ae069f&
            const pickervue_type_template_id_79ae069f_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return !_vm.ranged
                ? _c(
                  'el-input',
                  _vm._b(
                    {
                      directives: [
                        {
                          name: 'clickoutside',
                          rawName: 'v-clickoutside',
                          value: _vm.handleClose,
                          expression: 'handleClose',
                        },
                      ],
                      ref: 'reference',
                      staticClass: 'el-date-editor',
                      class: `el-date-editor--${_vm.type}`,
                      attrs: {
                        readonly:
                !_vm.editable
                || _vm.readonly
                || _vm.type === 'dates'
                || _vm.type === 'week',
                        disabled: _vm.pickerDisabled,
                        size: _vm.pickerSize,
                        name: _vm.name,
                        placeholder: _vm.placeholder,
                        value: _vm.displayValue,
                        validateEvent: false,
                      },
                      on: {
                        focus: _vm.handleFocus,
                        input(value) {
                          return (_vm.userInput = value);
                        },
                        change: _vm.handleChange,
                      },
                      nativeOn: {
                        keydown($event) {
                          return _vm.handleKeydown($event);
                        },
                        mouseenter($event) {
                          return _vm.handleMouseEnter($event);
                        },
                        mouseleave($event) {
                          _vm.showClose = false;
                        },
                      },
                    },
                    'el-input',
                    _vm.firstInputId,
                    false,
                  ),
                  [
                    _c('i', {
                      staticClass: 'el-input__icon',
                      class: _vm.triggerClass,
                      attrs: { slot: 'prefix' },
                      on: { click: _vm.handleFocus },
                      slot: 'prefix',
                    }),
                    _vm.haveTrigger
                      ? _c('i', {
                        staticClass: 'el-input__icon',
                        class: [_vm.showClose ? `${_vm.clearIcon}` : ''],
                        attrs: { slot: 'suffix' },
                        on: { click: _vm.handleClickIcon },
                        slot: 'suffix',
                      })
                      : _vm._e(),
                  ],
                )
                : _c(
                  'div',
                  {
                    directives: [
                      {
                        name: 'clickoutside',
                        rawName: 'v-clickoutside',
                        value: _vm.handleClose,
                        expression: 'handleClose',
                      },
                    ],
                    ref: 'reference',
                    staticClass: 'el-date-editor el-range-editor el-input__inner',
                    class: [
                      `el-date-editor--${_vm.type}`,
                      _vm.pickerSize ? `el-range-editor--${_vm.pickerSize}` : '',
                      _vm.pickerDisabled ? 'is-disabled' : '',
                      _vm.pickerVisible ? 'is-active' : '',
                    ],
                    on: {
                      click: _vm.handleRangeClick,
                      mouseenter: _vm.handleMouseEnter,
                      mouseleave($event) {
                        _vm.showClose = false;
                      },
                      keydown: _vm.handleKeydown,
                    },
                  },
                  [
                    _c('i', {
                      class: ['el-input__icon', 'el-range__icon', _vm.triggerClass],
                    }),
                    _c(
                      'input',
                      _vm._b(
                        {
                          staticClass: 'el-range-input',
                          attrs: {
                            autocomplete: 'off',
                            placeholder: _vm.startPlaceholder,
                            disabled: _vm.pickerDisabled,
                            readonly: !_vm.editable || _vm.readonly,
                            name: _vm.name && _vm.name[0],
                          },
                          domProps: { value: _vm.displayValue && _vm.displayValue[0] },
                          on: {
                            input: _vm.handleStartInput,
                            change: _vm.handleStartChange,
                            focus: _vm.handleFocus,
                          },
                        },
                        'input',
                        _vm.firstInputId,
                        false,
                      ),
                    ),
                    _vm._t('range-separator', [
                      _c('span', { staticClass: 'el-range-separator' }, [
                        _vm._v(_vm._s(_vm.rangeSeparator)),
                      ]),
                    ]),
                    _c(
                      'input',
                      _vm._b(
                        {
                          staticClass: 'el-range-input',
                          attrs: {
                            autocomplete: 'off',
                            placeholder: _vm.endPlaceholder,
                            disabled: _vm.pickerDisabled,
                            readonly: !_vm.editable || _vm.readonly,
                            name: _vm.name && _vm.name[1],
                          },
                          domProps: { value: _vm.displayValue && _vm.displayValue[1] },
                          on: {
                            input: _vm.handleEndInput,
                            change: _vm.handleEndChange,
                            focus: _vm.handleFocus,
                          },
                        },
                        'input',
                        _vm.secondInputId,
                        false,
                      ),
                    ),
                    _vm.haveTrigger
                      ? _c('i', {
                        staticClass: 'el-input__icon el-range__close-icon',
                        class: [_vm.showClose ? `${_vm.clearIcon}` : ''],
                        on: { click: _vm.handleClickIcon },
                      })
                      : _vm._e(),
                  ],
                  2,
                );
            };
            const pickervue_type_template_id_79ae069f_staticRenderFns = [];
            pickervue_type_template_id_79ae069f_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/picker.vue?vue&type=template&id=79ae069f&

            // EXTERNAL MODULE: external "element-ui/lib/utils/date-util"
            const date_util_ = __webpack_require__(0);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/picker.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const NewPopper = {
              props: {
                appendToBody: vue_popper_default.a.props.appendToBody,
                offset: vue_popper_default.a.props.offset,
                boundariesPadding: vue_popper_default.a.props.boundariesPadding,
                arrowOffset: vue_popper_default.a.props.arrowOffset,
              },
              methods: vue_popper_default.a.methods,
              data: function data() {
                return merge_default()({ visibleArrow: true }, vue_popper_default.a.data);
              },

              beforeDestroy: vue_popper_default.a.beforeDestroy,
            };

            const DEFAULT_FORMATS = {
              date: 'yyyy-MM-dd',
              month: 'yyyy-MM',
              datetime: 'yyyy-MM-dd HH:mm:ss',
              time: 'HH:mm:ss',
              week: 'yyyywWW',
              timerange: 'HH:mm:ss',
              daterange: 'yyyy-MM-dd',
              monthrange: 'yyyy-MM',
              datetimerange: 'yyyy-MM-dd HH:mm:ss',
              year: 'yyyy',
            };
            const HAVE_TRIGGER_TYPES = ['date', 'datetime', 'time', 'time-select', 'week', 'month', 'year', 'daterange', 'monthrange', 'timerange', 'datetimerange', 'dates'];
            const pickervue_type_script_lang_js_DATE_FORMATTER = function DATE_FORMATTER(value, format) {
              if (format === 'timestamp') return value.getTime();
              return Object(date_util_.formatDate)(value, format);
            };
            const pickervue_type_script_lang_js_DATE_PARSER = function DATE_PARSER(text, format) {
              if (format === 'timestamp') return new Date(Number(text));
              return Object(date_util_.parseDate)(text, format);
            };
            const RANGE_FORMATTER = function RANGE_FORMATTER(value, format) {
              if (Array.isArray(value) && value.length === 2) {
                const start = value[0];
                const end = value[1];

                if (start && end) {
                  return [pickervue_type_script_lang_js_DATE_FORMATTER(start, format), pickervue_type_script_lang_js_DATE_FORMATTER(end, format)];
                }
              }
              return '';
            };
            const RANGE_PARSER = function RANGE_PARSER(array, format, separator) {
              if (!Array.isArray(array)) {
                array = array.split(separator);
              }
              if (array.length === 2) {
                const range1 = array[0];
                const range2 = array[1];

                return [pickervue_type_script_lang_js_DATE_PARSER(range1, format), pickervue_type_script_lang_js_DATE_PARSER(range2, format)];
              }
              return [];
            };
            var TYPE_VALUE_RESOLVER_MAP = {
              default: {
                formatter: function formatter(value) {
                  if (!value) return '';
                  return `${value}`;
                },
                parser: function parser(text) {
                  if (text === undefined || text === '') return null;
                  return text;
                },
              },
              week: {
                formatter: function formatter(value, format) {
                  const week = Object(date_util_.getWeekNumber)(value);
                  const month = value.getMonth();
                  const trueDate = new Date(value);
                  if (week === 1 && month === 11) {
                    trueDate.setHours(0, 0, 0, 0);
                    trueDate.setDate(trueDate.getDate() + 3 - (trueDate.getDay() + 6) % 7);
                  }
                  let date = Object(date_util_.formatDate)(trueDate, format);

                  date = /WW/.test(date) ? date.replace(/WW/, week < 10 ? `0${week}` : week) : date.replace(/W/, week);
                  return date;
                },
                parser: function parser(text, format) {
                  // parse as if a normal date
                  return TYPE_VALUE_RESOLVER_MAP.date.parser(text, format);
                },
              },
              date: {
                formatter: pickervue_type_script_lang_js_DATE_FORMATTER,
                parser: pickervue_type_script_lang_js_DATE_PARSER,
              },
              datetime: {
                formatter: pickervue_type_script_lang_js_DATE_FORMATTER,
                parser: pickervue_type_script_lang_js_DATE_PARSER,
              },
              daterange: {
                formatter: RANGE_FORMATTER,
                parser: RANGE_PARSER,
              },
              monthrange: {
                formatter: RANGE_FORMATTER,
                parser: RANGE_PARSER,
              },
              datetimerange: {
                formatter: RANGE_FORMATTER,
                parser: RANGE_PARSER,
              },
              timerange: {
                formatter: RANGE_FORMATTER,
                parser: RANGE_PARSER,
              },
              time: {
                formatter: pickervue_type_script_lang_js_DATE_FORMATTER,
                parser: pickervue_type_script_lang_js_DATE_PARSER,
              },
              month: {
                formatter: pickervue_type_script_lang_js_DATE_FORMATTER,
                parser: pickervue_type_script_lang_js_DATE_PARSER,
              },
              year: {
                formatter: pickervue_type_script_lang_js_DATE_FORMATTER,
                parser: pickervue_type_script_lang_js_DATE_PARSER,
              },
              number: {
                formatter: function formatter(value) {
                  if (!value) return '';
                  return `${value}`;
                },
                parser: function parser(text) {
                  const result = Number(text);

                  if (!isNaN(text)) {
                    return result;
                  }
                  return null;
                },
              },
              dates: {
                formatter: function formatter(value, format) {
                  return value.map((date) => pickervue_type_script_lang_js_DATE_FORMATTER(date, format));
                },
                parser: function parser(value, format) {
                  return (typeof value === 'string' ? value.split(', ') : value).map((date) => (date instanceof Date ? date : pickervue_type_script_lang_js_DATE_PARSER(date, format)));
                },
              },
            };
            const PLACEMENT_MAP = {
              left: 'bottom-start',
              center: 'bottom',
              right: 'bottom-end',
            };

            const parseAsFormatAndType = function parseAsFormatAndType(value, customFormat, type) {
              const rangeSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '-';

              if (!value) return null;
              const { parser } = TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP.default;
              const format = customFormat || DEFAULT_FORMATS[type];
              return parser(value, format, rangeSeparator);
            };

            const formatAsFormatAndType = function formatAsFormatAndType(value, customFormat, type) {
              if (!value) return null;
              const { formatter } = TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP.default;
              const format = customFormat || DEFAULT_FORMATS[type];
              return formatter(value, format);
            };

            /*
 * Considers:
 *   1. Date object
 *   2. date string
 *   3. array of 1 or 2
 */
            const valueEquals = function valueEquals(a, b) {
              // considers Date object and string
              const dateEquals = function dateEquals(a, b) {
                const aIsDate = a instanceof Date;
                const bIsDate = b instanceof Date;
                if (aIsDate && bIsDate) {
                  return a.getTime() === b.getTime();
                }
                if (!aIsDate && !bIsDate) {
                  return a === b;
                }
                return false;
              };

              const aIsArray = a instanceof Array;
              const bIsArray = b instanceof Array;
              if (aIsArray && bIsArray) {
                if (a.length !== b.length) {
                  return false;
                }
                return a.every((item, index) => dateEquals(item, b[index]));
              }
              if (!aIsArray && !bIsArray) {
                return dateEquals(a, b);
              }
              return false;
            };

            const isString = function isString(val) {
              return typeof val === 'string' || val instanceof String;
            };

            const pickervue_type_script_lang_js_validator = function validator(val) {
              // either: String, Array of String, null / undefined
              return val === null || val === undefined || isString(val) || Array.isArray(val) && val.length === 2 && val.every(isString);
            };

            /* harmony default export */ const pickervue_type_script_lang_js_ = ({
              mixins: [emitter_default.a, NewPopper],

              inject: {
                elForm: {
                  default: '',
                },
                elFormItem: {
                  default: '',
                },
              },

              props: {
                size: String,
                format: String,
                valueFormat: String,
                readonly: Boolean,
                placeholder: String,
                startPlaceholder: String,
                endPlaceholder: String,
                prefixIcon: String,
                clearIcon: {
                  type: String,
                  default: 'el-icon-circle-close',
                },
                name: {
                  default: '',
                  validator: pickervue_type_script_lang_js_validator,
                },
                disabled: Boolean,
                clearable: {
                  type: Boolean,
                  default: true,
                },
                id: {
                  default: '',
                  validator: pickervue_type_script_lang_js_validator,
                },
                popperClass: String,
                editable: {
                  type: Boolean,
                  default: true,
                },
                align: {
                  type: String,
                  default: 'left',
                },
                value: {},
                defaultValue: {},
                defaultTime: {},
                rangeSeparator: {
                  default: '-',
                },
                pickerOptions: {},
                unlinkPanels: Boolean,
                validateEvent: {
                  type: Boolean,
                  default: true,
                },
              },

              components: { ElInput: input_default.a },

              directives: { Clickoutside: clickoutside_default.a },

              data: function data() {
                return {
                  pickerVisible: false,
                  showClose: false,
                  userInput: null,
                  valueOnOpen: null, // value when picker opens, used to determine whether to emit change
                  unwatchPickerOptions: null,
                };
              },

              watch: {
                pickerVisible: function pickerVisible(val) {
                  if (this.readonly || this.pickerDisabled) return;
                  if (val) {
                    this.showPicker();
                    this.valueOnOpen = Array.isArray(this.value) ? [].concat(this.value) : this.value;
                  } else {
                    this.hidePicker();
                    this.emitChange(this.value);
                    this.userInput = null;
                    if (this.validateEvent) {
                      this.dispatch('ElFormItem', 'el.form.blur');
                    }
                    this.$emit('blur', this);
                    this.blur();
                  }
                },

                parsedValue: {
                  immediate: true,
                  handler: function handler(val) {
                    if (this.picker) {
                      this.picker.value = val;
                    }
                  },
                },
                defaultValue: function defaultValue(val) {
                  // NOTE: should eventually move to jsx style picker + panel ?
                  if (this.picker) {
                    this.picker.defaultValue = val;
                  }
                },
                value: function value(val, oldVal) {
                  if (!valueEquals(val, oldVal) && !this.pickerVisible && this.validateEvent) {
                    this.dispatch('ElFormItem', 'el.form.change', val);
                  }
                },
              },

              computed: {
                ranged: function ranged() {
                  return this.type.indexOf('range') > -1;
                },
                reference: function reference() {
                  const { reference } = this.$refs;
                  return reference.$el || reference;
                },
                refInput: function refInput() {
                  if (this.reference) {
                    return [].slice.call(this.reference.querySelectorAll('input'));
                  }
                  return [];
                },
                valueIsEmpty: function valueIsEmpty() {
                  const val = this.value;
                  if (Array.isArray(val)) {
                    for (let i = 0, len = val.length; i < len; i++) {
                      if (val[i]) {
                        return false;
                      }
                    }
                  } else if (val) {
                    return false;
                  }
                  return true;
                },
                triggerClass: function triggerClass() {
                  return this.prefixIcon || (this.type.indexOf('time') !== -1 ? 'el-icon-time' : 'el-icon-date');
                },
                selectionMode: function selectionMode() {
                  if (this.type === 'week') {
                    return 'week';
                  } if (this.type === 'month') {
                    return 'month';
                  } if (this.type === 'year') {
                    return 'year';
                  } if (this.type === 'dates') {
                    return 'dates';
                  }

                  return 'day';
                },
                haveTrigger: function haveTrigger() {
                  if (typeof this.showTrigger !== 'undefined') {
                    return this.showTrigger;
                  }
                  return HAVE_TRIGGER_TYPES.indexOf(this.type) !== -1;
                },
                displayValue: function displayValue() {
                  let formattedValue = formatAsFormatAndType(this.parsedValue, this.format, this.type, this.rangeSeparator);
                  if (Array.isArray(this.userInput)) {
                    return [this.userInput[0] || formattedValue && formattedValue[0] || '', this.userInput[1] || formattedValue && formattedValue[1] || ''];
                  } if (this.userInput !== null) {
                    return this.userInput;
                  } if (formattedValue) {
                    return this.type === 'dates' ? formattedValue.join(', ') : formattedValue;
                  }
                  return '';
                },
                parsedValue: function parsedValue() {
                  if (!this.value) return this.value; // component value is not set
                  if (this.type === 'time-select') return this.value; // time-select does not require parsing, this might change in next major version

                  const valueIsDateObject = Object(date_util_.isDateObject)(this.value) || Array.isArray(this.value) && this.value.every(date_util_.isDateObject);
                  if (valueIsDateObject) {
                    return this.value;
                  }

                  if (this.valueFormat) {
                    return parseAsFormatAndType(this.value, this.valueFormat, this.type, this.rangeSeparator) || this.value;
                  }

                  // NOTE: deal with common but incorrect usage, should remove in next major version
                  // user might provide string / timestamp without value-format, coerce them into date (or array of date)
                  return Array.isArray(this.value) ? this.value.map((val) => new Date(val)) : new Date(this.value);
                },
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                pickerSize: function pickerSize() {
                  return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
                pickerDisabled: function pickerDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
                firstInputId: function firstInputId() {
                  const obj = {};
                  let id = void 0;
                  if (this.ranged) {
                    id = this.id && this.id[0];
                  } else {
                    id = this.id;
                  }
                  if (id) obj.id = id;
                  return obj;
                },
                secondInputId: function secondInputId() {
                  const obj = {};
                  let id = void 0;
                  if (this.ranged) {
                    id = this.id && this.id[1];
                  }
                  if (id) obj.id = id;
                  return obj;
                },
              },

              created: function created() {
                // vue-popper
                this.popperOptions = {
                  boundariesPadding: 0,
                  gpuAcceleration: false,
                };
                this.placement = PLACEMENT_MAP[this.align] || PLACEMENT_MAP.left;

                this.$on('fieldReset', this.handleFieldReset);
              },

              methods: {
                focus: function focus() {
                  if (!this.ranged) {
                    this.$refs.reference.focus();
                  } else {
                    this.handleFocus();
                  }
                },
                blur: function blur() {
                  this.refInput.forEach((input) => input.blur());
                },

                // {parse, formatTo} Value deals maps component value with internal Date
                parseValue: function parseValue(value) {
                  const isParsed = Object(date_util_.isDateObject)(value) || Array.isArray(value) && value.every(date_util_.isDateObject);
                  if (this.valueFormat && !isParsed) {
                    return parseAsFormatAndType(value, this.valueFormat, this.type, this.rangeSeparator) || value;
                  }
                  return value;
                },
                formatToValue: function formatToValue(date) {
                  const isFormattable = Object(date_util_.isDateObject)(date) || Array.isArray(date) && date.every(date_util_.isDateObject);
                  if (this.valueFormat && isFormattable) {
                    return formatAsFormatAndType(date, this.valueFormat, this.type, this.rangeSeparator);
                  }
                  return date;
                },

                // {parse, formatTo} String deals with user input
                parseString: function parseString(value) {
                  const type = Array.isArray(value) ? this.type : this.type.replace('range', '');
                  return parseAsFormatAndType(value, this.format, type);
                },
                formatToString: function formatToString(value) {
                  const type = Array.isArray(value) ? this.type : this.type.replace('range', '');
                  return formatAsFormatAndType(value, this.format, type);
                },
                handleMouseEnter: function handleMouseEnter() {
                  if (this.readonly || this.pickerDisabled) return;
                  if (!this.valueIsEmpty && this.clearable) {
                    this.showClose = true;
                  }
                },
                handleChange: function handleChange() {
                  if (this.userInput) {
                    const value = this.parseString(this.displayValue);
                    if (value) {
                      this.picker.value = value;
                      if (this.isValidValue(value)) {
                        this.emitInput(value);
                        this.userInput = null;
                      }
                    }
                  }
                  if (this.userInput === '') {
                    this.emitInput(null);
                    this.emitChange(null);
                    this.userInput = null;
                  }
                },
                handleStartInput: function handleStartInput(event) {
                  if (this.userInput) {
                    this.userInput = [event.target.value, this.userInput[1]];
                  } else {
                    this.userInput = [event.target.value, null];
                  }
                },
                handleEndInput: function handleEndInput(event) {
                  if (this.userInput) {
                    this.userInput = [this.userInput[0], event.target.value];
                  } else {
                    this.userInput = [null, event.target.value];
                  }
                },
                handleStartChange: function handleStartChange(event) {
                  const value = this.parseString(this.userInput && this.userInput[0]);
                  if (value) {
                    this.userInput = [this.formatToString(value), this.displayValue[1]];
                    const newValue = [value, this.picker.value && this.picker.value[1]];
                    this.picker.value = newValue;
                    if (this.isValidValue(newValue)) {
                      this.emitInput(newValue);
                      this.userInput = null;
                    }
                  }
                },
                handleEndChange: function handleEndChange(event) {
                  const value = this.parseString(this.userInput && this.userInput[1]);
                  if (value) {
                    this.userInput = [this.displayValue[0], this.formatToString(value)];
                    const newValue = [this.picker.value && this.picker.value[0], value];
                    this.picker.value = newValue;
                    if (this.isValidValue(newValue)) {
                      this.emitInput(newValue);
                      this.userInput = null;
                    }
                  }
                },
                handleClickIcon: function handleClickIcon(event) {
                  if (this.readonly || this.pickerDisabled) return;
                  if (this.showClose) {
                    this.valueOnOpen = this.value;
                    event.stopPropagation();
                    this.emitInput(null);
                    this.emitChange(null);
                    this.showClose = false;
                    if (this.picker && typeof this.picker.handleClear === 'function') {
                      this.picker.handleClear();
                    }
                  } else {
                    this.pickerVisible = !this.pickerVisible;
                  }
                },
                handleClose: function handleClose() {
                  if (!this.pickerVisible) return;
                  this.pickerVisible = false;

                  if (this.type === 'dates') {
                    // restore to former value
                    const oldValue = parseAsFormatAndType(this.valueOnOpen, this.valueFormat, this.type, this.rangeSeparator) || this.valueOnOpen;
                    this.emitInput(oldValue);
                  }
                },
                handleFieldReset: function handleFieldReset(initialValue) {
                  this.userInput = initialValue === '' ? null : initialValue;
                },
                handleFocus: function handleFocus() {
                  const { type } = this;

                  if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {
                    this.pickerVisible = true;
                  }
                  this.$emit('focus', this);
                },
                handleKeydown: function handleKeydown(event) {
                  const _this = this;

                  const { keyCode } = event;

                  // ESC
                  if (keyCode === 27) {
                    this.pickerVisible = false;
                    event.stopPropagation();
                    return;
                  }

                  // Tab
                  if (keyCode === 9) {
                    if (!this.ranged) {
                      this.handleChange();
                      this.pickerVisible = this.picker.visible = false;
                      this.blur();
                      event.stopPropagation();
                    } else {
                      // user may change focus between two input
                      setTimeout(() => {
                        if (_this.refInput.indexOf(document.activeElement) === -1) {
                          _this.pickerVisible = false;
                          _this.blur();
                          event.stopPropagation();
                        }
                      }, 0);
                    }
                    return;
                  }

                  // Enter
                  if (keyCode === 13) {
                    if (this.userInput === '' || this.isValidValue(this.parseString(this.displayValue))) {
                      this.handleChange();
                      this.pickerVisible = this.picker.visible = false;
                      this.blur();
                    }
                    event.stopPropagation();
                    return;
                  }

                  // if user is typing, do not let picker handle key input
                  if (this.userInput) {
                    event.stopPropagation();
                    return;
                  }

                  // delegate other keys to panel
                  if (this.picker && this.picker.handleKeydown) {
                    this.picker.handleKeydown(event);
                  }
                },
                handleRangeClick: function handleRangeClick() {
                  const { type } = this;

                  if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {
                    this.pickerVisible = true;
                  }
                  this.$emit('focus', this);
                },
                hidePicker: function hidePicker() {
                  if (this.picker) {
                    this.picker.resetView && this.picker.resetView();
                    this.pickerVisible = this.picker.visible = false;
                    this.destroyPopper();
                  }
                },
                showPicker: function showPicker() {
                  const _this2 = this;

                  if (this.$isServer) return;
                  if (!this.picker) {
                    this.mountPicker();
                  }
                  this.pickerVisible = this.picker.visible = true;

                  this.updatePopper();

                  this.picker.value = this.parsedValue;
                  this.picker.resetView && this.picker.resetView();

                  this.$nextTick(() => {
                    _this2.picker.adjustSpinners && _this2.picker.adjustSpinners();
                  });
                },
                mountPicker: function mountPicker() {
                  const _this3 = this;

                  this.picker = new external_vue_default.a(this.panel).$mount();
                  this.picker.defaultValue = this.defaultValue;
                  this.picker.defaultTime = this.defaultTime;
                  this.picker.popperClass = this.popperClass;
                  this.popperElm = this.picker.$el;
                  this.picker.width = this.reference.getBoundingClientRect().width;
                  this.picker.showTime = this.type === 'datetime' || this.type === 'datetimerange';
                  this.picker.selectionMode = this.selectionMode;
                  this.picker.unlinkPanels = this.unlinkPanels;
                  this.picker.arrowControl = this.arrowControl || this.timeArrowControl || false;
                  this.$watch('format', (format) => {
                    _this3.picker.format = format;
                  });

                  const updateOptions = function updateOptions() {
                    const options = _this3.pickerOptions;

                    if (options && options.selectableRange) {
                      let ranges = options.selectableRange;
                      const { parser } = TYPE_VALUE_RESOLVER_MAP.datetimerange;
                      const format = DEFAULT_FORMATS.timerange;

                      ranges = Array.isArray(ranges) ? ranges : [ranges];
                      _this3.picker.selectableRange = ranges.map((range) => parser(range, format, _this3.rangeSeparator));
                    }

                    for (const option in options) {
                      if (options.hasOwnProperty(option)
          // 忽略 time-picker 的该配置项
          && option !== 'selectableRange') {
                        _this3.picker[option] = options[option];
                      }
                    }

                    // main format must prevail over undocumented pickerOptions.format
                    if (_this3.format) {
                      _this3.picker.format = _this3.format;
                    }
                  };
                  updateOptions();
                  this.unwatchPickerOptions = this.$watch('pickerOptions', () => updateOptions(), { deep: true });
                  this.$el.appendChild(this.picker.$el);
                  this.picker.resetView && this.picker.resetView();

                  this.picker.$on('dodestroy', this.doDestroy);
                  this.picker.$on('pick', function () {
                    const date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
                    const visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                    _this3.userInput = null;
                    _this3.pickerVisible = _this3.picker.visible = visible;
                    _this3.emitInput(date);
                    _this3.picker.resetView && _this3.picker.resetView();
                  });

                  this.picker.$on('select-range', (start, end, pos) => {
                    if (_this3.refInput.length === 0) return;
                    if (!pos || pos === 'min') {
                      _this3.refInput[0].setSelectionRange(start, end);
                      _this3.refInput[0].focus();
                    } else if (pos === 'max') {
                      _this3.refInput[1].setSelectionRange(start, end);
                      _this3.refInput[1].focus();
                    }
                  });
                },
                unmountPicker: function unmountPicker() {
                  if (this.picker) {
                    this.picker.$destroy();
                    this.picker.$off();
                    if (typeof this.unwatchPickerOptions === 'function') {
                      this.unwatchPickerOptions();
                    }
                    this.picker.$el.parentNode.removeChild(this.picker.$el);
                  }
                },
                emitChange: function emitChange(val) {
                  // determine user real change only
                  if (!valueEquals(val, this.valueOnOpen)) {
                    this.$emit('change', val);
                    this.valueOnOpen = val;
                    if (this.validateEvent) {
                      this.dispatch('ElFormItem', 'el.form.change', val);
                    }
                  }
                },
                emitInput: function emitInput(val) {
                  const formatted = this.formatToValue(val);
                  if (!valueEquals(this.value, formatted)) {
                    this.$emit('input', formatted);
                  }
                },
                isValidValue: function isValidValue(value) {
                  if (!this.picker) {
                    this.mountPicker();
                  }
                  if (this.picker.isValidValue) {
                    return value && this.picker.isValidValue(value);
                  }
                  return true;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/picker.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_pickervue_type_script_lang_js_ = (pickervue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/picker.vue

            /* normalize component */

            const picker_component = normalizeComponent(
              src_pickervue_type_script_lang_js_,
              pickervue_type_template_id_79ae069f_render,
              pickervue_type_template_id_79ae069f_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let picker_api; }
            picker_component.options.__file = 'packages/date-picker/src/picker.vue';
            /* harmony default export */ const picker = (picker_component.exports);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date.vue?vue&type=template&id=2440d4ea&
            const datevue_type_template_id_2440d4ea_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                {
                  attrs: { name: 'el-zoom-in-top' },
                  on: { 'after-enter': _vm.handleEnter, 'after-leave': _vm.handleLeave },
                },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.visible,
                          expression: 'visible',
                        },
                      ],
                      staticClass: 'el-picker-panel el-date-picker el-popper',
                      class: [
                        {
                          'has-sidebar': _vm.$slots.sidebar || _vm.shortcuts,
                          'has-time': _vm.showTime,
                        },
                        _vm.popperClass,
                      ],
                    },
                    [
                      _c(
                        'div',
                        { staticClass: 'el-picker-panel__body-wrapper' },
                        [
                          _vm._t('sidebar'),
                          _vm.shortcuts
                            ? _c(
                              'div',
                              { staticClass: 'el-picker-panel__sidebar' },
                              _vm._l(_vm.shortcuts, (shortcut, key) => _c(
                                'button',
                                {
                                  key,
                                  staticClass: 'el-picker-panel__shortcut',
                                  attrs: { type: 'button' },
                                  on: {
                                    click($event) {
                                      _vm.handleShortcutClick(shortcut);
                                    },
                                  },
                                },
                                [_vm._v(_vm._s(shortcut.text))],
                              )),
                              0,
                            )
                            : _vm._e(),
                          _c('div', { staticClass: 'el-picker-panel__body' }, [
                            _vm.showTime
                              ? _c('div', { staticClass: 'el-date-picker__time-header' }, [
                                _c(
                                  'span',
                                  { staticClass: 'el-date-picker__editor-wrap' },
                                  [
                                    _c('el-input', {
                                      attrs: {
                                        placeholder: _vm.t('el.datepicker.selectDate'),
                                        value: _vm.visibleDate,
                                        size: 'small',
                                      },
                                      on: {
                                        input(val) {
                                          return (_vm.userInputDate = val);
                                        },
                                        change: _vm.handleVisibleDateChange,
                                      },
                                    }),
                                  ],
                                  1,
                                ),
                                _c(
                                  'span',
                                  {
                                    directives: [
                                      {
                                        name: 'clickoutside',
                                        rawName: 'v-clickoutside',
                                        value: _vm.handleTimePickClose,
                                        expression: 'handleTimePickClose',
                                      },
                                    ],
                                    staticClass: 'el-date-picker__editor-wrap',
                                  },
                                  [
                                    _c('el-input', {
                                      ref: 'input',
                                      attrs: {
                                        placeholder: _vm.t('el.datepicker.selectTime'),
                                        value: _vm.visibleTime,
                                        size: 'small',
                                      },
                                      on: {
                                        focus($event) {
                                          _vm.timePickerVisible = true;
                                        },
                                        input(val) {
                                          return (_vm.userInputTime = val);
                                        },
                                        change: _vm.handleVisibleTimeChange,
                                      },
                                    }),
                                    _c('time-picker', {
                                      ref: 'timepicker',
                                      attrs: {
                                        'time-arrow-control': _vm.arrowControl,
                                        visible: _vm.timePickerVisible,
                                      },
                                      on: {
                                        pick: _vm.handleTimePick,
                                        mounted: _vm.proxyTimePickerDataProperties,
                                      },
                                    }),
                                  ],
                                  1,
                                ),
                              ])
                              : _vm._e(),
                            _c(
                              'div',
                              {
                                directives: [
                                  {
                                    name: 'show',
                                    rawName: 'v-show',
                                    value: _vm.currentView !== 'time',
                                    expression: "currentView !== 'time'",
                                  },
                                ],
                                staticClass: 'el-date-picker__header',
                                class: {
                                  'el-date-picker__header--bordered':
                        _vm.currentView === 'year'
                        || _vm.currentView === 'month',
                                },
                              },
                              [
                                _c('button', {
                                  staticClass:
                        'el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-d-arrow-left',
                                  attrs: {
                                    type: 'button',
                                    'aria-label': _vm.t('el.datepicker.prevYear'),
                                  },
                                  on: { click: _vm.prevYear },
                                }),
                                _c('button', {
                                  directives: [
                                    {
                                      name: 'show',
                                      rawName: 'v-show',
                                      value: _vm.currentView === 'date',
                                      expression: "currentView === 'date'",
                                    },
                                  ],
                                  staticClass:
                        'el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-arrow-left',
                                  attrs: {
                                    type: 'button',
                                    'aria-label': _vm.t('el.datepicker.prevMonth'),
                                  },
                                  on: { click: _vm.prevMonth },
                                }),
                                _c(
                                  'span',
                                  {
                                    staticClass: 'el-date-picker__header-label',
                                    attrs: { role: 'button' },
                                    on: { click: _vm.showYearPicker },
                                  },
                                  [_vm._v(_vm._s(_vm.yearLabel))],
                                ),
                                _c(
                                  'span',
                                  {
                                    directives: [
                                      {
                                        name: 'show',
                                        rawName: 'v-show',
                                        value: _vm.currentView === 'date',
                                        expression: "currentView === 'date'",
                                      },
                                    ],
                                    staticClass: 'el-date-picker__header-label',
                                    class: { active: _vm.currentView === 'month' },
                                    attrs: { role: 'button' },
                                    on: { click: _vm.showMonthPicker },
                                  },
                                  [
                                    _vm._v(
                                      _vm._s(_vm.t(`el.datepicker.month${_vm.month + 1}`)),
                                    ),
                                  ],
                                ),
                                _c('button', {
                                  staticClass:
                        'el-picker-panel__icon-btn el-date-picker__next-btn el-icon-d-arrow-right',
                                  attrs: {
                                    type: 'button',
                                    'aria-label': _vm.t('el.datepicker.nextYear'),
                                  },
                                  on: { click: _vm.nextYear },
                                }),
                                _c('button', {
                                  directives: [
                                    {
                                      name: 'show',
                                      rawName: 'v-show',
                                      value: _vm.currentView === 'date',
                                      expression: "currentView === 'date'",
                                    },
                                  ],
                                  staticClass:
                        'el-picker-panel__icon-btn el-date-picker__next-btn el-icon-arrow-right',
                                  attrs: {
                                    type: 'button',
                                    'aria-label': _vm.t('el.datepicker.nextMonth'),
                                  },
                                  on: { click: _vm.nextMonth },
                                }),
                              ],
                            ),
                            _c(
                              'div',
                              { staticClass: 'el-picker-panel__content' },
                              [
                                _c('date-table', {
                                  directives: [
                                    {
                                      name: 'show',
                                      rawName: 'v-show',
                                      value: _vm.currentView === 'date',
                                      expression: "currentView === 'date'",
                                    },
                                  ],
                                  attrs: {
                                    'selection-mode': _vm.selectionMode,
                                    'first-day-of-week': _vm.firstDayOfWeek,
                                    value: _vm.value,
                                    'default-value': _vm.defaultValue
                                      ? new Date(_vm.defaultValue)
                                      : null,
                                    date: _vm.date,
                                    'cell-class-name': _vm.cellClassName,
                                    'disabled-date': _vm.disabledDate,
                                  },
                                  on: { pick: _vm.handleDatePick },
                                }),
                                _c('year-table', {
                                  directives: [
                                    {
                                      name: 'show',
                                      rawName: 'v-show',
                                      value: _vm.currentView === 'year',
                                      expression: "currentView === 'year'",
                                    },
                                  ],
                                  attrs: {
                                    value: _vm.value,
                                    'default-value': _vm.defaultValue
                                      ? new Date(_vm.defaultValue)
                                      : null,
                                    date: _vm.date,
                                    'disabled-date': _vm.disabledDate,
                                  },
                                  on: { pick: _vm.handleYearPick },
                                }),
                                _c('month-table', {
                                  directives: [
                                    {
                                      name: 'show',
                                      rawName: 'v-show',
                                      value: _vm.currentView === 'month',
                                      expression: "currentView === 'month'",
                                    },
                                  ],
                                  attrs: {
                                    value: _vm.value,
                                    'default-value': _vm.defaultValue
                                      ? new Date(_vm.defaultValue)
                                      : null,
                                    date: _vm.date,
                                    'disabled-date': _vm.disabledDate,
                                  },
                                  on: { pick: _vm.handleMonthPick },
                                }),
                              ],
                              1,
                            ),
                          ]),
                        ],
                        2,
                      ),
                      _c(
                        'div',
                        {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: _vm.footerVisible && _vm.currentView === 'date',
                              expression: "footerVisible && currentView === 'date'",
                            },
                          ],
                          staticClass: 'el-picker-panel__footer',
                        },
                        [
                          _c(
                            'el-button',
                            {
                              directives: [
                                {
                                  name: 'show',
                                  rawName: 'v-show',
                                  value: _vm.selectionMode !== 'dates',
                                  expression: "selectionMode !== 'dates'",
                                },
                              ],
                              staticClass: 'el-picker-panel__link-btn',
                              attrs: { size: 'mini', type: 'text' },
                              on: { click: _vm.changeToNow },
                            },
                            [
                              _vm._v(
                                `\n        ${
                                  _vm._s(_vm.t('el.datepicker.now'))
                                }\n      `,
                              ),
                            ],
                          ),
                          _c(
                            'el-button',
                            {
                              staticClass: 'el-picker-panel__link-btn',
                              attrs: { plain: '', size: 'mini' },
                              on: { click: _vm.confirm },
                            },
                            [
                              _vm._v(
                                `\n        ${
                                  _vm._s(_vm.t('el.datepicker.confirm'))
                                }\n      `,
                              ),
                            ],
                          ),
                        ],
                        1,
                      ),
                    ],
                  ),
                ],
              );
            };
            const datevue_type_template_id_2440d4ea_staticRenderFns = [];
            datevue_type_template_id_2440d4ea_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/panel/date.vue?vue&type=template&id=2440d4ea&

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time.vue?vue&type=template&id=3d939089&
            const timevue_type_template_id_3d939089_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                {
                  attrs: { name: 'el-zoom-in-top' },
                  on: {
                    'after-leave': function ($event) {
                      _vm.$emit('dodestroy');
                    },
                  },
                },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.visible,
                          expression: 'visible',
                        },
                      ],
                      staticClass: 'el-time-panel el-popper',
                      class: _vm.popperClass,
                    },
                    [
                      _c(
                        'div',
                        {
                          staticClass: 'el-time-panel__content',
                          class: { 'has-seconds': _vm.showSeconds },
                        },
                        [
                          _c('time-spinner', {
                            ref: 'spinner',
                            attrs: {
                              'arrow-control': _vm.useArrow,
                              'show-seconds': _vm.showSeconds,
                              'am-pm-mode': _vm.amPmMode,
                              date: _vm.date,
                            },
                            on: {
                              change: _vm.handleChange,
                              'select-range': _vm.setSelectionRange,
                            },
                          }),
                        ],
                        1,
                      ),
                      _c('div', { staticClass: 'el-time-panel__footer' }, [
                        _c(
                          'button',
                          {
                            staticClass: 'el-time-panel__btn cancel',
                            attrs: { type: 'button' },
                            on: { click: _vm.handleCancel },
                          },
                          [_vm._v(_vm._s(_vm.t('el.datepicker.cancel')))],
                        ),
                        _c(
                          'button',
                          {
                            staticClass: 'el-time-panel__btn',
                            class: { confirm: !_vm.disabled },
                            attrs: { type: 'button' },
                            on: {
                              click($event) {
                                _vm.handleConfirm();
                              },
                            },
                          },
                          [_vm._v(_vm._s(_vm.t('el.datepicker.confirm')))],
                        ),
                      ]),
                    ],
                  ),
                ],
              );
            };
            const timevue_type_template_id_3d939089_staticRenderFns = [];
            timevue_type_template_id_3d939089_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/panel/time.vue?vue&type=template&id=3d939089&

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/time-spinner.vue?vue&type=template&id=1facadeb&
            const time_spinnervue_type_template_id_1facadeb_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-time-spinner',
                  class: { 'has-seconds': _vm.showSeconds },
                },
                [
                  !_vm.arrowControl
                    ? [
                      _c(
                        'el-scrollbar',
                        {
                          ref: 'hours',
                          staticClass: 'el-time-spinner__wrapper',
                          attrs: {
                            'wrap-style': 'max-height: inherit;',
                            'view-class': 'el-time-spinner__list',
                            noresize: '',
                            tag: 'ul',
                          },
                          nativeOn: {
                            mouseenter($event) {
                              _vm.emitSelectRange('hours');
                            },
                            mousemove($event) {
                              _vm.adjustCurrentSpinner('hours');
                            },
                          },
                        },
                        _vm._l(_vm.hoursList, (disabled, hour) => _c(
                          'li',
                          {
                            key: hour,
                            staticClass: 'el-time-spinner__item',
                            class: { active: hour === _vm.hours, disabled },
                            on: {
                              click($event) {
                                _vm.handleClick('hours', {
                                  value: hour,
                                  disabled,
                                });
                              },
                            },
                          },
                          [
                            _vm._v(
                              _vm._s(
                                (`0${_vm.amPmMode ? hour % 12 || 12 : hour}`).slice(
                                  -2,
                                ),
                              ) + _vm._s(_vm.amPm(hour)),
                            ),
                          ],
                        )),
                        0,
                      ),
                      _c(
                        'el-scrollbar',
                        {
                          ref: 'minutes',
                          staticClass: 'el-time-spinner__wrapper',
                          attrs: {
                            'wrap-style': 'max-height: inherit;',
                            'view-class': 'el-time-spinner__list',
                            noresize: '',
                            tag: 'ul',
                          },
                          nativeOn: {
                            mouseenter($event) {
                              _vm.emitSelectRange('minutes');
                            },
                            mousemove($event) {
                              _vm.adjustCurrentSpinner('minutes');
                            },
                          },
                        },
                        _vm._l(_vm.minutesList, (enabled, key) => _c(
                          'li',
                          {
                            key,
                            staticClass: 'el-time-spinner__item',
                            class: { active: key === _vm.minutes, disabled: !enabled },
                            on: {
                              click($event) {
                                _vm.handleClick('minutes', {
                                  value: key,
                                  disabled: false,
                                });
                              },
                            },
                          },
                          [_vm._v(_vm._s((`0${key}`).slice(-2)))],
                        )),
                        0,
                      ),
                      _c(
                        'el-scrollbar',
                        {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: _vm.showSeconds,
                              expression: 'showSeconds',
                            },
                          ],
                          ref: 'seconds',
                          staticClass: 'el-time-spinner__wrapper',
                          attrs: {
                            'wrap-style': 'max-height: inherit;',
                            'view-class': 'el-time-spinner__list',
                            noresize: '',
                            tag: 'ul',
                          },
                          nativeOn: {
                            mouseenter($event) {
                              _vm.emitSelectRange('seconds');
                            },
                            mousemove($event) {
                              _vm.adjustCurrentSpinner('seconds');
                            },
                          },
                        },
                        _vm._l(60, (second, key) => _c(
                          'li',
                          {
                            key,
                            staticClass: 'el-time-spinner__item',
                            class: { active: key === _vm.seconds },
                            on: {
                              click($event) {
                                _vm.handleClick('seconds', {
                                  value: key,
                                  disabled: false,
                                });
                              },
                            },
                          },
                          [_vm._v(_vm._s((`0${key}`).slice(-2)))],
                        )),
                        0,
                      ),
                    ]
                    : _vm._e(),
                  _vm.arrowControl
                    ? [
                      _c(
                        'div',
                        {
                          staticClass: 'el-time-spinner__wrapper is-arrow',
                          on: {
                            mouseenter($event) {
                              _vm.emitSelectRange('hours');
                            },
                          },
                        },
                        [
                          _c('i', {
                            directives: [
                              {
                                name: 'repeat-click',
                                rawName: 'v-repeat-click',
                                value: _vm.decrease,
                                expression: 'decrease',
                              },
                            ],
                            staticClass: 'el-time-spinner__arrow el-icon-arrow-up',
                          }),
                          _c('i', {
                            directives: [
                              {
                                name: 'repeat-click',
                                rawName: 'v-repeat-click',
                                value: _vm.increase,
                                expression: 'increase',
                              },
                            ],
                            staticClass: 'el-time-spinner__arrow el-icon-arrow-down',
                          }),
                          _c(
                            'ul',
                            { ref: 'hours', staticClass: 'el-time-spinner__list' },
                            _vm._l(_vm.arrowHourList, (hour, key) => _c(
                              'li',
                              {
                                key,
                                staticClass: 'el-time-spinner__item',
                                class: {
                                  active: hour === _vm.hours,
                                  disabled: _vm.hoursList[hour],
                                },
                              },
                              [
                                _vm._v(
                                  _vm._s(
                                    hour === undefined
                                      ? ''
                                      : (
                                        `0${  _vm.amPmMode ? hour % 12 || 12 : hour}`
                                      ).slice(-2) + _vm.amPm(hour),
                                  ),
                                ),
                              ],
                            )),
                            0,
                          ),
                        ],
                      ),
                      _c(
                        'div',
                        {
                          staticClass: 'el-time-spinner__wrapper is-arrow',
                          on: {
                            mouseenter($event) {
                              _vm.emitSelectRange('minutes');
                            },
                          },
                        },
                        [
                          _c('i', {
                            directives: [
                              {
                                name: 'repeat-click',
                                rawName: 'v-repeat-click',
                                value: _vm.decrease,
                                expression: 'decrease',
                              },
                            ],
                            staticClass: 'el-time-spinner__arrow el-icon-arrow-up',
                          }),
                          _c('i', {
                            directives: [
                              {
                                name: 'repeat-click',
                                rawName: 'v-repeat-click',
                                value: _vm.increase,
                                expression: 'increase',
                              },
                            ],
                            staticClass: 'el-time-spinner__arrow el-icon-arrow-down',
                          }),
                          _c(
                            'ul',
                            { ref: 'minutes', staticClass: 'el-time-spinner__list' },
                            _vm._l(_vm.arrowMinuteList, (minute, key) => _c(
                              'li',
                              {
                                key,
                                staticClass: 'el-time-spinner__item',
                                class: { active: minute === _vm.minutes },
                              },
                              [
                                _vm._v(
                                  `\n          ${
                             _vm._s(
                              minute === undefined
                                ? ''
                                : (`0${  minute}`).slice(-2),
                            )
                             }\n        `,
                                ),
                              ],
                            )),
                            0,
                          ),
                        ],
                      ),
                      _vm.showSeconds
                        ? _c(
                          'div',
                          {
                            staticClass: 'el-time-spinner__wrapper is-arrow',
                            on: {
                              mouseenter($event) {
                                _vm.emitSelectRange('seconds');
                              },
                            },
                          },
                          [
                            _c('i', {
                              directives: [
                                {
                                  name: 'repeat-click',
                                  rawName: 'v-repeat-click',
                                  value: _vm.decrease,
                                  expression: 'decrease',
                                },
                              ],
                              staticClass: 'el-time-spinner__arrow el-icon-arrow-up',
                            }),
                            _c('i', {
                              directives: [
                                {
                                  name: 'repeat-click',
                                  rawName: 'v-repeat-click',
                                  value: _vm.increase,
                                  expression: 'increase',
                                },
                              ],
                              staticClass: 'el-time-spinner__arrow el-icon-arrow-down',
                            }),
                            _c(
                              'ul',
                              { ref: 'seconds', staticClass: 'el-time-spinner__list' },
                              _vm._l(_vm.arrowSecondList, (second, key) => _c(
                                'li',
                                {
                                  key,
                                  staticClass: 'el-time-spinner__item',
                                  class: { active: second === _vm.seconds },
                                },
                                [
                                  _vm._v(
                                    `\n          ${
                                 _vm._s(
                                  second === undefined
                                    ? ''
                                    : (`0${  second}`).slice(-2),
                                )
                                 }\n        `,
                                  ),
                                ],
                              )),
                              0,
                            ),
                          ],
                        )
                        : _vm._e(),
                    ]
                    : _vm._e(),
                ],
                2,
              );
            };
            const time_spinnervue_type_template_id_1facadeb_staticRenderFns = [];
            time_spinnervue_type_template_id_1facadeb_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/basic/time-spinner.vue?vue&type=template&id=1facadeb&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/time-spinner.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const time_spinnervue_type_script_lang_js_ = ({
              components: { ElScrollbar: scrollbar_default.a },

              directives: {
                repeatClick: repeat_click,
              },

              props: {
                date: {},
                defaultValue: {}, // reserved for future use
                showSeconds: {
                  type: Boolean,
                  default: true,
                },
                arrowControl: Boolean,
                amPmMode: {
                  type: String,
                  default: '', // 'a': am/pm; 'A': AM/PM
                },
              },

              computed: {
                hours: function hours() {
                  return this.date.getHours();
                },
                minutes: function minutes() {
                  return this.date.getMinutes();
                },
                seconds: function seconds() {
                  return this.date.getSeconds();
                },
                hoursList: function hoursList() {
                  return Object(date_util_.getRangeHours)(this.selectableRange);
                },
                minutesList: function minutesList() {
                  return Object(date_util_.getRangeMinutes)(this.selectableRange, this.hours);
                },
                arrowHourList: function arrowHourList() {
                  const { hours } = this;
                  return [hours > 0 ? hours - 1 : undefined, hours, hours < 23 ? hours + 1 : undefined];
                },
                arrowMinuteList: function arrowMinuteList() {
                  const { minutes } = this;
                  return [minutes > 0 ? minutes - 1 : undefined, minutes, minutes < 59 ? minutes + 1 : undefined];
                },
                arrowSecondList: function arrowSecondList() {
                  const { seconds } = this;
                  return [seconds > 0 ? seconds - 1 : undefined, seconds, seconds < 59 ? seconds + 1 : undefined];
                },
              },

              data: function data() {
                return {
                  selectableRange: [],
                  currentScrollbar: null,
                };
              },
              mounted: function mounted() {
                const _this = this;

                this.$nextTick(() => {
                  !_this.arrowControl && _this.bindScrollEvent();
                });
              },

              methods: {
                increase: function increase() {
                  this.scrollDown(1);
                },
                decrease: function decrease() {
                  this.scrollDown(-1);
                },
                modifyDateField: function modifyDateField(type, value) {
                  switch (type) {
                    case 'hours':
                      this.$emit('change', Object(date_util_.modifyTime)(this.date, value, this.minutes, this.seconds)); break;
                    case 'minutes':
                      this.$emit('change', Object(date_util_.modifyTime)(this.date, this.hours, value, this.seconds)); break;
                    case 'seconds':
                      this.$emit('change', Object(date_util_.modifyTime)(this.date, this.hours, this.minutes, value)); break;
                  }
                },
                handleClick: function handleClick(type, _ref) {
                  const { value } = _ref;
                  const { disabled } = _ref;

                  if (!disabled) {
                    this.modifyDateField(type, value);
                    this.emitSelectRange(type);
                    this.adjustSpinner(type, value);
                  }
                },
                emitSelectRange: function emitSelectRange(type) {
                  if (type === 'hours') {
                    this.$emit('select-range', 0, 2);
                  } else if (type === 'minutes') {
                    this.$emit('select-range', 3, 5);
                  } else if (type === 'seconds') {
                    this.$emit('select-range', 6, 8);
                  }
                  this.currentScrollbar = type;
                },
                bindScrollEvent: function bindScrollEvent() {
                  const _this2 = this;

                  const bindFuntion = function bindFuntion(type) {
                    _this2.$refs[type].wrap.onscroll = function (e) {
                      // TODO: scroll is emitted when set scrollTop programatically
                      // should find better solutions in the future!
                      _this2.handleScroll(type, e);
                    };
                  };
                  bindFuntion('hours');
                  bindFuntion('minutes');
                  bindFuntion('seconds');
                },
                handleScroll: function handleScroll(type) {
                  const value = Math.min(Math.round((this.$refs[type].wrap.scrollTop - (this.scrollBarHeight(type) * 0.5 - 10) / this.typeItemHeight(type) + 3) / this.typeItemHeight(type)), type === 'hours' ? 23 : 59);
                  this.modifyDateField(type, value);
                },

                // NOTE: used by datetime / date-range panel
                //       renamed from adjustScrollTop
                //       should try to refactory it
                adjustSpinners: function adjustSpinners() {
                  this.adjustSpinner('hours', this.hours);
                  this.adjustSpinner('minutes', this.minutes);
                  this.adjustSpinner('seconds', this.seconds);
                },
                adjustCurrentSpinner: function adjustCurrentSpinner(type) {
                  this.adjustSpinner(type, this[type]);
                },
                adjustSpinner: function adjustSpinner(type, value) {
                  if (this.arrowControl) return;
                  const el = this.$refs[type].wrap;
                  if (el) {
                    el.scrollTop = Math.max(0, value * this.typeItemHeight(type));
                  }
                },
                scrollDown: function scrollDown(step) {
                  const _this3 = this;

                  if (!this.currentScrollbar) {
                    this.emitSelectRange('hours');
                  }

                  const label = this.currentScrollbar;
                  const { hoursList } = this;
                  let now = this[label];

                  if (this.currentScrollbar === 'hours') {
                    let total = Math.abs(step);
                    step = step > 0 ? 1 : -1;
                    let { length } = hoursList;
                    while (length-- && total) {
                      now = (now + step + hoursList.length) % hoursList.length;
                      if (hoursList[now]) {
                        continue;
                      }
                      total--;
                    }
                    if (hoursList[now]) return;
                  } else {
                    now = (now + step + 60) % 60;
                  }

                  this.modifyDateField(label, now);
                  this.adjustSpinner(label, now);
                  this.$nextTick(() => _this3.emitSelectRange(_this3.currentScrollbar));
                },
                amPm: function amPm(hour) {
                  const shouldShowAmPm = this.amPmMode.toLowerCase() === 'a';
                  if (!shouldShowAmPm) return '';
                  const isCapital = this.amPmMode === 'A';
                  let content = hour < 12 ? ' am' : ' pm';
                  if (isCapital) content = content.toUpperCase();
                  return content;
                },
                typeItemHeight: function typeItemHeight(type) {
                  return this.$refs[type].$el.querySelector('li').offsetHeight;
                },
                scrollBarHeight: function scrollBarHeight(type) {
                  return this.$refs[type].$el.offsetHeight;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/basic/time-spinner.vue?vue&type=script&lang=js&
            /* harmony default export */ const basic_time_spinnervue_type_script_lang_js_ = (time_spinnervue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/basic/time-spinner.vue

            /* normalize component */

            const time_spinner_component = normalizeComponent(
              basic_time_spinnervue_type_script_lang_js_,
              time_spinnervue_type_template_id_1facadeb_render,
              time_spinnervue_type_template_id_1facadeb_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let time_spinner_api; }
            time_spinner_component.options.__file = 'packages/date-picker/src/basic/time-spinner.vue';
            /* harmony default export */ const time_spinner = (time_spinner_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const timevue_type_script_lang_js_ = ({
              mixins: [locale_default.a],

              components: {
                TimeSpinner: time_spinner,
              },

              props: {
                visible: Boolean,
                timeArrowControl: Boolean,
              },

              watch: {
                visible: function visible(val) {
                  const _this = this;

                  if (val) {
                    this.oldValue = this.value;
                    this.$nextTick(() => _this.$refs.spinner.emitSelectRange('hours'));
                  } else {
                    this.needInitAdjust = true;
                  }
                },
                value: function value(newVal) {
                  const _this2 = this;

                  let date = void 0;
                  if (newVal instanceof Date) {
                    date = Object(date_util_.limitTimeRange)(newVal, this.selectableRange, this.format);
                  } else if (!newVal) {
                    date = this.defaultValue ? new Date(this.defaultValue) : new Date();
                  }

                  this.date = date;
                  if (this.visible && this.needInitAdjust) {
                    this.$nextTick((_) => _this2.adjustSpinners());
                    this.needInitAdjust = false;
                  }
                },
                selectableRange: function selectableRange(val) {
                  this.$refs.spinner.selectableRange = val;
                },
                defaultValue: function defaultValue(val) {
                  if (!Object(date_util_.isDate)(this.value)) {
                    this.date = val ? new Date(val) : new Date();
                  }
                },
              },

              data: function data() {
                return {
                  popperClass: '',
                  format: 'HH:mm:ss',
                  value: '',
                  defaultValue: null,
                  date: new Date(),
                  oldValue: new Date(),
                  selectableRange: [],
                  selectionRange: [0, 2],
                  disabled: false,
                  arrowControl: false,
                  needInitAdjust: true,
                };
              },

              computed: {
                showSeconds: function showSeconds() {
                  return (this.format || '').indexOf('ss') !== -1;
                },
                useArrow: function useArrow() {
                  return this.arrowControl || this.timeArrowControl || false;
                },
                amPmMode: function amPmMode() {
                  if ((this.format || '').indexOf('A') !== -1) return 'A';
                  if ((this.format || '').indexOf('a') !== -1) return 'a';
                  return '';
                },
              },

              methods: {
                handleCancel: function handleCancel() {
                  this.$emit('pick', this.oldValue, false);
                },
                handleChange: function handleChange(date) {
                  // this.visible avoids edge cases, when use scrolls during panel closing animation
                  if (this.visible) {
                    this.date = Object(date_util_.clearMilliseconds)(date);
                    // if date is out of range, do not emit
                    if (this.isValidValue(this.date)) {
                      this.$emit('pick', this.date, true);
                    }
                  }
                },
                setSelectionRange: function setSelectionRange(start, end) {
                  this.$emit('select-range', start, end);
                  this.selectionRange = [start, end];
                },
                handleConfirm: function handleConfirm() {
                  const visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                  const first = arguments[1];

                  if (first) return;
                  const date = Object(date_util_.clearMilliseconds)(Object(date_util_.limitTimeRange)(this.date, this.selectableRange, this.format));
                  this.$emit('pick', date, visible, first);
                },
                handleKeydown: function handleKeydown(event) {
                  const { keyCode } = event;
                  const mapping = {
                    38: -1, 40: 1, 37: -1, 39: 1,
                  };

                  // Left or Right
                  if (keyCode === 37 || keyCode === 39) {
                    const step = mapping[keyCode];
                    this.changeSelectionRange(step);
                    event.preventDefault();
                    return;
                  }

                  // Up or Down
                  if (keyCode === 38 || keyCode === 40) {
                    const _step = mapping[keyCode];
                    this.$refs.spinner.scrollDown(_step);
                    event.preventDefault();
                  }
                },
                isValidValue: function isValidValue(date) {
                  return Object(date_util_.timeWithinRange)(date, this.selectableRange, this.format);
                },
                adjustSpinners: function adjustSpinners() {
                  return this.$refs.spinner.adjustSpinners();
                },
                changeSelectionRange: function changeSelectionRange(step) {
                  const list = [0, 3].concat(this.showSeconds ? [6] : []);
                  const mapping = ['hours', 'minutes'].concat(this.showSeconds ? ['seconds'] : []);
                  const index = list.indexOf(this.selectionRange[0]);
                  const next = (index + step + list.length) % list.length;
                  this.$refs.spinner.emitSelectRange(mapping[next]);
                },
              },

              mounted: function mounted() {
                const _this3 = this;

                this.$nextTick(() => _this3.handleConfirm(true, true));
                this.$emit('mounted');
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/time.vue?vue&type=script&lang=js&
            /* harmony default export */ const panel_timevue_type_script_lang_js_ = (timevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/time.vue

            /* normalize component */

            const time_component = normalizeComponent(
              panel_timevue_type_script_lang_js_,
              timevue_type_template_id_3d939089_render,
              timevue_type_template_id_3d939089_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let time_api; }
            time_component.options.__file = 'packages/date-picker/src/panel/time.vue';
            /* harmony default export */ const panel_time = (time_component.exports);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/year-table.vue?vue&type=template&id=c86ab5e0&
            const year_tablevue_type_template_id_c86ab5e0_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'table',
                { staticClass: 'el-year-table', on: { click: _vm.handleYearTableClick } },
                [
                  _c('tbody', [
                    _c('tr', [
                      _c(
                        'td',
                        {
                          staticClass: 'available',
                          class: _vm.getCellStyle(_vm.startYear + 0),
                        },
                        [_c('a', { staticClass: 'cell' }, [_vm._v(_vm._s(_vm.startYear))])],
                      ),
                      _c(
                        'td',
                        {
                          staticClass: 'available',
                          class: _vm.getCellStyle(_vm.startYear + 1),
                        },
                        [
                          _c('a', { staticClass: 'cell' }, [
                            _vm._v(_vm._s(_vm.startYear + 1)),
                          ]),
                        ],
                      ),
                      _c(
                        'td',
                        {
                          staticClass: 'available',
                          class: _vm.getCellStyle(_vm.startYear + 2),
                        },
                        [
                          _c('a', { staticClass: 'cell' }, [
                            _vm._v(_vm._s(_vm.startYear + 2)),
                          ]),
                        ],
                      ),
                      _c(
                        'td',
                        {
                          staticClass: 'available',
                          class: _vm.getCellStyle(_vm.startYear + 3),
                        },
                        [
                          _c('a', { staticClass: 'cell' }, [
                            _vm._v(_vm._s(_vm.startYear + 3)),
                          ]),
                        ],
                      ),
                    ]),
                    _c('tr', [
                      _c(
                        'td',
                        {
                          staticClass: 'available',
                          class: _vm.getCellStyle(_vm.startYear + 4),
                        },
                        [
                          _c('a', { staticClass: 'cell' }, [
                            _vm._v(_vm._s(_vm.startYear + 4)),
                          ]),
                        ],
                      ),
                      _c(
                        'td',
                        {
                          staticClass: 'available',
                          class: _vm.getCellStyle(_vm.startYear + 5),
                        },
                        [
                          _c('a', { staticClass: 'cell' }, [
                            _vm._v(_vm._s(_vm.startYear + 5)),
                          ]),
                        ],
                      ),
                      _c(
                        'td',
                        {
                          staticClass: 'available',
                          class: _vm.getCellStyle(_vm.startYear + 6),
                        },
                        [
                          _c('a', { staticClass: 'cell' }, [
                            _vm._v(_vm._s(_vm.startYear + 6)),
                          ]),
                        ],
                      ),
                      _c(
                        'td',
                        {
                          staticClass: 'available',
                          class: _vm.getCellStyle(_vm.startYear + 7),
                        },
                        [
                          _c('a', { staticClass: 'cell' }, [
                            _vm._v(_vm._s(_vm.startYear + 7)),
                          ]),
                        ],
                      ),
                    ]),
                    _c('tr', [
                      _c(
                        'td',
                        {
                          staticClass: 'available',
                          class: _vm.getCellStyle(_vm.startYear + 8),
                        },
                        [
                          _c('a', { staticClass: 'cell' }, [
                            _vm._v(_vm._s(_vm.startYear + 8)),
                          ]),
                        ],
                      ),
                      _c(
                        'td',
                        {
                          staticClass: 'available',
                          class: _vm.getCellStyle(_vm.startYear + 9),
                        },
                        [
                          _c('a', { staticClass: 'cell' }, [
                            _vm._v(_vm._s(_vm.startYear + 9)),
                          ]),
                        ],
                      ),
                      _c('td'),
                      _c('td'),
                    ]),
                  ]),
                ],
              );
            };
            const year_tablevue_type_template_id_c86ab5e0_staticRenderFns = [];
            year_tablevue_type_template_id_c86ab5e0_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/basic/year-table.vue?vue&type=template&id=c86ab5e0&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/year-table.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const year_tablevue_type_script_lang_js_datesInYear = function datesInYear(year) {
              const numOfDays = Object(date_util_.getDayCountOfYear)(year);
              const firstDay = new Date(year, 0, 1);
              return Object(date_util_.range)(numOfDays).map((n) => Object(date_util_.nextDate)(firstDay, n));
            };

            /* harmony default export */ const year_tablevue_type_script_lang_js_ = ({
              props: {
                disabledDate: {},
                value: {},
                defaultValue: {
                  validator: function validator(val) {
                    // null or valid Date Object
                    return val === null || val instanceof Date && Object(date_util_.isDate)(val);
                  },
                },
                date: {},
              },

              computed: {
                startYear: function startYear() {
                  return Math.floor(this.date.getFullYear() / 10) * 10;
                },
              },

              methods: {
                getCellStyle: function getCellStyle(year) {
                  const style = {};
                  const today = new Date();

                  style.disabled = typeof this.disabledDate === 'function' ? year_tablevue_type_script_lang_js_datesInYear(year).every(this.disabledDate) : false;
                  style.current = Object(util_.arrayFindIndex)(Object(util_.coerceTruthyValueToArray)(this.value), (date) => date.getFullYear() === year) >= 0;
                  style.today = today.getFullYear() === year;
                  style.default = this.defaultValue && this.defaultValue.getFullYear() === year;

                  return style;
                },
                handleYearTableClick: function handleYearTableClick(event) {
                  const { target } = event;
                  if (target.tagName === 'A') {
                    if (Object(dom_.hasClass)(target.parentNode, 'disabled')) return;
                    const year = target.textContent || target.innerText;
                    this.$emit('pick', Number(year));
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/basic/year-table.vue?vue&type=script&lang=js&
            /* harmony default export */ const basic_year_tablevue_type_script_lang_js_ = (year_tablevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/basic/year-table.vue

            /* normalize component */

            const year_table_component = normalizeComponent(
              basic_year_tablevue_type_script_lang_js_,
              year_tablevue_type_template_id_c86ab5e0_render,
              year_tablevue_type_template_id_c86ab5e0_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let year_table_api; }
            year_table_component.options.__file = 'packages/date-picker/src/basic/year-table.vue';
            /* harmony default export */ const year_table = (year_table_component.exports);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/month-table.vue?vue&type=template&id=654d4f42&
            const month_tablevue_type_template_id_654d4f42_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'table',
                {
                  staticClass: 'el-month-table',
                  on: { click: _vm.handleMonthTableClick, mousemove: _vm.handleMouseMove },
                },
                [
                  _c(
                    'tbody',
                    _vm._l(_vm.rows, (row, key) => _c(
                      'tr',
                      { key },
                      _vm._l(row, (cell, key) => _c('td', { key, class: _vm.getCellStyle(cell) }, [
                        _c('div', [
                          _c('a', { staticClass: 'cell' }, [
                            _vm._v(
                              _vm._s(
                                _vm.t('el.datepicker.months.' + _vm.months[cell.text]),
                              ),
                            ),
                          ]),
                        ]),
                      ])),
                      0,
                    )),
                    0,
                  ),
                ],
              );
            };
            const month_tablevue_type_template_id_654d4f42_staticRenderFns = [];
            month_tablevue_type_template_id_654d4f42_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/basic/month-table.vue?vue&type=template&id=654d4f42&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/month-table.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const month_tablevue_type_script_lang_js_datesInMonth = function datesInMonth(year, month) {
              const numOfDays = Object(date_util_.getDayCountOfMonth)(year, month);
              const firstDay = new Date(year, month, 1);
              return Object(date_util_.range)(numOfDays).map((n) => Object(date_util_.nextDate)(firstDay, n));
            };

            const clearDate = function clearDate(date) {
              return new Date(date.getFullYear(), date.getMonth());
            };

            const getMonthTimestamp = function getMonthTimestamp(time) {
              if (typeof time === 'number' || typeof time === 'string') {
                return clearDate(new Date(time)).getTime();
              } if (time instanceof Date) {
                return clearDate(time).getTime();
              }
              return NaN;
            };
            /* harmony default export */ const month_tablevue_type_script_lang_js_ = ({
              props: {
                disabledDate: {},
                value: {},
                selectionMode: {
                  default: 'month',
                },
                minDate: {},

                maxDate: {},
                defaultValue: {
                  validator: function validator(val) {
                    // null or valid Date Object
                    return val === null || Object(date_util_.isDate)(val) || Array.isArray(val) && val.every(date_util_.isDate);
                  },
                },
                date: {},
                rangeState: {
                  default: function _default() {
                    return {
                      endDate: null,
                      selecting: false,
                    };
                  },
                },
              },

              mixins: [locale_default.a],

              watch: {
                'rangeState.endDate': function rangeStateEndDate(newVal) {
                  this.markRange(this.minDate, newVal);
                },
                minDate: function minDate(newVal, oldVal) {
                  if (getMonthTimestamp(newVal) !== getMonthTimestamp(oldVal)) {
                    this.markRange(this.minDate, this.maxDate);
                  }
                },
                maxDate: function maxDate(newVal, oldVal) {
                  if (getMonthTimestamp(newVal) !== getMonthTimestamp(oldVal)) {
                    this.markRange(this.minDate, this.maxDate);
                  }
                },
              },

              data: function data() {
                return {
                  months: ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'],
                  tableRows: [[], [], []],
                  lastRow: null,
                  lastColumn: null,
                };
              },

              methods: {
                cellMatchesDate: function cellMatchesDate(cell, date) {
                  const value = new Date(date);
                  return this.date.getFullYear() === value.getFullYear() && Number(cell.text) === value.getMonth();
                },
                getCellStyle: function getCellStyle(cell) {
                  const _this = this;

                  const style = {};
                  const year = this.date.getFullYear();
                  const today = new Date();
                  const month = cell.text;
                  const defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];
                  style.disabled = typeof this.disabledDate === 'function' ? month_tablevue_type_script_lang_js_datesInMonth(year, month).every(this.disabledDate) : false;
                  style.current = Object(util_.arrayFindIndex)(Object(util_.coerceTruthyValueToArray)(this.value), (date) => date.getFullYear() === year && date.getMonth() === month) >= 0;
                  style.today = today.getFullYear() === year && today.getMonth() === month;
                  style.default = defaultValue.some((date) => _this.cellMatchesDate(cell, date));

                  if (cell.inRange) {
                    style['in-range'] = true;

                    if (cell.start) {
                      style['start-date'] = true;
                    }

                    if (cell.end) {
                      style['end-date'] = true;
                    }
                  }
                  return style;
                },
                getMonthOfCell: function getMonthOfCell(month) {
                  const year = this.date.getFullYear();
                  return new Date(year, month, 1);
                },
                markRange: function markRange(minDate, maxDate) {
                  minDate = getMonthTimestamp(minDate);
                  maxDate = getMonthTimestamp(maxDate) || minDate;
                  const _ref = [Math.min(minDate, maxDate), Math.max(minDate, maxDate)];
                  minDate = _ref[0];
                  maxDate = _ref[1];

                  const { rows } = this;
                  for (let i = 0, k = rows.length; i < k; i++) {
                    const row = rows[i];
                    for (let j = 0, l = row.length; j < l; j++) {
                      const cell = row[j];
                      const index = i * 4 + j;
                      const time = new Date(this.date.getFullYear(), index).getTime();

                      cell.inRange = minDate && time >= minDate && time <= maxDate;
                      cell.start = minDate && time === minDate;
                      cell.end = maxDate && time === maxDate;
                    }
                  }
                },
                handleMouseMove: function handleMouseMove(event) {
                  if (!this.rangeState.selecting) return;

                  let { target } = event;
                  if (target.tagName === 'A') {
                    target = target.parentNode.parentNode;
                  }
                  if (target.tagName === 'DIV') {
                    target = target.parentNode;
                  }
                  if (target.tagName !== 'TD') return;

                  const row = target.parentNode.rowIndex;
                  const column = target.cellIndex;
                  // can not select disabled date
                  if (this.rows[row][column].disabled) return;

                  // only update rangeState when mouse moves to a new cell
                  // this avoids frequent Date object creation and improves performance
                  if (row !== this.lastRow || column !== this.lastColumn) {
                    this.lastRow = row;
                    this.lastColumn = column;
                    this.$emit('changerange', {
                      minDate: this.minDate,
                      maxDate: this.maxDate,
                      rangeState: {
                        selecting: true,
                        endDate: this.getMonthOfCell(row * 4 + column),
                      },
                    });
                  }
                },
                handleMonthTableClick: function handleMonthTableClick(event) {
                  let { target } = event;
                  if (target.tagName === 'A') {
                    target = target.parentNode.parentNode;
                  }
                  if (target.tagName === 'DIV') {
                    target = target.parentNode;
                  }
                  if (target.tagName !== 'TD') return;
                  if (Object(dom_.hasClass)(target, 'disabled')) return;
                  const column = target.cellIndex;
                  const row = target.parentNode.rowIndex;
                  const month = row * 4 + column;
                  const newDate = this.getMonthOfCell(month);
                  if (this.selectionMode === 'range') {
                    if (!this.rangeState.selecting) {
                      this.$emit('pick', { minDate: newDate, maxDate: null });
                      this.rangeState.selecting = true;
                    } else {
                      if (newDate >= this.minDate) {
                        this.$emit('pick', { minDate: this.minDate, maxDate: newDate });
                      } else {
                        this.$emit('pick', { minDate: newDate, maxDate: this.minDate });
                      }
                      this.rangeState.selecting = false;
                    }
                  } else {
                    this.$emit('pick', month);
                  }
                },
              },

              computed: {
                rows: function rows() {
                  const _this2 = this;

                  // TODO: refactory rows / getCellClasses
                  const rows = this.tableRows;
                  const { disabledDate } = this;
                  const selectedDate = [];
                  const now = getMonthTimestamp(new Date());

                  for (var i = 0; i < 3; i++) {
                    var row = rows[i];

                    const _loop = function _loop(j) {
                      let cell = row[j];
                      if (!cell) {
                        cell = {
                          row: i, column: j, type: 'normal', inRange: false, start: false, end: false,
                        };
                      }

                      cell.type = 'normal';

                      const index = i * 4 + j;
                      const time = new Date(_this2.date.getFullYear(), index).getTime();
                      cell.inRange = time >= getMonthTimestamp(_this2.minDate) && time <= getMonthTimestamp(_this2.maxDate);
                      cell.start = _this2.minDate && time === getMonthTimestamp(_this2.minDate);
                      cell.end = _this2.maxDate && time === getMonthTimestamp(_this2.maxDate);
                      const isToday = time === now;

                      if (isToday) {
                        cell.type = 'today';
                      }
                      cell.text = index;
                      const cellDate = new Date(time);
                      cell.disabled = typeof disabledDate === 'function' && disabledDate(cellDate);
                      cell.selected = Object(util_.arrayFind)(selectedDate, (date) => date.getTime() === cellDate.getTime());

                      _this2.$set(row, j, cell);
                    };

                    for (let j = 0; j < 4; j++) {
                      _loop(j);
                    }
                  }
                  return rows;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/basic/month-table.vue?vue&type=script&lang=js&
            /* harmony default export */ const basic_month_tablevue_type_script_lang_js_ = (month_tablevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/basic/month-table.vue

            /* normalize component */

            const month_table_component = normalizeComponent(
              basic_month_tablevue_type_script_lang_js_,
              month_tablevue_type_template_id_654d4f42_render,
              month_tablevue_type_template_id_654d4f42_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let month_table_api; }
            month_table_component.options.__file = 'packages/date-picker/src/basic/month-table.vue';
            /* harmony default export */ const month_table = (month_table_component.exports);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/date-table.vue?vue&type=template&id=5d1f3341&
            const date_tablevue_type_template_id_5d1f3341_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'table',
                {
                  staticClass: 'el-date-table',
                  class: { 'is-week-mode': _vm.selectionMode === 'week' },
                  attrs: { cellspacing: '0', cellpadding: '0' },
                  on: { click: _vm.handleClick, mousemove: _vm.handleMouseMove },
                },
                [
                  _c(
                    'tbody',
                    [
                      _c(
                        'tr',
                        [
                          _vm.showWeekNumber
                            ? _c('th', [_vm._v(_vm._s(_vm.t('el.datepicker.week')))])
                            : _vm._e(),
                          _vm._l(_vm.WEEKS, (week, key) => _c('th', { key }, [
                            _vm._v(_vm._s(_vm.t(`el.datepicker.weeks.${week}`))),
                          ])),
                        ],
                        2,
                      ),
                      _vm._l(_vm.rows, (row, key) => _c(
                        'tr',
                        {
                          key,
                          staticClass: 'el-date-table__row',
                          class: { current: _vm.isWeekActive(row[1]) },
                        },
                        _vm._l(row, (cell, key) => _c('td', { key, class: _vm.getCellClasses(cell) }, [
                          _c('div', [
                            _c('span', [
                              _vm._v('\n          ' + _vm._s(cell.text) + '\n        '),
                            ]),
                          ]),
                        ])),
                        0,
                      )),
                    ],
                    2,
                  ),
                ],
              );
            };
            const date_tablevue_type_template_id_5d1f3341_staticRenderFns = [];
            date_tablevue_type_template_id_5d1f3341_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/basic/date-table.vue?vue&type=template&id=5d1f3341&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/date-table.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const _WEEKS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
            const date_tablevue_type_script_lang_js_getDateTimestamp = function getDateTimestamp(time) {
              if (typeof time === 'number' || typeof time === 'string') {
                return Object(date_util_.clearTime)(new Date(time)).getTime();
              } if (time instanceof Date) {
                return Object(date_util_.clearTime)(time).getTime();
              }
              return NaN;
            };

            // remove the first element that satisfies `pred` from arr
            // return a new array if modification occurs
            // return the original array otherwise
            const date_tablevue_type_script_lang_js_removeFromArray = function removeFromArray(arr, pred) {
              const idx = typeof pred === 'function' ? Object(util_.arrayFindIndex)(arr, pred) : arr.indexOf(pred);
              return idx >= 0 ? [].concat(arr.slice(0, idx), arr.slice(idx + 1)) : arr;
            };

            /* harmony default export */ const date_tablevue_type_script_lang_js_ = ({
              mixins: [locale_default.a],

              props: {
                firstDayOfWeek: {
                  default: 7,
                  type: Number,
                  validator: function validator(val) {
                    return val >= 1 && val <= 7;
                  },
                },

                value: {},

                defaultValue: {
                  validator: function validator(val) {
                    // either: null, valid Date object, Array of valid Date objects
                    return val === null || Object(date_util_.isDate)(val) || Array.isArray(val) && val.every(date_util_.isDate);
                  },
                },

                date: {},

                selectionMode: {
                  default: 'day',
                },

                showWeekNumber: {
                  type: Boolean,
                  default: false,
                },

                disabledDate: {},

                cellClassName: {},

                minDate: {},

                maxDate: {},

                rangeState: {
                  default: function _default() {
                    return {
                      endDate: null,
                      selecting: false,
                    };
                  },
                },
              },

              computed: {
                offsetDay: function offsetDay() {
                  const week = this.firstDayOfWeek;
                  // 周日为界限，左右偏移的天数，3217654 例如周一就是 -1，目的是调整前两行日期的位置
                  return week > 3 ? 7 - week : -week;
                },
                WEEKS: function WEEKS() {
                  const week = this.firstDayOfWeek;
                  return _WEEKS.concat(_WEEKS).slice(week, week + 7);
                },
                year: function year() {
                  return this.date.getFullYear();
                },
                month: function month() {
                  return this.date.getMonth();
                },
                startDate: function startDate() {
                  return Object(date_util_.getStartDateOfMonth)(this.year, this.month);
                },
                rows: function rows() {
                  const _this = this;

                  // TODO: refactory rows / getCellClasses
                  const date = new Date(this.year, this.month, 1);
                  let day = Object(date_util_.getFirstDayOfMonth)(date); // day of first day
                  const dateCountOfMonth = Object(date_util_.getDayCountOfMonth)(date.getFullYear(), date.getMonth());
                  const dateCountOfLastMonth = Object(date_util_.getDayCountOfMonth)(date.getFullYear(), date.getMonth() === 0 ? 11 : date.getMonth() - 1);

                  day = day === 0 ? 7 : day;

                  const offset = this.offsetDay;
                  const rows = this.tableRows;
                  let count = 1;

                  const { startDate } = this;
                  const { disabledDate } = this;
                  const { cellClassName } = this;
                  const selectedDate = this.selectionMode === 'dates' ? Object(util_.coerceTruthyValueToArray)(this.value) : [];
                  const now = date_tablevue_type_script_lang_js_getDateTimestamp(new Date());

                  for (var i = 0; i < 6; i++) {
                    var row = rows[i];

                    if (this.showWeekNumber) {
                      if (!row[0]) {
                        row[0] = { type: 'week', text: Object(date_util_.getWeekNumber)(Object(date_util_.nextDate)(startDate, i * 7 + 1)) };
                      }
                    }

                    const _loop = function _loop(j) {
                      let cell = row[_this.showWeekNumber ? j + 1 : j];
                      if (!cell) {
                        cell = {
                          row: i, column: j, type: 'normal', inRange: false, start: false, end: false,
                        };
                      }

                      cell.type = 'normal';

                      const index = i * 7 + j;
                      const time = Object(date_util_.nextDate)(startDate, index - offset).getTime();
                      cell.inRange = time >= date_tablevue_type_script_lang_js_getDateTimestamp(_this.minDate) && time <= date_tablevue_type_script_lang_js_getDateTimestamp(_this.maxDate);
                      cell.start = _this.minDate && time === date_tablevue_type_script_lang_js_getDateTimestamp(_this.minDate);
                      cell.end = _this.maxDate && time === date_tablevue_type_script_lang_js_getDateTimestamp(_this.maxDate);
                      const isToday = time === now;

                      if (isToday) {
                        cell.type = 'today';
                      }

                      if (i >= 0 && i <= 1) {
                        const numberOfDaysFromPreviousMonth = day + offset < 0 ? 7 + day + offset : day + offset;

                        if (j + i * 7 >= numberOfDaysFromPreviousMonth) {
                          cell.text = count++;
                        } else {
                          cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i * 7;
                          cell.type = 'prev-month';
                        }
                      } else if (count <= dateCountOfMonth) {
                        cell.text = count++;
                      } else {
                        cell.text = count++ - dateCountOfMonth;
                        cell.type = 'next-month';
                      }

                      const cellDate = new Date(time);
                      cell.disabled = typeof disabledDate === 'function' && disabledDate(cellDate);
                      cell.selected = Object(util_.arrayFind)(selectedDate, (date) => date.getTime() === cellDate.getTime());
                      cell.customClass = typeof cellClassName === 'function' && cellClassName(cellDate);
                      _this.$set(row, _this.showWeekNumber ? j + 1 : j, cell);
                    };

                    for (let j = 0; j < 7; j++) {
                      _loop(j);
                    }

                    if (this.selectionMode === 'week') {
                      const start = this.showWeekNumber ? 1 : 0;
                      const end = this.showWeekNumber ? 7 : 6;
                      const isWeekActive = this.isWeekActive(row[start + 1]);

                      row[start].inRange = isWeekActive;
                      row[start].start = isWeekActive;
                      row[end].inRange = isWeekActive;
                      row[end].end = isWeekActive;
                    }
                  }

                  return rows;
                },
              },

              watch: {
                'rangeState.endDate': function rangeStateEndDate(newVal) {
                  this.markRange(this.minDate, newVal);
                },
                minDate: function minDate(newVal, oldVal) {
                  if (date_tablevue_type_script_lang_js_getDateTimestamp(newVal) !== date_tablevue_type_script_lang_js_getDateTimestamp(oldVal)) {
                    this.markRange(this.minDate, this.maxDate);
                  }
                },
                maxDate: function maxDate(newVal, oldVal) {
                  if (date_tablevue_type_script_lang_js_getDateTimestamp(newVal) !== date_tablevue_type_script_lang_js_getDateTimestamp(oldVal)) {
                    this.markRange(this.minDate, this.maxDate);
                  }
                },
              },

              data: function data() {
                return {
                  tableRows: [[], [], [], [], [], []],
                  lastRow: null,
                  lastColumn: null,
                };
              },

              methods: {
                cellMatchesDate: function cellMatchesDate(cell, date) {
                  const value = new Date(date);
                  return this.year === value.getFullYear() && this.month === value.getMonth() && Number(cell.text) === value.getDate();
                },
                getCellClasses: function getCellClasses(cell) {
                  const _this2 = this;

                  const { selectionMode } = this;
                  const defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];

                  const classes = [];
                  if ((cell.type === 'normal' || cell.type === 'today') && !cell.disabled) {
                    classes.push('available');
                    if (cell.type === 'today') {
                      classes.push('today');
                    }
                  } else {
                    classes.push(cell.type);
                  }

                  if (cell.type === 'normal' && defaultValue.some((date) => _this2.cellMatchesDate(cell, date))) {
                    classes.push('default');
                  }

                  if (selectionMode === 'day' && (cell.type === 'normal' || cell.type === 'today') && this.cellMatchesDate(cell, this.value)) {
                    classes.push('current');
                  }

                  if (cell.inRange && (cell.type === 'normal' || cell.type === 'today' || this.selectionMode === 'week')) {
                    classes.push('in-range');

                    if (cell.start) {
                      classes.push('start-date');
                    }

                    if (cell.end) {
                      classes.push('end-date');
                    }
                  }

                  if (cell.disabled) {
                    classes.push('disabled');
                  }

                  if (cell.selected) {
                    classes.push('selected');
                  }

                  if (cell.customClass) {
                    classes.push(cell.customClass);
                  }

                  return classes.join(' ');
                },
                getDateOfCell: function getDateOfCell(row, column) {
                  const offsetFromStart = row * 7 + (column - (this.showWeekNumber ? 1 : 0)) - this.offsetDay;
                  return Object(date_util_.nextDate)(this.startDate, offsetFromStart);
                },
                isWeekActive: function isWeekActive(cell) {
                  if (this.selectionMode !== 'week') return false;
                  const newDate = new Date(this.year, this.month, 1);
                  const year = newDate.getFullYear();
                  const month = newDate.getMonth();

                  if (cell.type === 'prev-month') {
                    newDate.setMonth(month === 0 ? 11 : month - 1);
                    newDate.setFullYear(month === 0 ? year - 1 : year);
                  }

                  if (cell.type === 'next-month') {
                    newDate.setMonth(month === 11 ? 0 : month + 1);
                    newDate.setFullYear(month === 11 ? year + 1 : year);
                  }

                  newDate.setDate(parseInt(cell.text, 10));

                  if (Object(date_util_.isDate)(this.value)) {
                    const dayOffset = (this.value.getDay() - this.firstDayOfWeek + 7) % 7 - 1;
                    const weekDate = Object(date_util_.prevDate)(this.value, dayOffset);
                    return weekDate.getTime() === newDate.getTime();
                  }
                  return false;
                },
                markRange: function markRange(minDate, maxDate) {
                  minDate = date_tablevue_type_script_lang_js_getDateTimestamp(minDate);
                  maxDate = date_tablevue_type_script_lang_js_getDateTimestamp(maxDate) || minDate;
                  const _ref = [Math.min(minDate, maxDate), Math.max(minDate, maxDate)];
                  minDate = _ref[0];
                  maxDate = _ref[1];

                  const { startDate } = this;
                  const { rows } = this;
                  for (let i = 0, k = rows.length; i < k; i++) {
                    const row = rows[i];
                    for (let j = 0, l = row.length; j < l; j++) {
                      if (this.showWeekNumber && j === 0) continue;

                      const _cell = row[j];
                      const index = i * 7 + j + (this.showWeekNumber ? -1 : 0);
                      const time = Object(date_util_.nextDate)(startDate, index - this.offsetDay).getTime();

                      _cell.inRange = minDate && time >= minDate && time <= maxDate;
                      _cell.start = minDate && time === minDate;
                      _cell.end = maxDate && time === maxDate;
                    }
                  }
                },
                handleMouseMove: function handleMouseMove(event) {
                  if (!this.rangeState.selecting) return;

                  let { target } = event;
                  if (target.tagName === 'SPAN') {
                    target = target.parentNode.parentNode;
                  }
                  if (target.tagName === 'DIV') {
                    target = target.parentNode;
                  }
                  if (target.tagName !== 'TD') return;

                  const row = target.parentNode.rowIndex - 1;
                  const column = target.cellIndex;

                  // can not select disabled date
                  if (this.rows[row][column].disabled) return;

                  // only update rangeState when mouse moves to a new cell
                  // this avoids frequent Date object creation and improves performance
                  if (row !== this.lastRow || column !== this.lastColumn) {
                    this.lastRow = row;
                    this.lastColumn = column;
                    this.$emit('changerange', {
                      minDate: this.minDate,
                      maxDate: this.maxDate,
                      rangeState: {
                        selecting: true,
                        endDate: this.getDateOfCell(row, column),
                      },
                    });
                  }
                },
                handleClick: function handleClick(event) {
                  let { target } = event;
                  if (target.tagName === 'SPAN') {
                    target = target.parentNode.parentNode;
                  }
                  if (target.tagName === 'DIV') {
                    target = target.parentNode;
                  }

                  if (target.tagName !== 'TD') return;

                  const row = target.parentNode.rowIndex - 1;
                  const column = this.selectionMode === 'week' ? 1 : target.cellIndex;
                  const cell = this.rows[row][column];

                  if (cell.disabled || cell.type === 'week') return;

                  const newDate = this.getDateOfCell(row, column);

                  if (this.selectionMode === 'range') {
                    if (!this.rangeState.selecting) {
                      this.$emit('pick', { minDate: newDate, maxDate: null });
                      this.rangeState.selecting = true;
                    } else {
                      if (newDate >= this.minDate) {
                        this.$emit('pick', { minDate: this.minDate, maxDate: newDate });
                      } else {
                        this.$emit('pick', { minDate: newDate, maxDate: this.minDate });
                      }
                      this.rangeState.selecting = false;
                    }
                  } else if (this.selectionMode === 'day') {
                    this.$emit('pick', newDate);
                  } else if (this.selectionMode === 'week') {
                    const weekNumber = Object(date_util_.getWeekNumber)(newDate);
                    const value = `${newDate.getFullYear()}w${weekNumber}`;
                    this.$emit('pick', {
                      year: newDate.getFullYear(),
                      week: weekNumber,
                      value,
                      date: newDate,
                    });
                  } else if (this.selectionMode === 'dates') {
                    const _value = this.value || [];
                    const newValue = cell.selected ? date_tablevue_type_script_lang_js_removeFromArray(_value, (date) => date.getTime() === newDate.getTime()) : [].concat(_value, [newDate]);
                    this.$emit('pick', newValue);
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/basic/date-table.vue?vue&type=script&lang=js&
            /* harmony default export */ const basic_date_tablevue_type_script_lang_js_ = (date_tablevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/basic/date-table.vue

            /* normalize component */

            const date_table_component = normalizeComponent(
              basic_date_tablevue_type_script_lang_js_,
              date_tablevue_type_template_id_5d1f3341_render,
              date_tablevue_type_template_id_5d1f3341_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let date_table_api; }
            date_table_component.options.__file = 'packages/date-picker/src/basic/date-table.vue';
            /* harmony default export */ const date_table = (date_table_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const datevue_type_script_lang_js_ = ({
              mixins: [locale_default.a],

              directives: { Clickoutside: clickoutside_default.a },

              watch: {
                showTime: function showTime(val) {
                  const _this = this;

                  /* istanbul ignore if */
                  if (!val) return;
                  this.$nextTick((_) => {
                    const inputElm = _this.$refs.input.$el;
                    if (inputElm) {
                      _this.pickerWidth = inputElm.getBoundingClientRect().width + 10;
                    }
                  });
                },
                value: function value(val) {
                  if (this.selectionMode === 'dates' && this.value) return;
                  if (Object(date_util_.isDate)(val)) {
                    this.date = new Date(val);
                  } else {
                    this.date = this.getDefaultValue();
                  }
                },
                defaultValue: function defaultValue(val) {
                  if (!Object(date_util_.isDate)(this.value)) {
                    this.date = val ? new Date(val) : new Date();
                  }
                },
                timePickerVisible: function timePickerVisible(val) {
                  const _this2 = this;

                  if (val) {
                    this.$nextTick(() => _this2.$refs.timepicker.adjustSpinners());
                  }
                },
                selectionMode: function selectionMode(newVal) {
                  if (newVal === 'month') {
                    /* istanbul ignore next */
                    if (this.currentView !== 'year' || this.currentView !== 'month') {
                      this.currentView = 'month';
                    }
                  } else if (newVal === 'dates') {
                    this.currentView = 'date';
                  }
                },
              },

              methods: {
                proxyTimePickerDataProperties: function proxyTimePickerDataProperties() {
                  const _this3 = this;

                  const format = function format(timeFormat) {
                    _this3.$refs.timepicker.format = timeFormat;
                  };
                  const value = function value(_value) {
                    _this3.$refs.timepicker.value = _value;
                  };
                  const date = function date(_date) {
                    _this3.$refs.timepicker.date = _date;
                  };
                  const selectableRange = function selectableRange(_selectableRange) {
                    _this3.$refs.timepicker.selectableRange = _selectableRange;
                  };

                  this.$watch('value', value);
                  this.$watch('date', date);
                  this.$watch('selectableRange', selectableRange);

                  format(this.timeFormat);
                  value(this.value);
                  date(this.date);
                  selectableRange(this.selectableRange);
                },
                handleClear: function handleClear() {
                  this.date = this.getDefaultValue();
                  this.$emit('pick', null);
                },
                emit: function emit(value) {
                  const _this4 = this;

                  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }

                  if (!value) {
                    this.$emit.apply(this, ['pick', value].concat(args));
                  } else if (Array.isArray(value)) {
                    const dates = value.map((date) => (_this4.showTime ? Object(date_util_.clearMilliseconds)(date) : Object(date_util_.clearTime)(date)));
                    this.$emit.apply(this, ['pick', dates].concat(args));
                  } else {
                    this.$emit.apply(this, ['pick', this.showTime ? Object(date_util_.clearMilliseconds)(value) : Object(date_util_.clearTime)(value)].concat(args));
                  }
                  this.userInputDate = null;
                  this.userInputTime = null;
                },

                // resetDate() {
                //   this.date = new Date(this.date);
                // },

                showMonthPicker: function showMonthPicker() {
                  this.currentView = 'month';
                },
                showYearPicker: function showYearPicker() {
                  this.currentView = 'year';
                },

                // XXX: 没用到
                // handleLabelClick() {
                //   if (this.currentView === 'date') {
                //     this.showMonthPicker();
                //   } else if (this.currentView === 'month') {
                //     this.showYearPicker();
                //   }
                // },

                prevMonth: function prevMonth() {
                  this.date = Object(date_util_.prevMonth)(this.date);
                },
                nextMonth: function nextMonth() {
                  this.date = Object(date_util_.nextMonth)(this.date);
                },
                prevYear: function prevYear() {
                  if (this.currentView === 'year') {
                    this.date = Object(date_util_.prevYear)(this.date, 10);
                  } else {
                    this.date = Object(date_util_.prevYear)(this.date);
                  }
                },
                nextYear: function nextYear() {
                  if (this.currentView === 'year') {
                    this.date = Object(date_util_.nextYear)(this.date, 10);
                  } else {
                    this.date = Object(date_util_.nextYear)(this.date);
                  }
                },
                handleShortcutClick: function handleShortcutClick(shortcut) {
                  if (shortcut.onClick) {
                    shortcut.onClick(this);
                  }
                },
                handleTimePick: function handleTimePick(value, visible, first) {
                  if (Object(date_util_.isDate)(value)) {
                    const newDate = this.value ? Object(date_util_.modifyTime)(this.value, value.getHours(), value.getMinutes(), value.getSeconds()) : Object(date_util_.modifyWithTimeString)(this.getDefaultValue(), this.defaultTime);
                    this.date = newDate;
                    this.emit(this.date, true);
                  } else {
                    this.emit(value, true);
                  }
                  if (!first) {
                    this.timePickerVisible = visible;
                  }
                },
                handleTimePickClose: function handleTimePickClose() {
                  this.timePickerVisible = false;
                },
                handleMonthPick: function handleMonthPick(month) {
                  if (this.selectionMode === 'month') {
                    this.date = Object(date_util_.modifyDate)(this.date, this.year, month, 1);
                    this.emit(this.date);
                  } else {
                    this.date = Object(date_util_.changeYearMonthAndClampDate)(this.date, this.year, month);
                    // TODO: should emit intermediate value ??
                    // this.emit(this.date);
                    this.currentView = 'date';
                  }
                },
                handleDatePick: function handleDatePick(value) {
                  if (this.selectionMode === 'day') {
                    let newDate = this.value ? Object(date_util_.modifyDate)(this.value, value.getFullYear(), value.getMonth(), value.getDate()) : Object(date_util_.modifyWithTimeString)(value, this.defaultTime);
                    // change default time while out of selectableRange
                    if (!this.checkDateWithinRange(newDate)) {
                      newDate = Object(date_util_.modifyDate)(this.selectableRange[0][0], value.getFullYear(), value.getMonth(), value.getDate());
                    }
                    this.date = newDate;
                    this.emit(this.date, this.showTime);
                  } else if (this.selectionMode === 'week') {
                    this.emit(value.date);
                  } else if (this.selectionMode === 'dates') {
                    this.emit(value, true); // set false to keep panel open
                  }
                },
                handleYearPick: function handleYearPick(year) {
                  if (this.selectionMode === 'year') {
                    this.date = Object(date_util_.modifyDate)(this.date, year, 0, 1);
                    this.emit(this.date);
                  } else {
                    this.date = Object(date_util_.changeYearMonthAndClampDate)(this.date, year, this.month);
                    // TODO: should emit intermediate value ??
                    // this.emit(this.date, true);
                    this.currentView = 'month';
                  }
                },
                changeToNow: function changeToNow() {
                  // NOTE: not a permanent solution
                  //       consider disable "now" button in the future
                  if ((!this.disabledDate || !this.disabledDate(new Date())) && this.checkDateWithinRange(new Date())) {
                    this.date = new Date();
                    this.emit(this.date);
                  }
                },
                confirm: function confirm() {
                  if (this.selectionMode === 'dates') {
                    this.emit(this.value);
                  } else {
                    // value were emitted in handle{Date,Time}Pick, nothing to update here
                    // deal with the scenario where: user opens the picker, then confirm without doing anything
                    const value = this.value ? this.value : Object(date_util_.modifyWithTimeString)(this.getDefaultValue(), this.defaultTime);
                    this.date = new Date(value); // refresh date
                    this.emit(value);
                  }
                },
                resetView: function resetView() {
                  if (this.selectionMode === 'month') {
                    this.currentView = 'month';
                  } else if (this.selectionMode === 'year') {
                    this.currentView = 'year';
                  } else {
                    this.currentView = 'date';
                  }
                },
                handleEnter: function handleEnter() {
                  document.body.addEventListener('keydown', this.handleKeydown);
                },
                handleLeave: function handleLeave() {
                  this.$emit('dodestroy');
                  document.body.removeEventListener('keydown', this.handleKeydown);
                },
                handleKeydown: function handleKeydown(event) {
                  const { keyCode } = event;
                  const list = [38, 40, 37, 39];
                  if (this.visible && !this.timePickerVisible) {
                    if (list.indexOf(keyCode) !== -1) {
                      this.handleKeyControl(keyCode);
                      event.stopPropagation();
                      event.preventDefault();
                    }
                    if (keyCode === 13 && this.userInputDate === null && this.userInputTime === null) {
                      // Enter
                      this.emit(this.date, false);
                    }
                  }
                },
                handleKeyControl: function handleKeyControl(keyCode) {
                  const mapping = {
                    year: {
                      38: -4,
                      40: 4,
                      37: -1,
                      39: 1,
                      offset: function offset(date, step) {
                        return date.setFullYear(date.getFullYear() + step);
                      },
                    },
                    month: {
                      38: -4,
                      40: 4,
                      37: -1,
                      39: 1,
                      offset: function offset(date, step) {
                        return date.setMonth(date.getMonth() + step);
                      },
                    },
                    week: {
                      38: -1,
                      40: 1,
                      37: -1,
                      39: 1,
                      offset: function offset(date, step) {
                        return date.setDate(date.getDate() + step * 7);
                      },
                    },
                    day: {
                      38: -7,
                      40: 7,
                      37: -1,
                      39: 1,
                      offset: function offset(date, step) {
                        return date.setDate(date.getDate() + step);
                      },
                    },
                  };
                  const mode = this.selectionMode;
                  const year = 3.1536e10;
                  const now = this.date.getTime();
                  const newDate = new Date(this.date.getTime());
                  while (Math.abs(now - newDate.getTime()) <= year) {
                    const map = mapping[mode];
                    map.offset(newDate, map[keyCode]);
                    if (typeof this.disabledDate === 'function' && this.disabledDate(newDate)) {
                      continue;
                    }
                    this.date = newDate;
                    this.$emit('pick', newDate, true);
                    break;
                  }
                },
                handleVisibleTimeChange: function handleVisibleTimeChange(value) {
                  const time = Object(date_util_.parseDate)(value, this.timeFormat);
                  if (time && this.checkDateWithinRange(time)) {
                    this.date = Object(date_util_.modifyDate)(time, this.year, this.month, this.monthDate);
                    this.userInputTime = null;
                    this.$refs.timepicker.value = this.date;
                    this.timePickerVisible = false;
                    this.emit(this.date, true);
                  }
                },
                handleVisibleDateChange: function handleVisibleDateChange(value) {
                  const date = Object(date_util_.parseDate)(value, this.dateFormat);
                  if (date) {
                    if (typeof this.disabledDate === 'function' && this.disabledDate(date)) {
                      return;
                    }
                    this.date = Object(date_util_.modifyTime)(date, this.date.getHours(), this.date.getMinutes(), this.date.getSeconds());
                    this.userInputDate = null;
                    this.resetView();
                    this.emit(this.date, true);
                  }
                },
                isValidValue: function isValidValue(value) {
                  return value && !isNaN(value) && (typeof this.disabledDate === 'function' ? !this.disabledDate(value) : true) && this.checkDateWithinRange(value);
                },
                getDefaultValue: function getDefaultValue() {
                  // if default-value is set, return it
                  // otherwise, return now (the moment this method gets called)
                  return this.defaultValue ? new Date(this.defaultValue) : new Date();
                },
                checkDateWithinRange: function checkDateWithinRange(date) {
                  return this.selectableRange.length > 0 ? Object(date_util_.timeWithinRange)(date, this.selectableRange, this.format || 'HH:mm:ss') : true;
                },
              },

              components: {
                TimePicker: panel_time, YearTable: year_table, MonthTable: month_table, DateTable: date_table, ElInput: input_default.a, ElButton: button_default.a,
              },

              data: function data() {
                return {
                  popperClass: '',
                  date: new Date(),
                  value: '',
                  defaultValue: null, // use getDefaultValue() for time computation
                  defaultTime: null,
                  showTime: false,
                  selectionMode: 'day',
                  shortcuts: '',
                  visible: false,
                  currentView: 'date',
                  disabledDate: '',
                  cellClassName: '',
                  selectableRange: [],
                  firstDayOfWeek: 7,
                  showWeekNumber: false,
                  timePickerVisible: false,
                  format: '',
                  arrowControl: false,
                  userInputDate: null,
                  userInputTime: null,
                };
              },

              computed: {
                year: function year() {
                  return this.date.getFullYear();
                },
                month: function month() {
                  return this.date.getMonth();
                },
                week: function week() {
                  return Object(date_util_.getWeekNumber)(this.date);
                },
                monthDate: function monthDate() {
                  return this.date.getDate();
                },
                footerVisible: function footerVisible() {
                  return this.showTime || this.selectionMode === 'dates';
                },
                visibleTime: function visibleTime() {
                  if (this.userInputTime !== null) {
                    return this.userInputTime;
                  }
                  return Object(date_util_.formatDate)(this.value || this.defaultValue, this.timeFormat);
                },
                visibleDate: function visibleDate() {
                  if (this.userInputDate !== null) {
                    return this.userInputDate;
                  }
                  return Object(date_util_.formatDate)(this.value || this.defaultValue, this.dateFormat);
                },
                yearLabel: function yearLabel() {
                  const yearTranslation = this.t('el.datepicker.year');
                  if (this.currentView === 'year') {
                    const startYear = Math.floor(this.year / 10) * 10;
                    if (yearTranslation) {
                      return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
                    }
                    return `${startYear} - ${startYear + 9}`;
                  }
                  return `${this.year} ${yearTranslation}`;
                },
                timeFormat: function timeFormat() {
                  if (this.format) {
                    return Object(date_util_.extractTimeFormat)(this.format);
                  }
                  return 'HH:mm:ss';
                },
                dateFormat: function dateFormat() {
                  if (this.format) {
                    return Object(date_util_.extractDateFormat)(this.format);
                  }
                  return 'yyyy-MM-dd';
                },
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/date.vue?vue&type=script&lang=js&
            /* harmony default export */ const panel_datevue_type_script_lang_js_ = (datevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/date.vue

            /* normalize component */

            const date_component = normalizeComponent(
              panel_datevue_type_script_lang_js_,
              datevue_type_template_id_2440d4ea_render,
              datevue_type_template_id_2440d4ea_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let date_api; }
            date_component.options.__file = 'packages/date-picker/src/panel/date.vue';
            /* harmony default export */ const panel_date = (date_component.exports);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date-range.vue?vue&type=template&id=2652849a&
            const date_rangevue_type_template_id_2652849a_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                {
                  attrs: { name: 'el-zoom-in-top' },
                  on: {
                    'after-leave': function ($event) {
                      _vm.$emit('dodestroy');
                    },
                  },
                },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.visible,
                          expression: 'visible',
                        },
                      ],
                      staticClass: 'el-picker-panel el-date-range-picker el-popper',
                      class: [
                        {
                          'has-sidebar': _vm.$slots.sidebar || _vm.shortcuts,
                          'has-time': _vm.showTime,
                        },
                        _vm.popperClass,
                      ],
                    },
                    [
                      _c(
                        'div',
                        { staticClass: 'el-picker-panel__body-wrapper' },
                        [
                          _vm._t('sidebar'),
                          _vm.shortcuts
                            ? _c(
                              'div',
                              { staticClass: 'el-picker-panel__sidebar' },
                              _vm._l(_vm.shortcuts, (shortcut, key) => _c(
                                'button',
                                {
                                  key,
                                  staticClass: 'el-picker-panel__shortcut',
                                  attrs: { type: 'button' },
                                  on: {
                                    click($event) {
                                      _vm.handleShortcutClick(shortcut);
                                    },
                                  },
                                },
                                [_vm._v(_vm._s(shortcut.text))],
                              )),
                              0,
                            )
                            : _vm._e(),
                          _c('div', { staticClass: 'el-picker-panel__body' }, [
                            _vm.showTime
                              ? _c(
                                'div',
                                { staticClass: 'el-date-range-picker__time-header' },
                                [
                                  _c(
                                    'span',
                                    { staticClass: 'el-date-range-picker__editors-wrap' },
                                    [
                                      _c(
                                        'span',
                                        {
                                          staticClass:
                                  'el-date-range-picker__time-picker-wrap',
                                        },
                                        [
                                          _c('el-input', {
                                            ref: 'minInput',
                                            staticClass: 'el-date-range-picker__editor',
                                            attrs: {
                                              size: 'small',
                                              disabled: _vm.rangeState.selecting,
                                              placeholder: _vm.t(
                                                'el.datepicker.startDate',
                                              ),
                                              value: _vm.minVisibleDate,
                                            },
                                            on: {
                                              input(val) {
                                                return _vm.handleDateInput(val, 'min');
                                              },
                                              change(val) {
                                                return _vm.handleDateChange(val, 'min');
                                              },
                                            },
                                          }),
                                        ],
                                        1,
                                      ),
                                      _c(
                                        'span',
                                        {
                                          directives: [
                                            {
                                              name: 'clickoutside',
                                              rawName: 'v-clickoutside',
                                              value: _vm.handleMinTimeClose,
                                              expression: 'handleMinTimeClose',
                                            },
                                          ],
                                          staticClass:
                                  'el-date-range-picker__time-picker-wrap',
                                        },
                                        [
                                          _c('el-input', {
                                            staticClass: 'el-date-range-picker__editor',
                                            attrs: {
                                              size: 'small',
                                              disabled: _vm.rangeState.selecting,
                                              placeholder: _vm.t(
                                                'el.datepicker.startTime',
                                              ),
                                              value: _vm.minVisibleTime,
                                            },
                                            on: {
                                              focus($event) {
                                                _vm.minTimePickerVisible = true;
                                              },
                                              input(val) {
                                                return _vm.handleTimeInput(val, 'min');
                                              },
                                              change(val) {
                                                return _vm.handleTimeChange(val, 'min');
                                              },
                                            },
                                          }),
                                          _c('time-picker', {
                                            ref: 'minTimePicker',
                                            attrs: {
                                              'time-arrow-control': _vm.arrowControl,
                                              visible: _vm.minTimePickerVisible,
                                            },
                                            on: {
                                              pick: _vm.handleMinTimePick,
                                              mounted($event) {
                                                _vm.$refs.minTimePicker.format = _vm.timeFormat;
                                              },
                                            },
                                          }),
                                        ],
                                        1,
                                      ),
                                    ],
                                  ),
                                  _c('span', { staticClass: 'el-icon-arrow-right' }),
                                  _c(
                                    'span',
                                    {
                                      staticClass:
                              'el-date-range-picker__editors-wrap is-right',
                                    },
                                    [
                                      _c(
                                        'span',
                                        {
                                          staticClass:
                                  'el-date-range-picker__time-picker-wrap',
                                        },
                                        [
                                          _c('el-input', {
                                            staticClass: 'el-date-range-picker__editor',
                                            attrs: {
                                              size: 'small',
                                              disabled: _vm.rangeState.selecting,
                                              placeholder: _vm.t('el.datepicker.endDate'),
                                              value: _vm.maxVisibleDate,
                                              readonly: !_vm.minDate,
                                            },
                                            on: {
                                              input(val) {
                                                return _vm.handleDateInput(val, 'max');
                                              },
                                              change(val) {
                                                return _vm.handleDateChange(val, 'max');
                                              },
                                            },
                                          }),
                                        ],
                                        1,
                                      ),
                                      _c(
                                        'span',
                                        {
                                          directives: [
                                            {
                                              name: 'clickoutside',
                                              rawName: 'v-clickoutside',
                                              value: _vm.handleMaxTimeClose,
                                              expression: 'handleMaxTimeClose',
                                            },
                                          ],
                                          staticClass:
                                  'el-date-range-picker__time-picker-wrap',
                                        },
                                        [
                                          _c('el-input', {
                                            staticClass: 'el-date-range-picker__editor',
                                            attrs: {
                                              size: 'small',
                                              disabled: _vm.rangeState.selecting,
                                              placeholder: _vm.t('el.datepicker.endTime'),
                                              value: _vm.maxVisibleTime,
                                              readonly: !_vm.minDate,
                                            },
                                            on: {
                                              focus($event) {
                                                _vm.minDate
                                        && (_vm.maxTimePickerVisible = true);
                                              },
                                              input(val) {
                                                return _vm.handleTimeInput(val, 'max');
                                              },
                                              change(val) {
                                                return _vm.handleTimeChange(val, 'max');
                                              },
                                            },
                                          }),
                                          _c('time-picker', {
                                            ref: 'maxTimePicker',
                                            attrs: {
                                              'time-arrow-control': _vm.arrowControl,
                                              visible: _vm.maxTimePickerVisible,
                                            },
                                            on: {
                                              pick: _vm.handleMaxTimePick,
                                              mounted($event) {
                                                _vm.$refs.maxTimePicker.format = _vm.timeFormat;
                                              },
                                            },
                                          }),
                                        ],
                                        1,
                                      ),
                                    ],
                                  ),
                                ],
                              )
                              : _vm._e(),
                            _c(
                              'div',
                              {
                                staticClass:
                      'el-picker-panel__content el-date-range-picker__content is-left',
                              },
                              [
                                _c('div', { staticClass: 'el-date-range-picker__header' }, [
                                  _c('button', {
                                    staticClass:
                          'el-picker-panel__icon-btn el-icon-d-arrow-left',
                                    attrs: { type: 'button' },
                                    on: { click: _vm.leftPrevYear },
                                  }),
                                  _c('button', {
                                    staticClass:
                          'el-picker-panel__icon-btn el-icon-arrow-left',
                                    attrs: { type: 'button' },
                                    on: { click: _vm.leftPrevMonth },
                                  }),
                                  _vm.unlinkPanels
                                    ? _c('button', {
                                      staticClass:
                              'el-picker-panel__icon-btn el-icon-d-arrow-right',
                                      class: { 'is-disabled': !_vm.enableYearArrow },
                                      attrs: {
                                        type: 'button',
                                        disabled: !_vm.enableYearArrow,
                                      },
                                      on: { click: _vm.leftNextYear },
                                    })
                                    : _vm._e(),
                                  _vm.unlinkPanels
                                    ? _c('button', {
                                      staticClass:
                              'el-picker-panel__icon-btn el-icon-arrow-right',
                                      class: { 'is-disabled': !_vm.enableMonthArrow },
                                      attrs: {
                                        type: 'button',
                                        disabled: !_vm.enableMonthArrow,
                                      },
                                      on: { click: _vm.leftNextMonth },
                                    })
                                    : _vm._e(),
                                  _c('div', [_vm._v(_vm._s(_vm.leftLabel))]),
                                ]),
                                _c('date-table', {
                                  attrs: {
                                    'selection-mode': 'range',
                                    date: _vm.leftDate,
                                    'default-value': _vm.defaultValue,
                                    'min-date': _vm.minDate,
                                    'max-date': _vm.maxDate,
                                    'range-state': _vm.rangeState,
                                    'disabled-date': _vm.disabledDate,
                                    'cell-class-name': _vm.cellClassName,
                                    'first-day-of-week': _vm.firstDayOfWeek,
                                  },
                                  on: {
                                    changerange: _vm.handleChangeRange,
                                    pick: _vm.handleRangePick,
                                  },
                                }),
                              ],
                              1,
                            ),
                            _c(
                              'div',
                              {
                                staticClass:
                      'el-picker-panel__content el-date-range-picker__content is-right',
                              },
                              [
                                _c('div', { staticClass: 'el-date-range-picker__header' }, [
                                  _vm.unlinkPanels
                                    ? _c('button', {
                                      staticClass:
                              'el-picker-panel__icon-btn el-icon-d-arrow-left',
                                      class: { 'is-disabled': !_vm.enableYearArrow },
                                      attrs: {
                                        type: 'button',
                                        disabled: !_vm.enableYearArrow,
                                      },
                                      on: { click: _vm.rightPrevYear },
                                    })
                                    : _vm._e(),
                                  _vm.unlinkPanels
                                    ? _c('button', {
                                      staticClass:
                              'el-picker-panel__icon-btn el-icon-arrow-left',
                                      class: { 'is-disabled': !_vm.enableMonthArrow },
                                      attrs: {
                                        type: 'button',
                                        disabled: !_vm.enableMonthArrow,
                                      },
                                      on: { click: _vm.rightPrevMonth },
                                    })
                                    : _vm._e(),
                                  _c('button', {
                                    staticClass:
                          'el-picker-panel__icon-btn el-icon-d-arrow-right',
                                    attrs: { type: 'button' },
                                    on: { click: _vm.rightNextYear },
                                  }),
                                  _c('button', {
                                    staticClass:
                          'el-picker-panel__icon-btn el-icon-arrow-right',
                                    attrs: { type: 'button' },
                                    on: { click: _vm.rightNextMonth },
                                  }),
                                  _c('div', [_vm._v(_vm._s(_vm.rightLabel))]),
                                ]),
                                _c('date-table', {
                                  attrs: {
                                    'selection-mode': 'range',
                                    date: _vm.rightDate,
                                    'default-value': _vm.defaultValue,
                                    'min-date': _vm.minDate,
                                    'max-date': _vm.maxDate,
                                    'range-state': _vm.rangeState,
                                    'disabled-date': _vm.disabledDate,
                                    'cell-class-name': _vm.cellClassName,
                                    'first-day-of-week': _vm.firstDayOfWeek,
                                  },
                                  on: {
                                    changerange: _vm.handleChangeRange,
                                    pick: _vm.handleRangePick,
                                  },
                                }),
                              ],
                              1,
                            ),
                          ]),
                        ],
                        2,
                      ),
                      _vm.showTime
                        ? _c(
                          'div',
                          { staticClass: 'el-picker-panel__footer' },
                          [
                            _c(
                              'el-button',
                              {
                                staticClass: 'el-picker-panel__link-btn',
                                attrs: { size: 'mini', type: 'text' },
                                on: { click: _vm.handleClear },
                              },
                              [
                                _vm._v(
                                  `\n        ${
                                    _vm._s(_vm.t('el.datepicker.clear'))
                                  }\n      `,
                                ),
                              ],
                            ),
                            _c(
                              'el-button',
                              {
                                staticClass: 'el-picker-panel__link-btn',
                                attrs: {
                                  plain: '',
                                  size: 'mini',
                                  disabled: _vm.btnDisabled,
                                },
                                on: {
                                  click($event) {
                                    _vm.handleConfirm(false);
                                  },
                                },
                              },
                              [
                                _vm._v(
                                  `\n        ${
                                    _vm._s(_vm.t('el.datepicker.confirm'))
                                  }\n      `,
                                ),
                              ],
                            ),
                          ],
                          1,
                        )
                        : _vm._e(),
                    ],
                  ),
                ],
              );
            };
            const date_rangevue_type_template_id_2652849a_staticRenderFns = [];
            date_rangevue_type_template_id_2652849a_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/panel/date-range.vue?vue&type=template&id=2652849a&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date-range.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const date_rangevue_type_script_lang_js_calcDefaultValue = function calcDefaultValue(defaultValue) {
              if (Array.isArray(defaultValue)) {
                return [new Date(defaultValue[0]), new Date(defaultValue[1])];
              } if (defaultValue) {
                return [new Date(defaultValue), Object(date_util_.nextDate)(new Date(defaultValue), 1)];
              }
              return [new Date(), Object(date_util_.nextDate)(new Date(), 1)];
            };

            /* harmony default export */ const date_rangevue_type_script_lang_js_ = ({
              mixins: [locale_default.a],

              directives: { Clickoutside: clickoutside_default.a },

              computed: {
                btnDisabled: function btnDisabled() {
                  return !(this.minDate && this.maxDate && !this.selecting && this.isValidValue([this.minDate, this.maxDate]));
                },
                leftLabel: function leftLabel() {
                  return `${this.leftDate.getFullYear()} ${this.t('el.datepicker.year')} ${this.t(`el.datepicker.month${this.leftDate.getMonth() + 1}`)}`;
                },
                rightLabel: function rightLabel() {
                  return `${this.rightDate.getFullYear()} ${this.t('el.datepicker.year')} ${this.t(`el.datepicker.month${this.rightDate.getMonth() + 1}`)}`;
                },
                leftYear: function leftYear() {
                  return this.leftDate.getFullYear();
                },
                leftMonth: function leftMonth() {
                  return this.leftDate.getMonth();
                },
                leftMonthDate: function leftMonthDate() {
                  return this.leftDate.getDate();
                },
                rightYear: function rightYear() {
                  return this.rightDate.getFullYear();
                },
                rightMonth: function rightMonth() {
                  return this.rightDate.getMonth();
                },
                rightMonthDate: function rightMonthDate() {
                  return this.rightDate.getDate();
                },
                minVisibleDate: function minVisibleDate() {
                  if (this.dateUserInput.min !== null) return this.dateUserInput.min;
                  if (this.minDate) return Object(date_util_.formatDate)(this.minDate, this.dateFormat);
                  return '';
                },
                maxVisibleDate: function maxVisibleDate() {
                  if (this.dateUserInput.max !== null) return this.dateUserInput.max;
                  if (this.maxDate || this.minDate) return Object(date_util_.formatDate)(this.maxDate || this.minDate, this.dateFormat);
                  return '';
                },
                minVisibleTime: function minVisibleTime() {
                  if (this.timeUserInput.min !== null) return this.timeUserInput.min;
                  if (this.minDate) return Object(date_util_.formatDate)(this.minDate, this.timeFormat);
                  return '';
                },
                maxVisibleTime: function maxVisibleTime() {
                  if (this.timeUserInput.max !== null) return this.timeUserInput.max;
                  if (this.maxDate || this.minDate) return Object(date_util_.formatDate)(this.maxDate || this.minDate, this.timeFormat);
                  return '';
                },
                timeFormat: function timeFormat() {
                  if (this.format) {
                    return Object(date_util_.extractTimeFormat)(this.format);
                  }
                  return 'HH:mm:ss';
                },
                dateFormat: function dateFormat() {
                  if (this.format) {
                    return Object(date_util_.extractDateFormat)(this.format);
                  }
                  return 'yyyy-MM-dd';
                },
                enableMonthArrow: function enableMonthArrow() {
                  const nextMonth = (this.leftMonth + 1) % 12;
                  const yearOffset = this.leftMonth + 1 >= 12 ? 1 : 0;
                  return this.unlinkPanels && new Date(this.leftYear + yearOffset, nextMonth) < new Date(this.rightYear, this.rightMonth);
                },
                enableYearArrow: function enableYearArrow() {
                  return this.unlinkPanels && this.rightYear * 12 + this.rightMonth - (this.leftYear * 12 + this.leftMonth + 1) >= 12;
                },
              },

              data: function data() {
                return {
                  popperClass: '',
                  value: [],
                  defaultValue: null,
                  defaultTime: null,
                  minDate: '',
                  maxDate: '',
                  leftDate: new Date(),
                  rightDate: Object(date_util_.nextMonth)(new Date()),
                  rangeState: {
                    endDate: null,
                    selecting: false,
                    row: null,
                    column: null,
                  },
                  showTime: false,
                  shortcuts: '',
                  visible: '',
                  disabledDate: '',
                  cellClassName: '',
                  firstDayOfWeek: 7,
                  minTimePickerVisible: false,
                  maxTimePickerVisible: false,
                  format: '',
                  arrowControl: false,
                  unlinkPanels: false,
                  dateUserInput: {
                    min: null,
                    max: null,
                  },
                  timeUserInput: {
                    min: null,
                    max: null,
                  },
                };
              },

              watch: {
                minDate: function minDate(val) {
                  const _this = this;

                  this.dateUserInput.min = null;
                  this.timeUserInput.min = null;
                  this.$nextTick(() => {
                    if (_this.$refs.maxTimePicker && _this.maxDate && _this.maxDate < _this.minDate) {
                      const format = 'HH:mm:ss';
                      _this.$refs.maxTimePicker.selectableRange = [[Object(date_util_.parseDate)(Object(date_util_.formatDate)(_this.minDate, format), format), Object(date_util_.parseDate)('23:59:59', format)]];
                    }
                  });
                  if (val && this.$refs.minTimePicker) {
                    this.$refs.minTimePicker.date = val;
                    this.$refs.minTimePicker.value = val;
                  }
                },
                maxDate: function maxDate(val) {
                  this.dateUserInput.max = null;
                  this.timeUserInput.max = null;
                  if (val && this.$refs.maxTimePicker) {
                    this.$refs.maxTimePicker.date = val;
                    this.$refs.maxTimePicker.value = val;
                  }
                },
                minTimePickerVisible: function minTimePickerVisible(val) {
                  const _this2 = this;

                  if (val) {
                    this.$nextTick(() => {
                      _this2.$refs.minTimePicker.date = _this2.minDate;
                      _this2.$refs.minTimePicker.value = _this2.minDate;
                      _this2.$refs.minTimePicker.adjustSpinners();
                    });
                  }
                },
                maxTimePickerVisible: function maxTimePickerVisible(val) {
                  const _this3 = this;

                  if (val) {
                    this.$nextTick(() => {
                      _this3.$refs.maxTimePicker.date = _this3.maxDate;
                      _this3.$refs.maxTimePicker.value = _this3.maxDate;
                      _this3.$refs.maxTimePicker.adjustSpinners();
                    });
                  }
                },
                value: function value(newVal) {
                  if (!newVal) {
                    this.minDate = null;
                    this.maxDate = null;
                  } else if (Array.isArray(newVal)) {
                    this.minDate = Object(date_util_.isDate)(newVal[0]) ? new Date(newVal[0]) : null;
                    this.maxDate = Object(date_util_.isDate)(newVal[1]) ? new Date(newVal[1]) : null;
                    if (this.minDate) {
                      this.leftDate = this.minDate;
                      if (this.unlinkPanels && this.maxDate) {
                        const minDateYear = this.minDate.getFullYear();
                        const minDateMonth = this.minDate.getMonth();
                        const maxDateYear = this.maxDate.getFullYear();
                        const maxDateMonth = this.maxDate.getMonth();
                        this.rightDate = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? Object(date_util_.nextMonth)(this.maxDate) : this.maxDate;
                      } else {
                        this.rightDate = Object(date_util_.nextMonth)(this.leftDate);
                      }
                    } else {
                      this.leftDate = date_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[0];
                      this.rightDate = Object(date_util_.nextMonth)(this.leftDate);
                    }
                  }
                },
                defaultValue: function defaultValue(val) {
                  if (!Array.isArray(this.value)) {
                    const _calcDefaultValue = date_rangevue_type_script_lang_js_calcDefaultValue(val);
                    const left = _calcDefaultValue[0];
                    const right = _calcDefaultValue[1];

                    this.leftDate = left;
                    this.rightDate = val && val[1] && this.unlinkPanels ? right : Object(date_util_.nextMonth)(this.leftDate);
                  }
                },
              },

              methods: {
                handleClear: function handleClear() {
                  this.minDate = null;
                  this.maxDate = null;
                  this.leftDate = date_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[0];
                  this.rightDate = Object(date_util_.nextMonth)(this.leftDate);
                  this.$emit('pick', null);
                },
                handleChangeRange: function handleChangeRange(val) {
                  this.minDate = val.minDate;
                  this.maxDate = val.maxDate;
                  this.rangeState = val.rangeState;
                },
                handleDateInput: function handleDateInput(value, type) {
                  this.dateUserInput[type] = value;
                  if (value.length !== this.dateFormat.length) return;
                  const parsedValue = Object(date_util_.parseDate)(value, this.dateFormat);

                  if (parsedValue) {
                    if (typeof this.disabledDate === 'function' && this.disabledDate(new Date(parsedValue))) {
                      return;
                    }
                    if (type === 'min') {
                      this.minDate = Object(date_util_.modifyDate)(this.minDate || new Date(), parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
                      this.leftDate = new Date(parsedValue);
                      if (!this.unlinkPanels) {
                        this.rightDate = Object(date_util_.nextMonth)(this.leftDate);
                      }
                    } else {
                      this.maxDate = Object(date_util_.modifyDate)(this.maxDate || new Date(), parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
                      this.rightDate = new Date(parsedValue);
                      if (!this.unlinkPanels) {
                        this.leftDate = Object(date_util_.prevMonth)(parsedValue);
                      }
                    }
                  }
                },
                handleDateChange: function handleDateChange(value, type) {
                  const parsedValue = Object(date_util_.parseDate)(value, this.dateFormat);
                  if (parsedValue) {
                    if (type === 'min') {
                      this.minDate = Object(date_util_.modifyDate)(this.minDate, parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
                      if (this.minDate > this.maxDate) {
                        this.maxDate = this.minDate;
                      }
                    } else {
                      this.maxDate = Object(date_util_.modifyDate)(this.maxDate, parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
                      if (this.maxDate < this.minDate) {
                        this.minDate = this.maxDate;
                      }
                    }
                  }
                },
                handleTimeInput: function handleTimeInput(value, type) {
                  const _this4 = this;

                  this.timeUserInput[type] = value;
                  if (value.length !== this.timeFormat.length) return;
                  const parsedValue = Object(date_util_.parseDate)(value, this.timeFormat);

                  if (parsedValue) {
                    if (type === 'min') {
                      this.minDate = Object(date_util_.modifyTime)(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
                      this.$nextTick((_) => _this4.$refs.minTimePicker.adjustSpinners());
                    } else {
                      this.maxDate = Object(date_util_.modifyTime)(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
                      this.$nextTick((_) => _this4.$refs.maxTimePicker.adjustSpinners());
                    }
                  }
                },
                handleTimeChange: function handleTimeChange(value, type) {
                  const parsedValue = Object(date_util_.parseDate)(value, this.timeFormat);
                  if (parsedValue) {
                    if (type === 'min') {
                      this.minDate = Object(date_util_.modifyTime)(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
                      if (this.minDate > this.maxDate) {
                        this.maxDate = this.minDate;
                      }
                      this.$refs.minTimePicker.value = this.minDate;
                      this.minTimePickerVisible = false;
                    } else {
                      this.maxDate = Object(date_util_.modifyTime)(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
                      if (this.maxDate < this.minDate) {
                        this.minDate = this.maxDate;
                      }
                      this.$refs.maxTimePicker.value = this.minDate;
                      this.maxTimePickerVisible = false;
                    }
                  }
                },
                handleRangePick: function handleRangePick(val) {
                  const _this5 = this;

                  const close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

                  const defaultTime = this.defaultTime || [];
                  const minDate = Object(date_util_.modifyWithTimeString)(val.minDate, defaultTime[0]);
                  const maxDate = Object(date_util_.modifyWithTimeString)(val.maxDate, defaultTime[1]);

                  if (this.maxDate === maxDate && this.minDate === minDate) {
                    return;
                  }
                  this.onPick && this.onPick(val);
                  this.maxDate = maxDate;
                  this.minDate = minDate;

                  // workaround for https://github.com/ElemeFE/element/issues/7539, should remove this block when we don't have to care about Chromium 55 - 57
                  setTimeout(() => {
                    _this5.maxDate = maxDate;
                    _this5.minDate = minDate;
                  }, 10);
                  if (!close || this.showTime) return;
                  this.handleConfirm();
                },
                handleShortcutClick: function handleShortcutClick(shortcut) {
                  if (shortcut.onClick) {
                    shortcut.onClick(this);
                  }
                },
                handleMinTimePick: function handleMinTimePick(value, visible, first) {
                  this.minDate = this.minDate || new Date();
                  if (value) {
                    this.minDate = Object(date_util_.modifyTime)(this.minDate, value.getHours(), value.getMinutes(), value.getSeconds());
                  }

                  if (!first) {
                    this.minTimePickerVisible = visible;
                  }

                  if (!this.maxDate || this.maxDate && this.maxDate.getTime() < this.minDate.getTime()) {
                    this.maxDate = new Date(this.minDate);
                  }
                },
                handleMinTimeClose: function handleMinTimeClose() {
                  this.minTimePickerVisible = false;
                },
                handleMaxTimePick: function handleMaxTimePick(value, visible, first) {
                  if (this.maxDate && value) {
                    this.maxDate = Object(date_util_.modifyTime)(this.maxDate, value.getHours(), value.getMinutes(), value.getSeconds());
                  }

                  if (!first) {
                    this.maxTimePickerVisible = visible;
                  }

                  if (this.maxDate && this.minDate && this.minDate.getTime() > this.maxDate.getTime()) {
                    this.minDate = new Date(this.maxDate);
                  }
                },
                handleMaxTimeClose: function handleMaxTimeClose() {
                  this.maxTimePickerVisible = false;
                },

                // leftPrev*, rightNext* need to take care of `unlinkPanels`
                leftPrevYear: function leftPrevYear() {
                  this.leftDate = Object(date_util_.prevYear)(this.leftDate);
                  if (!this.unlinkPanels) {
                    this.rightDate = Object(date_util_.nextMonth)(this.leftDate);
                  }
                },
                leftPrevMonth: function leftPrevMonth() {
                  this.leftDate = Object(date_util_.prevMonth)(this.leftDate);
                  if (!this.unlinkPanels) {
                    this.rightDate = Object(date_util_.nextMonth)(this.leftDate);
                  }
                },
                rightNextYear: function rightNextYear() {
                  if (!this.unlinkPanels) {
                    this.leftDate = Object(date_util_.nextYear)(this.leftDate);
                    this.rightDate = Object(date_util_.nextMonth)(this.leftDate);
                  } else {
                    this.rightDate = Object(date_util_.nextYear)(this.rightDate);
                  }
                },
                rightNextMonth: function rightNextMonth() {
                  if (!this.unlinkPanels) {
                    this.leftDate = Object(date_util_.nextMonth)(this.leftDate);
                    this.rightDate = Object(date_util_.nextMonth)(this.leftDate);
                  } else {
                    this.rightDate = Object(date_util_.nextMonth)(this.rightDate);
                  }
                },

                // leftNext*, rightPrev* are called when `unlinkPanels` is true
                leftNextYear: function leftNextYear() {
                  this.leftDate = Object(date_util_.nextYear)(this.leftDate);
                },
                leftNextMonth: function leftNextMonth() {
                  this.leftDate = Object(date_util_.nextMonth)(this.leftDate);
                },
                rightPrevYear: function rightPrevYear() {
                  this.rightDate = Object(date_util_.prevYear)(this.rightDate);
                },
                rightPrevMonth: function rightPrevMonth() {
                  this.rightDate = Object(date_util_.prevMonth)(this.rightDate);
                },
                handleConfirm: function handleConfirm() {
                  const visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                  if (this.isValidValue([this.minDate, this.maxDate])) {
                    this.$emit('pick', [this.minDate, this.maxDate], visible);
                  }
                },
                isValidValue: function isValidValue(value) {
                  return Array.isArray(value) && value && value[0] && value[1] && Object(date_util_.isDate)(value[0]) && Object(date_util_.isDate)(value[1]) && value[0].getTime() <= value[1].getTime() && (typeof this.disabledDate === 'function' ? !this.disabledDate(value[0]) && !this.disabledDate(value[1]) : true);
                },
                resetView: function resetView() {
                  // NOTE: this is a hack to reset {min, max}Date on picker open.
                  // TODO: correct way of doing so is to refactor {min, max}Date to be dependent on value and internal selection state
                  //       an alternative would be resetView whenever picker becomes visible, should also investigate date-panel's resetView
                  if (this.minDate && this.maxDate == null) this.rangeState.selecting = false;
                  this.minDate = this.value && Object(date_util_.isDate)(this.value[0]) ? new Date(this.value[0]) : null;
                  this.maxDate = this.value && Object(date_util_.isDate)(this.value[0]) ? new Date(this.value[1]) : null;
                },
              },

              components: {
                TimePicker: panel_time, DateTable: date_table, ElInput: input_default.a, ElButton: button_default.a,
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/date-range.vue?vue&type=script&lang=js&
            /* harmony default export */ const panel_date_rangevue_type_script_lang_js_ = (date_rangevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/date-range.vue

            /* normalize component */

            const date_range_component = normalizeComponent(
              panel_date_rangevue_type_script_lang_js_,
              date_rangevue_type_template_id_2652849a_render,
              date_rangevue_type_template_id_2652849a_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let date_range_api; }
            date_range_component.options.__file = 'packages/date-picker/src/panel/date-range.vue';
            /* harmony default export */ const date_range = (date_range_component.exports);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/month-range.vue?vue&type=template&id=f2645fb8&
            const month_rangevue_type_template_id_f2645fb8_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                {
                  attrs: { name: 'el-zoom-in-top' },
                  on: {
                    'after-leave': function ($event) {
                      _vm.$emit('dodestroy');
                    },
                  },
                },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.visible,
                          expression: 'visible',
                        },
                      ],
                      staticClass: 'el-picker-panel el-date-range-picker el-popper',
                      class: [
                        {
                          'has-sidebar': _vm.$slots.sidebar || _vm.shortcuts,
                        },
                        _vm.popperClass,
                      ],
                    },
                    [
                      _c(
                        'div',
                        { staticClass: 'el-picker-panel__body-wrapper' },
                        [
                          _vm._t('sidebar'),
                          _vm.shortcuts
                            ? _c(
                              'div',
                              { staticClass: 'el-picker-panel__sidebar' },
                              _vm._l(_vm.shortcuts, (shortcut, key) => _c(
                                'button',
                                {
                                  key,
                                  staticClass: 'el-picker-panel__shortcut',
                                  attrs: { type: 'button' },
                                  on: {
                                    click($event) {
                                      _vm.handleShortcutClick(shortcut);
                                    },
                                  },
                                },
                                [_vm._v(_vm._s(shortcut.text))],
                              )),
                              0,
                            )
                            : _vm._e(),
                          _c('div', { staticClass: 'el-picker-panel__body' }, [
                            _c(
                              'div',
                              {
                                staticClass:
                      'el-picker-panel__content el-date-range-picker__content is-left',
                              },
                              [
                                _c('div', { staticClass: 'el-date-range-picker__header' }, [
                                  _c('button', {
                                    staticClass:
                          'el-picker-panel__icon-btn el-icon-d-arrow-left',
                                    attrs: { type: 'button' },
                                    on: { click: _vm.leftPrevYear },
                                  }),
                                  _vm.unlinkPanels
                                    ? _c('button', {
                                      staticClass:
                              'el-picker-panel__icon-btn el-icon-d-arrow-right',
                                      class: { 'is-disabled': !_vm.enableYearArrow },
                                      attrs: {
                                        type: 'button',
                                        disabled: !_vm.enableYearArrow,
                                      },
                                      on: { click: _vm.leftNextYear },
                                    })
                                    : _vm._e(),
                                  _c('div', [_vm._v(_vm._s(_vm.leftLabel))]),
                                ]),
                                _c('month-table', {
                                  attrs: {
                                    'selection-mode': 'range',
                                    date: _vm.leftDate,
                                    'default-value': _vm.defaultValue,
                                    'min-date': _vm.minDate,
                                    'max-date': _vm.maxDate,
                                    'range-state': _vm.rangeState,
                                    'disabled-date': _vm.disabledDate,
                                  },
                                  on: {
                                    changerange: _vm.handleChangeRange,
                                    pick: _vm.handleRangePick,
                                  },
                                }),
                              ],
                              1,
                            ),
                            _c(
                              'div',
                              {
                                staticClass:
                      'el-picker-panel__content el-date-range-picker__content is-right',
                              },
                              [
                                _c('div', { staticClass: 'el-date-range-picker__header' }, [
                                  _vm.unlinkPanels
                                    ? _c('button', {
                                      staticClass:
                              'el-picker-panel__icon-btn el-icon-d-arrow-left',
                                      class: { 'is-disabled': !_vm.enableYearArrow },
                                      attrs: {
                                        type: 'button',
                                        disabled: !_vm.enableYearArrow,
                                      },
                                      on: { click: _vm.rightPrevYear },
                                    })
                                    : _vm._e(),
                                  _c('button', {
                                    staticClass:
                          'el-picker-panel__icon-btn el-icon-d-arrow-right',
                                    attrs: { type: 'button' },
                                    on: { click: _vm.rightNextYear },
                                  }),
                                  _c('div', [_vm._v(_vm._s(_vm.rightLabel))]),
                                ]),
                                _c('month-table', {
                                  attrs: {
                                    'selection-mode': 'range',
                                    date: _vm.rightDate,
                                    'default-value': _vm.defaultValue,
                                    'min-date': _vm.minDate,
                                    'max-date': _vm.maxDate,
                                    'range-state': _vm.rangeState,
                                    'disabled-date': _vm.disabledDate,
                                  },
                                  on: {
                                    changerange: _vm.handleChangeRange,
                                    pick: _vm.handleRangePick,
                                  },
                                }),
                              ],
                              1,
                            ),
                          ]),
                        ],
                        2,
                      ),
                    ],
                  ),
                ],
              );
            };
            const month_rangevue_type_template_id_f2645fb8_staticRenderFns = [];
            month_rangevue_type_template_id_f2645fb8_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/panel/month-range.vue?vue&type=template&id=f2645fb8&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/month-range.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const month_rangevue_type_script_lang_js_calcDefaultValue = function calcDefaultValue(defaultValue) {
              if (Array.isArray(defaultValue)) {
                return [new Date(defaultValue[0]), new Date(defaultValue[1])];
              } if (defaultValue) {
                return [new Date(defaultValue), Object(date_util_.nextMonth)(new Date(defaultValue))];
              }
              return [new Date(), Object(date_util_.nextMonth)(new Date())];
            };
            /* harmony default export */ const month_rangevue_type_script_lang_js_ = ({
              mixins: [locale_default.a],

              directives: { Clickoutside: clickoutside_default.a },

              computed: {
                btnDisabled: function btnDisabled() {
                  return !(this.minDate && this.maxDate && !this.selecting && this.isValidValue([this.minDate, this.maxDate]));
                },
                leftLabel: function leftLabel() {
                  return `${this.leftDate.getFullYear()} ${this.t('el.datepicker.year')}`;
                },
                rightLabel: function rightLabel() {
                  return `${this.rightDate.getFullYear()} ${this.t('el.datepicker.year')}`;
                },
                leftYear: function leftYear() {
                  return this.leftDate.getFullYear();
                },
                rightYear: function rightYear() {
                  return this.rightDate.getFullYear() === this.leftDate.getFullYear() ? this.leftDate.getFullYear() + 1 : this.rightDate.getFullYear();
                },
                enableYearArrow: function enableYearArrow() {
                  return this.unlinkPanels && this.rightYear > this.leftYear + 1;
                },
              },

              data: function data() {
                return {
                  popperClass: '',
                  value: [],
                  defaultValue: null,
                  defaultTime: null,
                  minDate: '',
                  maxDate: '',
                  leftDate: new Date(),
                  rightDate: Object(date_util_.nextYear)(new Date()),
                  rangeState: {
                    endDate: null,
                    selecting: false,
                    row: null,
                    column: null,
                  },
                  shortcuts: '',
                  visible: '',
                  disabledDate: '',
                  format: '',
                  arrowControl: false,
                  unlinkPanels: false,
                };
              },

              watch: {
                value: function value(newVal) {
                  if (!newVal) {
                    this.minDate = null;
                    this.maxDate = null;
                  } else if (Array.isArray(newVal)) {
                    this.minDate = Object(date_util_.isDate)(newVal[0]) ? new Date(newVal[0]) : null;
                    this.maxDate = Object(date_util_.isDate)(newVal[1]) ? new Date(newVal[1]) : null;
                    if (this.minDate) {
                      this.leftDate = this.minDate;
                      if (this.unlinkPanels && this.maxDate) {
                        const minDateYear = this.minDate.getFullYear();
                        const maxDateYear = this.maxDate.getFullYear();
                        this.rightDate = minDateYear === maxDateYear ? Object(date_util_.nextYear)(this.maxDate) : this.maxDate;
                      } else {
                        this.rightDate = Object(date_util_.nextYear)(this.leftDate);
                      }
                    } else {
                      this.leftDate = month_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[0];
                      this.rightDate = Object(date_util_.nextYear)(this.leftDate);
                    }
                  }
                },
                defaultValue: function defaultValue(val) {
                  if (!Array.isArray(this.value)) {
                    const _calcDefaultValue = month_rangevue_type_script_lang_js_calcDefaultValue(val);
                    const left = _calcDefaultValue[0];
                    const right = _calcDefaultValue[1];

                    this.leftDate = left;
                    this.rightDate = val && val[1] && left.getFullYear() !== right.getFullYear() && this.unlinkPanels ? right : Object(date_util_.nextYear)(this.leftDate);
                  }
                },
              },

              methods: {
                handleClear: function handleClear() {
                  this.minDate = null;
                  this.maxDate = null;
                  this.leftDate = month_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[0];
                  this.rightDate = Object(date_util_.nextYear)(this.leftDate);
                  this.$emit('pick', null);
                },
                handleChangeRange: function handleChangeRange(val) {
                  this.minDate = val.minDate;
                  this.maxDate = val.maxDate;
                  this.rangeState = val.rangeState;
                },
                handleRangePick: function handleRangePick(val) {
                  const _this = this;

                  const close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

                  const defaultTime = this.defaultTime || [];
                  const minDate = Object(date_util_.modifyWithTimeString)(val.minDate, defaultTime[0]);
                  const maxDate = Object(date_util_.modifyWithTimeString)(val.maxDate, defaultTime[1]);
                  if (this.maxDate === maxDate && this.minDate === minDate) {
                    return;
                  }
                  this.onPick && this.onPick(val);
                  this.maxDate = maxDate;
                  this.minDate = minDate;

                  // workaround for https://github.com/ElemeFE/element/issues/7539, should remove this block when we don't have to care about Chromium 55 - 57
                  setTimeout(() => {
                    _this.maxDate = maxDate;
                    _this.minDate = minDate;
                  }, 10);
                  if (!close) return;
                  this.handleConfirm();
                },
                handleShortcutClick: function handleShortcutClick(shortcut) {
                  if (shortcut.onClick) {
                    shortcut.onClick(this);
                  }
                },

                // leftPrev*, rightNext* need to take care of `unlinkPanels`
                leftPrevYear: function leftPrevYear() {
                  this.leftDate = Object(date_util_.prevYear)(this.leftDate);
                  if (!this.unlinkPanels) {
                    this.rightDate = Object(date_util_.prevYear)(this.rightDate);
                  }
                },
                rightNextYear: function rightNextYear() {
                  if (!this.unlinkPanels) {
                    this.leftDate = Object(date_util_.nextYear)(this.leftDate);
                  }
                  this.rightDate = Object(date_util_.nextYear)(this.rightDate);
                },

                // leftNext*, rightPrev* are called when `unlinkPanels` is true
                leftNextYear: function leftNextYear() {
                  this.leftDate = Object(date_util_.nextYear)(this.leftDate);
                },
                rightPrevYear: function rightPrevYear() {
                  this.rightDate = Object(date_util_.prevYear)(this.rightDate);
                },
                handleConfirm: function handleConfirm() {
                  const visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                  if (this.isValidValue([this.minDate, this.maxDate])) {
                    this.$emit('pick', [this.minDate, this.maxDate], visible);
                  }
                },
                isValidValue: function isValidValue(value) {
                  return Array.isArray(value) && value && value[0] && value[1] && Object(date_util_.isDate)(value[0]) && Object(date_util_.isDate)(value[1]) && value[0].getTime() <= value[1].getTime() && (typeof this.disabledDate === 'function' ? !this.disabledDate(value[0]) && !this.disabledDate(value[1]) : true);
                },
                resetView: function resetView() {
                  // NOTE: this is a hack to reset {min, max}Date on picker open.
                  // TODO: correct way of doing so is to refactor {min, max}Date to be dependent on value and internal selection state
                  //       an alternative would be resetView whenever picker becomes visible, should also investigate date-panel's resetView
                  this.minDate = this.value && Object(date_util_.isDate)(this.value[0]) ? new Date(this.value[0]) : null;
                  this.maxDate = this.value && Object(date_util_.isDate)(this.value[0]) ? new Date(this.value[1]) : null;
                },
              },

              components: { MonthTable: month_table, ElInput: input_default.a, ElButton: button_default.a },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/month-range.vue?vue&type=script&lang=js&
            /* harmony default export */ const panel_month_rangevue_type_script_lang_js_ = (month_rangevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/month-range.vue

            /* normalize component */

            const month_range_component = normalizeComponent(
              panel_month_rangevue_type_script_lang_js_,
              month_rangevue_type_template_id_f2645fb8_render,
              month_rangevue_type_template_id_f2645fb8_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let month_range_api; }
            month_range_component.options.__file = 'packages/date-picker/src/panel/month-range.vue';
            /* harmony default export */ const month_range = (month_range_component.exports);
            // CONCATENATED MODULE: ./packages/date-picker/src/picker/date-picker.js

            const date_picker_getPanel = function getPanel(type) {
              if (type === 'daterange' || type === 'datetimerange') {
                return date_range;
              } if (type === 'monthrange') {
                return month_range;
              }
              return panel_date;
            };

            /* harmony default export */ const date_picker = ({
              mixins: [picker],

              name: 'ElDatePicker',

              props: {
                type: {
                  type: String,
                  default: 'date',
                },
                timeArrowControl: Boolean,
              },

              watch: {
                type: function type(_type) {
                  if (this.picker) {
                    this.unmountPicker();
                    this.panel = date_picker_getPanel(_type);
                    this.mountPicker();
                  } else {
                    this.panel = date_picker_getPanel(_type);
                  }
                },
              },

              created: function created() {
                this.panel = date_picker_getPanel(this.type);
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/index.js

            /* istanbul ignore next */
            date_picker.install = function install(Vue) {
              Vue.component(date_picker.name, date_picker);
            };

            /* harmony default export */ const packages_date_picker = (date_picker);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time-select.vue?vue&type=template&id=51ab9320&
            const time_selectvue_type_template_id_51ab9320_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                {
                  attrs: { name: 'el-zoom-in-top' },
                  on: {
                    'before-enter': _vm.handleMenuEnter,
                    'after-leave': function ($event) {
                      _vm.$emit('dodestroy');
                    },
                  },
                },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.visible,
                          expression: 'visible',
                        },
                      ],
                      ref: 'popper',
                      staticClass: 'el-picker-panel time-select el-popper',
                      class: _vm.popperClass,
                      style: { width: `${_vm.width}px` },
                    },
                    [
                      _c(
                        'el-scrollbar',
                        {
                          attrs: { noresize: '', 'wrap-class': 'el-picker-panel__content' },
                        },
                        _vm._l(_vm.items, (item) => _c(
                          'div',
                          {
                            key: item.value,
                            staticClass: 'time-select-item',
                            class: {
                              selected: _vm.value === item.value,
                              disabled: item.disabled,
                              default: item.value === _vm.defaultValue,
                            },
                            attrs: { disabled: item.disabled },
                            on: {
                              click($event) {
                                _vm.handleClick(item);
                              },
                            },
                          },
                          [_vm._v(_vm._s(item.value))],
                        )),
                        0,
                      ),
                    ],
                    1,
                  ),
                ],
              );
            };
            const time_selectvue_type_template_id_51ab9320_staticRenderFns = [];
            time_selectvue_type_template_id_51ab9320_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/panel/time-select.vue?vue&type=template&id=51ab9320&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time-select.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const parseTime = function parseTime(time) {
              const values = (time || '').split(':');
              if (values.length >= 2) {
                const hours = parseInt(values[0], 10);
                const minutes = parseInt(values[1], 10);

                return {
                  hours,
                  minutes,
                };
              }
              /* istanbul ignore next */
              return null;
            };

            const compareTime = function compareTime(time1, time2) {
              const value1 = parseTime(time1);
              const value2 = parseTime(time2);

              const minutes1 = value1.minutes + value1.hours * 60;
              const minutes2 = value2.minutes + value2.hours * 60;

              if (minutes1 === minutes2) {
                return 0;
              }

              return minutes1 > minutes2 ? 1 : -1;
            };

            const formatTime = function formatTime(time) {
              return `${time.hours < 10 ? `0${time.hours}` : time.hours}:${time.minutes < 10 ? `0${time.minutes}` : time.minutes}`;
            };

            const nextTime = function nextTime(time, step) {
              const timeValue = parseTime(time);
              const stepValue = parseTime(step);

              const next = {
                hours: timeValue.hours,
                minutes: timeValue.minutes,
              };

              next.minutes += stepValue.minutes;
              next.hours += stepValue.hours;

              next.hours += Math.floor(next.minutes / 60);
              next.minutes %= 60;

              return formatTime(next);
            };

            /* harmony default export */ const time_selectvue_type_script_lang_js_ = ({
              components: { ElScrollbar: scrollbar_default.a },

              watch: {
                value: function value(val) {
                  const _this = this;

                  if (!val) return;
                  this.$nextTick(() => _this.scrollToOption());
                },
              },

              methods: {
                handleClick: function handleClick(item) {
                  if (!item.disabled) {
                    this.$emit('pick', item.value);
                  }
                },
                handleClear: function handleClear() {
                  this.$emit('pick', null);
                },
                scrollToOption: function scrollToOption() {
                  const selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.selected';

                  const menu = this.$refs.popper.querySelector('.el-picker-panel__content');
                  scroll_into_view_default()(menu, menu.querySelector(selector));
                },
                handleMenuEnter: function handleMenuEnter() {
                  const _this2 = this;

                  const selected = this.items.map((item) => item.value).indexOf(this.value) !== -1;
                  const hasDefault = this.items.map((item) => item.value).indexOf(this.defaultValue) !== -1;
                  const option = selected && '.selected' || hasDefault && '.default' || '.time-select-item:not(.disabled)';
                  this.$nextTick(() => _this2.scrollToOption(option));
                },
                scrollDown: function scrollDown(step) {
                  const { items } = this;
                  const { length } = items;
                  let total = items.length;
                  let index = items.map((item) => item.value).indexOf(this.value);
                  while (total--) {
                    index = (index + step + length) % length;
                    if (!items[index].disabled) {
                      this.$emit('pick', items[index].value, true);
                      return;
                    }
                  }
                },
                isValidValue: function isValidValue(date) {
                  return this.items.filter((item) => !item.disabled).map((item) => item.value).indexOf(date) !== -1;
                },
                handleKeydown: function handleKeydown(event) {
                  const { keyCode } = event;
                  if (keyCode === 38 || keyCode === 40) {
                    const mapping = { 40: 1, 38: -1 };
                    const offset = mapping[keyCode.toString()];
                    this.scrollDown(offset);
                    event.stopPropagation();
                  }
                },
              },

              data: function data() {
                return {
                  popperClass: '',
                  start: '09:00',
                  end: '18:00',
                  step: '00:30',
                  value: '',
                  defaultValue: '',
                  visible: false,
                  minTime: '',
                  maxTime: '',
                  width: 0,
                };
              },

              computed: {
                items: function items() {
                  const { start } = this;
                  const { end } = this;
                  const { step } = this;

                  const result = [];

                  if (start && end && step) {
                    let current = start;
                    while (compareTime(current, end) <= 0) {
                      result.push({
                        value: current,
                        disabled: compareTime(current, this.minTime || '-1:-1') <= 0 || compareTime(current, this.maxTime || '100:100') >= 0,
                      });
                      current = nextTime(current, step);
                    }
                  }

                  return result;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/time-select.vue?vue&type=script&lang=js&
            /* harmony default export */ const panel_time_selectvue_type_script_lang_js_ = (time_selectvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/time-select.vue

            /* normalize component */

            const time_select_component = normalizeComponent(
              panel_time_selectvue_type_script_lang_js_,
              time_selectvue_type_template_id_51ab9320_render,
              time_selectvue_type_template_id_51ab9320_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let time_select_api; }
            time_select_component.options.__file = 'packages/date-picker/src/panel/time-select.vue';
            /* harmony default export */ const time_select = (time_select_component.exports);
            // CONCATENATED MODULE: ./packages/date-picker/src/picker/time-select.js

            /* harmony default export */ const picker_time_select = ({
              mixins: [picker],

              name: 'ElTimeSelect',

              componentName: 'ElTimeSelect',

              props: {
                type: {
                  type: String,
                  default: 'time-select',
                },
              },

              beforeCreate: function beforeCreate() {
                this.panel = time_select;
              },
            });
            // CONCATENATED MODULE: ./packages/time-select/index.js

            /* istanbul ignore next */
            picker_time_select.install = function (Vue) {
              Vue.component(picker_time_select.name, picker_time_select);
            };

            /* harmony default export */ const packages_time_select = (picker_time_select);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time-range.vue?vue&type=template&id=fb28660e&
            const time_rangevue_type_template_id_fb28660e_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                {
                  attrs: { name: 'el-zoom-in-top' },
                  on: {
                    'after-leave': function ($event) {
                      _vm.$emit('dodestroy');
                    },
                  },
                },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.visible,
                          expression: 'visible',
                        },
                      ],
                      staticClass: 'el-time-range-picker el-picker-panel el-popper',
                      class: _vm.popperClass,
                    },
                    [
                      _c('div', { staticClass: 'el-time-range-picker__content' }, [
                        _c('div', { staticClass: 'el-time-range-picker__cell' }, [
                          _c('div', { staticClass: 'el-time-range-picker__header' }, [
                            _vm._v(_vm._s(_vm.t('el.datepicker.startTime'))),
                          ]),
                          _c(
                            'div',
                            {
                              staticClass:
                    'el-time-range-picker__body el-time-panel__content',
                              class: {
                                'has-seconds': _vm.showSeconds,
                                'is-arrow': _vm.arrowControl,
                              },
                            },
                            [
                              _c('time-spinner', {
                                ref: 'minSpinner',
                                attrs: {
                                  'show-seconds': _vm.showSeconds,
                                  'am-pm-mode': _vm.amPmMode,
                                  'arrow-control': _vm.arrowControl,
                                  date: _vm.minDate,
                                },
                                on: {
                                  change: _vm.handleMinChange,
                                  'select-range': _vm.setMinSelectionRange,
                                },
                              }),
                            ],
                            1,
                          ),
                        ]),
                        _c('div', { staticClass: 'el-time-range-picker__cell' }, [
                          _c('div', { staticClass: 'el-time-range-picker__header' }, [
                            _vm._v(_vm._s(_vm.t('el.datepicker.endTime'))),
                          ]),
                          _c(
                            'div',
                            {
                              staticClass:
                    'el-time-range-picker__body el-time-panel__content',
                              class: {
                                'has-seconds': _vm.showSeconds,
                                'is-arrow': _vm.arrowControl,
                              },
                            },
                            [
                              _c('time-spinner', {
                                ref: 'maxSpinner',
                                attrs: {
                                  'show-seconds': _vm.showSeconds,
                                  'am-pm-mode': _vm.amPmMode,
                                  'arrow-control': _vm.arrowControl,
                                  date: _vm.maxDate,
                                },
                                on: {
                                  change: _vm.handleMaxChange,
                                  'select-range': _vm.setMaxSelectionRange,
                                },
                              }),
                            ],
                            1,
                          ),
                        ]),
                      ]),
                      _c('div', { staticClass: 'el-time-panel__footer' }, [
                        _c(
                          'button',
                          {
                            staticClass: 'el-time-panel__btn cancel',
                            attrs: { type: 'button' },
                            on: {
                              click($event) {
                                _vm.handleCancel();
                              },
                            },
                          },
                          [_vm._v(_vm._s(_vm.t('el.datepicker.cancel')))],
                        ),
                        _c(
                          'button',
                          {
                            staticClass: 'el-time-panel__btn confirm',
                            attrs: { type: 'button', disabled: _vm.btnDisabled },
                            on: {
                              click($event) {
                                _vm.handleConfirm();
                              },
                            },
                          },
                          [_vm._v(_vm._s(_vm.t('el.datepicker.confirm')))],
                        ),
                      ]),
                    ],
                  ),
                ],
              );
            };
            const time_rangevue_type_template_id_fb28660e_staticRenderFns = [];
            time_rangevue_type_template_id_fb28660e_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/date-picker/src/panel/time-range.vue?vue&type=template&id=fb28660e&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time-range.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const MIN_TIME = Object(date_util_.parseDate)('00:00:00', 'HH:mm:ss');
            const MAX_TIME = Object(date_util_.parseDate)('23:59:59', 'HH:mm:ss');

            const time_rangevue_type_script_lang_js_minTimeOfDay = function minTimeOfDay(date) {
              return Object(date_util_.modifyDate)(MIN_TIME, date.getFullYear(), date.getMonth(), date.getDate());
            };

            const time_rangevue_type_script_lang_js_maxTimeOfDay = function maxTimeOfDay(date) {
              return Object(date_util_.modifyDate)(MAX_TIME, date.getFullYear(), date.getMonth(), date.getDate());
            };

            // increase time by amount of milliseconds, but within the range of day
            const advanceTime = function advanceTime(date, amount) {
              return new Date(Math.min(date.getTime() + amount, time_rangevue_type_script_lang_js_maxTimeOfDay(date).getTime()));
            };

            /* harmony default export */ const time_rangevue_type_script_lang_js_ = ({
              mixins: [locale_default.a],

              components: { TimeSpinner: time_spinner },

              computed: {
                showSeconds: function showSeconds() {
                  return (this.format || '').indexOf('ss') !== -1;
                },
                offset: function offset() {
                  return this.showSeconds ? 11 : 8;
                },
                spinner: function spinner() {
                  return this.selectionRange[0] < this.offset ? this.$refs.minSpinner : this.$refs.maxSpinner;
                },
                btnDisabled: function btnDisabled() {
                  return this.minDate.getTime() > this.maxDate.getTime();
                },
                amPmMode: function amPmMode() {
                  if ((this.format || '').indexOf('A') !== -1) return 'A';
                  if ((this.format || '').indexOf('a') !== -1) return 'a';
                  return '';
                },
              },

              data: function data() {
                return {
                  popperClass: '',
                  minDate: new Date(),
                  maxDate: new Date(),
                  value: [],
                  oldValue: [new Date(), new Date()],
                  defaultValue: null,
                  format: 'HH:mm:ss',
                  visible: false,
                  selectionRange: [0, 2],
                  arrowControl: false,
                };
              },

              watch: {
                value: function value(_value) {
                  if (Array.isArray(_value)) {
                    this.minDate = new Date(_value[0]);
                    this.maxDate = new Date(_value[1]);
                  } else if (Array.isArray(this.defaultValue)) {
                    this.minDate = new Date(this.defaultValue[0]);
                    this.maxDate = new Date(this.defaultValue[1]);
                  } else if (this.defaultValue) {
                    this.minDate = new Date(this.defaultValue);
                    this.maxDate = advanceTime(new Date(this.defaultValue), 60 * 60 * 1000);
                  } else {
                    this.minDate = new Date();
                    this.maxDate = advanceTime(new Date(), 60 * 60 * 1000);
                  }
                },
                visible: function visible(val) {
                  const _this = this;

                  if (val) {
                    this.oldValue = this.value;
                    this.$nextTick(() => _this.$refs.minSpinner.emitSelectRange('hours'));
                  }
                },
              },

              methods: {
                handleClear: function handleClear() {
                  this.$emit('pick', null);
                },
                handleCancel: function handleCancel() {
                  this.$emit('pick', this.oldValue);
                },
                handleMinChange: function handleMinChange(date) {
                  this.minDate = Object(date_util_.clearMilliseconds)(date);
                  this.handleChange();
                },
                handleMaxChange: function handleMaxChange(date) {
                  this.maxDate = Object(date_util_.clearMilliseconds)(date);
                  this.handleChange();
                },
                handleChange: function handleChange() {
                  if (this.isValidValue([this.minDate, this.maxDate])) {
                    this.$refs.minSpinner.selectableRange = [[time_rangevue_type_script_lang_js_minTimeOfDay(this.minDate), this.maxDate]];
                    this.$refs.maxSpinner.selectableRange = [[this.minDate, time_rangevue_type_script_lang_js_maxTimeOfDay(this.maxDate)]];
                    this.$emit('pick', [this.minDate, this.maxDate], true);
                  }
                },
                setMinSelectionRange: function setMinSelectionRange(start, end) {
                  this.$emit('select-range', start, end, 'min');
                  this.selectionRange = [start, end];
                },
                setMaxSelectionRange: function setMaxSelectionRange(start, end) {
                  this.$emit('select-range', start, end, 'max');
                  this.selectionRange = [start + this.offset, end + this.offset];
                },
                handleConfirm: function handleConfirm() {
                  const visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                  const minSelectableRange = this.$refs.minSpinner.selectableRange;
                  const maxSelectableRange = this.$refs.maxSpinner.selectableRange;

                  this.minDate = Object(date_util_.limitTimeRange)(this.minDate, minSelectableRange, this.format);
                  this.maxDate = Object(date_util_.limitTimeRange)(this.maxDate, maxSelectableRange, this.format);

                  this.$emit('pick', [this.minDate, this.maxDate], visible);
                },
                adjustSpinners: function adjustSpinners() {
                  this.$refs.minSpinner.adjustSpinners();
                  this.$refs.maxSpinner.adjustSpinners();
                },
                changeSelectionRange: function changeSelectionRange(step) {
                  const list = this.showSeconds ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
                  const mapping = ['hours', 'minutes'].concat(this.showSeconds ? ['seconds'] : []);
                  const index = list.indexOf(this.selectionRange[0]);
                  const next = (index + step + list.length) % list.length;
                  const half = list.length / 2;
                  if (next < half) {
                    this.$refs.minSpinner.emitSelectRange(mapping[next]);
                  } else {
                    this.$refs.maxSpinner.emitSelectRange(mapping[next - half]);
                  }
                },
                isValidValue: function isValidValue(date) {
                  return Array.isArray(date) && Object(date_util_.timeWithinRange)(this.minDate, this.$refs.minSpinner.selectableRange) && Object(date_util_.timeWithinRange)(this.maxDate, this.$refs.maxSpinner.selectableRange);
                },
                handleKeydown: function handleKeydown(event) {
                  const { keyCode } = event;
                  const mapping = {
                    38: -1, 40: 1, 37: -1, 39: 1,
                  };

                  // Left or Right
                  if (keyCode === 37 || keyCode === 39) {
                    const step = mapping[keyCode];
                    this.changeSelectionRange(step);
                    event.preventDefault();
                    return;
                  }

                  // Up or Down
                  if (keyCode === 38 || keyCode === 40) {
                    const _step = mapping[keyCode];
                    this.spinner.scrollDown(_step);
                    event.preventDefault();
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/time-range.vue?vue&type=script&lang=js&
            /* harmony default export */ const panel_time_rangevue_type_script_lang_js_ = (time_rangevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/date-picker/src/panel/time-range.vue

            /* normalize component */

            const time_range_component = normalizeComponent(
              panel_time_rangevue_type_script_lang_js_,
              time_rangevue_type_template_id_fb28660e_render,
              time_rangevue_type_template_id_fb28660e_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let time_range_api; }
            time_range_component.options.__file = 'packages/date-picker/src/panel/time-range.vue';
            /* harmony default export */ const time_range = (time_range_component.exports);
            // CONCATENATED MODULE: ./packages/date-picker/src/picker/time-picker.js

            /* harmony default export */ const time_picker = ({
              mixins: [picker],

              name: 'ElTimePicker',

              props: {
                isRange: Boolean,
                arrowControl: Boolean,
              },

              data: function data() {
                return {
                  type: '',
                };
              },

              watch: {
                isRange: function isRange(_isRange) {
                  if (this.picker) {
                    this.unmountPicker();
                    this.type = _isRange ? 'timerange' : 'time';
                    this.panel = _isRange ? time_range : panel_time;
                    this.mountPicker();
                  } else {
                    this.type = _isRange ? 'timerange' : 'time';
                    this.panel = _isRange ? time_range : panel_time;
                  }
                },
              },

              created: function created() {
                this.type = this.isRange ? 'timerange' : 'time';
                this.panel = this.isRange ? time_range : panel_time;
              },
            });
            // CONCATENATED MODULE: ./packages/time-picker/index.js

            /* istanbul ignore next */
            time_picker.install = function (Vue) {
              Vue.component(time_picker.name, time_picker);
            };

            /* harmony default export */ const packages_time_picker = (time_picker);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/popover/src/main.vue?vue&type=template&id=52060272&
            const mainvue_type_template_id_52060272_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'span',
                [
                  _c(
                    'transition',
                    {
                      attrs: { name: _vm.transition },
                      on: {
                        'after-enter': _vm.handleAfterEnter,
                        'after-leave': _vm.handleAfterLeave,
                      },
                    },
                    [
                      _c(
                        'div',
                        {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: !_vm.disabled && _vm.showPopper,
                              expression: '!disabled && showPopper',
                            },
                          ],
                          ref: 'popper',
                          staticClass: 'el-popover el-popper',
                          class: [_vm.popperClass, _vm.content && 'el-popover--plain'],
                          style: { width: `${_vm.width}px` },
                          attrs: {
                            role: 'tooltip',
                            id: _vm.tooltipId,
                            'aria-hidden':
                  _vm.disabled || !_vm.showPopper ? 'true' : 'false',
                          },
                        },
                        [
                          _vm.title
                            ? _c('div', {
                              staticClass: 'el-popover__title',
                              domProps: { textContent: _vm._s(_vm.title) },
                            })
                            : _vm._e(),
                          _vm._t('default', [_vm._v(_vm._s(_vm.content))]),
                        ],
                        2,
                      ),
                    ],
                  ),
                  _c(
                    'span',
                    { ref: 'wrapper', staticClass: 'el-popover__reference-wrapper' },
                    [_vm._t('reference')],
                    2,
                  ),
                ],
                1,
              );
            };
            const mainvue_type_template_id_52060272_staticRenderFns = [];
            mainvue_type_template_id_52060272_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/popover/src/main.vue?vue&type=template&id=52060272&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/popover/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const mainvue_type_script_lang_js_ = ({
              name: 'ElPopover',

              mixins: [vue_popper_default.a],

              props: {
                trigger: {
                  type: String,
                  default: 'click',
                  validator: function validator(value) {
                    return ['click', 'focus', 'hover', 'manual'].indexOf(value) > -1;
                  },
                },
                openDelay: {
                  type: Number,
                  default: 0,
                },
                closeDelay: {
                  type: Number,
                  default: 200,
                },
                title: String,
                disabled: Boolean,
                content: String,
                reference: {},
                popperClass: String,
                width: {},
                visibleArrow: {
                  default: true,
                },
                arrowOffset: {
                  type: Number,
                  default: 0,
                },
                transition: {
                  type: String,
                  default: 'fade-in-linear',
                },
                tabindex: {
                  type: Number,
                  default: 0,
                },
              },

              computed: {
                tooltipId: function tooltipId() {
                  return `el-popover-${Object(util_.generateId)()}`;
                },
              },
              watch: {
                showPopper: function showPopper(val) {
                  if (this.disabled) {
                    return;
                  }
                  val ? this.$emit('show') : this.$emit('hide');
                },
              },

              mounted: function mounted() {
                const _this = this;

                let reference = this.referenceElm = this.reference || this.$refs.reference;
                const popper = this.popper || this.$refs.popper;

                if (!reference && this.$refs.wrapper.children) {
                  reference = this.referenceElm = this.$refs.wrapper.children[0];
                }
                // 可访问性
                if (reference) {
                  Object(dom_.addClass)(reference, 'el-popover__reference');
                  reference.setAttribute('aria-describedby', this.tooltipId);
                  reference.setAttribute('tabindex', this.tabindex); // tab序列
                  popper.setAttribute('tabindex', 0);

                  if (this.trigger !== 'click') {
                    Object(dom_.on)(reference, 'focusin', () => {
                      _this.handleFocus();
                      const instance = reference.__vue__;
                      if (instance && typeof instance.focus === 'function') {
                        instance.focus();
                      }
                    });
                    Object(dom_.on)(popper, 'focusin', this.handleFocus);
                    Object(dom_.on)(reference, 'focusout', this.handleBlur);
                    Object(dom_.on)(popper, 'focusout', this.handleBlur);
                  }
                  Object(dom_.on)(reference, 'keydown', this.handleKeydown);
                  Object(dom_.on)(reference, 'click', this.handleClick);
                }
                if (this.trigger === 'click') {
                  Object(dom_.on)(reference, 'click', this.doToggle);
                  Object(dom_.on)(document, 'click', this.handleDocumentClick);
                } else if (this.trigger === 'hover') {
                  Object(dom_.on)(reference, 'mouseenter', this.handleMouseEnter);
                  Object(dom_.on)(popper, 'mouseenter', this.handleMouseEnter);
                  Object(dom_.on)(reference, 'mouseleave', this.handleMouseLeave);
                  Object(dom_.on)(popper, 'mouseleave', this.handleMouseLeave);
                } else if (this.trigger === 'focus') {
                  if (this.tabindex < 0) {
                    console.warn('[Element Warn][Popover]a negative taindex means that the element cannot be focused by tab key');
                  }
                  if (reference.querySelector('input, textarea')) {
                    Object(dom_.on)(reference, 'focusin', this.doShow);
                    Object(dom_.on)(reference, 'focusout', this.doClose);
                  } else {
                    Object(dom_.on)(reference, 'mousedown', this.doShow);
                    Object(dom_.on)(reference, 'mouseup', this.doClose);
                  }
                }
              },
              beforeDestroy: function beforeDestroy() {
                this.cleanup();
              },
              deactivated: function deactivated() {
                this.cleanup();
              },

              methods: {
                doToggle: function doToggle() {
                  this.showPopper = !this.showPopper;
                },
                doShow: function doShow() {
                  this.showPopper = true;
                },
                doClose: function doClose() {
                  this.showPopper = false;
                },
                handleFocus: function handleFocus() {
                  Object(dom_.addClass)(this.referenceElm, 'focusing');
                  if (this.trigger === 'click' || this.trigger === 'focus') this.showPopper = true;
                },
                handleClick: function handleClick() {
                  Object(dom_.removeClass)(this.referenceElm, 'focusing');
                },
                handleBlur: function handleBlur() {
                  Object(dom_.removeClass)(this.referenceElm, 'focusing');
                  if (this.trigger === 'click' || this.trigger === 'focus') this.showPopper = false;
                },
                handleMouseEnter: function handleMouseEnter() {
                  const _this2 = this;

                  clearTimeout(this._timer);
                  if (this.openDelay) {
                    this._timer = setTimeout(() => {
                      _this2.showPopper = true;
                    }, this.openDelay);
                  } else {
                    this.showPopper = true;
                  }
                },
                handleKeydown: function handleKeydown(ev) {
                  if (ev.keyCode === 27 && this.trigger !== 'manual') {
                    // esc
                    this.doClose();
                  }
                },
                handleMouseLeave: function handleMouseLeave() {
                  const _this3 = this;

                  clearTimeout(this._timer);
                  if (this.closeDelay) {
                    this._timer = setTimeout(() => {
                      _this3.showPopper = false;
                    }, this.closeDelay);
                  } else {
                    this.showPopper = false;
                  }
                },
                handleDocumentClick: function handleDocumentClick(e) {
                  let reference = this.reference || this.$refs.reference;
                  const popper = this.popper || this.$refs.popper;

                  if (!reference && this.$refs.wrapper.children) {
                    reference = this.referenceElm = this.$refs.wrapper.children[0];
                  }
                  if (!this.$el || !reference || this.$el.contains(e.target) || reference.contains(e.target) || !popper || popper.contains(e.target)) return;
                  this.showPopper = false;
                },
                handleAfterEnter: function handleAfterEnter() {
                  this.$emit('after-enter');
                },
                handleAfterLeave: function handleAfterLeave() {
                  this.$emit('after-leave');
                  this.doDestroy();
                },
                cleanup: function cleanup() {
                  if (this.openDelay || this.closeDelay) {
                    clearTimeout(this._timer);
                  }
                },
              },

              destroyed: function destroyed() {
                const { reference } = this;

                Object(dom_.off)(reference, 'click', this.doToggle);
                Object(dom_.off)(reference, 'mouseup', this.doClose);
                Object(dom_.off)(reference, 'mousedown', this.doShow);
                Object(dom_.off)(reference, 'focusin', this.doShow);
                Object(dom_.off)(reference, 'focusout', this.doClose);
                Object(dom_.off)(reference, 'mousedown', this.doShow);
                Object(dom_.off)(reference, 'mouseup', this.doClose);
                Object(dom_.off)(reference, 'mouseleave', this.handleMouseLeave);
                Object(dom_.off)(reference, 'mouseenter', this.handleMouseEnter);
                Object(dom_.off)(document, 'click', this.handleDocumentClick);
              },
            });
            // CONCATENATED MODULE: ./packages/popover/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_mainvue_type_script_lang_js_ = (mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/popover/src/main.vue

            /* normalize component */

            const main_component = normalizeComponent(
              src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_52060272_render,
              mainvue_type_template_id_52060272_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let main_api; }
            main_component.options.__file = 'packages/popover/src/main.vue';
            /* harmony default export */ const main = (main_component.exports);
            // CONCATENATED MODULE: ./packages/popover/src/directive.js
            const getReference = function getReference(el, binding, vnode) {
              const _ref = binding.expression ? binding.value : binding.arg;
              const popper = vnode.context.$refs[_ref];
              if (popper) {
                if (Array.isArray(popper)) {
                  popper[0].$refs.reference = el;
                } else {
                  popper.$refs.reference = el;
                }
              }
            };

            /* harmony default export */ const directive = ({
              bind: function bind(el, binding, vnode) {
                getReference(el, binding, vnode);
              },
              inserted: function inserted(el, binding, vnode) {
                getReference(el, binding, vnode);
              },
            });
            // CONCATENATED MODULE: ./packages/popover/index.js

            external_vue_default.a.directive('popover', directive);

            /* istanbul ignore next */
            main.install = function (Vue) {
              Vue.directive('popover', directive);
              Vue.component(main.name, main);
            };
            main.directive = directive;

            /* harmony default export */ const popover = (main);
            // CONCATENATED MODULE: ./packages/tooltip/src/main.js

            /* harmony default export */ const src_main = ({
              name: 'ElTooltip',

              mixins: [vue_popper_default.a],

              props: {
                openDelay: {
                  type: Number,
                  default: 0,
                },
                disabled: Boolean,
                manual: Boolean,
                effect: {
                  type: String,
                  default: 'dark',
                },
                arrowOffset: {
                  type: Number,
                  default: 0,
                },
                popperClass: String,
                content: String,
                visibleArrow: {
                  default: true,
                },
                transition: {
                  type: String,
                  default: 'el-fade-in-linear',
                },
                popperOptions: {
                  default: function _default() {
                    return {
                      boundariesPadding: 10,
                      gpuAcceleration: false,
                    };
                  },
                },
                enterable: {
                  type: Boolean,
                  default: true,
                },
                hideAfter: {
                  type: Number,
                  default: 0,
                },
                tabindex: {
                  type: Number,
                  default: 0,
                },
              },

              data: function data() {
                return {
                  tooltipId: `el-tooltip-${Object(util_.generateId)()}`,
                  timeoutPending: null,
                  focusing: false,
                };
              },
              beforeCreate: function beforeCreate() {
                const _this = this;

                if (this.$isServer) return;

                this.popperVM = new external_vue_default.a({
                  data: { node: '' },
                  render: function render(h) {
                    return this.node;
                  },
                }).$mount();

                this.debounceClose = debounce_default()(200, () => _this.handleClosePopper());
              },
              render: function render(h) {
                const _this2 = this;

                if (this.popperVM) {
                  this.popperVM.node = h(
                    'transition',
                    {
                      attrs: {
                        name: this.transition,
                      },
                      on: {
                        afterLeave: this.doDestroy,
                      },
                    },
                    [h(
                      'div',
                      {
                        on: {
                          mouseleave: function mouseleave() {
                            _this2.setExpectedState(false); _this2.debounceClose();
                          },
                          mouseenter: function mouseenter() {
                            _this2.setExpectedState(true);
                          },
                        },

                        ref: 'popper',
                        attrs: {
                          role: 'tooltip',
                          id: this.tooltipId,
                          'aria-hidden': this.disabled || !this.showPopper ? 'true' : 'false',
                        },
                        directives: [{
                          name: 'show',
                          value: !this.disabled && this.showPopper,
                        }],

                        class: ['el-tooltip__popper', `is-${this.effect}`, this.popperClass],
                      },
                      [this.$slots.content || this.content],
                    )],
                  );
                }

                const firstElement = this.getFirstElement();
                if (!firstElement) return null;

                const data = firstElement.data = firstElement.data || {};
                data.staticClass = this.addTooltipClass(data.staticClass);

                return firstElement;
              },
              mounted: function mounted() {
                const _this3 = this;

                this.referenceElm = this.$el;
                if (this.$el.nodeType === 1) {
                  this.$el.setAttribute('aria-describedby', this.tooltipId);
                  this.$el.setAttribute('tabindex', this.tabindex);
                  Object(dom_.on)(this.referenceElm, 'mouseenter', this.show);
                  Object(dom_.on)(this.referenceElm, 'mouseleave', this.hide);
                  Object(dom_.on)(this.referenceElm, 'focus', () => {
                    if (!_this3.$slots.default || !_this3.$slots.default.length) {
                      _this3.handleFocus();
                      return;
                    }
                    const instance = _this3.$slots.default[0].componentInstance;
                    if (instance && instance.focus) {
                      instance.focus();
                    } else {
                      _this3.handleFocus();
                    }
                  });
                  Object(dom_.on)(this.referenceElm, 'blur', this.handleBlur);
                  Object(dom_.on)(this.referenceElm, 'click', this.removeFocusing);
                }
                // fix issue https://github.com/ElemeFE/element/issues/14424
                if (this.value && this.popperVM) {
                  this.popperVM.$nextTick(() => {
                    if (_this3.value) {
                      _this3.updatePopper();
                    }
                  });
                }
              },

              watch: {
                focusing: function focusing(val) {
                  if (val) {
                    Object(dom_.addClass)(this.referenceElm, 'focusing');
                  } else {
                    Object(dom_.removeClass)(this.referenceElm, 'focusing');
                  }
                },
              },
              methods: {
                show: function show() {
                  this.setExpectedState(true);
                  this.handleShowPopper();
                },
                hide: function hide() {
                  this.setExpectedState(false);
                  this.debounceClose();
                },
                handleFocus: function handleFocus() {
                  this.focusing = true;
                  this.show();
                },
                handleBlur: function handleBlur() {
                  this.focusing = false;
                  this.hide();
                },
                removeFocusing: function removeFocusing() {
                  this.focusing = false;
                },
                addTooltipClass: function addTooltipClass(prev) {
                  if (!prev) {
                    return 'el-tooltip';
                  }
                  return `el-tooltip ${prev.replace('el-tooltip', '')}`;
                },
                handleShowPopper: function handleShowPopper() {
                  const _this4 = this;

                  if (!this.expectedState || this.manual) return;
                  clearTimeout(this.timeout);
                  this.timeout = setTimeout(() => {
                    _this4.showPopper = true;
                  }, this.openDelay);

                  if (this.hideAfter > 0) {
                    this.timeoutPending = setTimeout(() => {
                      _this4.showPopper = false;
                    }, this.hideAfter);
                  }
                },
                handleClosePopper: function handleClosePopper() {
                  if (this.enterable && this.expectedState || this.manual) return;
                  clearTimeout(this.timeout);

                  if (this.timeoutPending) {
                    clearTimeout(this.timeoutPending);
                  }
                  this.showPopper = false;

                  if (this.disabled) {
                    this.doDestroy();
                  }
                },
                setExpectedState: function setExpectedState(expectedState) {
                  if (expectedState === false) {
                    clearTimeout(this.timeoutPending);
                  }
                  this.expectedState = expectedState;
                },
                getFirstElement: function getFirstElement() {
                  const slots = this.$slots.default;
                  if (!Array.isArray(slots)) return null;
                  let element = null;
                  for (let index = 0; index < slots.length; index++) {
                    if (slots[index] && slots[index].tag) {
                      element = slots[index];
                    }
                  }
                  return element;
                },
              },

              beforeDestroy: function beforeDestroy() {
                this.popperVM && this.popperVM.$destroy();
              },
              destroyed: function destroyed() {
                const reference = this.referenceElm;
                if (reference.nodeType === 1) {
                  Object(dom_.off)(reference, 'mouseenter', this.show);
                  Object(dom_.off)(reference, 'mouseleave', this.hide);
                  Object(dom_.off)(reference, 'focus', this.handleFocus);
                  Object(dom_.off)(reference, 'blur', this.handleBlur);
                  Object(dom_.off)(reference, 'click', this.removeFocusing);
                }
              },
            });
            // CONCATENATED MODULE: ./packages/tooltip/index.js

            /* istanbul ignore next */
            src_main.install = function (Vue) {
              Vue.component(src_main.name, src_main);
            };

            /* harmony default export */ const packages_tooltip = (src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/message-box/src/main.vue?vue&type=template&id=6b29b012&
            const mainvue_type_template_id_6b29b012_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('transition', { attrs: { name: 'msgbox-fade' } }, [
                _c(
                  'div',
                  {
                    directives: [
                      {
                        name: 'show',
                        rawName: 'v-show',
                        value: _vm.visible,
                        expression: 'visible',
                      },
                    ],
                    staticClass: 'el-message-box__wrapper',
                    attrs: {
                      tabindex: '-1',
                      role: 'dialog',
                      'aria-modal': 'true',
                      'aria-label': _vm.title || 'dialog',
                    },
                    on: {
                      click($event) {
                        if ($event.target !== $event.currentTarget) {
                          return null;
                        }
                        return _vm.handleWrapperClick($event);
                      },
                    },
                  },
                  [
                    _c(
                      'div',
                      {
                        staticClass: 'el-message-box',
                        class: [_vm.customClass, _vm.center && 'el-message-box--center'],
                      },
                      [
                        _vm.title !== null
                          ? _c('div', { staticClass: 'el-message-box__header' }, [
                            _c('div', { staticClass: 'el-message-box__title' }, [
                              _vm.icon && _vm.center
                                ? _c('div', {
                                  class: ['el-message-box__status', _vm.icon],
                                })
                                : _vm._e(),
                              _c('span', [_vm._v(_vm._s(_vm.title))]),
                            ]),
                            _vm.showClose
                              ? _c(
                                'button',
                                {
                                  staticClass: 'el-message-box__headerbtn',
                                  attrs: { type: 'button', 'aria-label': 'Close' },
                                  on: {
                                    click($event) {
                                      _vm.handleAction(
                                        _vm.distinguishCancelAndClose
                                          ? 'close'
                                          : 'cancel',
                                      );
                                    },
                                    keydown($event) {
                                      if (
                                        !('button' in $event)
                                && _vm._k(
                                  $event.keyCode,
                                  'enter',
                                  13,
                                  $event.key,
                                  'Enter',
                                )
                                      ) {
                                        return null;
                                      }
                                      _vm.handleAction(
                                        _vm.distinguishCancelAndClose
                                          ? 'close'
                                          : 'cancel',
                                      );
                                    },
                                  },
                                },
                                [
                                  _c('i', {
                                    staticClass: 'el-message-box__close el-icon-close',
                                  }),
                                ],
                              )
                              : _vm._e(),
                          ])
                          : _vm._e(),
                        _c('div', { staticClass: 'el-message-box__content' }, [
                          _c('div', { staticClass: 'el-message-box__container' }, [
                            _vm.icon && !_vm.center && _vm.message !== ''
                              ? _c('div', { class: ['el-message-box__status', _vm.icon] })
                              : _vm._e(),
                            _vm.message !== ''
                              ? _c(
                                'div',
                                { staticClass: 'el-message-box__message' },
                                [
                                  _vm._t('default', [
                                    !_vm.dangerouslyUseHTMLString
                                      ? _c('p', [_vm._v(_vm._s(_vm.message))])
                                      : _c('p', {
                                        domProps: { innerHTML: _vm._s(_vm.message) },
                                      }),
                                  ]),
                                ],
                                2,
                              )
                              : _vm._e(),
                          ]),
                          _c(
                            'div',
                            {
                              directives: [
                                {
                                  name: 'show',
                                  rawName: 'v-show',
                                  value: _vm.showInput,
                                  expression: 'showInput',
                                },
                              ],
                              staticClass: 'el-message-box__input',
                            },
                            [
                              _c('el-input', {
                                ref: 'input',
                                attrs: {
                                  type: _vm.inputType,
                                  placeholder: _vm.inputPlaceholder,
                                },
                                nativeOn: {
                                  keydown($event) {
                                    if (
                                      !('button' in $event)
                          && _vm._k(
                            $event.keyCode,
                            'enter',
                            13,
                            $event.key,
                            'Enter',
                          )
                                    ) {
                                      return null;
                                    }
                                    return _vm.handleInputEnter($event);
                                  },
                                },
                                model: {
                                  value: _vm.inputValue,
                                  callback($$v) {
                                    _vm.inputValue = $$v;
                                  },
                                  expression: 'inputValue',
                                },
                              }),
                              _c(
                                'div',
                                {
                                  staticClass: 'el-message-box__errormsg',
                                  style: {
                                    visibility: _vm.editorErrorMessage
                                      ? 'visible'
                                      : 'hidden',
                                  },
                                },
                                [_vm._v(_vm._s(_vm.editorErrorMessage))],
                              ),
                            ],
                            1,
                          ),
                        ]),
                        _c(
                          'div',
                          { staticClass: 'el-message-box__btns' },
                          [
                            _vm.showCancelButton
                              ? _c(
                                'el-button',
                                {
                                  class: [_vm.cancelButtonClasses],
                                  attrs: {
                                    loading: _vm.cancelButtonLoading,
                                    round: _vm.roundButton,
                                    size: 'small',
                                  },
                                  on: {
                                    keydown($event) {
                                      if (
                                        !('button' in $event)
                              && _vm._k(
                                $event.keyCode,
                                'enter',
                                13,
                                $event.key,
                                'Enter',
                              )
                                      ) {
                                        return null;
                                      }
                                      _vm.handleAction('cancel');
                                    },
                                  },
                                  nativeOn: {
                                    click($event) {
                                      _vm.handleAction('cancel');
                                    },
                                  },
                                },
                                [
                                  _vm._v(
                                    `\n          ${
                                      _vm._s(
                                        _vm.cancelButtonText
                                || _vm.t('el.messagebox.cancel'),
                                      )
                                    }\n        `,
                                  ),
                                ],
                              )
                              : _vm._e(),
                            _c(
                              'el-button',
                              {
                                directives: [
                                  {
                                    name: 'show',
                                    rawName: 'v-show',
                                    value: _vm.showConfirmButton,
                                    expression: 'showConfirmButton',
                                  },
                                ],
                                ref: 'confirm',
                                class: [_vm.confirmButtonClasses],
                                attrs: {
                                  loading: _vm.confirmButtonLoading,
                                  round: _vm.roundButton,
                                  size: 'small',
                                },
                                on: {
                                  keydown($event) {
                                    if (
                                      !('button' in $event)
                          && _vm._k(
                            $event.keyCode,
                            'enter',
                            13,
                            $event.key,
                            'Enter',
                          )
                                    ) {
                                      return null;
                                    }
                                    _vm.handleAction('confirm');
                                  },
                                },
                                nativeOn: {
                                  click($event) {
                                    _vm.handleAction('confirm');
                                  },
                                },
                              },
                              [
                                _vm._v(
                                  `\n          ${
                                    _vm._s(
                                      _vm.confirmButtonText
                            || _vm.t('el.messagebox.confirm'),
                                    )
                                  }\n        `,
                                ),
                              ],
                            ),
                          ],
                          1,
                        ),
                      ],
                    ),
                  ],
                ),
              ]);
            };
            const mainvue_type_template_id_6b29b012_staticRenderFns = [];
            mainvue_type_template_id_6b29b012_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/message-box/src/main.vue?vue&type=template&id=6b29b012&

            // EXTERNAL MODULE: external "element-ui/lib/locale"
            const lib_locale_ = __webpack_require__(15);
            const lib_locale_default = /* #__PURE__ */__webpack_require__.n(lib_locale_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/aria-dialog"
            const aria_dialog_ = __webpack_require__(39);
            const aria_dialog_default = /* #__PURE__ */__webpack_require__.n(aria_dialog_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/message-box/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            let messageBox = void 0;
            const typeMap = {
              success: 'success',
              info: 'info',
              warning: 'warning',
              error: 'error',
            };

            /* harmony default export */ const message_box_src_mainvue_type_script_lang_js_ = ({
              mixins: [popup_default.a, locale_default.a],

              props: {
                modal: {
                  default: true,
                },
                lockScroll: {
                  default: true,
                },
                showClose: {
                  type: Boolean,
                  default: true,
                },
                closeOnClickModal: {
                  default: true,
                },
                closeOnPressEscape: {
                  default: true,
                },
                closeOnHashChange: {
                  default: true,
                },
                center: {
                  default: false,
                  type: Boolean,
                },
                roundButton: {
                  default: false,
                  type: Boolean,
                },
              },

              components: {
                ElInput: input_default.a,
                ElButton: button_default.a,
              },

              computed: {
                icon: function icon() {
                  const { type } = this;
                  const { iconClass } = this;

                  return iconClass || (type && typeMap[type] ? `el-icon-${typeMap[type]}` : '');
                },
                confirmButtonClasses: function confirmButtonClasses() {
                  return `el-button--primary ${this.confirmButtonClass}`;
                },
                cancelButtonClasses: function cancelButtonClasses() {
                  return `${this.cancelButtonClass}`;
                },
              },

              methods: {
                getSafeClose: function getSafeClose() {
                  const _this = this;

                  const currentId = this.uid;
                  return function () {
                    _this.$nextTick(() => {
                      if (currentId === _this.uid) _this.doClose();
                    });
                  };
                },
                doClose: function doClose() {
                  const _this2 = this;

                  if (!this.visible) return;
                  this.visible = false;
                  this._closing = true;

                  this.onClose && this.onClose();
                  messageBox.closeDialog(); // 解绑
                  if (this.lockScroll) {
                    setTimeout(this.restoreBodyStyle, 200);
                  }
                  this.opened = false;
                  this.doAfterClose();
                  setTimeout(() => {
                    if (_this2.action) _this2.callback(_this2.action, _this2);
                  });
                },
                handleWrapperClick: function handleWrapperClick() {
                  if (this.closeOnClickModal) {
                    this.handleAction(this.distinguishCancelAndClose ? 'close' : 'cancel');
                  }
                },
                handleInputEnter: function handleInputEnter() {
                  if (this.inputType !== 'textarea') {
                    return this.handleAction('confirm');
                  }
                },
                handleAction: function handleAction(action) {
                  if (this.$type === 'prompt' && action === 'confirm' && !this.validate()) {
                    return;
                  }
                  this.action = action;
                  if (typeof this.beforeClose === 'function') {
                    this.close = this.getSafeClose();
                    this.beforeClose(action, this, this.close);
                  } else {
                    this.doClose();
                  }
                },
                validate: function validate() {
                  if (this.$type === 'prompt') {
                    const { inputPattern } = this;
                    if (inputPattern && !inputPattern.test(this.inputValue || '')) {
                      this.editorErrorMessage = this.inputErrorMessage || Object(lib_locale_.t)('el.messagebox.error');
                      Object(dom_.addClass)(this.getInputElement(), 'invalid');
                      return false;
                    }
                    const { inputValidator } = this;
                    if (typeof inputValidator === 'function') {
                      const validateResult = inputValidator(this.inputValue);
                      if (validateResult === false) {
                        this.editorErrorMessage = this.inputErrorMessage || Object(lib_locale_.t)('el.messagebox.error');
                        Object(dom_.addClass)(this.getInputElement(), 'invalid');
                        return false;
                      }
                      if (typeof validateResult === 'string') {
                        this.editorErrorMessage = validateResult;
                        Object(dom_.addClass)(this.getInputElement(), 'invalid');
                        return false;
                      }
                    }
                  }
                  this.editorErrorMessage = '';
                  Object(dom_.removeClass)(this.getInputElement(), 'invalid');
                  return true;
                },
                getFirstFocus: function getFirstFocus() {
                  const btn = this.$el.querySelector('.el-message-box__btns .el-button');
                  const title = this.$el.querySelector('.el-message-box__btns .el-message-box__title');
                  return btn || title;
                },
                getInputElement: function getInputElement() {
                  const inputRefs = this.$refs.input.$refs;
                  return inputRefs.input || inputRefs.textarea;
                },
                handleClose: function handleClose() {
                  this.handleAction('close');
                },
              },

              watch: {
                inputValue: {
                  immediate: true,
                  handler: function handler(val) {
                    const _this3 = this;

                    this.$nextTick((_) => {
                      if (_this3.$type === 'prompt' && val !== null) {
                        _this3.validate();
                      }
                    });
                  },
                },

                visible: function visible(val) {
                  const _this4 = this;

                  if (val) {
                    this.uid++;
                    if (this.$type === 'alert' || this.$type === 'confirm') {
                      this.$nextTick(() => {
                        _this4.$refs.confirm.$el.focus();
                      });
                    }
                    this.focusAfterClosed = document.activeElement;
                    messageBox = new aria_dialog_default.a(this.$el, this.focusAfterClosed, this.getFirstFocus());
                  }

                  // prompt
                  if (this.$type !== 'prompt') return;
                  if (val) {
                    setTimeout(() => {
                      if (_this4.$refs.input && _this4.$refs.input.$el) {
                        _this4.getInputElement().focus();
                      }
                    }, 500);
                  } else {
                    this.editorErrorMessage = '';
                    Object(dom_.removeClass)(this.getInputElement(), 'invalid');
                  }
                },
              },

              mounted: function mounted() {
                const _this5 = this;

                this.$nextTick(() => {
                  if (_this5.closeOnHashChange) {
                    window.addEventListener('hashchange', _this5.close);
                  }
                });
              },
              beforeDestroy: function beforeDestroy() {
                if (this.closeOnHashChange) {
                  window.removeEventListener('hashchange', this.close);
                }
                setTimeout(() => {
                  messageBox.closeDialog();
                });
              },
              data: function data() {
                return {
                  uid: 1,
                  title: undefined,
                  message: '',
                  type: '',
                  iconClass: '',
                  customClass: '',
                  showInput: false,
                  inputValue: null,
                  inputPlaceholder: '',
                  inputType: 'text',
                  inputPattern: null,
                  inputValidator: null,
                  inputErrorMessage: '',
                  showConfirmButton: true,
                  showCancelButton: false,
                  action: '',
                  confirmButtonText: '',
                  cancelButtonText: '',
                  confirmButtonLoading: false,
                  cancelButtonLoading: false,
                  confirmButtonClass: '',
                  confirmButtonDisabled: false,
                  cancelButtonClass: '',
                  editorErrorMessage: null,
                  callback: null,
                  dangerouslyUseHTMLString: false,
                  focusAfterClosed: null,
                  isOnComposition: false,
                  distinguishCancelAndClose: false,
                };
              },
            });
            // CONCATENATED MODULE: ./packages/message-box/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_message_box_src_mainvue_type_script_lang_js_ = (message_box_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/message-box/src/main.vue

            /* normalize component */

            const src_main_component = normalizeComponent(
              packages_message_box_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_6b29b012_render,
              mainvue_type_template_id_6b29b012_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let src_main_api; }
            src_main_component.options.__file = 'packages/message-box/src/main.vue';
            /* harmony default export */ const message_box_src_main = (src_main_component.exports);
            // EXTERNAL MODULE: external "element-ui/lib/utils/vdom"
            const vdom_ = __webpack_require__(23);

            // CONCATENATED MODULE: ./packages/message-box/src/main.js
            const main_typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

            const main_defaults = {
              title: null,
              message: '',
              type: '',
              iconClass: '',
              showInput: false,
              showClose: true,
              modalFade: true,
              lockScroll: true,
              closeOnClickModal: true,
              closeOnPressEscape: true,
              closeOnHashChange: true,
              inputValue: null,
              inputPlaceholder: '',
              inputType: 'text',
              inputPattern: null,
              inputValidator: null,
              inputErrorMessage: '',
              showConfirmButton: true,
              showCancelButton: false,
              confirmButtonPosition: 'right',
              confirmButtonHighlight: false,
              cancelButtonHighlight: false,
              confirmButtonText: '',
              cancelButtonText: '',
              confirmButtonClass: '',
              cancelButtonClass: '',
              customClass: '',
              beforeClose: null,
              dangerouslyUseHTMLString: false,
              center: false,
              roundButton: false,
              distinguishCancelAndClose: false,
            };

            const MessageBoxConstructor = external_vue_default.a.extend(message_box_src_main);

            let currentMsg = void 0;
            let main_instance = void 0;
            let msgQueue = [];

            const defaultCallback = function defaultCallback(action) {
              if (currentMsg) {
                const { callback } = currentMsg;
                if (typeof callback === 'function') {
                  if (main_instance.showInput) {
                    callback(main_instance.inputValue, action);
                  } else {
                    callback(action);
                  }
                }
                if (currentMsg.resolve) {
                  if (action === 'confirm') {
                    if (main_instance.showInput) {
                      currentMsg.resolve({ value: main_instance.inputValue, action });
                    } else {
                      currentMsg.resolve(action);
                    }
                  } else if (currentMsg.reject && (action === 'cancel' || action === 'close')) {
                    currentMsg.reject(action);
                  }
                }
              }
            };

            const initInstance = function initInstance() {
              main_instance = new MessageBoxConstructor({
                el: document.createElement('div'),
              });

              main_instance.callback = defaultCallback;
            };

            const main_showNextMsg = function showNextMsg() {
              if (!main_instance) {
                initInstance();
              }
              main_instance.action = '';

              if (!main_instance.visible || main_instance.closeTimer) {
                if (msgQueue.length > 0) {
                  currentMsg = msgQueue.shift();

                  const { options } = currentMsg;
                  for (const prop in options) {
                    if (options.hasOwnProperty(prop)) {
                      main_instance[prop] = options[prop];
                    }
                  }
                  if (options.callback === undefined) {
                    main_instance.callback = defaultCallback;
                  }

                  const oldCb = main_instance.callback;
                  main_instance.callback = function (action, instance) {
                    oldCb(action, instance);
                    showNextMsg();
                  };
                  if (Object(vdom_.isVNode)(main_instance.message)) {
                    main_instance.$slots.default = [main_instance.message];
                    main_instance.message = null;
                  } else {
                    delete main_instance.$slots.default;
                  }
                  ['modal', 'showClose', 'closeOnClickModal', 'closeOnPressEscape', 'closeOnHashChange'].forEach((prop) => {
                    if (main_instance[prop] === undefined) {
                      main_instance[prop] = true;
                    }
                  });
                  document.body.appendChild(main_instance.$el);

                  external_vue_default.a.nextTick(() => {
                    main_instance.visible = true;
                  });
                }
              }
            };

            const main_MessageBox = function MessageBox(options, callback) {
              if (external_vue_default.a.prototype.$isServer) return;
              if (typeof options === 'string' || Object(vdom_.isVNode)(options)) {
                options = {
                  message: options,
                };
                if (typeof arguments[1] === 'string') {
                  options.title = arguments[1];
                }
              } else if (options.callback && !callback) {
                callback = options.callback;
              }

              if (typeof Promise !== 'undefined') {
                return new Promise(((resolve, reject) => {
      // eslint-disable-line
                  msgQueue.push({
                    options: merge_default()({}, main_defaults, MessageBox.defaults, options),
                    callback,
                    resolve,
                    reject,
                  });

                  main_showNextMsg();
                }));
              }
              msgQueue.push({
                options: merge_default()({}, main_defaults, MessageBox.defaults, options),
                callback,
              });

              main_showNextMsg();
            };

            main_MessageBox.setDefaults = function (defaults) {
              main_MessageBox.defaults = defaults;
            };

            main_MessageBox.alert = function (message, title, options) {
              if ((typeof title === 'undefined' ? 'undefined' : main_typeof(title)) === 'object') {
                options = title;
                title = '';
              } else if (title === undefined) {
                title = '';
              }
              return main_MessageBox(merge_default()({
                title,
                message,
                $type: 'alert',
                closeOnPressEscape: false,
                closeOnClickModal: false,
              }, options));
            };

            main_MessageBox.confirm = function (message, title, options) {
              if ((typeof title === 'undefined' ? 'undefined' : main_typeof(title)) === 'object') {
                options = title;
                title = '';
              } else if (title === undefined) {
                title = '';
              }
              return main_MessageBox(merge_default()({
                title,
                message,
                $type: 'confirm',
                showCancelButton: true,
              }, options));
            };

            main_MessageBox.prompt = function (message, title, options) {
              if ((typeof title === 'undefined' ? 'undefined' : main_typeof(title)) === 'object') {
                options = title;
                title = '';
              } else if (title === undefined) {
                title = '';
              }
              return main_MessageBox(merge_default()({
                title,
                message,
                showCancelButton: true,
                showInput: true,
                $type: 'prompt',
              }, options));
            };

            main_MessageBox.close = function () {
              main_instance.doClose();
              main_instance.visible = false;
              msgQueue = [];
              currentMsg = null;
            };

            /* harmony default export */ const packages_message_box_src_main = (main_MessageBox);

            // CONCATENATED MODULE: ./packages/message-box/index.js

            /* harmony default export */ const message_box = (packages_message_box_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/breadcrumb/src/breadcrumb.vue?vue&type=template&id=4b464c06&
            const breadcrumbvue_type_template_id_4b464c06_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-breadcrumb',
                  attrs: { 'aria-label': 'Breadcrumb', role: 'navigation' },
                },
                [_vm._t('default')],
                2,
              );
            };
            const breadcrumbvue_type_template_id_4b464c06_staticRenderFns = [];
            breadcrumbvue_type_template_id_4b464c06_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb.vue?vue&type=template&id=4b464c06&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/breadcrumb/src/breadcrumb.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //

            /* harmony default export */ const breadcrumbvue_type_script_lang_js_ = ({
              name: 'ElBreadcrumb',

              props: {
                separator: {
                  type: String,
                  default: '/',
                },
                separatorClass: {
                  type: String,
                  default: '',
                },
              },

              provide: function provide() {
                return {
                  elBreadcrumb: this,
                };
              },
              mounted: function mounted() {
                const items = this.$el.querySelectorAll('.el-breadcrumb__item');
                if (items.length) {
                  items[items.length - 1].setAttribute('aria-current', 'page');
                }
              },
            });
            // CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_breadcrumbvue_type_script_lang_js_ = (breadcrumbvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb.vue

            /* normalize component */

            const breadcrumb_component = normalizeComponent(
              src_breadcrumbvue_type_script_lang_js_,
              breadcrumbvue_type_template_id_4b464c06_render,
              breadcrumbvue_type_template_id_4b464c06_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let breadcrumb_api; }
            breadcrumb_component.options.__file = 'packages/breadcrumb/src/breadcrumb.vue';
            /* harmony default export */ const breadcrumb = (breadcrumb_component.exports);
            // CONCATENATED MODULE: ./packages/breadcrumb/index.js

            /* istanbul ignore next */
            breadcrumb.install = function (Vue) {
              Vue.component(breadcrumb.name, breadcrumb);
            };

            /* harmony default export */ const packages_breadcrumb = (breadcrumb);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/breadcrumb/src/breadcrumb-item.vue?vue&type=template&id=fcf9eaac&
            const breadcrumb_itemvue_type_template_id_fcf9eaac_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('span', { staticClass: 'el-breadcrumb__item' }, [
                _c(
                  'span',
                  {
                    ref: 'link',
                    class: ['el-breadcrumb__inner', _vm.to ? 'is-link' : ''],
                    attrs: { role: 'link' },
                  },
                  [_vm._t('default')],
                  2,
                ),
                _vm.separatorClass
                  ? _c('i', {
                    staticClass: 'el-breadcrumb__separator',
                    class: _vm.separatorClass,
                  })
                  : _c(
                    'span',
                    {
                      staticClass: 'el-breadcrumb__separator',
                      attrs: { role: 'presentation' },
                    },
                    [_vm._v(_vm._s(_vm.separator))],
                  ),
              ]);
            };
            const breadcrumb_itemvue_type_template_id_fcf9eaac_staticRenderFns = [];
            breadcrumb_itemvue_type_template_id_fcf9eaac_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-item.vue?vue&type=template&id=fcf9eaac&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/breadcrumb/src/breadcrumb-item.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const breadcrumb_itemvue_type_script_lang_js_ = ({
              name: 'ElBreadcrumbItem',
              props: {
                to: {},
                replace: Boolean,
              },
              data: function data() {
                return {
                  separator: '',
                  separatorClass: '',
                };
              },

              inject: ['elBreadcrumb'],

              mounted: function mounted() {
                const _this = this;

                this.separator = this.elBreadcrumb.separator;
                this.separatorClass = this.elBreadcrumb.separatorClass;
                const { link } = this.$refs;
                link.setAttribute('role', 'link');
                link.addEventListener('click', (_) => {
                  const { to } = _this;
                  let { $router } = _this;

                  if (!to || !$router) return;
                  _this.replace ? $router.replace(to) : $router.push(to);
                });
              },
            });
            // CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-item.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_breadcrumb_itemvue_type_script_lang_js_ = (breadcrumb_itemvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-item.vue

            /* normalize component */

            const breadcrumb_item_component = normalizeComponent(
              src_breadcrumb_itemvue_type_script_lang_js_,
              breadcrumb_itemvue_type_template_id_fcf9eaac_render,
              breadcrumb_itemvue_type_template_id_fcf9eaac_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let breadcrumb_item_api; }
            breadcrumb_item_component.options.__file = 'packages/breadcrumb/src/breadcrumb-item.vue';
            /* harmony default export */ const breadcrumb_item = (breadcrumb_item_component.exports);
            // CONCATENATED MODULE: ./packages/breadcrumb-item/index.js

            /* istanbul ignore next */
            breadcrumb_item.install = function (Vue) {
              Vue.component(breadcrumb_item.name, breadcrumb_item);
            };

            /* harmony default export */ const packages_breadcrumb_item = (breadcrumb_item);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/form/src/form.vue?vue&type=template&id=a1b5ff34&
            const formvue_type_template_id_a1b5ff34_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'form',
                {
                  staticClass: 'el-form',
                  class: [
                    _vm.labelPosition ? `el-form--label-${_vm.labelPosition}` : '',
                    { 'el-form--inline': _vm.inline },
                  ],
                },
                [_vm._t('default')],
                2,
              );
            };
            const formvue_type_template_id_a1b5ff34_staticRenderFns = [];
            formvue_type_template_id_a1b5ff34_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/form/src/form.vue?vue&type=template&id=a1b5ff34&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/form/src/form.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const formvue_type_script_lang_js_ = ({
              name: 'ElForm',

              componentName: 'ElForm',

              provide: function provide() {
                return {
                  elForm: this,
                };
              },

              props: {
                model: Object,
                rules: Object,
                labelPosition: String,
                labelWidth: String,
                labelSuffix: {
                  type: String,
                  default: '',
                },
                inline: Boolean,
                inlineMessage: Boolean,
                statusIcon: Boolean,
                showMessage: {
                  type: Boolean,
                  default: true,
                },
                size: String,
                disabled: Boolean,
                validateOnRuleChange: {
                  type: Boolean,
                  default: true,
                },
                hideRequiredAsterisk: {
                  type: Boolean,
                  default: false,
                },
              },
              watch: {
                rules: function rules() {
                  // remove then add event listeners on form-item after form rules change
                  this.fields.forEach((field) => {
                    field.removeValidateEvents();
                    field.addValidateEvents();
                  });

                  if (this.validateOnRuleChange) {
                    this.validate(() => {});
                  }
                },
              },
              computed: {
                autoLabelWidth: function autoLabelWidth() {
                  if (!this.potentialLabelWidthArr.length) return 0;
                  const max = Math.max.apply(Math, this.potentialLabelWidthArr);
                  return max ? `${max}px` : '';
                },
              },
              data: function data() {
                return {
                  fields: [],
                  potentialLabelWidthArr: [], // use this array to calculate auto width
                };
              },
              created: function created() {
                const _this = this;

                this.$on('el.form.addField', (field) => {
                  if (field) {
                    _this.fields.push(field);
                  }
                });
                /* istanbul ignore next */
                this.$on('el.form.removeField', (field) => {
                  if (field.prop) {
                    _this.fields.splice(_this.fields.indexOf(field), 1);
                  }
                });
              },

              methods: {
                resetFields: function resetFields() {
                  if (!this.model) {
                    console.warn('[Element Warn][Form]model is required for resetFields to work.');
                    return;
                  }
                  this.fields.forEach((field) => {
                    field.resetField();
                  });
                },
                clearValidate: function clearValidate() {
                  const props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

                  const fields = props.length ? typeof props === 'string' ? this.fields.filter((field) => props === field.prop) : this.fields.filter((field) => props.indexOf(field.prop) > -1) : this.fields;
                  fields.forEach((field) => {
                    field.clearValidate();
                  });
                },
                validate: function validate(callback) {
                  const _this2 = this;

                  if (!this.model) {
                    console.warn('[Element Warn][Form]model is required for validate to work!');
                    return;
                  }

                  let promise = void 0;
                  // if no callback, return promise
                  if (typeof callback !== 'function' && window.Promise) {
                    promise = new window.Promise(((resolve, reject) => {
                      callback = function callback(valid) {
                        valid ? resolve(valid) : reject(valid);
                      };
                    }));
                  }

                  let valid = true;
                  let count = 0;
                  // 如果需要验证的fields为空，调用验证时立刻返回callback
                  if (this.fields.length === 0 && callback) {
                    callback(true);
                  }
                  let invalidFields = {};
                  this.fields.forEach((field) => {
                    field.validate('', (message, field) => {
                      if (message) {
                        valid = false;
                      }
                      invalidFields = merge_default()({}, invalidFields, field);
                      if (typeof callback === 'function' && ++count === _this2.fields.length) {
                        callback(valid, invalidFields);
                      }
                    });
                  });

                  if (promise) {
                    return promise;
                  }
                },
                validateField: function validateField(props, cb) {
                  props = [].concat(props);
                  const fields = this.fields.filter((field) => props.indexOf(field.prop) !== -1);
                  if (!fields.length) {
                    console.warn('[Element Warn]please pass correct props!');
                    return;
                  }

                  fields.forEach((field) => {
                    field.validate('', cb);
                  });
                },
                getLabelWidthIndex: function getLabelWidthIndex(width) {
                  const index = this.potentialLabelWidthArr.indexOf(width);
                  // it's impossible
                  if (index === -1) {
                    throw new Error('[ElementForm]unpected width ', width);
                  }
                  return index;
                },
                registerLabelWidth: function registerLabelWidth(val, oldVal) {
                  if (val && oldVal) {
                    const index = this.getLabelWidthIndex(oldVal);
                    this.potentialLabelWidthArr.splice(index, 1, val);
                  } else if (val) {
                    this.potentialLabelWidthArr.push(val);
                  }
                },
                deregisterLabelWidth: function deregisterLabelWidth(val) {
                  const index = this.getLabelWidthIndex(val);
                  this.potentialLabelWidthArr.splice(index, 1);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/form/src/form.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_formvue_type_script_lang_js_ = (formvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/form/src/form.vue

            /* normalize component */

            const form_component = normalizeComponent(
              src_formvue_type_script_lang_js_,
              formvue_type_template_id_a1b5ff34_render,
              formvue_type_template_id_a1b5ff34_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let form_api; }
            form_component.options.__file = 'packages/form/src/form.vue';
            /* harmony default export */ const src_form = (form_component.exports);
            // CONCATENATED MODULE: ./packages/form/index.js

            /* istanbul ignore next */
            src_form.install = function (Vue) {
              Vue.component(src_form.name, src_form);
            };

            /* harmony default export */ const packages_form = (src_form);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/form/src/form-item.vue?vue&type=template&id=b6f3db6c&
            const form_itemvue_type_template_id_b6f3db6c_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-form-item',
                  class: [
                    {
                      'el-form-item--feedback': _vm.elForm && _vm.elForm.statusIcon,
                      'is-error': _vm.validateState === 'error',
                      'is-validating': _vm.validateState === 'validating',
                      'is-success': _vm.validateState === 'success',
                      'is-required': _vm.isRequired || _vm.required,
                      'is-no-asterisk': _vm.elForm && _vm.elForm.hideRequiredAsterisk,
                    },
                    _vm.sizeClass ? `el-form-item--${_vm.sizeClass}` : '',
                  ],
                },
                [
                  _c(
                    'label-wrap',
                    {
                      attrs: {
                        'is-auto-width': _vm.labelStyle && _vm.labelStyle.width === 'auto',
                        'update-all': _vm.form.labelWidth === 'auto',
                      },
                    },
                    [
                      _vm.label || _vm.$slots.label
                        ? _c(
                          'label',
                          {
                            staticClass: 'el-form-item__label',
                            style: _vm.labelStyle,
                            attrs: { for: _vm.labelFor },
                          },
                          [
                            _vm._t('label', [
                              _vm._v(_vm._s(_vm.label + _vm.form.labelSuffix)),
                            ]),
                          ],
                          2,
                        )
                        : _vm._e(),
                    ],
                  ),
                  _c(
                    'div',
                    { staticClass: 'el-form-item__content', style: _vm.contentStyle },
                    [
                      _vm._t('default'),
                      _c(
                        'transition',
                        { attrs: { name: 'el-zoom-in-top' } },
                        [
                          _vm.validateState === 'error'
              && _vm.showMessage
              && _vm.form.showMessage
                            ? _vm._t(
                              'error',
                              [
                                _c(
                                  'div',
                                  {
                                    staticClass: 'el-form-item__error',
                                    class: {
                                      'el-form-item__error--inline':
                              typeof _vm.inlineMessage === 'boolean'
                                ? _vm.inlineMessage
                                : (_vm.elForm && _vm.elForm.inlineMessage)
                                  || false,
                                    },
                                  },
                                  [
                                    _vm._v(
                                      `\n          ${
                                        _vm._s(_vm.validateMessage)
                                      }\n        `,
                                    ),
                                  ],
                                ),
                              ],
                              { error: _vm.validateMessage },
                            )
                            : _vm._e(),
                        ],
                        2,
                      ),
                    ],
                    2,
                  ),
                ],
                1,
              );
            };
            const form_itemvue_type_template_id_b6f3db6c_staticRenderFns = [];
            form_itemvue_type_template_id_b6f3db6c_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/form/src/form-item.vue?vue&type=template&id=b6f3db6c&

            // EXTERNAL MODULE: external "async-validator"
            const external_async_validator_ = __webpack_require__(40);
            const external_async_validator_default = /* #__PURE__ */__webpack_require__.n(external_async_validator_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/form/src/label-wrap.vue?vue&type=script&lang=js&

            /* harmony default export */ const label_wrapvue_type_script_lang_js_ = ({
              props: {
                isAutoWidth: Boolean,
                updateAll: Boolean,
              },

              inject: ['elForm', 'elFormItem'],

              render: function render() {
                const h = arguments[0];

                const slots = this.$slots.default;
                if (!slots) return null;
                if (this.isAutoWidth) {
                  const { autoLabelWidth } = this.elForm;
                  const style = {};
                  if (autoLabelWidth && autoLabelWidth !== 'auto') {
                    const marginLeft = parseInt(autoLabelWidth, 10) - this.computedWidth;
                    if (marginLeft) {
                      style.marginLeft = `${marginLeft}px`;
                    }
                  }
                  return h(
                    'div',
                    { class: 'el-form-item__label-wrap', style },
                    [slots],
                  );
                }
                return slots[0];
              },

              methods: {
                getLabelWidth: function getLabelWidth() {
                  if (this.$el && this.$el.firstElementChild) {
                    const computedWidth = window.getComputedStyle(this.$el.firstElementChild).width;
                    return Math.ceil(parseFloat(computedWidth));
                  }
                  return 0;
                },
                updateLabelWidth: function updateLabelWidth() {
                  const action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'update';

                  if (this.$slots.default && this.isAutoWidth && this.$el.firstElementChild) {
                    if (action === 'update') {
                      this.computedWidth = this.getLabelWidth();
                    } else if (action === 'remove') {
                      this.elForm.deregisterLabelWidth(this.computedWidth);
                    }
                  }
                },
              },

              watch: {
                computedWidth: function computedWidth(val, oldVal) {
                  if (this.updateAll) {
                    this.elForm.registerLabelWidth(val, oldVal);
                    this.elFormItem.updateComputedLabelWidth(val);
                  }
                },
              },

              data: function data() {
                return {
                  computedWidth: 0,
                };
              },
              mounted: function mounted() {
                this.updateLabelWidth('update');
              },
              updated: function updated() {
                this.updateLabelWidth('update');
              },
              beforeDestroy: function beforeDestroy() {
                this.updateLabelWidth('remove');
              },
            });
            // CONCATENATED MODULE: ./packages/form/src/label-wrap.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_label_wrapvue_type_script_lang_js_ = (label_wrapvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/form/src/label-wrap.vue
            let label_wrap_render; let
              label_wrap_staticRenderFns;

            /* normalize component */

            const label_wrap_component = normalizeComponent(
              src_label_wrapvue_type_script_lang_js_,
              label_wrap_render,
              label_wrap_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let label_wrap_api; }
            label_wrap_component.options.__file = 'packages/form/src/label-wrap.vue';
            /* harmony default export */ const label_wrap = (label_wrap_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/form/src/form-item.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const form_itemvue_type_script_lang_js_ = ({
              name: 'ElFormItem',

              componentName: 'ElFormItem',

              mixins: [emitter_default.a],

              provide: function provide() {
                return {
                  elFormItem: this,
                };
              },

              inject: ['elForm'],

              props: {
                label: String,
                labelWidth: String,
                prop: String,
                required: {
                  type: Boolean,
                  default: undefined,
                },
                rules: [Object, Array],
                error: String,
                validateStatus: String,
                for: String,
                inlineMessage: {
                  type: [String, Boolean],
                  default: '',
                },
                showMessage: {
                  type: Boolean,
                  default: true,
                },
                size: String,
              },
              components: {
                // use this component to calculate auto width
                LabelWrap: label_wrap,
              },
              watch: {
                error: {
                  immediate: true,
                  handler: function handler(value) {
                    this.validateMessage = value;
                    this.validateState = value ? 'error' : '';
                  },
                },
                validateStatus: function validateStatus(value) {
                  this.validateState = value;
                },
              },
              computed: {
                labelFor: function labelFor() {
                  return this.for || this.prop;
                },
                labelStyle: function labelStyle() {
                  const ret = {};
                  if (this.form.labelPosition === 'top') return ret;
                  const labelWidth = this.labelWidth || this.form.labelWidth;
                  if (labelWidth) {
                    ret.width = labelWidth;
                  }
                  return ret;
                },
                contentStyle: function contentStyle() {
                  const ret = {};
                  const { label } = this;
                  if (this.form.labelPosition === 'top' || this.form.inline) return ret;
                  if (!label && !this.labelWidth && this.isNested) return ret;
                  const labelWidth = this.labelWidth || this.form.labelWidth;
                  if (labelWidth === 'auto') {
                    if (this.labelWidth === 'auto') {
                      ret.marginLeft = this.computedLabelWidth;
                    } else if (this.form.labelWidth === 'auto') {
                      ret.marginLeft = this.elForm.autoLabelWidth;
                    }
                  } else {
                    ret.marginLeft = labelWidth;
                  }
                  return ret;
                },
                form: function form() {
                  let parent = this.$parent;
                  let parentName = parent.$options.componentName;
                  while (parentName !== 'ElForm') {
                    if (parentName === 'ElFormItem') {
                      this.isNested = true;
                    }
                    parent = parent.$parent;
                    parentName = parent.$options.componentName;
                  }
                  return parent;
                },
                fieldValue: function fieldValue() {
                  const { model } = this.form;
                  if (!model || !this.prop) {
                    return;
                  }

                  let path = this.prop;
                  if (path.indexOf(':') !== -1) {
                    path = path.replace(/:/, '.');
                  }

                  return Object(util_.getPropByPath)(model, path, true).v;
                },
                isRequired: function isRequired() {
                  const rules = this.getRules();
                  let isRequired = false;

                  if (rules && rules.length) {
                    rules.every((rule) => {
                      if (rule.required) {
                        isRequired = true;
                        return false;
                      }
                      return true;
                    });
                  }
                  return isRequired;
                },
                _formSize: function _formSize() {
                  return this.elForm.size;
                },
                elFormItemSize: function elFormItemSize() {
                  return this.size || this._formSize;
                },
                sizeClass: function sizeClass() {
                  return this.elFormItemSize || (this.$ELEMENT || {}).size;
                },
              },
              data: function data() {
                return {
                  validateState: '',
                  validateMessage: '',
                  validateDisabled: false,
                  validator: {},
                  isNested: false,
                  computedLabelWidth: '',
                };
              },

              methods: {
                validate: function validate(trigger) {
                  const _this = this;

                  const callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : util_.noop;

                  this.validateDisabled = false;
                  const rules = this.getFilteredRule(trigger);
                  if ((!rules || rules.length === 0) && this.required === undefined) {
                    callback();
                    return true;
                  }

                  this.validateState = 'validating';

                  const descriptor = {};
                  if (rules && rules.length > 0) {
                    rules.forEach((rule) => {
                      delete rule.trigger;
                    });
                  }
                  descriptor[this.prop] = rules;

                  const validator = new external_async_validator_default.a(descriptor);
                  const model = {};

                  model[this.prop] = this.fieldValue;

                  validator.validate(model, { firstFields: true }, (errors, invalidFields) => {
                    _this.validateState = !errors ? 'success' : 'error';
                    _this.validateMessage = errors ? errors[0].message : '';

                    callback(_this.validateMessage, invalidFields);
                    _this.elForm && _this.elForm.$emit('validate', _this.prop, !errors, _this.validateMessage || null);
                  });
                },
                clearValidate: function clearValidate() {
                  this.validateState = '';
                  this.validateMessage = '';
                  this.validateDisabled = false;
                },
                resetField: function resetField() {
                  const _this2 = this;

                  this.validateState = '';
                  this.validateMessage = '';

                  const { model } = this.form;
                  const value = this.fieldValue;
                  let path = this.prop;
                  if (path.indexOf(':') !== -1) {
                    path = path.replace(/:/, '.');
                  }

                  const prop = Object(util_.getPropByPath)(model, path, true);

                  this.validateDisabled = true;
                  if (Array.isArray(value)) {
                    prop.o[prop.k] = [].concat(this.initialValue);
                  } else {
                    prop.o[prop.k] = this.initialValue;
                  }

                  // reset validateDisabled after onFieldChange triggered
                  this.$nextTick(() => {
                    _this2.validateDisabled = false;
                  });

                  this.broadcast('ElTimeSelect', 'fieldReset', this.initialValue);
                },
                getRules: function getRules() {
                  let formRules = this.form.rules;
                  const selfRules = this.rules;
                  const requiredRule = this.required !== undefined ? { required: !!this.required } : [];

                  const prop = Object(util_.getPropByPath)(formRules, this.prop || '');
                  formRules = formRules ? prop.o[this.prop || ''] || prop.v : [];

                  return [].concat(selfRules || formRules || []).concat(requiredRule);
                },
                getFilteredRule: function getFilteredRule(trigger) {
                  const rules = this.getRules();

                  return rules.filter((rule) => {
                    if (!rule.trigger || trigger === '') return true;
                    if (Array.isArray(rule.trigger)) {
                      return rule.trigger.indexOf(trigger) > -1;
                    }
                    return rule.trigger === trigger;
                  }).map((rule) => merge_default()({}, rule));
                },
                onFieldBlur: function onFieldBlur() {
                  this.validate('blur');
                },
                onFieldChange: function onFieldChange() {
                  if (this.validateDisabled) {
                    this.validateDisabled = false;
                    return;
                  }

                  this.validate('change');
                },
                updateComputedLabelWidth: function updateComputedLabelWidth(width) {
                  this.computedLabelWidth = width ? `${width}px` : '';
                },
                addValidateEvents: function addValidateEvents() {
                  const rules = this.getRules();

                  if (rules.length || this.required !== undefined) {
                    this.$on('el.form.blur', this.onFieldBlur);
                    this.$on('el.form.change', this.onFieldChange);
                  }
                },
                removeValidateEvents: function removeValidateEvents() {
                  this.$off();
                },
              },
              mounted: function mounted() {
                if (this.prop) {
                  this.dispatch('ElForm', 'el.form.addField', [this]);

                  let initialValue = this.fieldValue;
                  if (Array.isArray(initialValue)) {
                    initialValue = [].concat(initialValue);
                  }
                  Object.defineProperty(this, 'initialValue', {
                    value: initialValue,
                  });

                  this.addValidateEvents();
                }
              },
              beforeDestroy: function beforeDestroy() {
                this.dispatch('ElForm', 'el.form.removeField', [this]);
              },
            });
            // CONCATENATED MODULE: ./packages/form/src/form-item.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_form_itemvue_type_script_lang_js_ = (form_itemvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/form/src/form-item.vue

            /* normalize component */

            const form_item_component = normalizeComponent(
              src_form_itemvue_type_script_lang_js_,
              form_itemvue_type_template_id_b6f3db6c_render,
              form_itemvue_type_template_id_b6f3db6c_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let form_item_api; }
            form_item_component.options.__file = 'packages/form/src/form-item.vue';
            /* harmony default export */ const form_item = (form_item_component.exports);
            // CONCATENATED MODULE: ./packages/form-item/index.js

            /* istanbul ignore next */
            form_item.install = function (Vue) {
              Vue.component(form_item.name, form_item);
            };

            /* harmony default export */ const packages_form_item = (form_item);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-bar.vue?vue&type=template&id=2031f33a&
            const tab_barvue_type_template_id_2031f33a_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('div', {
                staticClass: 'el-tabs__active-bar',
                class: `is-${_vm.rootTabs.tabPosition}`,
                style: _vm.barStyle,
              });
            };
            const tab_barvue_type_template_id_2031f33a_staticRenderFns = [];
            tab_barvue_type_template_id_2031f33a_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/tabs/src/tab-bar.vue?vue&type=template&id=2031f33a&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-bar.vue?vue&type=script&lang=js&
            //
            //
            //

            /* harmony default export */ const tab_barvue_type_script_lang_js_ = ({
              name: 'TabBar',

              props: {
                tabs: Array,
              },

              inject: ['rootTabs'],

              computed: {
                barStyle: {
                  get: function get() {
                    const _this = this;

                    const style = {};
                    let offset = 0;
                    let tabSize = 0;
                    const sizeName = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'width' : 'height';
                    const sizeDir = sizeName === 'width' ? 'x' : 'y';
                    const firstUpperCase = function firstUpperCase(str) {
                      return str.toLowerCase().replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
                    };
                    this.tabs.every((tab, index) => {
                      const $el = Object(util_.arrayFind)(_this.$parent.$refs.tabs || [], (t) => t.id.replace('tab-', '') === tab.paneName);
                      if (!$el) {
                        return false;
                      }

                      if (!tab.active) {
                        offset += $el[`client${firstUpperCase(sizeName)}`];
                        return true;
                      }
                      tabSize = $el[`client${firstUpperCase(sizeName)}`];
                      const tabStyles = window.getComputedStyle($el);
                      if (sizeName === 'width' && _this.tabs.length > 1) {
                        tabSize -= parseFloat(tabStyles.paddingLeft) + parseFloat(tabStyles.paddingRight);
                      }
                      if (sizeName === 'width') {
                        offset += parseFloat(tabStyles.paddingLeft);
                      }
                      return false;
                    });

                    const transform = `translate${firstUpperCase(sizeDir)}(${offset}px)`;
                    style[sizeName] = `${tabSize}px`;
                    style.transform = transform;
                    style.msTransform = transform;
                    style.webkitTransform = transform;

                    return style;
                  },
                },
              },
            });
            // CONCATENATED MODULE: ./packages/tabs/src/tab-bar.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_tab_barvue_type_script_lang_js_ = (tab_barvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/tabs/src/tab-bar.vue

            /* normalize component */

            const tab_bar_component = normalizeComponent(
              src_tab_barvue_type_script_lang_js_,
              tab_barvue_type_template_id_2031f33a_render,
              tab_barvue_type_template_id_2031f33a_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let tab_bar_api; }
            tab_bar_component.options.__file = 'packages/tabs/src/tab-bar.vue';
            /* harmony default export */ const tab_bar = (tab_bar_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-nav.vue?vue&type=script&lang=js&

            function noop() {}
            const tab_navvue_type_script_lang_js_firstUpperCase = function firstUpperCase(str) {
              return str.toLowerCase().replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
            };

            /* harmony default export */ const tab_navvue_type_script_lang_js_ = ({
              name: 'TabNav',

              components: {
                TabBar: tab_bar,
              },

              inject: ['rootTabs'],

              props: {
                panes: Array,
                currentName: String,
                editable: Boolean,
                onTabClick: {
                  type: Function,
                  default: noop,
                },
                onTabRemove: {
                  type: Function,
                  default: noop,
                },
                type: String,
                stretch: Boolean,
              },

              data: function data() {
                return {
                  scrollable: false,
                  navOffset: 0,
                  isFocus: false,
                  focusable: true,
                };
              },

              computed: {
                navStyle: function navStyle() {
                  const dir = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'X' : 'Y';
                  return {
                    transform: `translate${dir}(-${this.navOffset}px)`,
                  };
                },
                sizeName: function sizeName() {
                  return ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'width' : 'height';
                },
              },

              methods: {
                scrollPrev: function scrollPrev() {
                  const containerSize = this.$refs.navScroll[`offset${tab_navvue_type_script_lang_js_firstUpperCase(this.sizeName)}`];
                  const currentOffset = this.navOffset;

                  if (!currentOffset) return;

                  const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;

                  this.navOffset = newOffset;
                },
                scrollNext: function scrollNext() {
                  const navSize = this.$refs.nav[`offset${tab_navvue_type_script_lang_js_firstUpperCase(this.sizeName)}`];
                  const containerSize = this.$refs.navScroll[`offset${tab_navvue_type_script_lang_js_firstUpperCase(this.sizeName)}`];
                  const currentOffset = this.navOffset;

                  if (navSize - currentOffset <= containerSize) return;

                  const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;

                  this.navOffset = newOffset;
                },
                scrollToActiveTab: function scrollToActiveTab() {
                  if (!this.scrollable) return;
                  const { nav } = this.$refs;
                  const activeTab = this.$el.querySelector('.is-active');
                  if (!activeTab) return;
                  const { navScroll } = this.$refs;
                  const isHorizontal = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1;
                  const activeTabBounding = activeTab.getBoundingClientRect();
                  const navScrollBounding = navScroll.getBoundingClientRect();
                  const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
                  const currentOffset = this.navOffset;
                  let newOffset = currentOffset;

                  if (isHorizontal) {
                    if (activeTabBounding.left < navScrollBounding.left) {
                      newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
                    }
                    if (activeTabBounding.right > navScrollBounding.right) {
                      newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
                    }
                  } else {
                    if (activeTabBounding.top < navScrollBounding.top) {
                      newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
                    }
                    if (activeTabBounding.bottom > navScrollBounding.bottom) {
                      newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
                    }
                  }
                  newOffset = Math.max(newOffset, 0);
                  this.navOffset = Math.min(newOffset, maxOffset);
                },
                update: function update() {
                  if (!this.$refs.nav) return;
                  const { sizeName } = this;
                  const navSize = this.$refs.nav[`offset${tab_navvue_type_script_lang_js_firstUpperCase(sizeName)}`];
                  const containerSize = this.$refs.navScroll[`offset${tab_navvue_type_script_lang_js_firstUpperCase(sizeName)}`];
                  const currentOffset = this.navOffset;

                  if (containerSize < navSize) {
                    const _currentOffset = this.navOffset;
                    this.scrollable = this.scrollable || {};
                    this.scrollable.prev = _currentOffset;
                    this.scrollable.next = _currentOffset + containerSize < navSize;
                    if (navSize - _currentOffset < containerSize) {
                      this.navOffset = navSize - containerSize;
                    }
                  } else {
                    this.scrollable = false;
                    if (currentOffset > 0) {
                      this.navOffset = 0;
                    }
                  }
                },
                changeTab: function changeTab(e) {
                  const { keyCode } = e;
                  let nextIndex = void 0;
                  let currentIndex = void 0;
                  let tabList = void 0;
                  if ([37, 38, 39, 40].indexOf(keyCode) !== -1) {
                    // 左右上下键更换tab
                    tabList = e.currentTarget.querySelectorAll('[role=tab]');
                    currentIndex = Array.prototype.indexOf.call(tabList, e.target);
                  } else {
                    return;
                  }
                  if (keyCode === 37 || keyCode === 38) {
                    // left
                    if (currentIndex === 0) {
                      // first
                      nextIndex = tabList.length - 1;
                    } else {
                      nextIndex = currentIndex - 1;
                    }
                  } else {
                    // right
                    if (currentIndex < tabList.length - 1) {
                      // not last
                      nextIndex = currentIndex + 1;
                    } else {
                      nextIndex = 0;
                    }
                  }
                  tabList[nextIndex].focus(); // 改变焦点元素
                  tabList[nextIndex].click(); // 选中下一个tab
                  this.setFocus();
                },
                setFocus: function setFocus() {
                  if (this.focusable) {
                    this.isFocus = true;
                  }
                },
                removeFocus: function removeFocus() {
                  this.isFocus = false;
                },
                visibilityChangeHandler: function visibilityChangeHandler() {
                  const _this = this;

                  const visibility = document.visibilityState;
                  if (visibility === 'hidden') {
                    this.focusable = false;
                  } else if (visibility === 'visible') {
                    setTimeout(() => {
                      _this.focusable = true;
                    }, 50);
                  }
                },
                windowBlurHandler: function windowBlurHandler() {
                  this.focusable = false;
                },
                windowFocusHandler: function windowFocusHandler() {
                  const _this2 = this;

                  setTimeout(() => {
                    _this2.focusable = true;
                  }, 50);
                },
              },

              updated: function updated() {
                this.update();
              },
              render: function render(h) {
                const _this3 = this;

                const { type } = this;
                const { panes } = this;
                const { editable } = this;
                const { stretch } = this;
                const { onTabClick } = this;
                const { onTabRemove } = this;
                const { navStyle } = this;
                const { scrollable } = this;
                const { scrollNext } = this;
                const { scrollPrev } = this;
                const { changeTab } = this;
                const { setFocus } = this;
                const { removeFocus } = this;

                const scrollBtn = scrollable ? [h(
                  'span',
                  {
                    class: ['el-tabs__nav-prev', scrollable.prev ? '' : 'is-disabled'],
                    on: {
                      click: scrollPrev,
                    },
                  },
                  [h('i', { class: 'el-icon-arrow-left' })],
                ), h(
                  'span',
                  {
                    class: ['el-tabs__nav-next', scrollable.next ? '' : 'is-disabled'],
                    on: {
                      click: scrollNext,
                    },
                  },
                  [h('i', { class: 'el-icon-arrow-right' })],
                )] : null;

                const tabs = this._l(panes, (pane, index) => {
                  let _ref;

                  const tabName = pane.name || pane.index || index;
                  const closable = pane.isClosable || editable;

                  pane.index = `${index}`;

                  const btnClose = closable ? h('span', {
                    class: 'el-icon-close',
                    on: {
                      click: function click(ev) {
                        onTabRemove(pane, ev);
                      },
                    },
                  }) : null;

                  const tabLabelContent = pane.$slots.label || pane.label;
                  const tabindex = pane.active ? 0 : -1;
                  return h(
                    'div',
                    {
                      class: (_ref = {
                        'el-tabs__item': true,
                      }, _ref[`is-${_this3.rootTabs.tabPosition}`] = true, _ref['is-active'] = pane.active, _ref['is-disabled'] = pane.disabled, _ref['is-closable'] = closable, _ref['is-focus'] = _this3.isFocus, _ref),
                      attrs: {
                        id: `tab-${tabName}`,

                        'aria-controls': `pane-${tabName}`,
                        role: 'tab',
                        'aria-selected': pane.active,

                        tabindex,
                      },
                      key: `tab-${tabName}`,
                      ref: 'tabs',
                      refInFor: true,
                      on: {
                        focus: function focus() {
                          setFocus();
                        },
                        blur: function blur() {
                          removeFocus();
                        },
                        click: function click(ev) {
                          removeFocus(); onTabClick(pane, tabName, ev);
                        },
                        keydown: function keydown(ev) {
                          if (closable && (ev.keyCode === 46 || ev.keyCode === 8)) {
                            onTabRemove(pane, ev);
                          }
                        },
                      },
                    },
                    [tabLabelContent, btnClose],
                  );
                });
                return h(
                  'div',
                  { class: ['el-tabs__nav-wrap', scrollable ? 'is-scrollable' : '', `is-${this.rootTabs.tabPosition}`] },
                  [scrollBtn, h(
                    'div',
                    { class: ['el-tabs__nav-scroll'], ref: 'navScroll' },
                    [h(
                      'div',
                      {
                        class: ['el-tabs__nav', `is-${this.rootTabs.tabPosition}`, stretch && ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'is-stretch' : ''],
                        ref: 'nav',
                        style: navStyle,
                        attrs: { role: 'tablist' },
                        on: {
                          keydown: changeTab,
                        },
                      },
                      [!type ? h('tab-bar', {
                        attrs: { tabs: panes },
                      }) : null, tabs],
                    )],
                  )],
                );
              },
              mounted: function mounted() {
                const _this4 = this;

                Object(resize_event_.addResizeListener)(this.$el, this.update);
                document.addEventListener('visibilitychange', this.visibilityChangeHandler);
                window.addEventListener('blur', this.windowBlurHandler);
                window.addEventListener('focus', this.windowFocusHandler);
                setTimeout(() => {
                  _this4.scrollToActiveTab();
                }, 0);
              },
              beforeDestroy: function beforeDestroy() {
                if (this.$el && this.update) Object(resize_event_.removeResizeListener)(this.$el, this.update);
                document.removeEventListener('visibilitychange', this.visibilityChangeHandler);
                window.removeEventListener('blur', this.windowBlurHandler);
                window.removeEventListener('focus', this.windowFocusHandler);
              },
            });
            // CONCATENATED MODULE: ./packages/tabs/src/tab-nav.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_tab_navvue_type_script_lang_js_ = (tab_navvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/tabs/src/tab-nav.vue
            let tab_nav_render; let
              tab_nav_staticRenderFns;

            /* normalize component */

            const tab_nav_component = normalizeComponent(
              src_tab_navvue_type_script_lang_js_,
              tab_nav_render,
              tab_nav_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let tab_nav_api; }
            tab_nav_component.options.__file = 'packages/tabs/src/tab-nav.vue';
            /* harmony default export */ const tab_nav = (tab_nav_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tabs.vue?vue&type=script&lang=js&

            /* harmony default export */ const tabsvue_type_script_lang_js_ = ({
              name: 'ElTabs',

              components: {
                TabNav: tab_nav,
              },

              props: {
                type: String,
                activeName: String,
                closable: Boolean,
                addable: Boolean,
                value: {},
                editable: Boolean,
                tabPosition: {
                  type: String,
                  default: 'top',
                },
                beforeLeave: Function,
                stretch: Boolean,
              },

              provide: function provide() {
                return {
                  rootTabs: this,
                };
              },
              data: function data() {
                return {
                  currentName: this.value || this.activeName,
                  panes: [],
                };
              },

              watch: {
                activeName: function activeName(value) {
                  this.setCurrentName(value);
                },
                value: function value(_value) {
                  this.setCurrentName(_value);
                },
                currentName: function currentName(value) {
                  const _this = this;

                  if (this.$refs.nav) {
                    this.$nextTick(() => {
                      _this.$refs.nav.$nextTick((_) => {
                        _this.$refs.nav.scrollToActiveTab();
                      });
                    });
                  }
                },
              },

              methods: {
                calcPaneInstances: function calcPaneInstances() {
                  const _this2 = this;

                  const isForceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                  if (this.$slots.default) {
                    const paneSlots = this.$slots.default.filter((vnode) => vnode.tag && vnode.componentOptions && vnode.componentOptions.Ctor.options.name === 'ElTabPane');
                    // update indeed
                    const panes = paneSlots.map((_ref) => {
                      const { componentInstance } = _ref;
                      return componentInstance;
                    });
                    const panesChanged = !(panes.length === this.panes.length && panes.every((pane, index) => pane === _this2.panes[index]));
                    if (isForceUpdate || panesChanged) {
                      this.panes = panes;
                    }
                  } else if (this.panes.length !== 0) {
                    this.panes = [];
                  }
                },
                handleTabClick: function handleTabClick(tab, tabName, event) {
                  if (tab.disabled) return;
                  this.setCurrentName(tabName);
                  this.$emit('tab-click', tab, event);
                },
                handleTabRemove: function handleTabRemove(pane, ev) {
                  if (pane.disabled) return;
                  ev.stopPropagation();
                  this.$emit('edit', pane.name, 'remove');
                  this.$emit('tab-remove', pane.name);
                },
                handleTabAdd: function handleTabAdd() {
                  this.$emit('edit', null, 'add');
                  this.$emit('tab-add');
                },
                setCurrentName: function setCurrentName(value) {
                  const _this3 = this;

                  const changeCurrentName = function changeCurrentName() {
                    _this3.currentName = value;
                    _this3.$emit('input', value);
                  };
                  if (this.currentName !== value && this.beforeLeave) {
                    const before = this.beforeLeave(value, this.currentName);
                    if (before && before.then) {
                      before.then(() => {
                        changeCurrentName();
                        _this3.$refs.nav && _this3.$refs.nav.removeFocus();
                      }, () => {
                        // https://github.com/ElemeFE/element/pull/14816
                        // ignore promise rejection in `before-leave` hook
                      });
                    } else if (before !== false) {
                      changeCurrentName();
                    }
                  } else {
                    changeCurrentName();
                  }
                },
              },

              render: function render(h) {
                let _ref2;

                const { type } = this;
                const { handleTabClick } = this;
                const { handleTabRemove } = this;
                const { handleTabAdd } = this;
                const { currentName } = this;
                const { panes } = this;
                const { editable } = this;
                const { addable } = this;
                const { tabPosition } = this;
                const { stretch } = this;

                const newButton = editable || addable ? h(
                  'span',
                  {
                    class: 'el-tabs__new-tab',
                    on: {
                      click: handleTabAdd,
                      keydown: function keydown(ev) {
                        if (ev.keyCode === 13) {
                          handleTabAdd();
                        }
                      },
                    },
                    attrs: {
                      tabindex: '0',
                    },
                  },
                  [h('i', { class: 'el-icon-plus' })],
                ) : null;

                const navData = {
                  props: {
                    currentName,
                    onTabClick: handleTabClick,
                    onTabRemove: handleTabRemove,
                    editable,
                    type,
                    panes,
                    stretch,
                  },
                  ref: 'nav',
                };
                const header = h(
                  'div',
                  { class: ['el-tabs__header', `is-${tabPosition}`] },
                  [newButton, h('tab-nav', navData)],
                );
                const panels = h(
                  'div',
                  { class: 'el-tabs__content' },
                  [this.$slots.default],
                );

                return h(
                  'div',
                  {
                    class: (_ref2 = {
                      'el-tabs': true,
                      'el-tabs--card': type === 'card',
                    }, _ref2[`el-tabs--${tabPosition}`] = true, _ref2['el-tabs--border-card'] = type === 'border-card', _ref2),
                  },
                  [tabPosition !== 'bottom' ? [header, panels] : [panels, header]],
                );
              },
              created: function created() {
                if (!this.currentName) {
                  this.setCurrentName('0');
                }

                this.$on('tab-nav-update', this.calcPaneInstances.bind(null, true));
              },
              mounted: function mounted() {
                this.calcPaneInstances();
              },
              updated: function updated() {
                this.calcPaneInstances();
              },
            });
            // CONCATENATED MODULE: ./packages/tabs/src/tabs.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_tabsvue_type_script_lang_js_ = (tabsvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/tabs/src/tabs.vue
            let tabs_render; let
              tabs_staticRenderFns;

            /* normalize component */

            const tabs_component = normalizeComponent(
              src_tabsvue_type_script_lang_js_,
              tabs_render,
              tabs_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let tabs_api; }
            tabs_component.options.__file = 'packages/tabs/src/tabs.vue';
            /* harmony default export */ const tabs = (tabs_component.exports);
            // CONCATENATED MODULE: ./packages/tabs/index.js

            /* istanbul ignore next */
            tabs.install = function (Vue) {
              Vue.component(tabs.name, tabs);
            };

            /* harmony default export */ const packages_tabs = (tabs);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-pane.vue?vue&type=template&id=9145a070&
            const tab_panevue_type_template_id_9145a070_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return !_vm.lazy || _vm.loaded || _vm.active
                ? _c(
                  'div',
                  {
                    directives: [
                      {
                        name: 'show',
                        rawName: 'v-show',
                        value: _vm.active,
                        expression: 'active',
                      },
                    ],
                    staticClass: 'el-tab-pane',
                    attrs: {
                      role: 'tabpanel',
                      'aria-hidden': !_vm.active,
                      id: `pane-${_vm.paneName}`,
                      'aria-labelledby': `tab-${_vm.paneName}`,
                    },
                  },
                  [_vm._t('default')],
                  2,
                )
                : _vm._e();
            };
            const tab_panevue_type_template_id_9145a070_staticRenderFns = [];
            tab_panevue_type_template_id_9145a070_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/tabs/src/tab-pane.vue?vue&type=template&id=9145a070&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-pane.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const tab_panevue_type_script_lang_js_ = ({
              name: 'ElTabPane',

              componentName: 'ElTabPane',

              props: {
                label: String,
                labelContent: Function,
                name: String,
                closable: Boolean,
                disabled: Boolean,
                lazy: Boolean,
              },

              data: function data() {
                return {
                  index: null,
                  loaded: false,
                };
              },

              computed: {
                isClosable: function isClosable() {
                  return this.closable || this.$parent.closable;
                },
                active: function active() {
                  const active = this.$parent.currentName === (this.name || this.index);
                  if (active) {
                    this.loaded = true;
                  }
                  return active;
                },
                paneName: function paneName() {
                  return this.name || this.index;
                },
              },

              updated: function updated() {
                this.$parent.$emit('tab-nav-update');
              },
            });
            // CONCATENATED MODULE: ./packages/tabs/src/tab-pane.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_tab_panevue_type_script_lang_js_ = (tab_panevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/tabs/src/tab-pane.vue

            /* normalize component */

            const tab_pane_component = normalizeComponent(
              src_tab_panevue_type_script_lang_js_,
              tab_panevue_type_template_id_9145a070_render,
              tab_panevue_type_template_id_9145a070_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let tab_pane_api; }
            tab_pane_component.options.__file = 'packages/tabs/src/tab-pane.vue';
            /* harmony default export */ const tab_pane = (tab_pane_component.exports);
            // CONCATENATED MODULE: ./packages/tab-pane/index.js

            /* istanbul ignore next */
            tab_pane.install = function (Vue) {
              Vue.component(tab_pane.name, tab_pane);
            };

            /* harmony default export */ const packages_tab_pane = (tab_pane);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tag/src/tag.vue?vue&type=script&lang=js&

            /* harmony default export */ const tagvue_type_script_lang_js_ = ({
              name: 'ElTag',
              props: {
                text: String,
                closable: Boolean,
                type: String,
                hit: Boolean,
                disableTransitions: Boolean,
                color: String,
                size: String,
                effect: {
                  type: String,
                  default: 'light',
                  validator: function validator(val) {
                    return ['dark', 'light', 'plain'].indexOf(val) !== -1;
                  },
                },
              },
              methods: {
                handleClose: function handleClose(event) {
                  event.stopPropagation();
                  this.$emit('close', event);
                },
                handleClick: function handleClick(event) {
                  this.$emit('click', event);
                },
              },
              computed: {
                tagSize: function tagSize() {
                  return this.size || (this.$ELEMENT || {}).size;
                },
              },
              render: function render(h) {
                const { type } = this;
                const { tagSize } = this;
                const { hit } = this;
                const { effect } = this;

                const classes = ['el-tag', type ? `el-tag--${type}` : '', tagSize ? `el-tag--${tagSize}` : '', effect ? `el-tag--${effect}` : '', hit && 'is-hit'];
                const tagEl = h(
                  'span',
                  {
                    class: classes,
                    style: { backgroundColor: this.color },
                    on: {
                      click: this.handleClick,
                    },
                  },
                  [this.$slots.default, this.closable && h('i', {
                    class: 'el-tag__close el-icon-close',
                    on: {
                      click: this.handleClose,
                    },
                  })],
                );

                return this.disableTransitions ? tagEl : h(
                  'transition',
                  {
                    attrs: { name: 'el-zoom-in-center' },
                  },
                  [tagEl],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/tag/src/tag.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_tagvue_type_script_lang_js_ = (tagvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/tag/src/tag.vue
            let tag_render; let
              tag_staticRenderFns;

            /* normalize component */

            const tag_component = normalizeComponent(
              src_tagvue_type_script_lang_js_,
              tag_render,
              tag_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let tag_api; }
            tag_component.options.__file = 'packages/tag/src/tag.vue';
            /* harmony default export */ const tag = (tag_component.exports);
            // CONCATENATED MODULE: ./packages/tag/index.js

            /* istanbul ignore next */
            tag.install = function (Vue) {
              Vue.component(tag.name, tag);
            };

            /* harmony default export */ const packages_tag = (tag);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree.vue?vue&type=template&id=547575a6&
            const treevue_type_template_id_547575a6_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-tree',
                  class: {
                    'el-tree--highlight-current': _vm.highlightCurrent,
                    'is-dragging': !!_vm.dragState.draggingNode,
                    'is-drop-not-allow': !_vm.dragState.allowDrop,
                    'is-drop-inner': _vm.dragState.dropType === 'inner',
                  },
                  attrs: { role: 'tree' },
                },
                [
                  _vm._l(_vm.root.childNodes, (child) => _c('el-tree-node', {
                    key: _vm.getNodeKey(child),
                    attrs: {
                      node: child,
                      props: _vm.props,
                      'render-after-expand': _vm.renderAfterExpand,
                      'show-checkbox': _vm.showCheckbox,
                      'render-content': _vm.renderContent,
                    },
                    on: { 'node-expand': _vm.handleNodeExpand },
                  })),
                  _vm.isEmpty
                    ? _c('div', { staticClass: 'el-tree__empty-block' }, [
                      _c('span', { staticClass: 'el-tree__empty-text' }, [
                        _vm._v(_vm._s(_vm.emptyText)),
                      ]),
                    ])
                    : _vm._e(),
                  _c('div', {
                    directives: [
                      {
                        name: 'show',
                        rawName: 'v-show',
                        value: _vm.dragState.showDropIndicator,
                        expression: 'dragState.showDropIndicator',
                      },
                    ],
                    ref: 'dropIndicator',
                    staticClass: 'el-tree__drop-indicator',
                  }),
                ],
                2,
              );
            };
            const treevue_type_template_id_547575a6_staticRenderFns = [];
            treevue_type_template_id_547575a6_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/tree/src/tree.vue?vue&type=template&id=547575a6&

            // CONCATENATED MODULE: ./packages/tree/src/model/util.js
            const NODE_KEY = '$treeNodeId';

            const markNodeData = function markNodeData(node, data) {
              if (!data || data[NODE_KEY]) return;
              Object.defineProperty(data, NODE_KEY, {
                value: node.id,
                enumerable: false,
                configurable: false,
                writable: false,
              });
            };

            const util_getNodeKey = function getNodeKey(key, data) {
              if (!key) return data[NODE_KEY];
              return data[key];
            };

            const findNearestComponent = function findNearestComponent(element, componentName) {
              let target = element;
              while (target && target.tagName !== 'BODY') {
                if (target.__vue__ && target.__vue__.$options.name === componentName) {
                  return target.__vue__;
                }
                target = target.parentNode;
              }
              return null;
            };
            // CONCATENATED MODULE: ./packages/tree/src/model/node.js
            const _createClass = (function () { function defineProperties(target, props) { for (let i = 0; i < props.length; i++) { const descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }());

            function node_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

            const getChildState = function getChildState(node) {
              let all = true;
              let none = true;
              let allWithoutDisable = true;
              for (let i = 0, j = node.length; i < j; i++) {
                const n = node[i];
                if (n.checked !== true || n.indeterminate) {
                  all = false;
                  if (!n.disabled) {
                    allWithoutDisable = false;
                  }
                }
                if (n.checked !== false || n.indeterminate) {
                  none = false;
                }
              }

              return {
                all, none, allWithoutDisable, half: !all && !none,
              };
            };

            const reInitChecked = function reInitChecked(node) {
              if (node.childNodes.length === 0) return;

              const _getChildState = getChildState(node.childNodes);
              const { all } = _getChildState;
              const { none } = _getChildState;
              const { half } = _getChildState;

              if (all) {
                node.checked = true;
                node.indeterminate = false;
              } else if (half) {
                node.checked = false;
                node.indeterminate = true;
              } else if (none) {
                node.checked = false;
                node.indeterminate = false;
              }

              const { parent } = node;
              if (!parent || parent.level === 0) return;

              if (!node.store.checkStrictly) {
                reInitChecked(parent);
              }
            };

            const getPropertyFromData = function getPropertyFromData(node, prop) {
              const { props } = node.store;
              const data = node.data || {};
              const config = props[prop];

              if (typeof config === 'function') {
                return config(data, node);
              } if (typeof config === 'string') {
                return data[config];
              } if (typeof config === 'undefined') {
                const dataProp = data[prop];
                return dataProp === undefined ? '' : dataProp;
              }
            };

            let nodeIdSeed = 0;

            const node_Node = (function () {
              function Node(options) {
                node_classCallCheck(this, Node);

                this.id = nodeIdSeed++;
                this.text = null;
                this.checked = false;
                this.indeterminate = false;
                this.data = null;
                this.expanded = false;
                this.parent = null;
                this.visible = true;
                this.isCurrent = false;

                for (const name in options) {
                  if (options.hasOwnProperty(name)) {
                    this[name] = options[name];
                  }
                }

                // internal
                this.level = 0;
                this.loaded = false;
                this.childNodes = [];
                this.loading = false;

                if (this.parent) {
                  this.level = this.parent.level + 1;
                }

                const { store } = this;
                if (!store) {
                  throw new Error('[Node]store is required!');
                }
                store.registerNode(this);

                const { props } = store;
                if (props && typeof props.isLeaf !== 'undefined') {
                  const isLeaf = getPropertyFromData(this, 'isLeaf');
                  if (typeof isLeaf === 'boolean') {
                    this.isLeafByUser = isLeaf;
                  }
                }

                if (store.lazy !== true && this.data) {
                  this.setData(this.data);

                  if (store.defaultExpandAll) {
                    this.expanded = true;
                  }
                } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
                  this.expand();
                }
                if (!Array.isArray(this.data)) {
                  markNodeData(this, this.data);
                }
                if (!this.data) return;
                const { defaultExpandedKeys } = store;
                const { key } = store;
                if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {
                  this.expand(null, store.autoExpandParent);
                }

                if (key && store.currentNodeKey !== undefined && this.key === store.currentNodeKey) {
                  store.currentNode = this;
                  store.currentNode.isCurrent = true;
                }

                if (store.lazy) {
                  store._initDefaultCheckedNode(this);
                }

                this.updateLeafState();
              }

              Node.prototype.setData = function setData(data) {
                if (!Array.isArray(data)) {
                  markNodeData(this, data);
                }

                this.data = data;
                this.childNodes = [];

                let children = void 0;
                if (this.level === 0 && this.data instanceof Array) {
                  children = this.data;
                } else {
                  children = getPropertyFromData(this, 'children') || [];
                }

                for (let i = 0, j = children.length; i < j; i++) {
                  this.insertChild({ data: children[i] });
                }
              };

              Node.prototype.contains = function contains(target) {
                const deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

                const walk = function walk(parent) {
                  const children = parent.childNodes || [];
                  let result = false;
                  for (let i = 0, j = children.length; i < j; i++) {
                    const child = children[i];
                    if (child === target || deep && walk(child)) {
                      result = true;
                      break;
                    }
                  }
                  return result;
                };

                return walk(this);
              };

              Node.prototype.remove = function remove() {
                const { parent } = this;
                if (parent) {
                  parent.removeChild(this);
                }
              };

              Node.prototype.insertChild = function insertChild(child, index, batch) {
                if (!child) throw new Error('insertChild error: child is required.');

                if (!(child instanceof Node)) {
                  if (!batch) {
                    const children = this.getChildren(true);
                    if (children.indexOf(child.data) === -1) {
                      if (typeof index === 'undefined' || index < 0) {
                        children.push(child.data);
                      } else {
                        children.splice(index, 0, child.data);
                      }
                    }
                  }
                  merge_default()(child, {
                    parent: this,
                    store: this.store,
                  });
                  child = new Node(child);
                }

                child.level = this.level + 1;

                if (typeof index === 'undefined' || index < 0) {
                  this.childNodes.push(child);
                } else {
                  this.childNodes.splice(index, 0, child);
                }

                this.updateLeafState();
              };

              Node.prototype.insertBefore = function insertBefore(child, ref) {
                let index = void 0;
                if (ref) {
                  index = this.childNodes.indexOf(ref);
                }
                this.insertChild(child, index);
              };

              Node.prototype.insertAfter = function insertAfter(child, ref) {
                let index = void 0;
                if (ref) {
                  index = this.childNodes.indexOf(ref);
                  if (index !== -1) index += 1;
                }
                this.insertChild(child, index);
              };

              Node.prototype.removeChild = function removeChild(child) {
                const children = this.getChildren() || [];
                const dataIndex = children.indexOf(child.data);
                if (dataIndex > -1) {
                  children.splice(dataIndex, 1);
                }

                const index = this.childNodes.indexOf(child);

                if (index > -1) {
                  this.store && this.store.deregisterNode(child);
                  child.parent = null;
                  this.childNodes.splice(index, 1);
                }

                this.updateLeafState();
              };

              Node.prototype.removeChildByData = function removeChildByData(data) {
                let targetNode = null;

                for (let i = 0; i < this.childNodes.length; i++) {
                  if (this.childNodes[i].data === data) {
                    targetNode = this.childNodes[i];
                    break;
                  }
                }

                if (targetNode) {
                  this.removeChild(targetNode);
                }
              };

              Node.prototype.expand = function expand(callback, expandParent) {
                const _this = this;

                const done = function done() {
                  if (expandParent) {
                    let { parent } = _this;
                    while (parent.level > 0) {
                      parent.expanded = true;
                      parent = parent.parent;
                    }
                  }
                  _this.expanded = true;
                  if (callback) callback();
                };

                if (this.shouldLoadData()) {
                  this.loadData((data) => {
                    if (data instanceof Array) {
                      if (_this.checked) {
                        _this.setChecked(true, true);
                      } else if (!_this.store.checkStrictly) {
                        reInitChecked(_this);
                      }
                      done();
                    }
                  });
                } else {
                  done();
                }
              };

              Node.prototype.doCreateChildren = function doCreateChildren(array) {
                const _this2 = this;

                const defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                array.forEach((item) => {
                  _this2.insertChild(merge_default()({ data: item }, defaultProps), undefined, true);
                });
              };

              Node.prototype.collapse = function collapse() {
                this.expanded = false;
              };

              Node.prototype.shouldLoadData = function shouldLoadData() {
                return this.store.lazy === true && this.store.load && !this.loaded;
              };

              Node.prototype.updateLeafState = function updateLeafState() {
                if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== 'undefined') {
                  this.isLeaf = this.isLeafByUser;
                  return;
                }
                const { childNodes } = this;
                if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
                  this.isLeaf = !childNodes || childNodes.length === 0;
                  return;
                }
                this.isLeaf = false;
              };

              Node.prototype.setChecked = function setChecked(value, deep, recursion, passValue) {
                const _this3 = this;

                this.indeterminate = value === 'half';
                this.checked = value === true;

                if (this.store.checkStrictly) return;

                if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
                  const _getChildState2 = getChildState(this.childNodes);
                  let { all } = _getChildState2;
                  let { allWithoutDisable } = _getChildState2;

                  if (!this.isLeaf && !all && allWithoutDisable) {
                    this.checked = false;
                    value = false;
                  }

                  const handleDescendants = function handleDescendants() {
                    if (deep) {
                      const { childNodes } = _this3;
                      for (let i = 0, j = childNodes.length; i < j; i++) {
                        const child = childNodes[i];
                        passValue = passValue || value !== false;
                        const isCheck = child.disabled ? child.checked : passValue;
                        child.setChecked(isCheck, deep, true, passValue);
                      }

                      const _getChildState3 = getChildState(childNodes);
                      let { half } = _getChildState3;
                      let _all = _getChildState3.all;

                      if (!_all) {
                        _this3.checked = _all;
                        _this3.indeterminate = half;
                      }
                    }
                  };

                  if (this.shouldLoadData()) {
                    // Only work on lazy load data.
                    this.loadData(() => {
                      handleDescendants();
                      reInitChecked(_this3);
                    }, {
                      checked: value !== false,
                    });
                    return;
                  }
                  handleDescendants();
                }

                const { parent } = this;
                if (!parent || parent.level === 0) return;

                if (!recursion) {
                  reInitChecked(parent);
                }
              };

              Node.prototype.getChildren = function getChildren() {
                const forceInit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                // this is data
                if (this.level === 0) return this.data;
                const { data } = this;
                if (!data) return null;

                const { props } = this.store;
                let children = 'children';
                if (props) {
                  children = props.children || 'children';
                }

                if (data[children] === undefined) {
                  data[children] = null;
                }

                if (forceInit && !data[children]) {
                  data[children] = [];
                }

                return data[children];
              };

              Node.prototype.updateChildren = function updateChildren() {
                const _this4 = this;

                const newData = this.getChildren() || [];
                const oldData = this.childNodes.map((node) => node.data);

                const newDataMap = {};
                const newNodes = [];

                newData.forEach((item, index) => {
                  const key = item[NODE_KEY];
                  const isNodeExists = !!key && Object(util_.arrayFindIndex)(oldData, (data) => data[NODE_KEY] === key) >= 0;
                  if (isNodeExists) {
                    newDataMap[key] = { index, data: item };
                  } else {
                    newNodes.push({ index, data: item });
                  }
                });

                if (!this.store.lazy) {
                  oldData.forEach((item) => {
                    if (!newDataMap[item[NODE_KEY]]) _this4.removeChildByData(item);
                  });
                }

                newNodes.forEach((_ref) => {
                  const { index } = _ref;
                  var {data} = _ref;

                  _this4.insertChild({ data }, index);
                });

                this.updateLeafState();
              };

              Node.prototype.loadData = function loadData(callback) {
                const _this5 = this;

                const defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {
                  this.loading = true;

                  const resolve = function resolve(children) {
                    _this5.loaded = true;
                    _this5.loading = false;
                    _this5.childNodes = [];

                    _this5.doCreateChildren(children, defaultProps);

                    _this5.updateLeafState();
                    if (callback) {
                      callback.call(_this5, children);
                    }
                  };

                  this.store.load(this, resolve);
                } else if (callback) {
                  callback.call(this);
                }
              };

              _createClass(Node, [{
                key: 'label',
                get: function get() {
                  return getPropertyFromData(this, 'label');
                },
              }, {
                key: 'key',
                get: function get() {
                  const nodeKey = this.store.key;
                  if (this.data) return this.data[nodeKey];
                  return null;
                },
              }, {
                key: 'disabled',
                get: function get() {
                  return getPropertyFromData(this, 'disabled');
                },
              }, {
                key: 'nextSibling',
                get: function get() {
                  const { parent } = this;
                  if (parent) {
                    const index = parent.childNodes.indexOf(this);
                    if (index > -1) {
                      return parent.childNodes[index + 1];
                    }
                  }
                  return null;
                },
              }, {
                key: 'previousSibling',
                get: function get() {
                  const { parent } = this;
                  if (parent) {
                    const index = parent.childNodes.indexOf(this);
                    if (index > -1) {
                      return index > 0 ? parent.childNodes[index - 1] : null;
                    }
                  }
                  return null;
                },
              }]);

              return Node;
            }());

            /* harmony default export */ const model_node = (node_Node);
            // CONCATENATED MODULE: ./packages/tree/src/model/tree-store.js
            const tree_store_typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

            function tree_store_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

            const tree_store_TreeStore = (function () {
              function TreeStore(options) {
                const _this = this;

                tree_store_classCallCheck(this, TreeStore);

                this.currentNode = null;
                this.currentNodeKey = null;

                for (const option in options) {
                  if (options.hasOwnProperty(option)) {
                    this[option] = options[option];
                  }
                }

                this.nodesMap = {};

                this.root = new model_node({
                  data: this.data,
                  store: this,
                });

                if (this.lazy && this.load) {
                  const loadFn = this.load;
                  loadFn(this.root, (data) => {
                    _this.root.doCreateChildren(data);
                    _this._initDefaultCheckedNodes();
                  });
                } else {
                  this._initDefaultCheckedNodes();
                }
              }

              TreeStore.prototype.filter = function filter(value) {
                const { filterNodeMethod } = this;
                const { lazy } = this;
                const traverse = function traverse(node) {
                  const childNodes = node.root ? node.root.childNodes : node.childNodes;

                  childNodes.forEach((child) => {
                    child.visible = filterNodeMethod.call(child, value, child.data, child);

                    traverse(child);
                  });

                  if (!node.visible && childNodes.length) {
                    let allHidden = true;
                    allHidden = !childNodes.some((child) => child.visible);

                    if (node.root) {
                      node.root.visible = allHidden === false;
                    } else {
                      node.visible = allHidden === false;
                    }
                  }
                  if (!value) return;

                  if (node.visible && !node.isLeaf && !lazy) node.expand();
                };

                traverse(this);
              };

              TreeStore.prototype.setData = function setData(newVal) {
                const instanceChanged = newVal !== this.root.data;
                if (instanceChanged) {
                  this.root.setData(newVal);
                  this._initDefaultCheckedNodes();
                } else {
                  this.root.updateChildren();
                }
              };

              TreeStore.prototype.getNode = function getNode(data) {
                if (data instanceof model_node) return data;
                const key = (typeof data === 'undefined' ? 'undefined' : tree_store_typeof(data)) !== 'object' ? data : util_getNodeKey(this.key, data);
                return this.nodesMap[key] || null;
              };

              TreeStore.prototype.insertBefore = function insertBefore(data, refData) {
                const refNode = this.getNode(refData);
                refNode.parent.insertBefore({ data }, refNode);
              };

              TreeStore.prototype.insertAfter = function insertAfter(data, refData) {
                const refNode = this.getNode(refData);
                refNode.parent.insertAfter({ data }, refNode);
              };

              TreeStore.prototype.remove = function remove(data) {
                const node = this.getNode(data);

                if (node && node.parent) {
                  if (node === this.currentNode) {
                    this.currentNode = null;
                  }
                  node.parent.removeChild(node);
                }
              };

              TreeStore.prototype.append = function append(data, parentData) {
                const parentNode = parentData ? this.getNode(parentData) : this.root;

                if (parentNode) {
                  parentNode.insertChild({ data });
                }
              };

              TreeStore.prototype._initDefaultCheckedNodes = function _initDefaultCheckedNodes() {
                const _this2 = this;

                const defaultCheckedKeys = this.defaultCheckedKeys || [];
                const { nodesMap } = this;

                defaultCheckedKeys.forEach((checkedKey) => {
                  const node = nodesMap[checkedKey];

                  if (node) {
                    node.setChecked(true, !_this2.checkStrictly);
                  }
                });
              };

              TreeStore.prototype._initDefaultCheckedNode = function _initDefaultCheckedNode(node) {
                const defaultCheckedKeys = this.defaultCheckedKeys || [];

                if (defaultCheckedKeys.indexOf(node.key) !== -1) {
                  node.setChecked(true, !this.checkStrictly);
                }
              };

              TreeStore.prototype.setDefaultCheckedKey = function setDefaultCheckedKey(newVal) {
                if (newVal !== this.defaultCheckedKeys) {
                  this.defaultCheckedKeys = newVal;
                  this._initDefaultCheckedNodes();
                }
              };

              TreeStore.prototype.registerNode = function registerNode(node) {
                const { key } = this;
                if (!key || !node || !node.data) return;

                const nodeKey = node.key;
                if (nodeKey !== undefined) this.nodesMap[node.key] = node;
              };

              TreeStore.prototype.deregisterNode = function deregisterNode(node) {
                const _this3 = this;

                const { key } = this;
                if (!key || !node || !node.data) return;

                node.childNodes.forEach((child) => {
                  _this3.deregisterNode(child);
                });

                delete this.nodesMap[node.key];
              };

              TreeStore.prototype.getCheckedNodes = function getCheckedNodes() {
                const leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                const includeHalfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                const checkedNodes = [];
                const traverse = function traverse(node) {
                  const childNodes = node.root ? node.root.childNodes : node.childNodes;

                  childNodes.forEach((child) => {
                    if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
                      checkedNodes.push(child.data);
                    }

                    traverse(child);
                  });
                };

                traverse(this);

                return checkedNodes;
              };

              TreeStore.prototype.getCheckedKeys = function getCheckedKeys() {
                const _this4 = this;

                const leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                return this.getCheckedNodes(leafOnly).map((data) => (data || {})[_this4.key]);
              };

              TreeStore.prototype.getHalfCheckedNodes = function getHalfCheckedNodes() {
                const nodes = [];
                const traverse = function traverse(node) {
                  const childNodes = node.root ? node.root.childNodes : node.childNodes;

                  childNodes.forEach((child) => {
                    if (child.indeterminate) {
                      nodes.push(child.data);
                    }

                    traverse(child);
                  });
                };

                traverse(this);

                return nodes;
              };

              TreeStore.prototype.getHalfCheckedKeys = function getHalfCheckedKeys() {
                const _this5 = this;

                return this.getHalfCheckedNodes().map((data) => (data || {})[_this5.key]);
              };

              TreeStore.prototype._getAllNodes = function _getAllNodes() {
                const allNodes = [];
                const { nodesMap } = this;
                for (const nodeKey in nodesMap) {
                  if (nodesMap.hasOwnProperty(nodeKey)) {
                    allNodes.push(nodesMap[nodeKey]);
                  }
                }

                return allNodes;
              };

              TreeStore.prototype.updateChildren = function updateChildren(key, data) {
                const node = this.nodesMap[key];
                if (!node) return;
                const { childNodes } = node;
                for (let i = childNodes.length - 1; i >= 0; i--) {
                  const child = childNodes[i];
                  this.remove(child.data);
                }
                for (let _i = 0, j = data.length; _i < j; _i++) {
                  const _child = data[_i];
                  this.append(_child, node.data);
                }
              };

              TreeStore.prototype._setCheckedKeys = function _setCheckedKeys(key) {
                const leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                const checkedKeys = arguments[2];

                const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level);
                const cache = Object.create(null);
                const keys = Object.keys(checkedKeys);
                allNodes.forEach((node) => node.setChecked(false, false));
                for (let i = 0, j = allNodes.length; i < j; i++) {
                  var node = allNodes[i];
                  const nodeKey = node.data[key].toString();
                  const checked = keys.indexOf(nodeKey) > -1;
                  if (!checked) {
                    if (node.checked && !cache[nodeKey]) {
                      node.setChecked(false, false);
                    }
                    continue;
                  }

                  let { parent } = node;
                  while (parent && parent.level > 0) {
                    cache[parent.data[key]] = true;
                    parent = parent.parent;
                  }

                  if (node.isLeaf || this.checkStrictly) {
                    node.setChecked(true, false);
                    continue;
                  }
                  node.setChecked(true, true);

                  if (leafOnly) {
                    (function () {
                      node.setChecked(false, false);
                      const traverse = function traverse(node) {
                        const { childNodes } = node;
                        childNodes.forEach((child) => {
                          if (!child.isLeaf) {
                            child.setChecked(false, false);
                          }
                          traverse(child);
                        });
                      };
                      traverse(node);
                    }());
                  }
                }
              };

              TreeStore.prototype.setCheckedNodes = function setCheckedNodes(array) {
                const leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                const { key } = this;
                const checkedKeys = {};
                array.forEach((item) => {
                  checkedKeys[(item || {})[key]] = true;
                });

                this._setCheckedKeys(key, leafOnly, checkedKeys);
              };

              TreeStore.prototype.setCheckedKeys = function setCheckedKeys(keys) {
                const leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                this.defaultCheckedKeys = keys;
                const { key } = this;
                const checkedKeys = {};
                keys.forEach((key) => {
                  checkedKeys[key] = true;
                });

                this._setCheckedKeys(key, leafOnly, checkedKeys);
              };

              TreeStore.prototype.setDefaultExpandedKeys = function setDefaultExpandedKeys(keys) {
                const _this6 = this;

                keys = keys || [];
                this.defaultExpandedKeys = keys;

                keys.forEach((key) => {
                  const node = _this6.getNode(key);
                  if (node) node.expand(null, _this6.autoExpandParent);
                });
              };

              TreeStore.prototype.setChecked = function setChecked(data, checked, deep) {
                const node = this.getNode(data);

                if (node) {
                  node.setChecked(!!checked, deep);
                }
              };

              TreeStore.prototype.getCurrentNode = function getCurrentNode() {
                return this.currentNode;
              };

              TreeStore.prototype.setCurrentNode = function setCurrentNode(currentNode) {
                const prevCurrentNode = this.currentNode;
                if (prevCurrentNode) {
                  prevCurrentNode.isCurrent = false;
                }
                this.currentNode = currentNode;
                this.currentNode.isCurrent = true;
              };

              TreeStore.prototype.setUserCurrentNode = function setUserCurrentNode(node) {
                const key = node[this.key];
                const currNode = this.nodesMap[key];
                this.setCurrentNode(currNode);
              };

              TreeStore.prototype.setCurrentNodeKey = function setCurrentNodeKey(key) {
                if (key === null || key === undefined) {
                  this.currentNode && (this.currentNode.isCurrent = false);
                  this.currentNode = null;
                  return;
                }
                const node = this.getNode(key);
                if (node) {
                  this.setCurrentNode(node);
                }
              };

              return TreeStore;
            }());

            /* harmony default export */ const tree_store = (tree_store_TreeStore);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree-node.vue?vue&type=template&id=3ba3ef0e&
            const tree_nodevue_type_template_id_3ba3ef0e_render = function () {
              const this$1 = this;
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  directives: [
                    {
                      name: 'show',
                      rawName: 'v-show',
                      value: _vm.node.visible,
                      expression: 'node.visible',
                    },
                  ],
                  ref: 'node',
                  staticClass: 'el-tree-node',
                  class: {
                    'is-expanded': _vm.expanded,
                    'is-current': _vm.node.isCurrent,
                    'is-hidden': !_vm.node.visible,
                    'is-focusable': !_vm.node.disabled,
                    'is-checked': !_vm.node.disabled && _vm.node.checked,
                  },
                  attrs: {
                    role: 'treeitem',
                    tabindex: '-1',
                    'aria-expanded': _vm.expanded,
                    'aria-disabled': _vm.node.disabled,
                    'aria-checked': _vm.node.checked,
                    draggable: _vm.tree.draggable,
                  },
                  on: {
                    click($event) {
                      $event.stopPropagation();
                      return _vm.handleClick($event);
                    },
                    contextmenu($event) {
                      return this$1.handleContextMenu($event);
                    },
                    dragstart($event) {
                      $event.stopPropagation();
                      return _vm.handleDragStart($event);
                    },
                    dragover($event) {
                      $event.stopPropagation();
                      return _vm.handleDragOver($event);
                    },
                    dragend($event) {
                      $event.stopPropagation();
                      return _vm.handleDragEnd($event);
                    },
                    drop($event) {
                      $event.stopPropagation();
                      return _vm.handleDrop($event);
                    },
                  },
                },
                [
                  _c(
                    'div',
                    {
                      staticClass: 'el-tree-node__content',
                      style: {
                        'padding-left': `${(_vm.node.level - 1) * _vm.tree.indent}px`,
                      },
                    },
                    [
                      _c('span', {
                        class: [
                          {
                            'is-leaf': _vm.node.isLeaf,
                            expanded: !_vm.node.isLeaf && _vm.expanded,
                          },
                          'el-tree-node__expand-icon',
                          _vm.tree.iconClass ? _vm.tree.iconClass : 'el-icon-caret-right',
                        ],
                        on: {
                          click($event) {
                            $event.stopPropagation();
                            return _vm.handleExpandIconClick($event);
                          },
                        },
                      }),
                      _vm.showCheckbox
                        ? _c('el-checkbox', {
                          attrs: {
                            indeterminate: _vm.node.indeterminate,
                            disabled: !!_vm.node.disabled,
                          },
                          on: { change: _vm.handleCheckChange },
                          nativeOn: {
                            click($event) {
                              $event.stopPropagation();
                            },
                          },
                          model: {
                            value: _vm.node.checked,
                            callback($$v) {
                              _vm.$set(_vm.node, 'checked', $$v);
                            },
                            expression: 'node.checked',
                          },
                        })
                        : _vm._e(),
                      _vm.node.loading
                        ? _c('span', {
                          staticClass: 'el-tree-node__loading-icon el-icon-loading',
                        })
                        : _vm._e(),
                      _c('node-content', { attrs: { node: _vm.node } }),
                    ],
                    1,
                  ),
                  _c('el-collapse-transition', [
                    !_vm.renderAfterExpand || _vm.childNodeRendered
                      ? _c(
                        'div',
                        {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: _vm.expanded,
                              expression: 'expanded',
                            },
                          ],
                          staticClass: 'el-tree-node__children',
                          attrs: { role: 'group', 'aria-expanded': _vm.expanded },
                        },
                        _vm._l(_vm.node.childNodes, (child) => _c('el-tree-node', {
                          key: _vm.getNodeKey(child),
                          attrs: {
                            'render-content': _vm.renderContent,
                            'render-after-expand': _vm.renderAfterExpand,
                            'show-checkbox': _vm.showCheckbox,
                            node: child,
                          },
                          on: { 'node-expand': _vm.handleChildNodeExpand },
                        })),
                        1,
                      )
                      : _vm._e(),
                  ]),
                ],
                1,
              );
            };
            const tree_nodevue_type_template_id_3ba3ef0e_staticRenderFns = [];
            tree_nodevue_type_template_id_3ba3ef0e_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/tree/src/tree-node.vue?vue&type=template&id=3ba3ef0e&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree-node.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const tree_nodevue_type_script_lang_js_ = ({
              name: 'ElTreeNode',

              componentName: 'ElTreeNode',

              mixins: [emitter_default.a],

              props: {
                node: {
                  default: function _default() {
                    return {};
                  },
                },
                props: {},
                renderContent: Function,
                renderAfterExpand: {
                  type: Boolean,
                  default: true,
                },
                showCheckbox: {
                  type: Boolean,
                  default: false,
                },
              },

              components: {
                ElCollapseTransition: collapse_transition_default.a,
                ElCheckbox: checkbox_default.a,
                NodeContent: {
                  props: {
                    node: {
                      required: true,
                    },
                  },
                  render: function render(h) {
                    const parent = this.$parent;
                    const { tree } = parent;
                    const { node } = this;
                    const { data } = node;
                    const { store } = node;

                    return parent.renderContent ? parent.renderContent.call(parent._renderProxy, h, {
                      _self: tree.$vnode.context, node, data, store,
                    }) : tree.$scopedSlots.default ? tree.$scopedSlots.default({ node, data }) : h(
                      'span',
                      { class: 'el-tree-node__label' },
                      [node.label],
                    );
                  },
                },
              },

              data: function data() {
                return {
                  tree: null,
                  expanded: false,
                  childNodeRendered: false,
                  oldChecked: null,
                  oldIndeterminate: null,
                };
              },

              watch: {
                'node.indeterminate': function nodeIndeterminate(val) {
                  this.handleSelectChange(this.node.checked, val);
                },
                'node.checked': function nodeChecked(val) {
                  this.handleSelectChange(val, this.node.indeterminate);
                },
                'node.expanded': function nodeExpanded(val) {
                  const _this = this;

                  this.$nextTick(() => _this.expanded = val);
                  if (val) {
                    this.childNodeRendered = true;
                  }
                },
              },

              methods: {
                getNodeKey: function getNodeKey(node) {
                  return util_getNodeKey(this.tree.nodeKey, node.data);
                },
                handleSelectChange: function handleSelectChange(checked, indeterminate) {
                  if (this.oldChecked !== checked && this.oldIndeterminate !== indeterminate) {
                    this.tree.$emit('check-change', this.node.data, checked, indeterminate);
                  }
                  this.oldChecked = checked;
                  this.indeterminate = indeterminate;
                },
                handleClick: function handleClick() {
                  const { store } = this.tree;
                  store.setCurrentNode(this.node);
                  this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
                  this.tree.currentNode = this;
                  if (this.tree.expandOnClickNode) {
                    this.handleExpandIconClick();
                  }
                  if (this.tree.checkOnClickNode && !this.node.disabled) {
                    this.handleCheckChange(null, {
                      target: { checked: !this.node.checked },
                    });
                  }
                  this.tree.$emit('node-click', this.node.data, this.node, this);
                },
                handleContextMenu: function handleContextMenu(event) {
                  if (this.tree._events['node-contextmenu'] && this.tree._events['node-contextmenu'].length > 0) {
                    event.stopPropagation();
                    event.preventDefault();
                  }
                  this.tree.$emit('node-contextmenu', event, this.node.data, this.node, this);
                },
                handleExpandIconClick: function handleExpandIconClick() {
                  if (this.node.isLeaf) return;
                  if (this.expanded) {
                    this.tree.$emit('node-collapse', this.node.data, this.node, this);
                    this.node.collapse();
                  } else {
                    this.node.expand();
                    this.$emit('node-expand', this.node.data, this.node, this);
                  }
                },
                handleCheckChange: function handleCheckChange(value, ev) {
                  const _this2 = this;

                  this.node.setChecked(ev.target.checked, !this.tree.checkStrictly);
                  this.$nextTick(() => {
                    const { store } = _this2.tree;
                    _this2.tree.$emit('check', _this2.node.data, {
                      checkedNodes: store.getCheckedNodes(),
                      checkedKeys: store.getCheckedKeys(),
                      halfCheckedNodes: store.getHalfCheckedNodes(),
                      halfCheckedKeys: store.getHalfCheckedKeys(),
                    });
                  });
                },
                handleChildNodeExpand: function handleChildNodeExpand(nodeData, node, instance) {
                  this.broadcast('ElTreeNode', 'tree-node-expand', node);
                  this.tree.$emit('node-expand', nodeData, node, instance);
                },
                handleDragStart: function handleDragStart(event) {
                  if (!this.tree.draggable) return;
                  this.tree.$emit('tree-node-drag-start', event, this);
                },
                handleDragOver: function handleDragOver(event) {
                  if (!this.tree.draggable) return;
                  this.tree.$emit('tree-node-drag-over', event, this);
                  event.preventDefault();
                },
                handleDrop: function handleDrop(event) {
                  event.preventDefault();
                },
                handleDragEnd: function handleDragEnd(event) {
                  if (!this.tree.draggable) return;
                  this.tree.$emit('tree-node-drag-end', event, this);
                },
              },

              created: function created() {
                const _this3 = this;

                const parent = this.$parent;

                if (parent.isTree) {
                  this.tree = parent;
                } else {
                  this.tree = parent.tree;
                }

                const { tree } = this;
                if (!tree) {
                  console.warn('Can not find node\'s tree.');
                }

                const props = tree.props || {};
                const childrenKey = props.children || 'children';

                this.$watch(`node.data.${childrenKey}`, () => {
                  _this3.node.updateChildren();
                });

                if (this.node.expanded) {
                  this.expanded = true;
                  this.childNodeRendered = true;
                }

                if (this.tree.accordion) {
                  this.$on('tree-node-expand', (node) => {
                    if (_this3.node !== node) {
                      _this3.node.collapse();
                    }
                  });
                }
              },
            });
            // CONCATENATED MODULE: ./packages/tree/src/tree-node.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_tree_nodevue_type_script_lang_js_ = (tree_nodevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/tree/src/tree-node.vue

            /* normalize component */

            const tree_node_component = normalizeComponent(
              src_tree_nodevue_type_script_lang_js_,
              tree_nodevue_type_template_id_3ba3ef0e_render,
              tree_nodevue_type_template_id_3ba3ef0e_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let tree_node_api; }
            tree_node_component.options.__file = 'packages/tree/src/tree-node.vue';
            /* harmony default export */ const tree_node = (tree_node_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const treevue_type_script_lang_js_ = ({
              name: 'ElTree',

              mixins: [emitter_default.a],

              components: {
                ElTreeNode: tree_node,
              },

              data: function data() {
                return {
                  store: null,
                  root: null,
                  currentNode: null,
                  treeItems: null,
                  checkboxItems: [],
                  dragState: {
                    showDropIndicator: false,
                    draggingNode: null,
                    dropNode: null,
                    allowDrop: true,
                  },
                };
              },

              props: {
                data: {
                  type: Array,
                },
                emptyText: {
                  type: String,
                  default: function _default() {
                    return Object(lib_locale_.t)('el.tree.emptyText');
                  },
                },
                renderAfterExpand: {
                  type: Boolean,
                  default: true,
                },
                nodeKey: String,
                checkStrictly: Boolean,
                defaultExpandAll: Boolean,
                expandOnClickNode: {
                  type: Boolean,
                  default: true,
                },
                checkOnClickNode: Boolean,
                checkDescendants: {
                  type: Boolean,
                  default: false,
                },
                autoExpandParent: {
                  type: Boolean,
                  default: true,
                },
                defaultCheckedKeys: Array,
                defaultExpandedKeys: Array,
                currentNodeKey: [String, Number],
                renderContent: Function,
                showCheckbox: {
                  type: Boolean,
                  default: false,
                },
                draggable: {
                  type: Boolean,
                  default: false,
                },
                allowDrag: Function,
                allowDrop: Function,
                props: {
                  default: function _default() {
                    return {
                      children: 'children',
                      label: 'label',
                      disabled: 'disabled',
                    };
                  },
                },
                lazy: {
                  type: Boolean,
                  default: false,
                },
                highlightCurrent: Boolean,
                load: Function,
                filterNodeMethod: Function,
                accordion: Boolean,
                indent: {
                  type: Number,
                  default: 18,
                },
                iconClass: String,
              },

              computed: {
                children: {
                  set: function set(value) {
                    this.data = value;
                  },
                  get: function get() {
                    return this.data;
                  },
                },

                treeItemArray: function treeItemArray() {
                  return Array.prototype.slice.call(this.treeItems);
                },
                isEmpty: function isEmpty() {
                  const { childNodes } = this.root;

                  return !childNodes || childNodes.length === 0 || childNodes.every((_ref) => {
                    const { visible } = _ref;
                    return !visible;
                  });
                },
              },

              watch: {
                defaultCheckedKeys: function defaultCheckedKeys(newVal) {
                  this.store.setDefaultCheckedKey(newVal);
                },
                defaultExpandedKeys: function defaultExpandedKeys(newVal) {
                  this.store.defaultExpandedKeys = newVal;
                  this.store.setDefaultExpandedKeys(newVal);
                },
                data: function data(newVal) {
                  this.store.setData(newVal);
                },
                checkboxItems: function checkboxItems(val) {
                  Array.prototype.forEach.call(val, (checkbox) => {
                    checkbox.setAttribute('tabindex', -1);
                  });
                },
                checkStrictly: function checkStrictly(newVal) {
                  this.store.checkStrictly = newVal;
                },
              },

              methods: {
                filter: function filter(value) {
                  if (!this.filterNodeMethod) throw new Error('[Tree] filterNodeMethod is required when filter');
                  this.store.filter(value);
                },
                getNodeKey: function getNodeKey(node) {
                  return util_getNodeKey(this.nodeKey, node.data);
                },
                getNodePath: function getNodePath(data) {
                  if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getNodePath');
                  const node = this.store.getNode(data);
                  if (!node) return [];
                  const path = [node.data];
                  let { parent } = node;
                  while (parent && parent !== this.root) {
                    path.push(parent.data);
                    parent = parent.parent;
                  }
                  return path.reverse();
                },
                getCheckedNodes: function getCheckedNodes(leafOnly, includeHalfChecked) {
                  return this.store.getCheckedNodes(leafOnly, includeHalfChecked);
                },
                getCheckedKeys: function getCheckedKeys(leafOnly) {
                  return this.store.getCheckedKeys(leafOnly);
                },
                getCurrentNode: function getCurrentNode() {
                  const currentNode = this.store.getCurrentNode();
                  return currentNode ? currentNode.data : null;
                },
                getCurrentKey: function getCurrentKey() {
                  if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getCurrentKey');
                  const currentNode = this.getCurrentNode();
                  return currentNode ? currentNode[this.nodeKey] : null;
                },
                setCheckedNodes: function setCheckedNodes(nodes, leafOnly) {
                  if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedNodes');
                  this.store.setCheckedNodes(nodes, leafOnly);
                },
                setCheckedKeys: function setCheckedKeys(keys, leafOnly) {
                  if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedKeys');
                  this.store.setCheckedKeys(keys, leafOnly);
                },
                setChecked: function setChecked(data, checked, deep) {
                  this.store.setChecked(data, checked, deep);
                },
                getHalfCheckedNodes: function getHalfCheckedNodes() {
                  return this.store.getHalfCheckedNodes();
                },
                getHalfCheckedKeys: function getHalfCheckedKeys() {
                  return this.store.getHalfCheckedKeys();
                },
                setCurrentNode: function setCurrentNode(node) {
                  if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentNode');
                  this.store.setUserCurrentNode(node);
                },
                setCurrentKey: function setCurrentKey(key) {
                  if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentKey');
                  this.store.setCurrentNodeKey(key);
                },
                getNode: function getNode(data) {
                  return this.store.getNode(data);
                },
                remove: function remove(data) {
                  this.store.remove(data);
                },
                append: function append(data, parentNode) {
                  this.store.append(data, parentNode);
                },
                insertBefore: function insertBefore(data, refNode) {
                  this.store.insertBefore(data, refNode);
                },
                insertAfter: function insertAfter(data, refNode) {
                  this.store.insertAfter(data, refNode);
                },
                handleNodeExpand: function handleNodeExpand(nodeData, node, instance) {
                  this.broadcast('ElTreeNode', 'tree-node-expand', node);
                  this.$emit('node-expand', nodeData, node, instance);
                },
                updateKeyChildren: function updateKeyChildren(key, data) {
                  if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in updateKeyChild');
                  this.store.updateChildren(key, data);
                },
                initTabIndex: function initTabIndex() {
                  this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');
                  this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
                  const checkedItem = this.$el.querySelectorAll('.is-checked[role=treeitem]');
                  if (checkedItem.length) {
                    checkedItem[0].setAttribute('tabindex', 0);
                    return;
                  }
                  this.treeItems[0] && this.treeItems[0].setAttribute('tabindex', 0);
                },
                handleKeydown: function handleKeydown(ev) {
                  const currentItem = ev.target;
                  if (currentItem.className.indexOf('el-tree-node') === -1) return;
                  const { keyCode } = ev;
                  this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');
                  const currentIndex = this.treeItemArray.indexOf(currentItem);
                  let nextIndex = void 0;
                  if ([38, 40].indexOf(keyCode) > -1) {
                    // up、down
                    ev.preventDefault();
                    if (keyCode === 38) {
                      // up
                      nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
                    } else {
                      nextIndex = currentIndex < this.treeItemArray.length - 1 ? currentIndex + 1 : 0;
                    }
                    this.treeItemArray[nextIndex].focus(); // 选中
                  }
                  if ([37, 39].indexOf(keyCode) > -1) {
                    // left、right 展开
                    ev.preventDefault();
                    currentItem.click(); // 选中
                  }
                  const hasInput = currentItem.querySelector('[type="checkbox"]');
                  if ([13, 32].indexOf(keyCode) > -1 && hasInput) {
                    // space enter选中checkbox
                    ev.preventDefault();
                    hasInput.click();
                  }
                },
              },

              created: function created() {
                const _this = this;

                this.isTree = true;

                this.store = new tree_store({
                  key: this.nodeKey,
                  data: this.data,
                  lazy: this.lazy,
                  props: this.props,
                  load: this.load,
                  currentNodeKey: this.currentNodeKey,
                  checkStrictly: this.checkStrictly,
                  checkDescendants: this.checkDescendants,
                  defaultCheckedKeys: this.defaultCheckedKeys,
                  defaultExpandedKeys: this.defaultExpandedKeys,
                  autoExpandParent: this.autoExpandParent,
                  defaultExpandAll: this.defaultExpandAll,
                  filterNodeMethod: this.filterNodeMethod,
                });

                this.root = this.store.root;

                const { dragState } = this;
                this.$on('tree-node-drag-start', (event, treeNode) => {
                  if (typeof _this.allowDrag === 'function' && !_this.allowDrag(treeNode.node)) {
                    event.preventDefault();
                    return false;
                  }
                  event.dataTransfer.effectAllowed = 'move';

                  // wrap in try catch to address IE's error when first param is 'text/plain'
                  try {
                    // setData is required for draggable to work in FireFox
                    // the content has to be '' so dragging a node out of the tree won't open a new tab in FireFox
                    event.dataTransfer.setData('text/plain', '');
                  } catch (e) {}
                  dragState.draggingNode = treeNode;
                  _this.$emit('node-drag-start', treeNode.node, event);
                });

                this.$on('tree-node-drag-over', (event, treeNode) => {
                  const dropNode = findNearestComponent(event.target, 'ElTreeNode');
                  const oldDropNode = dragState.dropNode;
                  if (oldDropNode && oldDropNode !== dropNode) {
                    Object(dom_.removeClass)(oldDropNode.$el, 'is-drop-inner');
                  }
                  const { draggingNode } = dragState;
                  if (!draggingNode || !dropNode) return;

                  let dropPrev = true;
                  let dropInner = true;
                  let dropNext = true;
                  let userAllowDropInner = true;
                  if (typeof _this.allowDrop === 'function') {
                    dropPrev = _this.allowDrop(draggingNode.node, dropNode.node, 'prev');
                    userAllowDropInner = dropInner = _this.allowDrop(draggingNode.node, dropNode.node, 'inner');
                    dropNext = _this.allowDrop(draggingNode.node, dropNode.node, 'next');
                  }
                  event.dataTransfer.dropEffect = dropInner ? 'move' : 'none';
                  if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
                    if (oldDropNode) {
                      _this.$emit('node-drag-leave', draggingNode.node, oldDropNode.node, event);
                    }
                    _this.$emit('node-drag-enter', draggingNode.node, dropNode.node, event);
                  }

                  if (dropPrev || dropInner || dropNext) {
                    dragState.dropNode = dropNode;
                  }

                  if (dropNode.node.nextSibling === draggingNode.node) {
                    dropNext = false;
                  }
                  if (dropNode.node.previousSibling === draggingNode.node) {
                    dropPrev = false;
                  }
                  if (dropNode.node.contains(draggingNode.node, false)) {
                    dropInner = false;
                  }
                  if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
                    dropPrev = false;
                    dropInner = false;
                    dropNext = false;
                  }

                  const targetPosition = dropNode.$el.getBoundingClientRect();
                  const treePosition = _this.$el.getBoundingClientRect();

                  let dropType = void 0;
                  const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
                  const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;

                  let indicatorTop = -9999;
                  const distance = event.clientY - targetPosition.top;
                  if (distance < targetPosition.height * prevPercent) {
                    dropType = 'before';
                  } else if (distance > targetPosition.height * nextPercent) {
                    dropType = 'after';
                  } else if (dropInner) {
                    dropType = 'inner';
                  } else {
                    dropType = 'none';
                  }

                  const iconPosition = dropNode.$el.querySelector('.el-tree-node__expand-icon').getBoundingClientRect();
                  const { dropIndicator } = _this.$refs;
                  if (dropType === 'before') {
                    indicatorTop = iconPosition.top - treePosition.top;
                  } else if (dropType === 'after') {
                    indicatorTop = iconPosition.bottom - treePosition.top;
                  }
                  dropIndicator.style.top = `${indicatorTop}px`;
                  dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`;

                  if (dropType === 'inner') {
                    Object(dom_.addClass)(dropNode.$el, 'is-drop-inner');
                  } else {
                    Object(dom_.removeClass)(dropNode.$el, 'is-drop-inner');
                  }

                  dragState.showDropIndicator = dropType === 'before' || dropType === 'after';
                  dragState.allowDrop = dragState.showDropIndicator || userAllowDropInner;
                  dragState.dropType = dropType;
                  _this.$emit('node-drag-over', draggingNode.node, dropNode.node, event);
                });

                this.$on('tree-node-drag-end', (event) => {
                  const { draggingNode } = dragState;
                  let { dropType } = dragState;
                  let { dropNode } = dragState;

                  event.preventDefault();
                  event.dataTransfer.dropEffect = 'move';

                  if (draggingNode && dropNode) {
                    const draggingNodeCopy = { data: draggingNode.node.data };
                    if (dropType !== 'none') {
                      draggingNode.node.remove();
                    }
                    if (dropType === 'before') {
                      dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
                    } else if (dropType === 'after') {
                      dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
                    } else if (dropType === 'inner') {
                      dropNode.node.insertChild(draggingNodeCopy);
                    }
                    if (dropType !== 'none') {
                      _this.store.registerNode(draggingNodeCopy);
                    }

                    Object(dom_.removeClass)(dropNode.$el, 'is-drop-inner');

                    _this.$emit('node-drag-end', draggingNode.node, dropNode.node, dropType, event);
                    if (dropType !== 'none') {
                      _this.$emit('node-drop', draggingNode.node, dropNode.node, dropType, event);
                    }
                  }
                  if (draggingNode && !dropNode) {
                    _this.$emit('node-drag-end', draggingNode.node, null, dropType, event);
                  }

                  dragState.showDropIndicator = false;
                  dragState.draggingNode = null;
                  dragState.dropNode = null;
                  dragState.allowDrop = true;
                });
              },
              mounted: function mounted() {
                this.initTabIndex();
                this.$el.addEventListener('keydown', this.handleKeydown);
              },
              updated: function updated() {
                this.treeItems = this.$el.querySelectorAll('[role=treeitem]');
                this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
              },
            });
            // CONCATENATED MODULE: ./packages/tree/src/tree.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_treevue_type_script_lang_js_ = (treevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/tree/src/tree.vue

            /* normalize component */

            const tree_component = normalizeComponent(
              src_treevue_type_script_lang_js_,
              treevue_type_template_id_547575a6_render,
              treevue_type_template_id_547575a6_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let tree_api; }
            tree_component.options.__file = 'packages/tree/src/tree.vue';
            /* harmony default export */ const src_tree = (tree_component.exports);
            // CONCATENATED MODULE: ./packages/tree/index.js

            /* istanbul ignore next */
            src_tree.install = function (Vue) {
              Vue.component(src_tree.name, src_tree);
            };

            /* harmony default export */ const packages_tree = (src_tree);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/alert/src/main.vue?vue&type=template&id=6e53341b&
            const mainvue_type_template_id_6e53341b_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('transition', { attrs: { name: 'el-alert-fade' } }, [
                _c(
                  'div',
                  {
                    directives: [
                      {
                        name: 'show',
                        rawName: 'v-show',
                        value: _vm.visible,
                        expression: 'visible',
                      },
                    ],
                    staticClass: 'el-alert',
                    class: [
                      _vm.typeClass,
                      _vm.center ? 'is-center' : '',
                      `is-${_vm.effect}`,
                    ],
                    attrs: { role: 'alert' },
                  },
                  [
                    _vm.showIcon
                      ? _c('i', {
                        staticClass: 'el-alert__icon',
                        class: [_vm.iconClass, _vm.isBigIcon],
                      })
                      : _vm._e(),
                    _c('div', { staticClass: 'el-alert__content' }, [
                      _vm.title || _vm.$slots.title
                        ? _c(
                          'span',
                          { staticClass: 'el-alert__title', class: [_vm.isBoldTitle] },
                          [_vm._t('title', [_vm._v(_vm._s(_vm.title))])],
                          2,
                        )
                        : _vm._e(),
                      _vm.$slots.default && !_vm.description
                        ? _c(
                          'p',
                          { staticClass: 'el-alert__description' },
                          [_vm._t('default')],
                          2,
                        )
                        : _vm._e(),
                      _vm.description && !_vm.$slots.default
                        ? _c('p', { staticClass: 'el-alert__description' }, [
                          _vm._v(_vm._s(_vm.description)),
                        ])
                        : _vm._e(),
                      _c(
                        'i',
                        {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: _vm.closable,
                              expression: 'closable',
                            },
                          ],
                          staticClass: 'el-alert__closebtn',
                          class: {
                            'is-customed': _vm.closeText !== '',
                            'el-icon-close': _vm.closeText === '',
                          },
                          on: {
                            click($event) {
                              _vm.close();
                            },
                          },
                        },
                        [_vm._v(_vm._s(_vm.closeText))],
                      ),
                    ]),
                  ],
                ),
              ]);
            };
            const mainvue_type_template_id_6e53341b_staticRenderFns = [];
            mainvue_type_template_id_6e53341b_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/alert/src/main.vue?vue&type=template&id=6e53341b&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/alert/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const TYPE_CLASSES_MAP = {
              success: 'el-icon-success',
              warning: 'el-icon-warning',
              error: 'el-icon-error',
            };
            /* harmony default export */ const alert_src_mainvue_type_script_lang_js_ = ({
              name: 'ElAlert',

              props: {
                title: {
                  type: String,
                  default: '',
                },
                description: {
                  type: String,
                  default: '',
                },
                type: {
                  type: String,
                  default: 'info',
                },
                closable: {
                  type: Boolean,
                  default: true,
                },
                closeText: {
                  type: String,
                  default: '',
                },
                showIcon: Boolean,
                center: Boolean,
                effect: {
                  type: String,
                  default: 'light',
                  validator: function validator(value) {
                    return ['light', 'dark'].indexOf(value) !== -1;
                  },
                },
              },

              data: function data() {
                return {
                  visible: true,
                };
              },

              methods: {
                close: function close() {
                  this.visible = false;
                  this.$emit('close');
                },
              },

              computed: {
                typeClass: function typeClass() {
                  return `el-alert--${this.type}`;
                },
                iconClass: function iconClass() {
                  return TYPE_CLASSES_MAP[this.type] || 'el-icon-info';
                },
                isBigIcon: function isBigIcon() {
                  return this.description || this.$slots.default ? 'is-big' : '';
                },
                isBoldTitle: function isBoldTitle() {
                  return this.description || this.$slots.default ? 'is-bold' : '';
                },
              },
            });
            // CONCATENATED MODULE: ./packages/alert/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_alert_src_mainvue_type_script_lang_js_ = (alert_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/alert/src/main.vue

            /* normalize component */

            const alert_src_main_component = normalizeComponent(
              packages_alert_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_6e53341b_render,
              mainvue_type_template_id_6e53341b_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let alert_src_main_api; }
            alert_src_main_component.options.__file = 'packages/alert/src/main.vue';
            /* harmony default export */ const alert_src_main = (alert_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/alert/index.js

            /* istanbul ignore next */
            alert_src_main.install = function (Vue) {
              Vue.component(alert_src_main.name, alert_src_main);
            };

            /* harmony default export */ const packages_alert = (alert_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/notification/src/main.vue?vue&type=template&id=43dbc3d8&
            const mainvue_type_template_id_43dbc3d8_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('transition', { attrs: { name: 'el-notification-fade' } }, [
                _c(
                  'div',
                  {
                    directives: [
                      {
                        name: 'show',
                        rawName: 'v-show',
                        value: _vm.visible,
                        expression: 'visible',
                      },
                    ],
                    class: ['el-notification', _vm.customClass, _vm.horizontalClass],
                    style: _vm.positionStyle,
                    attrs: { role: 'alert' },
                    on: {
                      mouseenter($event) {
                        _vm.clearTimer();
                      },
                      mouseleave($event) {
                        _vm.startTimer();
                      },
                      click: _vm.click,
                    },
                  },
                  [
                    _vm.type || _vm.iconClass
                      ? _c('i', {
                        staticClass: 'el-notification__icon',
                        class: [_vm.typeClass, _vm.iconClass],
                      })
                      : _vm._e(),
                    _c(
                      'div',
                      {
                        staticClass: 'el-notification__group',
                        class: { 'is-with-icon': _vm.typeClass || _vm.iconClass },
                      },
                      [
                        _c('h2', {
                          staticClass: 'el-notification__title',
                          domProps: { textContent: _vm._s(_vm.title) },
                        }),
                        _c(
                          'div',
                          {
                            directives: [
                              {
                                name: 'show',
                                rawName: 'v-show',
                                value: _vm.message,
                                expression: 'message',
                              },
                            ],
                            staticClass: 'el-notification__content',
                          },
                          [
                            _vm._t('default', [
                              !_vm.dangerouslyUseHTMLString
                                ? _c('p', [_vm._v(_vm._s(_vm.message))])
                                : _c('p', { domProps: { innerHTML: _vm._s(_vm.message) } }),
                            ]),
                          ],
                          2,
                        ),
                        _vm.showClose
                          ? _c('div', {
                            staticClass: 'el-notification__closeBtn el-icon-close',
                            on: {
                              click($event) {
                                $event.stopPropagation();
                                return _vm.close($event);
                              },
                            },
                          })
                          : _vm._e(),
                      ],
                    ),
                  ],
                ),
              ]);
            };
            const mainvue_type_template_id_43dbc3d8_staticRenderFns = [];
            mainvue_type_template_id_43dbc3d8_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/notification/src/main.vue?vue&type=template&id=43dbc3d8&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/notification/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const mainvue_type_script_lang_js_typeMap = {
              success: 'success',
              info: 'info',
              warning: 'warning',
              error: 'error',
            };

            /* harmony default export */ const notification_src_mainvue_type_script_lang_js_ = ({
              data: function data() {
                return {
                  visible: false,
                  title: '',
                  message: '',
                  duration: 4500,
                  type: '',
                  showClose: true,
                  customClass: '',
                  iconClass: '',
                  onClose: null,
                  onClick: null,
                  closed: false,
                  verticalOffset: 0,
                  timer: null,
                  dangerouslyUseHTMLString: false,
                  position: 'top-right',
                };
              },

              computed: {
                typeClass: function typeClass() {
                  return this.type && mainvue_type_script_lang_js_typeMap[this.type] ? `el-icon-${mainvue_type_script_lang_js_typeMap[this.type]}` : '';
                },
                horizontalClass: function horizontalClass() {
                  return this.position.indexOf('right') > -1 ? 'right' : 'left';
                },
                verticalProperty: function verticalProperty() {
                  return (/^top-/.test(this.position) ? 'top' : 'bottom'
                  );
                },
                positionStyle: function positionStyle() {
                  let _ref;

                  return _ref = {}, _ref[this.verticalProperty] = `${this.verticalOffset}px`, _ref;
                },
              },

              watch: {
                closed: function closed(newVal) {
                  if (newVal) {
                    this.visible = false;
                    this.$el.addEventListener('transitionend', this.destroyElement);
                  }
                },
              },

              methods: {
                destroyElement: function destroyElement() {
                  this.$el.removeEventListener('transitionend', this.destroyElement);
                  this.$destroy(true);
                  this.$el.parentNode.removeChild(this.$el);
                },
                click: function click() {
                  if (typeof this.onClick === 'function') {
                    this.onClick();
                  }
                },
                close: function close() {
                  this.closed = true;
                  if (typeof this.onClose === 'function') {
                    this.onClose();
                  }
                },
                clearTimer: function clearTimer() {
                  clearTimeout(this.timer);
                },
                startTimer: function startTimer() {
                  const _this = this;

                  if (this.duration > 0) {
                    this.timer = setTimeout(() => {
                      if (!_this.closed) {
                        _this.close();
                      }
                    }, this.duration);
                  }
                },
                keydown: function keydown(e) {
                  if (e.keyCode === 46 || e.keyCode === 8) {
                    this.clearTimer(); // detele 取消倒计时
                  } else if (e.keyCode === 27) {
                    // esc关闭消息
                    if (!this.closed) {
                      this.close();
                    }
                  } else {
                    this.startTimer(); // 恢复倒计时
                  }
                },
              },
              mounted: function mounted() {
                const _this2 = this;

                if (this.duration > 0) {
                  this.timer = setTimeout(() => {
                    if (!_this2.closed) {
                      _this2.close();
                    }
                  }, this.duration);
                }
                document.addEventListener('keydown', this.keydown);
              },
              beforeDestroy: function beforeDestroy() {
                document.removeEventListener('keydown', this.keydown);
              },
            });
            // CONCATENATED MODULE: ./packages/notification/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_notification_src_mainvue_type_script_lang_js_ = (notification_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/notification/src/main.vue

            /* normalize component */

            const notification_src_main_component = normalizeComponent(
              packages_notification_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_43dbc3d8_render,
              mainvue_type_template_id_43dbc3d8_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let notification_src_main_api; }
            notification_src_main_component.options.__file = 'packages/notification/src/main.vue';
            /* harmony default export */ const notification_src_main = (notification_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/notification/src/main.js

            const NotificationConstructor = external_vue_default.a.extend(notification_src_main);

            let src_main_instance = void 0;
            const instances = [];
            let seed = 1;

            const main_Notification = function Notification(options) {
              if (external_vue_default.a.prototype.$isServer) return;
              options = merge_default()({}, options);
              const userOnClose = options.onClose;
              const id = `notification_${seed++}`;
              const position = options.position || 'top-right';

              options.onClose = function () {
                Notification.close(id, userOnClose);
              };

              src_main_instance = new NotificationConstructor({
                data: options,
              });

              if (Object(vdom_.isVNode)(options.message)) {
                src_main_instance.$slots.default = [options.message];
                options.message = 'REPLACED_BY_VNODE';
              }
              src_main_instance.id = id;
              src_main_instance.$mount();
              document.body.appendChild(src_main_instance.$el);
              src_main_instance.visible = true;
              src_main_instance.dom = src_main_instance.$el;
              src_main_instance.dom.style.zIndex = popup_.PopupManager.nextZIndex();

              let verticalOffset = options.offset || 0;
              instances.filter((item) => item.position === position).forEach((item) => {
                verticalOffset += item.$el.offsetHeight + 16;
              });
              verticalOffset += 16;
              src_main_instance.verticalOffset = verticalOffset;
              instances.push(src_main_instance);
              return src_main_instance;
            };

            ['success', 'warning', 'info', 'error'].forEach((type) => {
              main_Notification[type] = function (options) {
                if (typeof options === 'string' || Object(vdom_.isVNode)(options)) {
                  options = {
                    message: options,
                  };
                }
                options.type = type;
                return main_Notification(options);
              };
            });

            main_Notification.close = function (id, userOnClose) {
              let index = -1;
              const len = instances.length;
              const instance = instances.filter((instance, i) => {
                if (instance.id === id) {
                  index = i;
                  return true;
                }
                return false;
              })[0];
              if (!instance) return;

              if (typeof userOnClose === 'function') {
                userOnClose(instance);
              }
              instances.splice(index, 1);

              if (len <= 1) return;
              const { position } = instance;
              const removedHeight = instance.dom.offsetHeight;
              for (let i = index; i < len - 1; i++) {
                if (instances[i].position === position) {
                  instances[i].dom.style[instance.verticalProperty] = `${parseInt(instances[i].dom.style[instance.verticalProperty], 10) - removedHeight - 16}px`;
                }
              }
            };

            main_Notification.closeAll = function () {
              for (let i = instances.length - 1; i >= 0; i--) {
                instances[i].close();
              }
            };

            /* harmony default export */ const packages_notification_src_main = (main_Notification);
            // CONCATENATED MODULE: ./packages/notification/index.js

            /* harmony default export */ const notification = (packages_notification_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/slider/src/main.vue?vue&type=template&id=32708644&
            const mainvue_type_template_id_32708644_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-slider',
                  class: {
                    'is-vertical': _vm.vertical,
                    'el-slider--with-input': _vm.showInput,
                  },
                  attrs: {
                    role: 'slider',
                    'aria-valuemin': _vm.min,
                    'aria-valuemax': _vm.max,
                    'aria-orientation': _vm.vertical ? 'vertical' : 'horizontal',
                    'aria-disabled': _vm.sliderDisabled,
                  },
                },
                [
                  _vm.showInput && !_vm.range
                    ? _c('el-input-number', {
                      ref: 'input',
                      staticClass: 'el-slider__input',
                      attrs: {
                        step: _vm.step,
                        disabled: _vm.sliderDisabled,
                        controls: _vm.showInputControls,
                        min: _vm.min,
                        max: _vm.max,
                        debounce: _vm.debounce,
                        size: _vm.inputSize,
                      },
                      on: { change: _vm.emitChange },
                      model: {
                        value: _vm.firstValue,
                        callback($$v) {
                          _vm.firstValue = $$v;
                        },
                        expression: 'firstValue',
                      },
                    })
                    : _vm._e(),
                  _c(
                    'div',
                    {
                      ref: 'slider',
                      staticClass: 'el-slider__runway',
                      class: { 'show-input': _vm.showInput, disabled: _vm.sliderDisabled },
                      style: _vm.runwayStyle,
                      on: { click: _vm.onSliderClick },
                    },
                    [
                      _c('div', { staticClass: 'el-slider__bar', style: _vm.barStyle }),
                      _c('slider-button', {
                        ref: 'button1',
                        attrs: {
                          vertical: _vm.vertical,
                          'tooltip-class': _vm.tooltipClass,
                        },
                        model: {
                          value: _vm.firstValue,
                          callback($$v) {
                            _vm.firstValue = $$v;
                          },
                          expression: 'firstValue',
                        },
                      }),
                      _vm.range
                        ? _c('slider-button', {
                          ref: 'button2',
                          attrs: {
                            vertical: _vm.vertical,
                            'tooltip-class': _vm.tooltipClass,
                          },
                          model: {
                            value: _vm.secondValue,
                            callback($$v) {
                              _vm.secondValue = $$v;
                            },
                            expression: 'secondValue',
                          },
                        })
                        : _vm._e(),
                      _vm._l(_vm.stops, (item, key) => (_vm.showStops
                        ? _c('div', {
                          key,
                          staticClass: 'el-slider__stop',
                          style: _vm.getStopStyle(item),
                        })
                        : _vm._e())),
                      _vm.markList.length > 0
                        ? [
                          _c(
                            'div',
                            _vm._l(_vm.markList, (item, key) => _c('div', {
                              key,
                              staticClass: 'el-slider__stop el-slider__marks-stop',
                              style: _vm.getStopStyle(item.position),
                            })),
                            0,
                          ),
                          _c(
                            'div',
                            { staticClass: 'el-slider__marks' },
                            _vm._l(_vm.markList, (item, key) => _c('slider-marker', {
                              key,
                              style: _vm.getStopStyle(item.position),
                              attrs: { mark: item.mark },
                            })),
                            1,
                          ),
                        ]
                        : _vm._e(),
                    ],
                    2,
                  ),
                ],
                1,
              );
            };
            const mainvue_type_template_id_32708644_staticRenderFns = [];
            mainvue_type_template_id_32708644_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/slider/src/main.vue?vue&type=template&id=32708644&

            // EXTERNAL MODULE: external "element-ui/lib/input-number"
            const input_number_ = __webpack_require__(41);
            const input_number_default = /* #__PURE__ */__webpack_require__.n(input_number_);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/slider/src/button.vue?vue&type=template&id=e72d2ad2&
            const buttonvue_type_template_id_e72d2ad2_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  ref: 'button',
                  staticClass: 'el-slider__button-wrapper',
                  class: { hover: _vm.hovering, dragging: _vm.dragging },
                  style: _vm.wrapperStyle,
                  attrs: { tabindex: '0' },
                  on: {
                    mouseenter: _vm.handleMouseEnter,
                    mouseleave: _vm.handleMouseLeave,
                    mousedown: _vm.onButtonDown,
                    touchstart: _vm.onButtonDown,
                    focus: _vm.handleMouseEnter,
                    blur: _vm.handleMouseLeave,
                    keydown: [
                      function ($event) {
                        if (
                          !('button' in $event)
              && _vm._k($event.keyCode, 'left', 37, $event.key, [
                'Left',
                'ArrowLeft',
              ])
                        ) {
                          return null;
                        }
                        if ('button' in $event && $event.button !== 0) {
                          return null;
                        }
                        return _vm.onLeftKeyDown($event);
                      },
                      function ($event) {
                        if (
                          !('button' in $event)
              && _vm._k($event.keyCode, 'right', 39, $event.key, [
                'Right',
                'ArrowRight',
              ])
                        ) {
                          return null;
                        }
                        if ('button' in $event && $event.button !== 2) {
                          return null;
                        }
                        return _vm.onRightKeyDown($event);
                      },
                      function ($event) {
                        if (
                          !('button' in $event)
              && _vm._k($event.keyCode, 'down', 40, $event.key, [
                'Down',
                'ArrowDown',
              ])
                        ) {
                          return null;
                        }
                        $event.preventDefault();
                        return _vm.onLeftKeyDown($event);
                      },
                      function ($event) {
                        if (
                          !('button' in $event)
              && _vm._k($event.keyCode, 'up', 38, $event.key, ['Up', 'ArrowUp'])
                        ) {
                          return null;
                        }
                        $event.preventDefault();
                        return _vm.onRightKeyDown($event);
                      },
                    ],
                  },
                },
                [
                  _c(
                    'el-tooltip',
                    {
                      ref: 'tooltip',
                      attrs: {
                        placement: 'top',
                        'popper-class': _vm.tooltipClass,
                        disabled: !_vm.showTooltip,
                      },
                    },
                    [
                      _c('span', { attrs: { slot: 'content' }, slot: 'content' }, [
                        _vm._v(_vm._s(_vm.formatValue)),
                      ]),
                      _c('div', {
                        staticClass: 'el-slider__button',
                        class: { hover: _vm.hovering, dragging: _vm.dragging },
                      }),
                    ],
                  ),
                ],
                1,
              );
            };
            const buttonvue_type_template_id_e72d2ad2_staticRenderFns = [];
            buttonvue_type_template_id_e72d2ad2_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/slider/src/button.vue?vue&type=template&id=e72d2ad2&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/slider/src/button.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const slider_src_buttonvue_type_script_lang_js_ = ({
              name: 'ElSliderButton',

              components: {
                ElTooltip: tooltip_default.a,
              },

              props: {
                value: {
                  type: Number,
                  default: 0,
                },
                vertical: {
                  type: Boolean,
                  default: false,
                },
                tooltipClass: String,
              },

              data: function data() {
                return {
                  hovering: false,
                  dragging: false,
                  isClick: false,
                  startX: 0,
                  currentX: 0,
                  startY: 0,
                  currentY: 0,
                  startPosition: 0,
                  newPosition: null,
                  oldValue: this.value,
                };
              },

              computed: {
                disabled: function disabled() {
                  return this.$parent.sliderDisabled;
                },
                max: function max() {
                  return this.$parent.max;
                },
                min: function min() {
                  return this.$parent.min;
                },
                step: function step() {
                  return this.$parent.step;
                },
                showTooltip: function showTooltip() {
                  return this.$parent.showTooltip;
                },
                precision: function precision() {
                  return this.$parent.precision;
                },
                currentPosition: function currentPosition() {
                  return `${(this.value - this.min) / (this.max - this.min) * 100}%`;
                },
                enableFormat: function enableFormat() {
                  return this.$parent.formatTooltip instanceof Function;
                },
                formatValue: function formatValue() {
                  return this.enableFormat && this.$parent.formatTooltip(this.value) || this.value;
                },
                wrapperStyle: function wrapperStyle() {
                  return this.vertical ? { bottom: this.currentPosition } : { left: this.currentPosition };
                },
              },

              watch: {
                dragging: function dragging(val) {
                  this.$parent.dragging = val;
                },
              },

              methods: {
                displayTooltip: function displayTooltip() {
                  this.$refs.tooltip && (this.$refs.tooltip.showPopper = true);
                },
                hideTooltip: function hideTooltip() {
                  this.$refs.tooltip && (this.$refs.tooltip.showPopper = false);
                },
                handleMouseEnter: function handleMouseEnter() {
                  this.hovering = true;
                  this.displayTooltip();
                },
                handleMouseLeave: function handleMouseLeave() {
                  this.hovering = false;
                  this.hideTooltip();
                },
                onButtonDown: function onButtonDown(event) {
                  if (this.disabled) return;
                  event.preventDefault();
                  this.onDragStart(event);
                  window.addEventListener('mousemove', this.onDragging);
                  window.addEventListener('touchmove', this.onDragging);
                  window.addEventListener('mouseup', this.onDragEnd);
                  window.addEventListener('touchend', this.onDragEnd);
                  window.addEventListener('contextmenu', this.onDragEnd);
                },
                onLeftKeyDown: function onLeftKeyDown() {
                  if (this.disabled) return;
                  this.newPosition = parseFloat(this.currentPosition) - this.step / (this.max - this.min) * 100;
                  this.setPosition(this.newPosition);
                  this.$parent.emitChange();
                },
                onRightKeyDown: function onRightKeyDown() {
                  if (this.disabled) return;
                  this.newPosition = parseFloat(this.currentPosition) + this.step / (this.max - this.min) * 100;
                  this.setPosition(this.newPosition);
                  this.$parent.emitChange();
                },
                onDragStart: function onDragStart(event) {
                  this.dragging = true;
                  this.isClick = true;
                  if (event.type === 'touchstart') {
                    event.clientY = event.touches[0].clientY;
                    event.clientX = event.touches[0].clientX;
                  }
                  if (this.vertical) {
                    this.startY = event.clientY;
                  } else {
                    this.startX = event.clientX;
                  }
                  this.startPosition = parseFloat(this.currentPosition);
                  this.newPosition = this.startPosition;
                },
                onDragging: function onDragging(event) {
                  if (this.dragging) {
                    this.isClick = false;
                    this.displayTooltip();
                    this.$parent.resetSize();
                    let diff = 0;
                    if (event.type === 'touchmove') {
                      event.clientY = event.touches[0].clientY;
                      event.clientX = event.touches[0].clientX;
                    }
                    if (this.vertical) {
                      this.currentY = event.clientY;
                      diff = (this.startY - this.currentY) / this.$parent.sliderSize * 100;
                    } else {
                      this.currentX = event.clientX;
                      diff = (this.currentX - this.startX) / this.$parent.sliderSize * 100;
                    }
                    this.newPosition = this.startPosition + diff;
                    this.setPosition(this.newPosition);
                  }
                },
                onDragEnd: function onDragEnd() {
                  const _this = this;

                  if (this.dragging) {
                    /*
         * 防止在 mouseup 后立即触发 click，导致滑块有几率产生一小段位移
         * 不使用 preventDefault 是因为 mouseup 和 click 没有注册在同一个 DOM 上
         */
                    setTimeout(() => {
                      _this.dragging = false;
                      _this.hideTooltip();
                      if (!_this.isClick) {
                        _this.setPosition(_this.newPosition);
                        _this.$parent.emitChange();
                      }
                    }, 0);
                    window.removeEventListener('mousemove', this.onDragging);
                    window.removeEventListener('touchmove', this.onDragging);
                    window.removeEventListener('mouseup', this.onDragEnd);
                    window.removeEventListener('touchend', this.onDragEnd);
                    window.removeEventListener('contextmenu', this.onDragEnd);
                  }
                },
                setPosition: function setPosition(newPosition) {
                  const _this2 = this;

                  if (newPosition === null || isNaN(newPosition)) return;
                  if (newPosition < 0) {
                    newPosition = 0;
                  } else if (newPosition > 100) {
                    newPosition = 100;
                  }
                  const lengthPerStep = 100 / ((this.max - this.min) / this.step);
                  const steps = Math.round(newPosition / lengthPerStep);
                  let value = steps * lengthPerStep * (this.max - this.min) * 0.01 + this.min;
                  value = parseFloat(value.toFixed(this.precision));
                  this.$emit('input', value);
                  this.$nextTick(() => {
                    _this2.displayTooltip();
                    _this2.$refs.tooltip && _this2.$refs.tooltip.updatePopper();
                  });
                  if (!this.dragging && this.value !== this.oldValue) {
                    this.oldValue = this.value;
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/slider/src/button.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_slider_src_buttonvue_type_script_lang_js_ = (slider_src_buttonvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/slider/src/button.vue

            /* normalize component */

            const src_button_component = normalizeComponent(
              packages_slider_src_buttonvue_type_script_lang_js_,
              buttonvue_type_template_id_e72d2ad2_render,
              buttonvue_type_template_id_e72d2ad2_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let src_button_api; }
            src_button_component.options.__file = 'packages/slider/src/button.vue';
            /* harmony default export */ const slider_src_button = (src_button_component.exports);
            // CONCATENATED MODULE: ./packages/slider/src/marker.js
            /* harmony default export */ const marker = ({
              name: 'ElMarker',

              props: {
                mark: {
                  type: [String, Object],
                },
              },
              render: function render() {
                const h = arguments[0];

                const label = typeof this.mark === 'string' ? this.mark : this.mark.label;

                return h(
                  'div',
                  { class: 'el-slider__marks-text', style: this.mark.style || {} },
                  [label],
                );
              },
            });
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/slider/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const slider_src_mainvue_type_script_lang_js_ = ({
              name: 'ElSlider',

              mixins: [emitter_default.a],

              inject: {
                elForm: {
                  default: '',
                },
              },

              props: {
                min: {
                  type: Number,
                  default: 0,
                },
                max: {
                  type: Number,
                  default: 100,
                },
                step: {
                  type: Number,
                  default: 1,
                },
                value: {
                  type: [Number, Array],
                  default: 0,
                },
                showInput: {
                  type: Boolean,
                  default: false,
                },
                showInputControls: {
                  type: Boolean,
                  default: true,
                },
                inputSize: {
                  type: String,
                  default: 'small',
                },
                showStops: {
                  type: Boolean,
                  default: false,
                },
                showTooltip: {
                  type: Boolean,
                  default: true,
                },
                formatTooltip: Function,
                disabled: {
                  type: Boolean,
                  default: false,
                },
                range: {
                  type: Boolean,
                  default: false,
                },
                vertical: {
                  type: Boolean,
                  default: false,
                },
                height: {
                  type: String,
                },
                debounce: {
                  type: Number,
                  default: 300,
                },
                label: {
                  type: String,
                },
                tooltipClass: String,
                marks: Object,
              },

              components: {
                ElInputNumber: input_number_default.a,
                SliderButton: slider_src_button,
                SliderMarker: marker,
              },

              data: function data() {
                return {
                  firstValue: null,
                  secondValue: null,
                  oldValue: null,
                  dragging: false,
                  sliderSize: 1,
                };
              },

              watch: {
                value: function value(val, oldVal) {
                  if (this.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index) => item === oldVal[index])) {
                    return;
                  }
                  this.setValues();
                },
                dragging: function dragging(val) {
                  if (!val) {
                    this.setValues();
                  }
                },
                firstValue: function firstValue(val) {
                  if (this.range) {
                    this.$emit('input', [this.minValue, this.maxValue]);
                  } else {
                    this.$emit('input', val);
                  }
                },
                secondValue: function secondValue() {
                  if (this.range) {
                    this.$emit('input', [this.minValue, this.maxValue]);
                  }
                },
                min: function min() {
                  this.setValues();
                },
                max: function max() {
                  this.setValues();
                },
              },

              methods: {
                valueChanged: function valueChanged() {
                  const _this = this;

                  if (this.range) {
                    return ![this.minValue, this.maxValue].every((item, index) => item === _this.oldValue[index]);
                  }
                  return this.value !== this.oldValue;
                },
                setValues: function setValues() {
                  if (this.min > this.max) {
                    console.error('[Element Error][Slider]min should not be greater than max.');
                    return;
                  }
                  const val = this.value;
                  if (this.range && Array.isArray(val)) {
                    if (val[1] < this.min) {
                      this.$emit('input', [this.min, this.min]);
                    } else if (val[0] > this.max) {
                      this.$emit('input', [this.max, this.max]);
                    } else if (val[0] < this.min) {
                      this.$emit('input', [this.min, val[1]]);
                    } else if (val[1] > this.max) {
                      this.$emit('input', [val[0], this.max]);
                    } else {
                      this.firstValue = val[0];
                      this.secondValue = val[1];
                      if (this.valueChanged()) {
                        this.dispatch('ElFormItem', 'el.form.change', [this.minValue, this.maxValue]);
                        this.oldValue = val.slice();
                      }
                    }
                  } else if (!this.range && typeof val === 'number' && !isNaN(val)) {
                    if (val < this.min) {
                      this.$emit('input', this.min);
                    } else if (val > this.max) {
                      this.$emit('input', this.max);
                    } else {
                      this.firstValue = val;
                      if (this.valueChanged()) {
                        this.dispatch('ElFormItem', 'el.form.change', val);
                        this.oldValue = val;
                      }
                    }
                  }
                },
                setPosition: function setPosition(percent) {
                  const targetValue = this.min + percent * (this.max - this.min) / 100;
                  if (!this.range) {
                    this.$refs.button1.setPosition(percent);
                    return;
                  }
                  let button = void 0;
                  if (Math.abs(this.minValue - targetValue) < Math.abs(this.maxValue - targetValue)) {
                    button = this.firstValue < this.secondValue ? 'button1' : 'button2';
                  } else {
                    button = this.firstValue > this.secondValue ? 'button1' : 'button2';
                  }
                  this.$refs[button].setPosition(percent);
                },
                onSliderClick: function onSliderClick(event) {
                  if (this.sliderDisabled || this.dragging) return;
                  this.resetSize();
                  if (this.vertical) {
                    const sliderOffsetBottom = this.$refs.slider.getBoundingClientRect().bottom;
                    this.setPosition((sliderOffsetBottom - event.clientY) / this.sliderSize * 100);
                  } else {
                    const sliderOffsetLeft = this.$refs.slider.getBoundingClientRect().left;
                    this.setPosition((event.clientX - sliderOffsetLeft) / this.sliderSize * 100);
                  }
                  this.emitChange();
                },
                resetSize: function resetSize() {
                  if (this.$refs.slider) {
                    this.sliderSize = this.$refs.slider[`client${this.vertical ? 'Height' : 'Width'}`];
                  }
                },
                emitChange: function emitChange() {
                  const _this2 = this;

                  this.$nextTick(() => {
                    _this2.$emit('change', _this2.range ? [_this2.minValue, _this2.maxValue] : _this2.value);
                  });
                },
                getStopStyle: function getStopStyle(position) {
                  return this.vertical ? { bottom: `${position}%` } : { left: `${position}%` };
                },
              },

              computed: {
                stops: function stops() {
                  const _this3 = this;

                  if (!this.showStops || this.min > this.max) return [];
                  if (this.step === 0) {
                    false && false;
                    return [];
                  }
                  const stopCount = (this.max - this.min) / this.step;
                  const stepWidth = 100 * this.step / (this.max - this.min);
                  const result = [];
                  for (let i = 1; i < stopCount; i++) {
                    result.push(i * stepWidth);
                  }
                  if (this.range) {
                    return result.filter((step) => step < 100 * (_this3.minValue - _this3.min) / (_this3.max - _this3.min) || step > 100 * (_this3.maxValue - _this3.min) / (_this3.max - _this3.min));
                  }
                  return result.filter((step) => step > 100 * (_this3.firstValue - _this3.min) / (_this3.max - _this3.min));
                },
                markList: function markList() {
                  const _this4 = this;

                  if (!this.marks) {
                    return [];
                  }

                  const marksKeys = Object.keys(this.marks);
                  return marksKeys.map(parseFloat).sort((a, b) => a - b).filter((point) => point <= _this4.max && point >= _this4.min).map((point) => ({
                    point,
                    position: (point - _this4.min) * 100 / (_this4.max - _this4.min),
                    mark: _this4.marks[point],
                  }));
                },
                minValue: function minValue() {
                  return Math.min(this.firstValue, this.secondValue);
                },
                maxValue: function maxValue() {
                  return Math.max(this.firstValue, this.secondValue);
                },
                barSize: function barSize() {
                  return this.range ? `${100 * (this.maxValue - this.minValue) / (this.max - this.min)}%` : `${100 * (this.firstValue - this.min) / (this.max - this.min)}%`;
                },
                barStart: function barStart() {
                  return this.range ? `${100 * (this.minValue - this.min) / (this.max - this.min)}%` : '0%';
                },
                precision: function precision() {
                  const precisions = [this.min, this.max, this.step].map((item) => {
                    const decimal = (`${item}`).split('.')[1];
                    return decimal ? decimal.length : 0;
                  });
                  return Math.max.apply(null, precisions);
                },
                runwayStyle: function runwayStyle() {
                  return this.vertical ? { height: this.height } : {};
                },
                barStyle: function barStyle() {
                  return this.vertical ? {
                    height: this.barSize,
                    bottom: this.barStart,
                  } : {
                    width: this.barSize,
                    left: this.barStart,
                  };
                },
                sliderDisabled: function sliderDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
              },

              mounted: function mounted() {
                let valuetext = void 0;
                if (this.range) {
                  if (Array.isArray(this.value)) {
                    this.firstValue = Math.max(this.min, this.value[0]);
                    this.secondValue = Math.min(this.max, this.value[1]);
                  } else {
                    this.firstValue = this.min;
                    this.secondValue = this.max;
                  }
                  this.oldValue = [this.firstValue, this.secondValue];
                  valuetext = `${this.firstValue}-${this.secondValue}`;
                } else {
                  if (typeof this.value !== 'number' || isNaN(this.value)) {
                    this.firstValue = this.min;
                  } else {
                    this.firstValue = Math.min(this.max, Math.max(this.min, this.value));
                  }
                  this.oldValue = this.firstValue;
                  valuetext = this.firstValue;
                }
                this.$el.setAttribute('aria-valuetext', valuetext);

                // label screen reader
                this.$el.setAttribute('aria-label', this.label ? this.label : `slider between ${this.min} and ${this.max}`);

                this.resetSize();
                window.addEventListener('resize', this.resetSize);
              },
              beforeDestroy: function beforeDestroy() {
                window.removeEventListener('resize', this.resetSize);
              },
            });
            // CONCATENATED MODULE: ./packages/slider/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_slider_src_mainvue_type_script_lang_js_ = (slider_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/slider/src/main.vue

            /* normalize component */

            const slider_src_main_component = normalizeComponent(
              packages_slider_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_32708644_render,
              mainvue_type_template_id_32708644_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let slider_src_main_api; }
            slider_src_main_component.options.__file = 'packages/slider/src/main.vue';
            /* harmony default export */ const slider_src_main = (slider_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/slider/index.js

            /* istanbul ignore next */
            slider_src_main.install = function (Vue) {
              Vue.component(slider_src_main.name, slider_src_main);
            };

            /* harmony default export */ const slider = (slider_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/loading/src/loading.vue?vue&type=template&id=eee0a7ac&
            const loadingvue_type_template_id_eee0a7ac_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                {
                  attrs: { name: 'el-loading-fade' },
                  on: { 'after-leave': _vm.handleAfterLeave },
                },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.visible,
                          expression: 'visible',
                        },
                      ],
                      staticClass: 'el-loading-mask',
                      class: [_vm.customClass, { 'is-fullscreen': _vm.fullscreen }],
                      style: { backgroundColor: _vm.background || '' },
                    },
                    [
                      _c('div', { staticClass: 'el-loading-spinner' }, [
                        !_vm.spinner
                          ? _c(
                            'svg',
                            {
                              staticClass: 'circular',
                              attrs: { viewBox: '25 25 50 50' },
                            },
                            [
                              _c('circle', {
                                staticClass: 'path',
                                attrs: {
                                  cx: '50', cy: '50', r: '20', fill: 'none',
                                },
                              }),
                            ],
                          )
                          : _c('i', { class: _vm.spinner }),
                        _vm.text
                          ? _c('p', { staticClass: 'el-loading-text' }, [
                            _vm._v(_vm._s(_vm.text)),
                          ])
                          : _vm._e(),
                      ]),
                    ],
                  ),
                ],
              );
            };
            const loadingvue_type_template_id_eee0a7ac_staticRenderFns = [];
            loadingvue_type_template_id_eee0a7ac_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/loading/src/loading.vue?vue&type=template&id=eee0a7ac&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/loading/src/loading.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const loadingvue_type_script_lang_js_ = ({
              data: function data() {
                return {
                  text: null,
                  spinner: null,
                  background: null,
                  fullscreen: true,
                  visible: false,
                  customClass: '',
                };
              },

              methods: {
                handleAfterLeave: function handleAfterLeave() {
                  this.$emit('after-leave');
                },
                setText: function setText(text) {
                  this.text = text;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/loading/src/loading.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_loadingvue_type_script_lang_js_ = (loadingvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/loading/src/loading.vue

            /* normalize component */

            const loading_component = normalizeComponent(
              src_loadingvue_type_script_lang_js_,
              loadingvue_type_template_id_eee0a7ac_render,
              loadingvue_type_template_id_eee0a7ac_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let loading_api; }
            loading_component.options.__file = 'packages/loading/src/loading.vue';
            /* harmony default export */ const loading = (loading_component.exports);
            // EXTERNAL MODULE: external "element-ui/lib/utils/after-leave"
            const after_leave_ = __webpack_require__(32);
            const after_leave_default = /* #__PURE__ */__webpack_require__.n(after_leave_);

            // CONCATENATED MODULE: ./packages/loading/src/directive.js

            const Mask = external_vue_default.a.extend(loading);

            const loadingDirective = {};
            loadingDirective.install = function (Vue) {
              if (Vue.prototype.$isServer) return;
              const toggleLoading = function toggleLoading(el, binding) {
                if (binding.value) {
                  Vue.nextTick(() => {
                    if (binding.modifiers.fullscreen) {
                      el.originalPosition = Object(dom_.getStyle)(document.body, 'position');
                      el.originalOverflow = Object(dom_.getStyle)(document.body, 'overflow');
                      el.maskStyle.zIndex = popup_.PopupManager.nextZIndex();

                      Object(dom_.addClass)(el.mask, 'is-fullscreen');
                      insertDom(document.body, el, binding);
                    } else {
                      Object(dom_.removeClass)(el.mask, 'is-fullscreen');

                      if (binding.modifiers.body) {
                        el.originalPosition = Object(dom_.getStyle)(document.body, 'position');

                        ['top', 'left'].forEach((property) => {
                          const scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
                          el.maskStyle[property] = `${el.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] - parseInt(Object(dom_.getStyle)(document.body, `margin-${property}`), 10)}px`;
                        });
                        ['height', 'width'].forEach((property) => {
                          el.maskStyle[property] = `${el.getBoundingClientRect()[property]}px`;
                        });

                        insertDom(document.body, el, binding);
                      } else {
                        el.originalPosition = Object(dom_.getStyle)(el, 'position');
                        insertDom(el, el, binding);
                      }
                    }
                  });
                } else {
                  after_leave_default()(el.instance, (_) => {
                    if (!el.instance.hiding) return;
                    el.domVisible = false;
                    const target = binding.modifiers.fullscreen || binding.modifiers.body ? document.body : el;
                    Object(dom_.removeClass)(target, 'el-loading-parent--relative');
                    Object(dom_.removeClass)(target, 'el-loading-parent--hidden');
                    el.instance.hiding = false;
                  }, 300, true);
                  el.instance.visible = false;
                  el.instance.hiding = true;
                }
              };
              var insertDom = function insertDom(parent, el, binding) {
                if (!el.domVisible && Object(dom_.getStyle)(el, 'display') !== 'none' && Object(dom_.getStyle)(el, 'visibility') !== 'hidden') {
                  Object.keys(el.maskStyle).forEach((property) => {
                    el.mask.style[property] = el.maskStyle[property];
                  });

                  if (el.originalPosition !== 'absolute' && el.originalPosition !== 'fixed') {
                    Object(dom_.addClass)(parent, 'el-loading-parent--relative');
                  }
                  if (binding.modifiers.fullscreen && binding.modifiers.lock) {
                    Object(dom_.addClass)(parent, 'el-loading-parent--hidden');
                  }
                  el.domVisible = true;

                  parent.appendChild(el.mask);
                  Vue.nextTick(() => {
                    if (el.instance.hiding) {
                      el.instance.$emit('after-leave');
                    } else {
                      el.instance.visible = true;
                    }
                  });
                  el.domInserted = true;
                } else if (el.domVisible && el.instance.hiding === true) {
                  el.instance.visible = true;
                  el.instance.hiding = false;
                }
              };

              Vue.directive('loading', {
                bind: function bind(el, binding, vnode) {
                  const textExr = el.getAttribute('element-loading-text');
                  const spinnerExr = el.getAttribute('element-loading-spinner');
                  const backgroundExr = el.getAttribute('element-loading-background');
                  const customClassExr = el.getAttribute('element-loading-custom-class');
                  const vm = vnode.context;
                  const mask = new Mask({
                    el: document.createElement('div'),
                    data: {
                      text: vm && vm[textExr] || textExr,
                      spinner: vm && vm[spinnerExr] || spinnerExr,
                      background: vm && vm[backgroundExr] || backgroundExr,
                      customClass: vm && vm[customClassExr] || customClassExr,
                      fullscreen: !!binding.modifiers.fullscreen,
                    },
                  });
                  el.instance = mask;
                  el.mask = mask.$el;
                  el.maskStyle = {};

                  binding.value && toggleLoading(el, binding);
                },

                update: function update(el, binding) {
                  el.instance.setText(el.getAttribute('element-loading-text'));
                  if (binding.oldValue !== binding.value) {
                    toggleLoading(el, binding);
                  }
                },

                unbind: function unbind(el, binding) {
                  if (el.domInserted) {
                    el.mask && el.mask.parentNode && el.mask.parentNode.removeChild(el.mask);
                    toggleLoading(el, { value: false, modifiers: binding.modifiers });
                  }
                  el.instance && el.instance.$destroy();
                },
              });
            };

            /* harmony default export */ const src_directive = (loadingDirective);
            // CONCATENATED MODULE: ./packages/loading/src/index.js

            const LoadingConstructor = external_vue_default.a.extend(loading);

            const src_defaults = {
              text: null,
              fullscreen: true,
              body: false,
              lock: false,
              customClass: '',
            };

            let fullscreenLoading = void 0;

            LoadingConstructor.prototype.originalPosition = '';
            LoadingConstructor.prototype.originalOverflow = '';

            LoadingConstructor.prototype.close = function () {
              const _this = this;

              if (this.fullscreen) {
                fullscreenLoading = undefined;
              }
              after_leave_default()(this, (_) => {
                const target = _this.fullscreen || _this.body ? document.body : _this.target;
                Object(dom_.removeClass)(target, 'el-loading-parent--relative');
                Object(dom_.removeClass)(target, 'el-loading-parent--hidden');
                if (_this.$el && _this.$el.parentNode) {
                  _this.$el.parentNode.removeChild(_this.$el);
                }
                _this.$destroy();
              }, 300);
              this.visible = false;
            };

            const src_addStyle = function addStyle(options, parent, instance) {
              const maskStyle = {};
              if (options.fullscreen) {
                instance.originalPosition = Object(dom_.getStyle)(document.body, 'position');
                instance.originalOverflow = Object(dom_.getStyle)(document.body, 'overflow');
                maskStyle.zIndex = popup_.PopupManager.nextZIndex();
              } else if (options.body) {
                instance.originalPosition = Object(dom_.getStyle)(document.body, 'position');
                ['top', 'left'].forEach((property) => {
                  const scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
                  maskStyle[property] = `${options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll]}px`;
                });
                ['height', 'width'].forEach((property) => {
                  maskStyle[property] = `${options.target.getBoundingClientRect()[property]}px`;
                });
              } else {
                instance.originalPosition = Object(dom_.getStyle)(parent, 'position');
              }
              Object.keys(maskStyle).forEach((property) => {
                instance.$el.style[property] = maskStyle[property];
              });
            };

            const src_Loading = function Loading() {
              let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              if (external_vue_default.a.prototype.$isServer) return;
              options = merge_default()({}, src_defaults, options);
              if (typeof options.target === 'string') {
                options.target = document.querySelector(options.target);
              }
              options.target = options.target || document.body;
              if (options.target !== document.body) {
                options.fullscreen = false;
              } else {
                options.body = true;
              }
              if (options.fullscreen && fullscreenLoading) {
                return fullscreenLoading;
              }

              const parent = options.body ? document.body : options.target;
              const instance = new LoadingConstructor({
                el: document.createElement('div'),
                data: options,
              });

              src_addStyle(options, parent, instance);
              if (instance.originalPosition !== 'absolute' && instance.originalPosition !== 'fixed') {
                Object(dom_.addClass)(parent, 'el-loading-parent--relative');
              }
              if (options.fullscreen && options.lock) {
                Object(dom_.addClass)(parent, 'el-loading-parent--hidden');
              }
              parent.appendChild(instance.$el);
              external_vue_default.a.nextTick(() => {
                instance.visible = true;
              });
              if (options.fullscreen) {
                fullscreenLoading = instance;
              }
              return instance;
            };

            /* harmony default export */ const src = (src_Loading);
            // CONCATENATED MODULE: ./packages/loading/index.js

            /* harmony default export */ const packages_loading = ({
              install: function install(Vue) {
                Vue.use(src_directive);
                Vue.prototype.$loading = src;
              },

              directive: src_directive,
              service: src,
            });
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/icon/src/icon.vue?vue&type=template&id=cb3fe7f4&
            const iconvue_type_template_id_cb3fe7f4_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('i', { class: `el-icon-${_vm.name}` });
            };
            const iconvue_type_template_id_cb3fe7f4_staticRenderFns = [];
            iconvue_type_template_id_cb3fe7f4_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/icon/src/icon.vue?vue&type=template&id=cb3fe7f4&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/icon/src/icon.vue?vue&type=script&lang=js&
            //
            //
            //
            //

            /* harmony default export */ const iconvue_type_script_lang_js_ = ({
              name: 'ElIcon',

              props: {
                name: String,
              },
            });
            // CONCATENATED MODULE: ./packages/icon/src/icon.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_iconvue_type_script_lang_js_ = (iconvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/icon/src/icon.vue

            /* normalize component */

            const icon_component = normalizeComponent(
              src_iconvue_type_script_lang_js_,
              iconvue_type_template_id_cb3fe7f4_render,
              iconvue_type_template_id_cb3fe7f4_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let icon_api; }
            icon_component.options.__file = 'packages/icon/src/icon.vue';
            /* harmony default export */ const icon = (icon_component.exports);
            // CONCATENATED MODULE: ./packages/icon/index.js

            /* istanbul ignore next */
            icon.install = function (Vue) {
              Vue.component(icon.name, icon);
            };

            /* harmony default export */ const packages_icon = (icon);
            // CONCATENATED MODULE: ./packages/row/src/row.js
            /* harmony default export */ const src_row = ({
              name: 'ElRow',

              componentName: 'ElRow',

              props: {
                tag: {
                  type: String,
                  default: 'div',
                },
                gutter: Number,
                type: String,
                justify: {
                  type: String,
                  default: 'start',
                },
                align: {
                  type: String,
                  default: 'top',
                },
              },

              computed: {
                style: function style() {
                  const ret = {};

                  if (this.gutter) {
                    ret.marginLeft = `-${this.gutter / 2}px`;
                    ret.marginRight = ret.marginLeft;
                  }

                  return ret;
                },
              },

              render: function render(h) {
                return h(this.tag, {
                  class: ['el-row', this.justify !== 'start' ? `is-justify-${this.justify}` : '', this.align !== 'top' ? `is-align-${this.align}` : '', { 'el-row--flex': this.type === 'flex' }],
                  style: this.style,
                }, this.$slots.default);
              },
            });
            // CONCATENATED MODULE: ./packages/row/index.js

            /* istanbul ignore next */
            src_row.install = function (Vue) {
              Vue.component(src_row.name, src_row);
            };

            /* harmony default export */ const packages_row = (src_row);
            // CONCATENATED MODULE: ./packages/col/src/col.js
            const col_typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

            /* harmony default export */ const col = ({
              name: 'ElCol',

              props: {
                span: {
                  type: Number,
                  default: 24,
                },
                tag: {
                  type: String,
                  default: 'div',
                },
                offset: Number,
                pull: Number,
                push: Number,
                xs: [Number, Object],
                sm: [Number, Object],
                md: [Number, Object],
                lg: [Number, Object],
                xl: [Number, Object],
              },

              computed: {
                gutter: function gutter() {
                  let parent = this.$parent;
                  while (parent && parent.$options.componentName !== 'ElRow') {
                    parent = parent.$parent;
                  }
                  return parent ? parent.gutter : 0;
                },
              },
              render: function render(h) {
                const _this = this;

                const classList = [];
                const style = {};

                if (this.gutter) {
                  style.paddingLeft = `${this.gutter / 2}px`;
                  style.paddingRight = style.paddingLeft;
                }

                ['span', 'offset', 'pull', 'push'].forEach((prop) => {
                  if (_this[prop] || _this[prop] === 0) {
                    classList.push(prop !== 'span' ? `el-col-${prop}-${_this[prop]}` : `el-col-${_this[prop]}`);
                  }
                });

                ['xs', 'sm', 'md', 'lg', 'xl'].forEach((size) => {
                  if (typeof _this[size] === 'number') {
                    classList.push(`el-col-${size}-${_this[size]}`);
                  } else if (col_typeof(_this[size]) === 'object') {
                    const props = _this[size];
                    Object.keys(props).forEach((prop) => {
                      classList.push(prop !== 'span' ? `el-col-${size}-${prop}-${props[prop]}` : `el-col-${size}-${props[prop]}`);
                    });
                  }
                });

                return h(this.tag, {
                  class: ['el-col', classList],
                  style,
                }, this.$slots.default);
              },
            });
            // CONCATENATED MODULE: ./packages/col/index.js

            /* istanbul ignore next */
            col.install = function (Vue) {
              Vue.component(col.name, col);
            };

            /* harmony default export */ const packages_col = (col);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/upload-list.vue?vue&type=template&id=173fedf5&
            const upload_listvue_type_template_id_173fedf5_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition-group',
                {
                  class: [
                    'el-upload-list',
                    `el-upload-list--${_vm.listType}`,
                    { 'is-disabled': _vm.disabled },
                  ],
                  attrs: { tag: 'ul', name: 'el-list' },
                },
                _vm._l(_vm.files, (file) => _c(
                  'li',
                  {
                    key: file.uid,
                    class: [
                      'el-upload-list__item',
                      `is-${  file.status}`,
                      _vm.focusing ? 'focusing' : '',
                    ],
                    attrs: { tabindex: '0' },
                    on: {
                      keydown($event) {
                        if (
                          !('button' in $event)
                && _vm._k($event.keyCode, 'delete', [8, 46], $event.key, [
                  'Backspace',
                  'Delete',
                  'Del',
                ])
                        ) {
                          return null;
                        }
                        !_vm.disabled && _vm.$emit('remove', file);
                      },
                      focus($event) {
                        _vm.focusing = true;
                      },
                      blur($event) {
                        _vm.focusing = false;
                      },
                      click($event) {
                        _vm.focusing = false;
                      },
                    },
                  },
                  [
                    _vm._t(
                      'default',
                      [
                        file.status !== 'uploading'
              && ['picture-card', 'picture'].indexOf(_vm.listType) > -1
                          ? _c('img', {
                            staticClass: 'el-upload-list__item-thumbnail',
                            attrs: { src: file.url, alt: '' },
                          })
                          : _vm._e(),
                        _c(
                          'a',
                          {
                            staticClass: 'el-upload-list__item-name',
                            on: {
                              click($event) {
                                _vm.handleClick(file);
                              },
                            },
                          },
                          [
                            _c('i', { staticClass: 'el-icon-document' }),
                            _vm._v(`${_vm._s(file.name)}\n      `),
                          ],
                        ),
                        _c(
                          'label',
                          { staticClass: 'el-upload-list__item-status-label' },
                          [
                            _c('i', {
                              class: {
                                'el-icon-upload-success': true,
                                'el-icon-circle-check': _vm.listType === 'text',
                                'el-icon-check':
                        ['picture-card', 'picture'].indexOf(_vm.listType) > -1,
                              },
                            }),
                          ],
                        ),
                        !_vm.disabled
                          ? _c('i', {
                            staticClass: 'el-icon-close',
                            on: {
                              click($event) {
                                _vm.$emit('remove', file);
                              },
                            },
                          })
                          : _vm._e(),
                        !_vm.disabled
                          ? _c('i', { staticClass: 'el-icon-close-tip' }, [
                            _vm._v(_vm._s(_vm.t('el.upload.deleteTip'))),
                          ])
                          : _vm._e(),
                        file.status === 'uploading'
                          ? _c('el-progress', {
                            attrs: {
                              type: _vm.listType === 'picture-card' ? 'circle' : 'line',
                              'stroke-width': _vm.listType === 'picture-card' ? 6 : 2,
                              percentage: _vm.parsePercentage(file.percentage),
                            },
                          })
                          : _vm._e(),
                        _vm.listType === 'picture-card'
                          ? _c('span', { staticClass: 'el-upload-list__item-actions' }, [
                            _vm.handlePreview && _vm.listType === 'picture-card'
                              ? _c(
                                'span',
                                {
                                  staticClass: 'el-upload-list__item-preview',
                                  on: {
                                    click($event) {
                                      _vm.handlePreview(file);
                                    },
                                  },
                                },
                                [_c('i', { staticClass: 'el-icon-zoom-in' })],
                              )
                              : _vm._e(),
                            !_vm.disabled
                              ? _c(
                                'span',
                                {
                                  staticClass: 'el-upload-list__item-delete',
                                  on: {
                                    click($event) {
                                      _vm.$emit('remove', file);
                                    },
                                  },
                                },
                                [_c('i', { staticClass: 'el-icon-delete' })],
                              )
                              : _vm._e(),
                          ])
                          : _vm._e(),
                      ],
                      { file },
                    ),
                  ],
                  2,
                )),
                0,
              );
            };
            const upload_listvue_type_template_id_173fedf5_staticRenderFns = [];
            upload_listvue_type_template_id_173fedf5_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/upload/src/upload-list.vue?vue&type=template&id=173fedf5&

            // EXTERNAL MODULE: external "element-ui/lib/progress"
            const progress_ = __webpack_require__(33);
            const progress_default = /* #__PURE__ */__webpack_require__.n(progress_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/upload-list.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const upload_listvue_type_script_lang_js_ = ({

              name: 'ElUploadList',

              mixins: [locale_default.a],

              data: function data() {
                return {
                  focusing: false,
                };
              },

              components: { ElProgress: progress_default.a },

              props: {
                files: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                disabled: {
                  type: Boolean,
                  default: false,
                },
                handlePreview: Function,
                listType: String,
              },
              methods: {
                parsePercentage: function parsePercentage(val) {
                  return parseInt(val, 10);
                },
                handleClick: function handleClick(file) {
                  this.handlePreview && this.handlePreview(file);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/upload/src/upload-list.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_upload_listvue_type_script_lang_js_ = (upload_listvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/upload/src/upload-list.vue

            /* normalize component */

            const upload_list_component = normalizeComponent(
              src_upload_listvue_type_script_lang_js_,
              upload_listvue_type_template_id_173fedf5_render,
              upload_listvue_type_template_id_173fedf5_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let upload_list_api; }
            upload_list_component.options.__file = 'packages/upload/src/upload-list.vue';
            /* harmony default export */ const upload_list = (upload_list_component.exports);
            // EXTERNAL MODULE: external "babel-helper-vue-jsx-merge-props"
            const external_babel_helper_vue_jsx_merge_props_ = __webpack_require__(24);
            const external_babel_helper_vue_jsx_merge_props_default = /* #__PURE__ */__webpack_require__.n(external_babel_helper_vue_jsx_merge_props_);

            // CONCATENATED MODULE: ./packages/upload/src/ajax.js
            function getError(action, option, xhr) {
              let msg = void 0;
              if (xhr.response) {
                msg = `${xhr.response.error || xhr.response}`;
              } else if (xhr.responseText) {
                msg = `${xhr.responseText}`;
              } else {
                msg = `fail to post ${action} ${xhr.status}`;
              }

              const err = new Error(msg);
              err.status = xhr.status;
              err.method = 'post';
              err.url = action;
              return err;
            }

            function getBody(xhr) {
              const text = xhr.responseText || xhr.response;
              if (!text) {
                return text;
              }

              try {
                return JSON.parse(text);
              } catch (e) {
                return text;
              }
            }

            function upload(option) {
              if (typeof XMLHttpRequest === 'undefined') {
                return;
              }

              const xhr = new XMLHttpRequest();
              const { action } = option;

              if (xhr.upload) {
                xhr.upload.onprogress = function progress(e) {
                  if (e.total > 0) {
                    e.percent = e.loaded / e.total * 100;
                  }
                  option.onProgress(e);
                };
              }

              const formData = new FormData();

              if (option.data) {
                Object.keys(option.data).forEach((key) => {
                  formData.append(key, option.data[key]);
                });
              }

              formData.append(option.filename, option.file, option.file.name);

              xhr.onerror = function error(e) {
                option.onError(e);
              };

              xhr.onload = function onload() {
                if (xhr.status < 200 || xhr.status >= 300) {
                  return option.onError(getError(action, option, xhr));
                }

                option.onSuccess(getBody(xhr));
              };

              xhr.open('post', action, true);

              if (option.withCredentials && 'withCredentials' in xhr) {
                xhr.withCredentials = true;
              }

              const headers = option.headers || {};

              for (const item in headers) {
                if (headers.hasOwnProperty(item) && headers[item] !== null) {
                  xhr.setRequestHeader(item, headers[item]);
                }
              }
              xhr.send(formData);
              return xhr;
            }
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/upload-dragger.vue?vue&type=template&id=7ebbf219&
            const upload_draggervue_type_template_id_7ebbf219_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-upload-dragger',
                  class: {
                    'is-dragover': _vm.dragover,
                  },
                  on: {
                    drop($event) {
                      $event.preventDefault();
                      return _vm.onDrop($event);
                    },
                    dragover($event) {
                      $event.preventDefault();
                      return _vm.onDragover($event);
                    },
                    dragleave($event) {
                      $event.preventDefault();
                      _vm.dragover = false;
                    },
                  },
                },
                [_vm._t('default')],
                2,
              );
            };
            const upload_draggervue_type_template_id_7ebbf219_staticRenderFns = [];
            upload_draggervue_type_template_id_7ebbf219_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/upload/src/upload-dragger.vue?vue&type=template&id=7ebbf219&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/upload-dragger.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const upload_draggervue_type_script_lang_js_ = ({
              name: 'ElUploadDrag',
              props: {
                disabled: Boolean,
              },
              inject: {
                uploader: {
                  default: '',
                },
              },
              data: function data() {
                return {
                  dragover: false,
                };
              },

              methods: {
                onDragover: function onDragover() {
                  if (!this.disabled) {
                    this.dragover = true;
                  }
                },
                onDrop: function onDrop(e) {
                  if (this.disabled || !this.uploader) return;
                  const { accept } = this.uploader;
                  this.dragover = false;
                  if (!accept) {
                    this.$emit('file', e.dataTransfer.files);
                    return;
                  }
                  this.$emit('file', [].slice.call(e.dataTransfer.files).filter((file) => {
                    const { type } = file;
                    let { name } = file;

                    const extension = name.indexOf('.') > -1 ? `.${name.split('.').pop()}` : '';
                    const baseType = type.replace(/\/.*$/, '');
                    return accept.split(',').map((type) => type.trim()).filter((type) => type).some((acceptedType) => {
                      if (/\..+$/.test(acceptedType)) {
                        return extension === acceptedType;
                      }
                      if (/\/\*$/.test(acceptedType)) {
                        return baseType === acceptedType.replace(/\/\*$/, '');
                      }
                      if (/^[^\/]+\/[^\/]+$/.test(acceptedType)) {
                        return type === acceptedType;
                      }
                      return false;
                    });
                  }));
                },
              },
            });
            // CONCATENATED MODULE: ./packages/upload/src/upload-dragger.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_upload_draggervue_type_script_lang_js_ = (upload_draggervue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/upload/src/upload-dragger.vue

            /* normalize component */

            const upload_dragger_component = normalizeComponent(
              src_upload_draggervue_type_script_lang_js_,
              upload_draggervue_type_template_id_7ebbf219_render,
              upload_draggervue_type_template_id_7ebbf219_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let upload_dragger_api; }
            upload_dragger_component.options.__file = 'packages/upload/src/upload-dragger.vue';
            /* harmony default export */ const upload_dragger = (upload_dragger_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/upload.vue?vue&type=script&lang=js&

            /* harmony default export */ const uploadvue_type_script_lang_js_ = ({
              inject: ['uploader'],
              components: {
                UploadDragger: upload_dragger,
              },
              props: {
                type: String,
                action: {
                  type: String,
                  required: true,
                },
                name: {
                  type: String,
                  default: 'file',
                },
                data: Object,
                headers: Object,
                withCredentials: Boolean,
                multiple: Boolean,
                accept: String,
                onStart: Function,
                onProgress: Function,
                onSuccess: Function,
                onError: Function,
                beforeUpload: Function,
                drag: Boolean,
                onPreview: {
                  type: Function,
                  default: function _default() {},
                },
                onRemove: {
                  type: Function,
                  default: function _default() {},
                },
                fileList: Array,
                autoUpload: Boolean,
                listType: String,
                httpRequest: {
                  type: Function,
                  default: upload,
                },
                disabled: Boolean,
                limit: Number,
                onExceed: Function,
              },

              data: function data() {
                return {
                  mouseover: false,
                  reqs: {},
                };
              },

              methods: {
                isImage: function isImage(str) {
                  return str.indexOf('image') !== -1;
                },
                handleChange: function handleChange(ev) {
                  const { files } = ev.target;

                  if (!files) return;
                  this.uploadFiles(files);
                },
                uploadFiles: function uploadFiles(files) {
                  const _this = this;

                  if (this.limit && this.fileList.length + files.length > this.limit) {
                    this.onExceed && this.onExceed(files, this.fileList);
                    return;
                  }

                  let postFiles = Array.prototype.slice.call(files);
                  if (!this.multiple) {
                    postFiles = postFiles.slice(0, 1);
                  }

                  if (postFiles.length === 0) {
                    return;
                  }

                  postFiles.forEach((rawFile) => {
                    _this.onStart(rawFile);
                    if (_this.autoUpload) _this.upload(rawFile);
                  });
                },
                upload: function upload(rawFile) {
                  const _this2 = this;

                  this.$refs.input.value = null;

                  if (!this.beforeUpload) {
                    return this.post(rawFile);
                  }

                  const before = this.beforeUpload(rawFile);
                  if (before && before.then) {
                    before.then((processedFile) => {
                      const fileType = Object.prototype.toString.call(processedFile);

                      if (fileType === '[object File]' || fileType === '[object Blob]') {
                        if (fileType === '[object Blob]') {
                          processedFile = new File([processedFile], rawFile.name, {
                            type: rawFile.type,
                          });
                        }
                        for (const p in rawFile) {
                          if (rawFile.hasOwnProperty(p)) {
                            processedFile[p] = rawFile[p];
                          }
                        }
                        _this2.post(processedFile);
                      } else {
                        _this2.post(rawFile);
                      }
                    }, () => {
                      _this2.onRemove(null, rawFile);
                    });
                  } else if (before !== false) {
                    this.post(rawFile);
                  } else {
                    this.onRemove(null, rawFile);
                  }
                },
                abort: function abort(file) {
                  const { reqs } = this;

                  if (file) {
                    let uid = file;
                    if (file.uid) uid = file.uid;
                    if (reqs[uid]) {
                      reqs[uid].abort();
                    }
                  } else {
                    Object.keys(reqs).forEach((uid) => {
                      if (reqs[uid]) reqs[uid].abort();
                      delete reqs[uid];
                    });
                  }
                },
                post: function post(rawFile) {
                  const _this3 = this;

                  const { uid } = rawFile;

                  const options = {
                    headers: this.headers,
                    withCredentials: this.withCredentials,
                    file: rawFile,
                    data: this.data,
                    filename: this.name,
                    action: this.action,
                    onProgress: function onProgress(e) {
                      _this3.onProgress(e, rawFile);
                    },
                    onSuccess: function onSuccess(res) {
                      _this3.onSuccess(res, rawFile);
                      delete _this3.reqs[uid];
                    },
                    onError: function onError(err) {
                      _this3.onError(err, rawFile);
                      delete _this3.reqs[uid];
                    },
                  };
                  const req = this.httpRequest(options);
                  this.reqs[uid] = req;
                  if (req && req.then) {
                    req.then(options.onSuccess, options.onError);
                  }
                },
                handleClick: function handleClick() {
                  if (!this.disabled) {
                    this.$refs.input.value = null;
                    this.$refs.input.click();
                  }
                },
                handleKeydown: function handleKeydown(e) {
                  if (e.target !== e.currentTarget) return;
                  if (e.keyCode === 13 || e.keyCode === 32) {
                    this.handleClick();
                  }
                },
              },

              render: function render(h) {
                const { handleClick } = this;
                const { drag } = this;
                const { name } = this;
                const { handleChange } = this;
                const { multiple } = this;
                const { accept } = this;
                const { listType } = this;
                const { uploadFiles } = this;
                const { disabled } = this;
                const { handleKeydown } = this;

                const data = {
                  class: {
                    'el-upload': true,
                  },
                  on: {
                    click: handleClick,
                    keydown: handleKeydown,
                  },
                };
                data.class[`el-upload--${listType}`] = true;
                return h(
                  'div',
                  external_babel_helper_vue_jsx_merge_props_default()([data, {
                    attrs: { tabindex: '0' },
                  }]),
                  [drag ? h(
                    'upload-dragger',
                    {
                      attrs: { disabled },
                      on: {
                        file: uploadFiles,
                      },
                    },
                    [this.$slots.default],
                  ) : this.$slots.default, h('input', {
                    class: 'el-upload__input',
                    attrs: {
                      type: 'file', name, multiple, accept,
                    },
                    ref: 'input',
                    on: {
                      change: handleChange,
                    },
                  })],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/upload/src/upload.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_uploadvue_type_script_lang_js_ = (uploadvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/upload/src/upload.vue
            let upload_render; let
              upload_staticRenderFns;

            /* normalize component */

            const upload_component = normalizeComponent(
              src_uploadvue_type_script_lang_js_,
              upload_render,
              upload_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let upload_api; }
            upload_component.options.__file = 'packages/upload/src/upload.vue';
            /* harmony default export */ const src_upload = (upload_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/index.vue?vue&type=script&lang=js&

            function srcvue_type_script_lang_js_noop() {}

            /* harmony default export */ const srcvue_type_script_lang_js_ = ({
              name: 'ElUpload',

              mixins: [migrating_default.a],

              components: {
                ElProgress: progress_default.a,
                UploadList: upload_list,
                Upload: src_upload,
              },

              provide: function provide() {
                return {
                  uploader: this,
                };
              },

              inject: {
                elForm: {
                  default: '',
                },
              },

              props: {
                action: {
                  type: String,
                  required: true,
                },
                headers: {
                  type: Object,
                  default: function _default() {
                    return {};
                  },
                },
                data: Object,
                multiple: Boolean,
                name: {
                  type: String,
                  default: 'file',
                },
                drag: Boolean,
                dragger: Boolean,
                withCredentials: Boolean,
                showFileList: {
                  type: Boolean,
                  default: true,
                },
                accept: String,
                type: {
                  type: String,
                  default: 'select',
                },
                beforeUpload: Function,
                beforeRemove: Function,
                onRemove: {
                  type: Function,
                  default: srcvue_type_script_lang_js_noop,
                },
                onChange: {
                  type: Function,
                  default: srcvue_type_script_lang_js_noop,
                },
                onPreview: {
                  type: Function,
                },
                onSuccess: {
                  type: Function,
                  default: srcvue_type_script_lang_js_noop,
                },
                onProgress: {
                  type: Function,
                  default: srcvue_type_script_lang_js_noop,
                },
                onError: {
                  type: Function,
                  default: srcvue_type_script_lang_js_noop,
                },
                fileList: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                autoUpload: {
                  type: Boolean,
                  default: true,
                },
                listType: {
                  type: String,
                  default: 'text', // text,picture,picture-card
                },
                httpRequest: Function,
                disabled: Boolean,
                limit: Number,
                onExceed: {
                  type: Function,
                  default: srcvue_type_script_lang_js_noop,
                },
              },

              data: function data() {
                return {
                  uploadFiles: [],
                  dragOver: false,
                  draging: false,
                  tempIndex: 1,
                };
              },

              computed: {
                uploadDisabled: function uploadDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
              },

              watch: {
                listType: function listType(type) {
                  if (type === 'picture-card' || type === 'picture') {
                    this.uploadFiles = this.uploadFiles.map((file) => {
                      if (!file.url && file.raw) {
                        try {
                          file.url = URL.createObjectURL(file.raw);
                        } catch (err) {
                          console.error('[Element Error][Upload]', err);
                        }
                      }
                      return file;
                    });
                  }
                },

                fileList: {
                  immediate: true,
                  handler: function handler(fileList) {
                    const _this = this;

                    this.uploadFiles = fileList.map((item) => {
                      item.uid = item.uid || Date.now() + _this.tempIndex++;
                      item.status = item.status || 'success';
                      return item;
                    });
                  },
                },
              },

              methods: {
                handleStart: function handleStart(rawFile) {
                  rawFile.uid = Date.now() + this.tempIndex++;
                  const file = {
                    status: 'ready',
                    name: rawFile.name,
                    size: rawFile.size,
                    percentage: 0,
                    uid: rawFile.uid,
                    raw: rawFile,
                  };

                  if (this.listType === 'picture-card' || this.listType === 'picture') {
                    try {
                      file.url = URL.createObjectURL(rawFile);
                    } catch (err) {
                      console.error('[Element Error][Upload]', err);
                      return;
                    }
                  }

                  this.uploadFiles.push(file);
                  this.onChange(file, this.uploadFiles);
                },
                handleProgress: function handleProgress(ev, rawFile) {
                  const file = this.getFile(rawFile);
                  this.onProgress(ev, file, this.uploadFiles);
                  file.status = 'uploading';
                  file.percentage = ev.percent || 0;
                },
                handleSuccess: function handleSuccess(res, rawFile) {
                  const file = this.getFile(rawFile);

                  if (file) {
                    file.status = 'success';
                    file.response = res;

                    this.onSuccess(res, file, this.uploadFiles);
                    this.onChange(file, this.uploadFiles);
                  }
                },
                handleError: function handleError(err, rawFile) {
                  const file = this.getFile(rawFile);
                  const fileList = this.uploadFiles;

                  file.status = 'fail';

                  fileList.splice(fileList.indexOf(file), 1);

                  this.onError(err, file, this.uploadFiles);
                  this.onChange(file, this.uploadFiles);
                },
                handleRemove: function handleRemove(file, raw) {
                  const _this2 = this;

                  if (raw) {
                    file = this.getFile(raw);
                  }
                  const doRemove = function doRemove() {
                    _this2.abort(file);
                    const fileList = _this2.uploadFiles;
                    fileList.splice(fileList.indexOf(file), 1);
                    _this2.onRemove(file, fileList);
                  };

                  if (!this.beforeRemove) {
                    doRemove();
                  } else if (typeof this.beforeRemove === 'function') {
                    const before = this.beforeRemove(file, this.uploadFiles);
                    if (before && before.then) {
                      before.then(() => {
                        doRemove();
                      }, srcvue_type_script_lang_js_noop);
                    } else if (before !== false) {
                      doRemove();
                    }
                  }
                },
                getFile: function getFile(rawFile) {
                  const fileList = this.uploadFiles;
                  let target = void 0;
                  fileList.every((item) => {
                    target = rawFile.uid === item.uid ? item : null;
                    return !target;
                  });
                  return target;
                },
                abort: function abort(file) {
                  this.$refs['upload-inner'].abort(file);
                },
                clearFiles: function clearFiles() {
                  this.uploadFiles = [];
                },
                submit: function submit() {
                  const _this3 = this;

                  this.uploadFiles.filter((file) => file.status === 'ready').forEach((file) => {
                    _this3.$refs['upload-inner'].upload(file.raw);
                  });
                },
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      'default-file-list': 'default-file-list is renamed to file-list.',
                      'show-upload-list': 'show-upload-list is renamed to show-file-list.',
                      'thumbnail-mode': 'thumbnail-mode has been deprecated, you can implement the same effect according to this case: http://element.eleme.io/#/zh-CN/component/upload#yong-hu-tou-xiang-shang-chuan',
                    },
                  };
                },
              },

              beforeDestroy: function beforeDestroy() {
                this.uploadFiles.forEach((file) => {
                  if (file.url && file.url.indexOf('blob:') === 0) {
                    URL.revokeObjectURL(file.url);
                  }
                });
              },
              render: function render(h) {
                const _this4 = this;

                let uploadList = void 0;

                if (this.showFileList) {
                  uploadList = h(
                    upload_list,
                    {
                      attrs: {
                        disabled: this.uploadDisabled,
                        listType: this.listType,
                        files: this.uploadFiles,

                        handlePreview: this.onPreview,
                      },
                      on: {
                        remove: this.handleRemove,
                      },
                    },
                    [function (props) {
                      if (_this4.$scopedSlots.file) {
                        return _this4.$scopedSlots.file({
                          file: props.file,
                        });
                      }
                    }],
                  );
                }

                const uploadData = {
                  props: {
                    type: this.type,
                    drag: this.drag,
                    action: this.action,
                    multiple: this.multiple,
                    'before-upload': this.beforeUpload,
                    'with-credentials': this.withCredentials,
                    headers: this.headers,
                    name: this.name,
                    data: this.data,
                    accept: this.accept,
                    fileList: this.uploadFiles,
                    autoUpload: this.autoUpload,
                    listType: this.listType,
                    disabled: this.uploadDisabled,
                    limit: this.limit,
                    'on-exceed': this.onExceed,
                    'on-start': this.handleStart,
                    'on-progress': this.handleProgress,
                    'on-success': this.handleSuccess,
                    'on-error': this.handleError,
                    'on-preview': this.onPreview,
                    'on-remove': this.handleRemove,
                    'http-request': this.httpRequest,
                  },
                  ref: 'upload-inner',
                };

                const trigger = this.$slots.trigger || this.$slots.default;
                const uploadComponent = h(
                  'upload',
                  uploadData,
                  [trigger],
                );

                return h('div', [this.listType === 'picture-card' ? uploadList : '', this.$slots.trigger ? [uploadComponent, this.$slots.default] : uploadComponent, this.$slots.tip, this.listType !== 'picture-card' ? uploadList : '']);
              },
            });
            // CONCATENATED MODULE: ./packages/upload/src/index.vue?vue&type=script&lang=js&
            /* harmony default export */ const upload_srcvue_type_script_lang_js_ = (srcvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/upload/src/index.vue
            let src_render; let
              src_staticRenderFns;

            /* normalize component */

            const upload_src_component = normalizeComponent(
              upload_srcvue_type_script_lang_js_,
              src_render,
              src_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let src_api; }
            upload_src_component.options.__file = 'packages/upload/src/index.vue';
            /* harmony default export */ const upload_src = (upload_src_component.exports);
            // CONCATENATED MODULE: ./packages/upload/index.js

            /* istanbul ignore next */
            upload_src.install = function (Vue) {
              Vue.component(upload_src.name, upload_src);
            };

            /* harmony default export */ const packages_upload = (upload_src);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/progress/src/progress.vue?vue&type=template&id=229ee406&
            const progressvue_type_template_id_229ee406_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-progress',
                  class: [
                    `el-progress--${_vm.type}`,
                    _vm.status ? `is-${_vm.status}` : '',
                    {
                      'el-progress--without-text': !_vm.showText,
                      'el-progress--text-inside': _vm.textInside,
                    },
                  ],
                  attrs: {
                    role: 'progressbar',
                    'aria-valuenow': _vm.percentage,
                    'aria-valuemin': '0',
                    'aria-valuemax': '100',
                  },
                },
                [
                  _vm.type === 'line'
                    ? _c('div', { staticClass: 'el-progress-bar' }, [
                      _c(
                        'div',
                        {
                          staticClass: 'el-progress-bar__outer',
                          style: { height: `${_vm.strokeWidth}px` },
                        },
                        [
                          _c(
                            'div',
                            {
                              staticClass: 'el-progress-bar__inner',
                              style: _vm.barStyle,
                            },
                            [
                              _vm.showText && _vm.textInside
                                ? _c(
                                  'div',
                                  { staticClass: 'el-progress-bar__innerText' },
                                  [_vm._v(_vm._s(_vm.content))],
                                )
                                : _vm._e(),
                            ],
                          ),
                        ],
                      ),
                    ])
                    : _c(
                      'div',
                      {
                        staticClass: 'el-progress-circle',
                        style: { height: `${_vm.width}px`, width: `${_vm.width}px` },
                      },
                      [
                        _c('svg', { attrs: { viewBox: '0 0 100 100' } }, [
                          _c('path', {
                            staticClass: 'el-progress-circle__track',
                            style: _vm.trailPathStyle,
                            attrs: {
                              d: _vm.trackPath,
                              stroke: '#e5e9f2',
                              'stroke-width': _vm.relativeStrokeWidth,
                              fill: 'none',
                            },
                          }),
                          _c('path', {
                            staticClass: 'el-progress-circle__path',
                            style: _vm.circlePathStyle,
                            attrs: {
                              d: _vm.trackPath,
                              stroke: _vm.stroke,
                              fill: 'none',
                              'stroke-linecap': _vm.strokeLinecap,
                              'stroke-width': _vm.percentage ? _vm.relativeStrokeWidth : 0,
                            },
                          }),
                        ]),
                      ],
                    ),
                  _vm.showText && !_vm.textInside
                    ? _c(
                      'div',
                      {
                        staticClass: 'el-progress__text',
                        style: { fontSize: `${_vm.progressTextSize}px` },
                      },
                      [
                        !_vm.status
                          ? [_vm._v(_vm._s(_vm.content))]
                          : _c('i', { class: _vm.iconClass }),
                      ],
                      2,
                    )
                    : _vm._e(),
                ],
              );
            };
            const progressvue_type_template_id_229ee406_staticRenderFns = [];
            progressvue_type_template_id_229ee406_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/progress/src/progress.vue?vue&type=template&id=229ee406&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/progress/src/progress.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const progressvue_type_script_lang_js_ = ({
              name: 'ElProgress',
              props: {
                type: {
                  type: String,
                  default: 'line',
                  validator: function validator(val) {
                    return ['line', 'circle', 'dashboard'].indexOf(val) > -1;
                  },
                },
                percentage: {
                  type: Number,
                  default: 0,
                  required: true,
                  validator: function validator(val) {
                    return val >= 0 && val <= 100;
                  },
                },
                status: {
                  type: String,
                  validator: function validator(val) {
                    return ['success', 'exception', 'warning'].indexOf(val) > -1;
                  },
                },
                strokeWidth: {
                  type: Number,
                  default: 6,
                },
                strokeLinecap: {
                  type: String,
                  default: 'round',
                },
                textInside: {
                  type: Boolean,
                  default: false,
                },
                width: {
                  type: Number,
                  default: 126,
                },
                showText: {
                  type: Boolean,
                  default: true,
                },
                color: {
                  type: [String, Array, Function],
                  default: '',
                },
                format: Function,
              },
              computed: {
                barStyle: function barStyle() {
                  const style = {};
                  style.width = `${this.percentage}%`;
                  style.backgroundColor = this.getCurrentColor(this.percentage);
                  return style;
                },
                relativeStrokeWidth: function relativeStrokeWidth() {
                  return (this.strokeWidth / this.width * 100).toFixed(1);
                },
                radius: function radius() {
                  if (this.type === 'circle' || this.type === 'dashboard') {
                    return parseInt(50 - parseFloat(this.relativeStrokeWidth) / 2, 10);
                  }
                  return 0;
                },
                trackPath: function trackPath() {
                  const { radius } = this;
                  const isDashboard = this.type === 'dashboard';
                  return `\n        M 50 50\n        m 0 ${isDashboard ? '' : '-'}${radius}\n        a ${radius} ${radius} 0 1 1 0 ${isDashboard ? '-' : ''}${radius * 2}\n        a ${radius} ${radius} 0 1 1 0 ${isDashboard ? '' : '-'}${radius * 2}\n        `;
                },
                perimeter: function perimeter() {
                  return 2 * Math.PI * this.radius;
                },
                rate: function rate() {
                  return this.type === 'dashboard' ? 0.75 : 1;
                },
                strokeDashoffset: function strokeDashoffset() {
                  const offset = -1 * this.perimeter * (1 - this.rate) / 2;
                  return `${offset}px`;
                },
                trailPathStyle: function trailPathStyle() {
                  return {
                    strokeDasharray: `${this.perimeter * this.rate}px, ${this.perimeter}px`,
                    strokeDashoffset: this.strokeDashoffset,
                  };
                },
                circlePathStyle: function circlePathStyle() {
                  return {
                    strokeDasharray: `${this.perimeter * this.rate * (this.percentage / 100)}px, ${this.perimeter}px`,
                    strokeDashoffset: this.strokeDashoffset,
                    transition: 'stroke-dasharray 0.6s ease 0s, stroke 0.6s ease',
                  };
                },
                stroke: function stroke() {
                  let ret = void 0;
                  if (this.color) {
                    ret = this.getCurrentColor(this.percentage);
                  } else {
                    switch (this.status) {
                      case 'success':
                        ret = '#13ce66';
                        break;
                      case 'exception':
                        ret = '#ff4949';
                        break;
                      case 'warning':
                        ret = '#e6a23c';
                        break;
                      default:
                        ret = '#20a0ff';
                    }
                  }
                  return ret;
                },
                iconClass: function iconClass() {
                  if (this.status === 'warning') {
                    return 'el-icon-warning';
                  }
                  if (this.type === 'line') {
                    return this.status === 'success' ? 'el-icon-circle-check' : 'el-icon-circle-close';
                  }
                  return this.status === 'success' ? 'el-icon-check' : 'el-icon-close';
                },
                progressTextSize: function progressTextSize() {
                  return this.type === 'line' ? 12 + this.strokeWidth * 0.4 : this.width * 0.111111 + 2;
                },
                content: function content() {
                  if (typeof this.format === 'function') {
                    return this.format(this.percentage) || '';
                  }
                  return `${this.percentage}%`;
                },
              },
              methods: {
                getCurrentColor: function getCurrentColor(percentage) {
                  if (typeof this.color === 'function') {
                    return this.color(percentage);
                  } if (typeof this.color === 'string') {
                    return this.color;
                  }
                  return this.getLevelColor(percentage);
                },
                getLevelColor: function getLevelColor(percentage) {
                  const colorArray = this.getColorArray().sort((a, b) => a.percentage - b.percentage);

                  for (let i = 0; i < colorArray.length; i++) {
                    if (colorArray[i].percentage > percentage) {
                      return colorArray[i].color;
                    }
                  }
                  return colorArray[colorArray.length - 1].color;
                },
                getColorArray: function getColorArray() {
                  const { color } = this;
                  const span = 100 / color.length;
                  return color.map((seriesColor, index) => {
                    if (typeof seriesColor === 'string') {
                      return {
                        color: seriesColor,
                        percentage: (index + 1) * span,
                      };
                    }
                    return seriesColor;
                  });
                },
              },
            });
            // CONCATENATED MODULE: ./packages/progress/src/progress.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_progressvue_type_script_lang_js_ = (progressvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/progress/src/progress.vue

            /* normalize component */

            const progress_component = normalizeComponent(
              src_progressvue_type_script_lang_js_,
              progressvue_type_template_id_229ee406_render,
              progressvue_type_template_id_229ee406_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let progress_api; }
            progress_component.options.__file = 'packages/progress/src/progress.vue';
            /* harmony default export */ const progress = (progress_component.exports);
            // CONCATENATED MODULE: ./packages/progress/index.js

            /* istanbul ignore next */
            progress.install = function (Vue) {
              Vue.component(progress.name, progress);
            };

            /* harmony default export */ const packages_progress = (progress);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/spinner/src/spinner.vue?vue&type=template&id=697b8538&
            const spinnervue_type_template_id_697b8538_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('span', { staticClass: 'el-spinner' }, [
                _c(
                  'svg',
                  {
                    staticClass: 'el-spinner-inner',
                    style: { width: `${_vm.radius / 2}px`, height: `${_vm.radius / 2}px` },
                    attrs: { viewBox: '0 0 50 50' },
                  },
                  [
                    _c('circle', {
                      staticClass: 'path',
                      attrs: {
                        cx: '25',
                        cy: '25',
                        r: '20',
                        fill: 'none',
                        stroke: _vm.strokeColor,
                        'stroke-width': _vm.strokeWidth,
                      },
                    }),
                  ],
                ),
              ]);
            };
            const spinnervue_type_template_id_697b8538_staticRenderFns = [];
            spinnervue_type_template_id_697b8538_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/spinner/src/spinner.vue?vue&type=template&id=697b8538&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/spinner/src/spinner.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const spinnervue_type_script_lang_js_ = ({
              name: 'ElSpinner',
              props: {
                type: String,
                radius: {
                  type: Number,
                  default: 100,
                },
                strokeWidth: {
                  type: Number,
                  default: 5,
                },
                strokeColor: {
                  type: String,
                  default: '#efefef',
                },
              },
            });
            // CONCATENATED MODULE: ./packages/spinner/src/spinner.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_spinnervue_type_script_lang_js_ = (spinnervue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/spinner/src/spinner.vue

            /* normalize component */

            const spinner_component = normalizeComponent(
              src_spinnervue_type_script_lang_js_,
              spinnervue_type_template_id_697b8538_render,
              spinnervue_type_template_id_697b8538_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let spinner_api; }
            spinner_component.options.__file = 'packages/spinner/src/spinner.vue';
            /* harmony default export */ const spinner = (spinner_component.exports);
            // CONCATENATED MODULE: ./packages/spinner/index.js

            /* istanbul ignore next */
            spinner.install = function (Vue) {
              Vue.component(spinner.name, spinner);
            };

            /* harmony default export */ const packages_spinner = (spinner);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/message/src/main.vue?vue&type=template&id=455b9f60&
            const mainvue_type_template_id_455b9f60_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                {
                  attrs: { name: 'el-message-fade' },
                  on: { 'after-leave': _vm.handleAfterLeave },
                },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.visible,
                          expression: 'visible',
                        },
                      ],
                      class: [
                        'el-message',
                        _vm.type && !_vm.iconClass ? `el-message--${_vm.type}` : '',
                        _vm.center ? 'is-center' : '',
                        _vm.showClose ? 'is-closable' : '',
                        _vm.customClass,
                      ],
                      style: _vm.positionStyle,
                      attrs: { role: 'alert' },
                      on: { mouseenter: _vm.clearTimer, mouseleave: _vm.startTimer },
                    },
                    [
                      _vm.iconClass
                        ? _c('i', { class: _vm.iconClass })
                        : _c('i', { class: _vm.typeClass }),
                      _vm._t('default', [
                        !_vm.dangerouslyUseHTMLString
                          ? _c('p', { staticClass: 'el-message__content' }, [
                            _vm._v(_vm._s(_vm.message)),
                          ])
                          : _c('p', {
                            staticClass: 'el-message__content',
                            domProps: { innerHTML: _vm._s(_vm.message) },
                          }),
                      ]),
                      _vm.showClose
                        ? _c('i', {
                          staticClass: 'el-message__closeBtn el-icon-close',
                          on: { click: _vm.close },
                        })
                        : _vm._e(),
                    ],
                    2,
                  ),
                ],
              );
            };
            const mainvue_type_template_id_455b9f60_staticRenderFns = [];
            mainvue_type_template_id_455b9f60_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/message/src/main.vue?vue&type=template&id=455b9f60&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/message/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const src_mainvue_type_script_lang_js_typeMap = {
              success: 'success',
              info: 'info',
              warning: 'warning',
              error: 'error',
            };

            /* harmony default export */ const message_src_mainvue_type_script_lang_js_ = ({
              data: function data() {
                return {
                  visible: false,
                  message: '',
                  duration: 3000,
                  type: 'info',
                  iconClass: '',
                  customClass: '',
                  onClose: null,
                  showClose: false,
                  closed: false,
                  verticalOffset: 20,
                  timer: null,
                  dangerouslyUseHTMLString: false,
                  center: false,
                };
              },

              computed: {
                typeClass: function typeClass() {
                  return this.type && !this.iconClass ? `el-message__icon el-icon-${src_mainvue_type_script_lang_js_typeMap[this.type]}` : '';
                },
                positionStyle: function positionStyle() {
                  return {
                    top: `${this.verticalOffset}px`,
                  };
                },
              },

              watch: {
                closed: function closed(newVal) {
                  if (newVal) {
                    this.visible = false;
                  }
                },
              },

              methods: {
                handleAfterLeave: function handleAfterLeave() {
                  this.$destroy(true);
                  this.$el.parentNode.removeChild(this.$el);
                },
                close: function close() {
                  this.closed = true;
                  if (typeof this.onClose === 'function') {
                    this.onClose(this);
                  }
                },
                clearTimer: function clearTimer() {
                  clearTimeout(this.timer);
                },
                startTimer: function startTimer() {
                  const _this = this;

                  if (this.duration > 0) {
                    this.timer = setTimeout(() => {
                      if (!_this.closed) {
                        _this.close();
                      }
                    }, this.duration);
                  }
                },
                keydown: function keydown(e) {
                  if (e.keyCode === 27) {
                    // esc关闭消息
                    if (!this.closed) {
                      this.close();
                    }
                  }
                },
              },
              mounted: function mounted() {
                this.startTimer();
                document.addEventListener('keydown', this.keydown);
              },
              beforeDestroy: function beforeDestroy() {
                document.removeEventListener('keydown', this.keydown);
              },
            });
            // CONCATENATED MODULE: ./packages/message/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_message_src_mainvue_type_script_lang_js_ = (message_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/message/src/main.vue

            /* normalize component */

            const message_src_main_component = normalizeComponent(
              packages_message_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_455b9f60_render,
              mainvue_type_template_id_455b9f60_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let message_src_main_api; }
            message_src_main_component.options.__file = 'packages/message/src/main.vue';
            /* harmony default export */ const message_src_main = (message_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/message/src/main.js

            const MessageConstructor = external_vue_default.a.extend(message_src_main);

            let message_src_main_instance = void 0;
            const main_instances = [];
            let main_seed = 1;

            const main_Message = function Message(options) {
              if (external_vue_default.a.prototype.$isServer) return;
              options = options || {};
              if (typeof options === 'string') {
                options = {
                  message: options,
                };
              }
              const userOnClose = options.onClose;
              const id = `message_${main_seed++}`;

              options.onClose = function () {
                Message.close(id, userOnClose);
              };
              message_src_main_instance = new MessageConstructor({
                data: options,
              });
              message_src_main_instance.id = id;
              if (Object(vdom_.isVNode)(message_src_main_instance.message)) {
                message_src_main_instance.$slots.default = [message_src_main_instance.message];
                message_src_main_instance.message = null;
              }
              message_src_main_instance.$mount();
              document.body.appendChild(message_src_main_instance.$el);
              let verticalOffset = options.offset || 20;
              main_instances.forEach((item) => {
                verticalOffset += item.$el.offsetHeight + 16;
              });
              message_src_main_instance.verticalOffset = verticalOffset;
              message_src_main_instance.visible = true;
              message_src_main_instance.$el.style.zIndex = popup_.PopupManager.nextZIndex();
              main_instances.push(message_src_main_instance);
              return message_src_main_instance;
            };

            ['success', 'warning', 'info', 'error'].forEach((type) => {
              main_Message[type] = function (options) {
                if (typeof options === 'string') {
                  options = {
                    message: options,
                  };
                }
                options.type = type;
                return main_Message(options);
              };
            });

            main_Message.close = function (id, userOnClose) {
              const len = main_instances.length;
              let index = -1;
              let removedHeight = void 0;
              for (let i = 0; i < len; i++) {
                if (id === main_instances[i].id) {
                  removedHeight = main_instances[i].$el.offsetHeight;
                  index = i;
                  if (typeof userOnClose === 'function') {
                    userOnClose(main_instances[i]);
                  }
                  main_instances.splice(i, 1);
                  break;
                }
              }
              if (len <= 1 || index === -1 || index > main_instances.length - 1) return;
              for (let _i = index; _i < len - 1; _i++) {
                const dom = main_instances[_i].$el;
                dom.style.top = `${parseInt(dom.style.top, 10) - removedHeight - 16}px`;
              }
            };

            main_Message.closeAll = function () {
              for (let i = main_instances.length - 1; i >= 0; i--) {
                main_instances[i].close();
              }
            };

            /* harmony default export */ const packages_message_src_main = (main_Message);
            // CONCATENATED MODULE: ./packages/message/index.js

            /* harmony default export */ const packages_message = (packages_message_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/badge/src/main.vue?vue&type=template&id=7ccb6598&
            const mainvue_type_template_id_7ccb6598_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                { staticClass: 'el-badge' },
                [
                  _vm._t('default'),
                  _c('transition', { attrs: { name: 'el-zoom-in-center' } }, [
                    _c('sup', {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value:
                !_vm.hidden && (_vm.content || _vm.content === 0 || _vm.isDot),
                          expression: '!hidden && (content || content === 0 || isDot)',
                        },
                      ],
                      staticClass: 'el-badge__content',
                      class: [
                        `el-badge__content--${_vm.type}`,
                        {
                          'is-fixed': _vm.$slots.default,
                          'is-dot': _vm.isDot,
                        },
                      ],
                      domProps: { textContent: _vm._s(_vm.content) },
                    }),
                  ]),
                ],
                2,
              );
            };
            const mainvue_type_template_id_7ccb6598_staticRenderFns = [];
            mainvue_type_template_id_7ccb6598_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/badge/src/main.vue?vue&type=template&id=7ccb6598&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/badge/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const badge_src_mainvue_type_script_lang_js_ = ({
              name: 'ElBadge',

              props: {
                value: [String, Number],
                max: Number,
                isDot: Boolean,
                hidden: Boolean,
                type: {
                  type: String,
                  validator: function validator(val) {
                    return ['primary', 'success', 'warning', 'info', 'danger'].indexOf(val) > -1;
                  },
                },
              },

              computed: {
                content: function content() {
                  if (this.isDot) return;

                  const { value } = this;
                  const { max } = this;

                  if (typeof value === 'number' && typeof max === 'number') {
                    return max < value ? `${max}+` : value;
                  }

                  return value;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/badge/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_badge_src_mainvue_type_script_lang_js_ = (badge_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/badge/src/main.vue

            /* normalize component */

            const badge_src_main_component = normalizeComponent(
              packages_badge_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_7ccb6598_render,
              mainvue_type_template_id_7ccb6598_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let badge_src_main_api; }
            badge_src_main_component.options.__file = 'packages/badge/src/main.vue';
            /* harmony default export */ const badge_src_main = (badge_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/badge/index.js

            /* istanbul ignore next */
            badge_src_main.install = function (Vue) {
              Vue.component(badge_src_main.name, badge_src_main);
            };

            /* harmony default export */ const badge = (badge_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/card/src/main.vue?vue&type=template&id=59a4a40f&
            const mainvue_type_template_id_59a4a40f_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-card',
                  class: _vm.shadow ? `is-${_vm.shadow}-shadow` : 'is-always-shadow',
                },
                [
                  _vm.$slots.header || _vm.header
                    ? _c(
                      'div',
                      { staticClass: 'el-card__header' },
                      [_vm._t('header', [_vm._v(_vm._s(_vm.header))])],
                      2,
                    )
                    : _vm._e(),
                  _c(
                    'div',
                    { staticClass: 'el-card__body', style: _vm.bodyStyle },
                    [_vm._t('default')],
                    2,
                  ),
                ],
              );
            };
            const mainvue_type_template_id_59a4a40f_staticRenderFns = [];
            mainvue_type_template_id_59a4a40f_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/card/src/main.vue?vue&type=template&id=59a4a40f&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/card/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const card_src_mainvue_type_script_lang_js_ = ({
              name: 'ElCard',
              props: {
                header: {},
                bodyStyle: {},
                shadow: {
                  type: String,
                },
              },
            });
            // CONCATENATED MODULE: ./packages/card/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_card_src_mainvue_type_script_lang_js_ = (card_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/card/src/main.vue

            /* normalize component */

            const card_src_main_component = normalizeComponent(
              packages_card_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_59a4a40f_render,
              mainvue_type_template_id_59a4a40f_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let card_src_main_api; }
            card_src_main_component.options.__file = 'packages/card/src/main.vue';
            /* harmony default export */ const card_src_main = (card_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/card/index.js

            /* istanbul ignore next */
            card_src_main.install = function (Vue) {
              Vue.component(card_src_main.name, card_src_main);
            };

            /* harmony default export */ const card = (card_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/rate/src/main.vue?vue&type=template&id=ada57782&
            const mainvue_type_template_id_ada57782_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-rate',
                  attrs: {
                    role: 'slider',
                    'aria-valuenow': _vm.currentValue,
                    'aria-valuetext': _vm.text,
                    'aria-valuemin': '0',
                    'aria-valuemax': _vm.max,
                    tabindex: '0',
                  },
                  on: { keydown: _vm.handleKey },
                },
                [
                  _vm._l(_vm.max, (item, key) => _c(
                    'span',
                    {
                      key,
                      staticClass: 'el-rate__item',
                      style: { cursor: _vm.rateDisabled ? 'auto' : 'pointer' },
                      on: {
                        mousemove($event) {
                          _vm.setCurrentValue(item, $event);
                        },
                        mouseleave: _vm.resetCurrentValue,
                        click($event) {
                          _vm.selectValue(item);
                        },
                      },
                    },
                    [
                      _c(
                        'i',
                        {
                          staticClass: 'el-rate__icon',
                          class: [
                            _vm.classes[item - 1],
                            { hover: _vm.hoverIndex === item },
                          ],
                          style: _vm.getIconStyle(item),
                        },
                        [
                          _vm.showDecimalIcon(item)
                            ? _c('i', {
                              staticClass: 'el-rate__decimal',
                              class: _vm.decimalIconClass,
                              style: _vm.decimalStyle,
                            })
                            : _vm._e(),
                        ],
                      ),
                    ],
                  )),
                  _vm.showText || _vm.showScore
                    ? _c(
                      'span',
                      { staticClass: 'el-rate__text', style: { color: _vm.textColor } },
                      [_vm._v(_vm._s(_vm.text))],
                    )
                    : _vm._e(),
                ],
                2,
              );
            };
            const mainvue_type_template_id_ada57782_staticRenderFns = [];
            mainvue_type_template_id_ada57782_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/rate/src/main.vue?vue&type=template&id=ada57782&

            // EXTERNAL MODULE: external "element-ui/lib/utils/types"
            const types_ = __webpack_require__(18);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/rate/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const rate_src_mainvue_type_script_lang_js_ = ({
              name: 'ElRate',

              mixins: [migrating_default.a],

              inject: {
                elForm: {
                  default: '',
                },
              },

              data: function data() {
                return {
                  pointerAtLeftHalf: true,
                  currentValue: this.value,
                  hoverIndex: -1,
                };
              },

              props: {
                value: {
                  type: Number,
                  default: 0,
                },
                lowThreshold: {
                  type: Number,
                  default: 2,
                },
                highThreshold: {
                  type: Number,
                  default: 4,
                },
                max: {
                  type: Number,
                  default: 5,
                },
                colors: {
                  type: [Array, Object],
                  default: function _default() {
                    return ['#F7BA2A', '#F7BA2A', '#F7BA2A'];
                  },
                },
                voidColor: {
                  type: String,
                  default: '#C6D1DE',
                },
                disabledVoidColor: {
                  type: String,
                  default: '#EFF2F7',
                },
                iconClasses: {
                  type: [Array, Object],
                  default: function _default() {
                    return ['el-icon-star-on', 'el-icon-star-on', 'el-icon-star-on'];
                  },
                },
                voidIconClass: {
                  type: String,
                  default: 'el-icon-star-off',
                },
                disabledVoidIconClass: {
                  type: String,
                  default: 'el-icon-star-on',
                },
                disabled: {
                  type: Boolean,
                  default: false,
                },
                allowHalf: {
                  type: Boolean,
                  default: false,
                },
                showText: {
                  type: Boolean,
                  default: false,
                },
                showScore: {
                  type: Boolean,
                  default: false,
                },
                textColor: {
                  type: String,
                  default: '#1f2d3d',
                },
                texts: {
                  type: Array,
                  default: function _default() {
                    return ['极差', '失望', '一般', '满意', '惊喜'];
                  },
                },
                scoreTemplate: {
                  type: String,
                  default: '{value}',
                },
              },

              computed: {
                text: function text() {
                  let result = '';
                  if (this.showScore) {
                    result = this.scoreTemplate.replace(/\{\s*value\s*\}/, this.rateDisabled ? this.value : this.currentValue);
                  } else if (this.showText) {
                    result = this.texts[Math.ceil(this.currentValue) - 1];
                  }
                  return result;
                },
                decimalStyle: function decimalStyle() {
                  let width = '';
                  if (this.rateDisabled) {
                    width = `${this.valueDecimal}%`;
                  } else if (this.allowHalf) {
                    width = '50%';
                  }
                  return {
                    color: this.activeColor,
                    width,
                  };
                },
                valueDecimal: function valueDecimal() {
                  return this.value * 100 - Math.floor(this.value) * 100;
                },
                classMap: function classMap() {
                  let _ref;

                  return Array.isArray(this.iconClasses) ? (_ref = {}, _ref[this.lowThreshold] = this.iconClasses[0], _ref[this.highThreshold] = { value: this.iconClasses[1], excluded: true }, _ref[this.max] = this.iconClasses[2], _ref) : this.iconClasses;
                },
                decimalIconClass: function decimalIconClass() {
                  return this.getValueFromMap(this.value, this.classMap);
                },
                voidClass: function voidClass() {
                  return this.rateDisabled ? this.disabledVoidIconClass : this.voidIconClass;
                },
                activeClass: function activeClass() {
                  return this.getValueFromMap(this.currentValue, this.classMap);
                },
                colorMap: function colorMap() {
                  let _ref2;

                  return Array.isArray(this.colors) ? (_ref2 = {}, _ref2[this.lowThreshold] = this.colors[0], _ref2[this.highThreshold] = { value: this.colors[1], excluded: true }, _ref2[this.max] = this.colors[2], _ref2) : this.colors;
                },
                activeColor: function activeColor() {
                  return this.getValueFromMap(this.currentValue, this.colorMap);
                },
                classes: function classes() {
                  const result = [];
                  let i = 0;
                  let threshold = this.currentValue;
                  if (this.allowHalf && this.currentValue !== Math.floor(this.currentValue)) {
                    threshold--;
                  }
                  for (; i < threshold; i++) {
                    result.push(this.activeClass);
                  }
                  for (; i < this.max; i++) {
                    result.push(this.voidClass);
                  }
                  return result;
                },
                rateDisabled: function rateDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
              },

              watch: {
                value: function value(val) {
                  this.currentValue = val;
                  this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
                },
              },

              methods: {
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      'text-template': 'text-template is renamed to score-template.',
                    },
                  };
                },
                getValueFromMap: function getValueFromMap(value, map) {
                  const matchedKeys = Object.keys(map).filter((key) => {
                    const val = map[key];
                    const excluded = Object(types_.isObject)(val) ? val.excluded : false;
                    return excluded ? value < key : value <= key;
                  }).sort((a, b) => a - b);
                  const matchedValue = map[matchedKeys[0]];
                  return Object(types_.isObject)(matchedValue) ? matchedValue.value : matchedValue || '';
                },
                showDecimalIcon: function showDecimalIcon(item) {
                  const showWhenDisabled = this.rateDisabled && this.valueDecimal > 0 && item - 1 < this.value && item > this.value;
                  /* istanbul ignore next */
                  const showWhenAllowHalf = this.allowHalf && this.pointerAtLeftHalf && item - 0.5 <= this.currentValue && item > this.currentValue;
                  return showWhenDisabled || showWhenAllowHalf;
                },
                getIconStyle: function getIconStyle(item) {
                  const voidColor = this.rateDisabled ? this.disabledVoidColor : this.voidColor;
                  return {
                    color: item <= this.currentValue ? this.activeColor : voidColor,
                  };
                },
                selectValue: function selectValue(value) {
                  if (this.rateDisabled) {
                    return;
                  }
                  if (this.allowHalf && this.pointerAtLeftHalf) {
                    this.$emit('input', this.currentValue);
                    this.$emit('change', this.currentValue);
                  } else {
                    this.$emit('input', value);
                    this.$emit('change', value);
                  }
                },
                handleKey: function handleKey(e) {
                  if (this.rateDisabled) {
                    return;
                  }
                  let { currentValue } = this;
                  const { keyCode } = e;
                  if (keyCode === 38 || keyCode === 39) {
                    // left / down
                    if (this.allowHalf) {
                      currentValue += 0.5;
                    } else {
                      currentValue += 1;
                    }
                    e.stopPropagation();
                    e.preventDefault();
                  } else if (keyCode === 37 || keyCode === 40) {
                    if (this.allowHalf) {
                      currentValue -= 0.5;
                    } else {
                      currentValue -= 1;
                    }
                    e.stopPropagation();
                    e.preventDefault();
                  }
                  currentValue = currentValue < 0 ? 0 : currentValue;
                  currentValue = currentValue > this.max ? this.max : currentValue;

                  this.$emit('input', currentValue);
                  this.$emit('change', currentValue);
                },
                setCurrentValue: function setCurrentValue(value, event) {
                  if (this.rateDisabled) {
                    return;
                  }
                  /* istanbul ignore if */
                  if (this.allowHalf) {
                    let { target } = event;
                    if (Object(dom_.hasClass)(target, 'el-rate__item')) {
                      target = target.querySelector('.el-rate__icon');
                    }
                    if (Object(dom_.hasClass)(target, 'el-rate__decimal')) {
                      target = target.parentNode;
                    }
                    this.pointerAtLeftHalf = event.offsetX * 2 <= target.clientWidth;
                    this.currentValue = this.pointerAtLeftHalf ? value - 0.5 : value;
                  } else {
                    this.currentValue = value;
                  }
                  this.hoverIndex = value;
                },
                resetCurrentValue: function resetCurrentValue() {
                  if (this.rateDisabled) {
                    return;
                  }
                  if (this.allowHalf) {
                    this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
                  }
                  this.currentValue = this.value;
                  this.hoverIndex = -1;
                },
              },

              created: function created() {
                if (!this.value) {
                  this.$emit('input', 0);
                }
              },
            });
            // CONCATENATED MODULE: ./packages/rate/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_rate_src_mainvue_type_script_lang_js_ = (rate_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/rate/src/main.vue

            /* normalize component */

            const rate_src_main_component = normalizeComponent(
              packages_rate_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_ada57782_render,
              mainvue_type_template_id_ada57782_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let rate_src_main_api; }
            rate_src_main_component.options.__file = 'packages/rate/src/main.vue';
            /* harmony default export */ const rate_src_main = (rate_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/rate/index.js

            /* istanbul ignore next */
            rate_src_main.install = function (Vue) {
              Vue.component(rate_src_main.name, rate_src_main);
            };

            /* harmony default export */ const rate = (rate_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/steps/src/steps.vue?vue&type=template&id=3c6b6dc0&
            const stepsvue_type_template_id_3c6b6dc0_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-steps',
                  class: [
                    !_vm.simple && `el-steps--${_vm.direction}`,
                    _vm.simple && 'el-steps--simple',
                  ],
                },
                [_vm._t('default')],
                2,
              );
            };
            const stepsvue_type_template_id_3c6b6dc0_staticRenderFns = [];
            stepsvue_type_template_id_3c6b6dc0_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/steps/src/steps.vue?vue&type=template&id=3c6b6dc0&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/steps/src/steps.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const stepsvue_type_script_lang_js_ = ({
              name: 'ElSteps',

              mixins: [migrating_default.a],

              props: {
                space: [Number, String],
                active: Number,
                direction: {
                  type: String,
                  default: 'horizontal',
                },
                alignCenter: Boolean,
                simple: Boolean,
                finishStatus: {
                  type: String,
                  default: 'finish',
                },
                processStatus: {
                  type: String,
                  default: 'process',
                },
              },

              data: function data() {
                return {
                  steps: [],
                  stepOffset: 0,
                };
              },

              methods: {
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      center: 'center is removed.',
                    },
                  };
                },
              },

              watch: {
                active: function active(newVal, oldVal) {
                  this.$emit('change', newVal, oldVal);
                },
                steps: function steps(_steps) {
                  _steps.forEach((child, index) => {
                    child.index = index;
                  });
                },
              },
            });
            // CONCATENATED MODULE: ./packages/steps/src/steps.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_stepsvue_type_script_lang_js_ = (stepsvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/steps/src/steps.vue

            /* normalize component */

            const steps_component = normalizeComponent(
              src_stepsvue_type_script_lang_js_,
              stepsvue_type_template_id_3c6b6dc0_render,
              stepsvue_type_template_id_3c6b6dc0_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let steps_api; }
            steps_component.options.__file = 'packages/steps/src/steps.vue';
            /* harmony default export */ const steps = (steps_component.exports);
            // CONCATENATED MODULE: ./packages/steps/index.js

            /* istanbul ignore next */
            steps.install = function (Vue) {
              Vue.component(steps.name, steps);
            };

            /* harmony default export */ const packages_steps = (steps);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/steps/src/step.vue?vue&type=template&id=f414a87a&
            const stepvue_type_template_id_f414a87a_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-step',
                  class: [
                    !_vm.isSimple && `is-${_vm.$parent.direction}`,
                    _vm.isSimple && 'is-simple',
                    _vm.isLast && !_vm.space && !_vm.isCenter && 'is-flex',
                    _vm.isCenter && !_vm.isVertical && !_vm.isSimple && 'is-center',
                  ],
                  style: _vm.style,
                },
                [
                  _c(
                    'div',
                    { staticClass: 'el-step__head', class: `is-${_vm.currentStatus}` },
                    [
                      _c(
                        'div',
                        {
                          staticClass: 'el-step__line',
                          style: _vm.isLast
                            ? ''
                            : { marginRight: `${_vm.$parent.stepOffset}px` },
                        },
                        [
                          _c('i', {
                            staticClass: 'el-step__line-inner',
                            style: _vm.lineStyle,
                          }),
                        ],
                      ),
                      _c(
                        'div',
                        {
                          staticClass: 'el-step__icon',
                          class: `is-${_vm.icon ? 'icon' : 'text'}`,
                        },
                        [
                          _vm.currentStatus !== 'success' && _vm.currentStatus !== 'error'
                            ? _vm._t('icon', [
                              _vm.icon
                                ? _c('i', {
                                  staticClass: 'el-step__icon-inner',
                                  class: [_vm.icon],
                                })
                                : _vm._e(),
                              !_vm.icon && !_vm.isSimple
                                ? _c('div', { staticClass: 'el-step__icon-inner' }, [
                                  _vm._v(_vm._s(_vm.index + 1)),
                                ])
                                : _vm._e(),
                            ])
                            : _c('i', {
                              staticClass: 'el-step__icon-inner is-status',
                              class: [
                                `el-icon-${
                                  _vm.currentStatus === 'success' ? 'check' : 'close'}`,
                              ],
                            }),
                        ],
                        2,
                      ),
                    ],
                  ),
                  _c('div', { staticClass: 'el-step__main' }, [
                    _c(
                      'div',
                      {
                        ref: 'title',
                        staticClass: 'el-step__title',
                        class: [`is-${_vm.currentStatus}`],
                      },
                      [_vm._t('title', [_vm._v(_vm._s(_vm.title))])],
                      2,
                    ),
                    _vm.isSimple
                      ? _c('div', { staticClass: 'el-step__arrow' })
                      : _c(
                        'div',
                        {
                          staticClass: 'el-step__description',
                          class: [`is-${_vm.currentStatus}`],
                        },
                        [_vm._t('description', [_vm._v(_vm._s(_vm.description))])],
                        2,
                      ),
                  ]),
                ],
              );
            };
            const stepvue_type_template_id_f414a87a_staticRenderFns = [];
            stepvue_type_template_id_f414a87a_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/steps/src/step.vue?vue&type=template&id=f414a87a&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/steps/src/step.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const stepvue_type_script_lang_js_ = ({
              name: 'ElStep',

              props: {
                title: String,
                icon: String,
                description: String,
                status: String,
              },

              data: function data() {
                return {
                  index: -1,
                  lineStyle: {},
                  internalStatus: '',
                };
              },
              beforeCreate: function beforeCreate() {
                this.$parent.steps.push(this);
              },
              beforeDestroy: function beforeDestroy() {
                const { steps } = this.$parent;
                const index = steps.indexOf(this);
                if (index >= 0) {
                  steps.splice(index, 1);
                }
              },

              computed: {
                currentStatus: function currentStatus() {
                  return this.status || this.internalStatus;
                },
                prevStatus: function prevStatus() {
                  const prevStep = this.$parent.steps[this.index - 1];
                  return prevStep ? prevStep.currentStatus : 'wait';
                },
                isCenter: function isCenter() {
                  return this.$parent.alignCenter;
                },
                isVertical: function isVertical() {
                  return this.$parent.direction === 'vertical';
                },
                isSimple: function isSimple() {
                  return this.$parent.simple;
                },
                isLast: function isLast() {
                  const parent = this.$parent;
                  return parent.steps[parent.steps.length - 1] === this;
                },
                stepsCount: function stepsCount() {
                  return this.$parent.steps.length;
                },
                space: function space() {
                  const { isSimple } = this;
                  const { space } = this.$parent;

                  return isSimple ? '' : space;
                },

                style: function style() {
                  const style = {};
                  const parent = this.$parent;
                  const len = parent.steps.length;

                  const space = typeof this.space === 'number' ? `${this.space}px` : this.space ? this.space : `${100 / (len - (this.isCenter ? 0 : 1))}%`;
                  style.flexBasis = space;
                  if (this.isVertical) return style;
                  if (this.isLast) {
                    style.maxWidth = `${100 / this.stepsCount}%`;
                  } else {
                    style.marginRight = `${-this.$parent.stepOffset}px`;
                  }

                  return style;
                },
              },

              methods: {
                updateStatus: function updateStatus(val) {
                  const prevChild = this.$parent.$children[this.index - 1];

                  if (val > this.index) {
                    this.internalStatus = this.$parent.finishStatus;
                  } else if (val === this.index && this.prevStatus !== 'error') {
                    this.internalStatus = this.$parent.processStatus;
                  } else {
                    this.internalStatus = 'wait';
                  }

                  if (prevChild) prevChild.calcProgress(this.internalStatus);
                },
                calcProgress: function calcProgress(status) {
                  let step = 100;
                  const style = {};

                  style.transitionDelay = `${150 * this.index}ms`;
                  if (status === this.$parent.processStatus) {
                    step = this.currentStatus !== 'error' ? 0 : 0;
                  } else if (status === 'wait') {
                    step = 0;
                    style.transitionDelay = `${-150 * this.index}ms`;
                  }

                  style.borderWidth = step && !this.isSimple ? '1px' : 0;
                  this.$parent.direction === 'vertical' ? style.height = `${step}%` : style.width = `${step}%`;

                  this.lineStyle = style;
                },
              },

              mounted: function mounted() {
                const _this = this;

                var unwatch = this.$watch('index', (val) => {
                  _this.$watch('$parent.active', _this.updateStatus, { immediate: true });
                  _this.$watch('$parent.processStatus', () => {
                    const activeIndex = _this.$parent.active;
                    _this.updateStatus(activeIndex);
                  }, { immediate: true });
                  unwatch();
                });
              },
            });
            // CONCATENATED MODULE: ./packages/steps/src/step.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_stepvue_type_script_lang_js_ = (stepvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/steps/src/step.vue

            /* normalize component */

            const step_component = normalizeComponent(
              src_stepvue_type_script_lang_js_,
              stepvue_type_template_id_f414a87a_render,
              stepvue_type_template_id_f414a87a_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let step_api; }
            step_component.options.__file = 'packages/steps/src/step.vue';
            /* harmony default export */ const step = (step_component.exports);
            // CONCATENATED MODULE: ./packages/step/index.js

            /* istanbul ignore next */
            step.install = function (Vue) {
              Vue.component(step.name, step);
            };

            /* harmony default export */ const packages_step = (step);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/carousel/src/main.vue?vue&type=template&id=5d5d1482&
            const mainvue_type_template_id_5d5d1482_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  class: _vm.carouselClasses,
                  on: {
                    mouseenter($event) {
                      $event.stopPropagation();
                      return _vm.handleMouseEnter($event);
                    },
                    mouseleave($event) {
                      $event.stopPropagation();
                      return _vm.handleMouseLeave($event);
                    },
                  },
                },
                [
                  _c(
                    'div',
                    {
                      staticClass: 'el-carousel__container',
                      style: { height: _vm.height },
                    },
                    [
                      _vm.arrowDisplay
                        ? _c('transition', { attrs: { name: 'carousel-arrow-left' } }, [
                          _c(
                            'button',
                            {
                              directives: [
                                {
                                  name: 'show',
                                  rawName: 'v-show',
                                  value:
                          (_vm.arrow === 'always' || _vm.hover)
                          && (_vm.loop || _vm.activeIndex > 0),
                                  expression:
                          "(arrow === 'always' || hover) && (loop || activeIndex > 0)",
                                },
                              ],
                              staticClass: 'el-carousel__arrow el-carousel__arrow--left',
                              attrs: { type: 'button' },
                              on: {
                                mouseenter($event) {
                                  _vm.handleButtonEnter('left');
                                },
                                mouseleave: _vm.handleButtonLeave,
                                click($event) {
                                  $event.stopPropagation();
                                  _vm.throttledArrowClick(_vm.activeIndex - 1);
                                },
                              },
                            },
                            [_c('i', { staticClass: 'el-icon-arrow-left' })],
                          ),
                        ])
                        : _vm._e(),
                      _vm.arrowDisplay
                        ? _c('transition', { attrs: { name: 'carousel-arrow-right' } }, [
                          _c(
                            'button',
                            {
                              directives: [
                                {
                                  name: 'show',
                                  rawName: 'v-show',
                                  value:
                          (_vm.arrow === 'always' || _vm.hover)
                          && (_vm.loop || _vm.activeIndex < _vm.items.length - 1),
                                  expression:
                          "(arrow === 'always' || hover) && (loop || activeIndex < items.length - 1)",
                                },
                              ],
                              staticClass: 'el-carousel__arrow el-carousel__arrow--right',
                              attrs: { type: 'button' },
                              on: {
                                mouseenter($event) {
                                  _vm.handleButtonEnter('right');
                                },
                                mouseleave: _vm.handleButtonLeave,
                                click($event) {
                                  $event.stopPropagation();
                                  _vm.throttledArrowClick(_vm.activeIndex + 1);
                                },
                              },
                            },
                            [_c('i', { staticClass: 'el-icon-arrow-right' })],
                          ),
                        ])
                        : _vm._e(),
                      _vm._t('default'),
                    ],
                    2,
                  ),
                  _vm.indicatorPosition !== 'none'
                    ? _c(
                      'ul',
                      { class: _vm.indicatorsClasses },
                      _vm._l(_vm.items, (item, index) => _c(
                        'li',
                        {
                          key: index,
                          class: [
                            'el-carousel__indicator',
                            `el-carousel__indicator--${  _vm.direction}`,
                            { 'is-active': index === _vm.activeIndex },
                          ],
                          on: {
                            mouseenter($event) {
                              _vm.throttledIndicatorHover(index);
                            },
                            click($event) {
                              $event.stopPropagation();
                              _vm.handleIndicatorClick(index);
                            },
                          },
                        },
                        [
                          _c('button', { staticClass: 'el-carousel__button' }, [
                            _vm.hasLabel
                              ? _c('span', [_vm._v(_vm._s(item.label))])
                              : _vm._e(),
                          ]),
                        ],
                      )),
                      0,
                    )
                    : _vm._e(),
                ],
              );
            };
            const mainvue_type_template_id_5d5d1482_staticRenderFns = [];
            mainvue_type_template_id_5d5d1482_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/carousel/src/main.vue?vue&type=template&id=5d5d1482&

            // EXTERNAL MODULE: external "throttle-debounce/throttle"
            const throttle_ = __webpack_require__(25);
            const throttle_default = /* #__PURE__ */__webpack_require__.n(throttle_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/carousel/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const carousel_src_mainvue_type_script_lang_js_ = ({
              name: 'ElCarousel',

              props: {
                initialIndex: {
                  type: Number,
                  default: 0,
                },
                height: String,
                trigger: {
                  type: String,
                  default: 'hover',
                },
                autoplay: {
                  type: Boolean,
                  default: true,
                },
                interval: {
                  type: Number,
                  default: 3000,
                },
                indicatorPosition: String,
                indicator: {
                  type: Boolean,
                  default: true,
                },
                arrow: {
                  type: String,
                  default: 'hover',
                },
                type: String,
                loop: {
                  type: Boolean,
                  default: true,
                },
                direction: {
                  type: String,
                  default: 'horizontal',
                  validator: function validator(val) {
                    return ['horizontal', 'vertical'].indexOf(val) !== -1;
                  },
                },
              },

              data: function data() {
                return {
                  items: [],
                  activeIndex: -1,
                  containerWidth: 0,
                  timer: null,
                  hover: false,
                };
              },

              computed: {
                arrowDisplay: function arrowDisplay() {
                  return this.arrow !== 'never' && this.direction !== 'vertical';
                },
                hasLabel: function hasLabel() {
                  return this.items.some((item) => item.label.toString().length > 0);
                },
                carouselClasses: function carouselClasses() {
                  const classes = ['el-carousel', `el-carousel--${this.direction}`];
                  if (this.type === 'card') {
                    classes.push('el-carousel--card');
                  }
                  return classes;
                },
                indicatorsClasses: function indicatorsClasses() {
                  const classes = ['el-carousel__indicators', `el-carousel__indicators--${this.direction}`];
                  if (this.hasLabel) {
                    classes.push('el-carousel__indicators--labels');
                  }
                  if (this.indicatorPosition === 'outside' || this.type === 'card') {
                    classes.push('el-carousel__indicators--outside');
                  }
                  return classes;
                },
              },

              watch: {
                items: function items(val) {
                  if (val.length > 0) this.setActiveItem(this.initialIndex);
                },
                activeIndex: function activeIndex(val, oldVal) {
                  this.resetItemPosition(oldVal);
                  if (oldVal > -1) {
                    this.$emit('change', val, oldVal);
                  }
                },
                autoplay: function autoplay(val) {
                  val ? this.startTimer() : this.pauseTimer();
                },
                loop: function loop() {
                  this.setActiveItem(this.activeIndex);
                },
              },

              methods: {
                handleMouseEnter: function handleMouseEnter() {
                  this.hover = true;
                  this.pauseTimer();
                },
                handleMouseLeave: function handleMouseLeave() {
                  this.hover = false;
                  this.startTimer();
                },
                itemInStage: function itemInStage(item, index) {
                  const { length } = this.items;
                  if (index === length - 1 && item.inStage && this.items[0].active || item.inStage && this.items[index + 1] && this.items[index + 1].active) {
                    return 'left';
                  } if (index === 0 && item.inStage && this.items[length - 1].active || item.inStage && this.items[index - 1] && this.items[index - 1].active) {
                    return 'right';
                  }
                  return false;
                },
                handleButtonEnter: function handleButtonEnter(arrow) {
                  const _this = this;

                  if (this.direction === 'vertical') return;
                  this.items.forEach((item, index) => {
                    if (arrow === _this.itemInStage(item, index)) {
                      item.hover = true;
                    }
                  });
                },
                handleButtonLeave: function handleButtonLeave() {
                  if (this.direction === 'vertical') return;
                  this.items.forEach((item) => {
                    item.hover = false;
                  });
                },
                updateItems: function updateItems() {
                  this.items = this.$children.filter((child) => child.$options.name === 'ElCarouselItem');
                },
                resetItemPosition: function resetItemPosition(oldIndex) {
                  const _this2 = this;

                  this.items.forEach((item, index) => {
                    item.translateItem(index, _this2.activeIndex, oldIndex);
                  });
                },
                playSlides: function playSlides() {
                  if (this.activeIndex < this.items.length - 1) {
                    this.activeIndex++;
                  } else if (this.loop) {
                    this.activeIndex = 0;
                  }
                },
                pauseTimer: function pauseTimer() {
                  if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                  }
                },
                startTimer: function startTimer() {
                  if (this.interval <= 0 || !this.autoplay || this.timer) return;
                  this.timer = setInterval(this.playSlides, this.interval);
                },
                setActiveItem: function setActiveItem(index) {
                  if (typeof index === 'string') {
                    const filteredItems = this.items.filter((item) => item.name === index);
                    if (filteredItems.length > 0) {
                      index = this.items.indexOf(filteredItems[0]);
                    }
                  }
                  index = Number(index);
                  if (isNaN(index) || index !== Math.floor(index)) {
                    console.warn('[Element Warn][Carousel]index must be an integer.');
                    return;
                  }
                  const { length } = this.items;
                  const oldIndex = this.activeIndex;
                  if (index < 0) {
                    this.activeIndex = this.loop ? length - 1 : 0;
                  } else if (index >= length) {
                    this.activeIndex = this.loop ? 0 : length - 1;
                  } else {
                    this.activeIndex = index;
                  }
                  if (oldIndex === this.activeIndex) {
                    this.resetItemPosition(oldIndex);
                  }
                },
                prev: function prev() {
                  this.setActiveItem(this.activeIndex - 1);
                },
                next: function next() {
                  this.setActiveItem(this.activeIndex + 1);
                },
                handleIndicatorClick: function handleIndicatorClick(index) {
                  this.activeIndex = index;
                },
                handleIndicatorHover: function handleIndicatorHover(index) {
                  if (this.trigger === 'hover' && index !== this.activeIndex) {
                    this.activeIndex = index;
                  }
                },
              },

              created: function created() {
                const _this3 = this;

                this.throttledArrowClick = throttle_default()(300, true, (index) => {
                  _this3.setActiveItem(index);
                });
                this.throttledIndicatorHover = throttle_default()(300, (index) => {
                  _this3.handleIndicatorHover(index);
                });
              },
              mounted: function mounted() {
                const _this4 = this;

                this.updateItems();
                this.$nextTick(() => {
                  Object(resize_event_.addResizeListener)(_this4.$el, _this4.resetItemPosition);
                  if (_this4.initialIndex < _this4.items.length && _this4.initialIndex >= 0) {
                    _this4.activeIndex = _this4.initialIndex;
                  }
                  _this4.startTimer();
                });
              },
              beforeDestroy: function beforeDestroy() {
                if (this.$el) Object(resize_event_.removeResizeListener)(this.$el, this.resetItemPosition);
                this.pauseTimer();
              },
            });
            // CONCATENATED MODULE: ./packages/carousel/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_carousel_src_mainvue_type_script_lang_js_ = (carousel_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/carousel/src/main.vue

            /* normalize component */

            const carousel_src_main_component = normalizeComponent(
              packages_carousel_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_5d5d1482_render,
              mainvue_type_template_id_5d5d1482_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let carousel_src_main_api; }
            carousel_src_main_component.options.__file = 'packages/carousel/src/main.vue';
            /* harmony default export */ const carousel_src_main = (carousel_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/carousel/index.js

            /* istanbul ignore next */
            carousel_src_main.install = function (Vue) {
              Vue.component(carousel_src_main.name, carousel_src_main);
            };

            /* harmony default export */ const carousel = (carousel_src_main);
            // CONCATENATED MODULE: ./packages/scrollbar/src/util.js
            const BAR_MAP = {
              vertical: {
                offset: 'offsetHeight',
                scroll: 'scrollTop',
                scrollSize: 'scrollHeight',
                size: 'height',
                key: 'vertical',
                axis: 'Y',
                client: 'clientY',
                direction: 'top',
              },
              horizontal: {
                offset: 'offsetWidth',
                scroll: 'scrollLeft',
                scrollSize: 'scrollWidth',
                size: 'width',
                key: 'horizontal',
                axis: 'X',
                client: 'clientX',
                direction: 'left',
              },
            };

            function renderThumbStyle(_ref) {
              const { move } = _ref;
              const { size } = _ref;
              const { bar } = _ref;

              const style = {};
              const translate = `translate${bar.axis}(${move}%)`;

              style[bar.size] = size;
              style.transform = translate;
              style.msTransform = translate;
              style.webkitTransform = translate;

              return style;
            }
            // CONCATENATED MODULE: ./packages/scrollbar/src/bar.js

            /* istanbul ignore next */
            /* harmony default export */ const src_bar = ({
              name: 'Bar',

              props: {
                vertical: Boolean,
                size: String,
                move: Number,
              },

              computed: {
                bar: function bar() {
                  return BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];
                },
                wrap: function wrap() {
                  return this.$parent.wrap;
                },
              },

              render: function render(h) {
                const { size } = this;
                const { move } = this;
                const { bar } = this;

                return h(
                  'div',
                  {
                    class: ['el-scrollbar__bar', `is-${bar.key}`],
                    on: {
                      mousedown: this.clickTrackHandler,
                    },
                  },
                  [h('div', {
                    ref: 'thumb',
                    class: 'el-scrollbar__thumb',
                    on: {
                      mousedown: this.clickThumbHandler,
                    },

                    style: renderThumbStyle({ size, move, bar }),
                  })],
                );
              },

              methods: {
                clickThumbHandler: function clickThumbHandler(e) {
                  // prevent click event of right button
                  if (e.ctrlKey || e.button === 2) {
                    return;
                  }
                  this.startDrag(e);
                  this[this.bar.axis] = e.currentTarget[this.bar.offset] - (e[this.bar.client] - e.currentTarget.getBoundingClientRect()[this.bar.direction]);
                },
                clickTrackHandler: function clickTrackHandler(e) {
                  const offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);
                  const thumbHalf = this.$refs.thumb[this.bar.offset] / 2;
                  const thumbPositionPercentage = (offset - thumbHalf) * 100 / this.$el[this.bar.offset];

                  this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
                },
                startDrag: function startDrag(e) {
                  e.stopImmediatePropagation();
                  this.cursorDown = true;

                  Object(dom_.on)(document, 'mousemove', this.mouseMoveDocumentHandler);
                  Object(dom_.on)(document, 'mouseup', this.mouseUpDocumentHandler);
                  document.onselectstart = function () {
                    return false;
                  };
                },
                mouseMoveDocumentHandler: function mouseMoveDocumentHandler(e) {
                  if (this.cursorDown === false) return;
                  const prevPage = this[this.bar.axis];

                  if (!prevPage) return;

                  const offset = (this.$el.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]) * -1;
                  const thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;
                  const thumbPositionPercentage = (offset - thumbClickPosition) * 100 / this.$el[this.bar.offset];

                  this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
                },
                mouseUpDocumentHandler: function mouseUpDocumentHandler(e) {
                  this.cursorDown = false;
                  this[this.bar.axis] = 0;
                  Object(dom_.off)(document, 'mousemove', this.mouseMoveDocumentHandler);
                  document.onselectstart = null;
                },
              },

              destroyed: function destroyed() {
                Object(dom_.off)(document, 'mouseup', this.mouseUpDocumentHandler);
              },
            });
            // CONCATENATED MODULE: ./packages/scrollbar/src/main.js
            // reference https://github.com/noeldelgado/gemini-scrollbar/blob/master/index.js

            /* istanbul ignore next */
            /* harmony default export */ const scrollbar_src_main = ({
              name: 'ElScrollbar',

              components: { Bar: src_bar },

              props: {
                native: Boolean,
                wrapStyle: {},
                wrapClass: {},
                viewClass: {},
                viewStyle: {},
                noresize: Boolean, // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
                tag: {
                  type: String,
                  default: 'div',
                },
              },

              data: function data() {
                return {
                  sizeWidth: '0',
                  sizeHeight: '0',
                  moveX: 0,
                  moveY: 0,
                };
              },

              computed: {
                wrap: function wrap() {
                  return this.$refs.wrap;
                },
              },

              render: function render(h) {
                const gutter = scrollbar_width_default()();
                let style = this.wrapStyle;

                if (gutter) {
                  const gutterWith = `-${gutter}px`;
                  const gutterStyle = `margin-bottom: ${gutterWith}; margin-right: ${gutterWith};`;

                  if (Array.isArray(this.wrapStyle)) {
                    style = Object(util_.toObject)(this.wrapStyle);
                    style.marginRight = style.marginBottom = gutterWith;
                  } else if (typeof this.wrapStyle === 'string') {
                    style += gutterStyle;
                  } else {
                    style = gutterStyle;
                  }
                }
                const view = h(this.tag, {
                  class: ['el-scrollbar__view', this.viewClass],
                  style: this.viewStyle,
                  ref: 'resize',
                }, this.$slots.default);
                const wrap = h(
                  'div',
                  {
                    ref: 'wrap',
                    style,
                    on: {
                      scroll: this.handleScroll,
                    },

                    class: [this.wrapClass, 'el-scrollbar__wrap', gutter ? '' : 'el-scrollbar__wrap--hidden-default'],
                  },
                  [[view]],
                );
                let nodes = void 0;

                if (!this.native) {
                  nodes = [wrap, h(src_bar, {
                    attrs: {
                      move: this.moveX,
                      size: this.sizeWidth,
                    },
                  }), h(src_bar, {
                    attrs: {
                      vertical: true,
                      move: this.moveY,
                      size: this.sizeHeight,
                    },
                  })];
                } else {
                  nodes = [h(
                    'div',
                    {
                      ref: 'wrap',
                      class: [this.wrapClass, 'el-scrollbar__wrap'],
                      style,
                    },
                    [[view]],
                  )];
                }
                return h('div', { class: 'el-scrollbar' }, nodes);
              },

              methods: {
                handleScroll: function handleScroll() {
                  const { wrap } = this;

                  this.moveY = wrap.scrollTop * 100 / wrap.clientHeight;
                  this.moveX = wrap.scrollLeft * 100 / wrap.clientWidth;
                },
                update: function update() {
                  let heightPercentage = void 0;
                  let widthPercentage = void 0;
                  const { wrap } = this;
                  if (!wrap) return;

                  heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
                  widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;

                  this.sizeHeight = heightPercentage < 100 ? `${heightPercentage}%` : '';
                  this.sizeWidth = widthPercentage < 100 ? `${widthPercentage}%` : '';
                },
              },

              mounted: function mounted() {
                if (this.native) return;
                this.$nextTick(this.update);
                !this.noresize && Object(resize_event_.addResizeListener)(this.$refs.resize, this.update);
              },
              beforeDestroy: function beforeDestroy() {
                if (this.native) return;
                !this.noresize && Object(resize_event_.removeResizeListener)(this.$refs.resize, this.update);
              },
            });
            // CONCATENATED MODULE: ./packages/scrollbar/index.js

            /* istanbul ignore next */
            scrollbar_src_main.install = function (Vue) {
              Vue.component(scrollbar_src_main.name, scrollbar_src_main);
            };

            /* harmony default export */ const scrollbar = (scrollbar_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/carousel/src/item.vue?vue&type=template&id=1801ae19&
            const itemvue_type_template_id_1801ae19_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  directives: [
                    {
                      name: 'show',
                      rawName: 'v-show',
                      value: _vm.ready,
                      expression: 'ready',
                    },
                  ],
                  staticClass: 'el-carousel__item',
                  class: {
                    'is-active': _vm.active,
                    'el-carousel__item--card': _vm.$parent.type === 'card',
                    'is-in-stage': _vm.inStage,
                    'is-hover': _vm.hover,
                    'is-animating': _vm.animating,
                  },
                  style: _vm.itemStyle,
                  on: { click: _vm.handleItemClick },
                },
                [
                  _vm.$parent.type === 'card'
                    ? _c('div', {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: !_vm.active,
                          expression: '!active',
                        },
                      ],
                      staticClass: 'el-carousel__mask',
                    })
                    : _vm._e(),
                  _vm._t('default'),
                ],
                2,
              );
            };
            const itemvue_type_template_id_1801ae19_staticRenderFns = [];
            itemvue_type_template_id_1801ae19_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/carousel/src/item.vue?vue&type=template&id=1801ae19&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/carousel/src/item.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const CARD_SCALE = 0.83;
            /* harmony default export */ const itemvue_type_script_lang_js_ = ({
              name: 'ElCarouselItem',

              props: {
                name: String,
                label: {
                  type: [String, Number],
                  default: '',
                },
              },

              data: function data() {
                return {
                  hover: false,
                  translate: 0,
                  scale: 1,
                  active: false,
                  ready: false,
                  inStage: false,
                  animating: false,
                };
              },

              methods: {
                processIndex: function processIndex(index, activeIndex, length) {
                  if (activeIndex === 0 && index === length - 1) {
                    return -1;
                  } if (activeIndex === length - 1 && index === 0) {
                    return length;
                  } if (index < activeIndex - 1 && activeIndex - index >= length / 2) {
                    return length + 1;
                  } if (index > activeIndex + 1 && index - activeIndex >= length / 2) {
                    return -2;
                  }
                  return index;
                },
                calcCardTranslate: function calcCardTranslate(index, activeIndex) {
                  const parentWidth = this.$parent.$el.offsetWidth;
                  if (this.inStage) {
                    return parentWidth * ((2 - CARD_SCALE) * (index - activeIndex) + 1) / 4;
                  } if (index < activeIndex) {
                    return -(1 + CARD_SCALE) * parentWidth / 4;
                  }
                  return (3 + CARD_SCALE) * parentWidth / 4;
                },
                calcTranslate: function calcTranslate(index, activeIndex, isVertical) {
                  const distance = this.$parent.$el[isVertical ? 'offsetHeight' : 'offsetWidth'];
                  return distance * (index - activeIndex);
                },
                translateItem: function translateItem(index, activeIndex, oldIndex) {
                  const parentType = this.$parent.type;
                  const { parentDirection } = this;
                  const { length } = this.$parent.items;
                  if (parentType !== 'card' && oldIndex !== undefined) {
                    this.animating = index === activeIndex || index === oldIndex;
                  }
                  if (index !== activeIndex && length > 2 && this.$parent.loop) {
                    index = this.processIndex(index, activeIndex, length);
                  }
                  if (parentType === 'card') {
                    if (parentDirection === 'vertical') {
                      console.warn('[Element Warn][Carousel]vertical direction is not supported in card mode');
                    }
                    this.inStage = Math.round(Math.abs(index - activeIndex)) <= 1;
                    this.active = index === activeIndex;
                    this.translate = this.calcCardTranslate(index, activeIndex);
                    this.scale = this.active ? 1 : CARD_SCALE;
                  } else {
                    this.active = index === activeIndex;
                    const isVertical = parentDirection === 'vertical';
                    this.translate = this.calcTranslate(index, activeIndex, isVertical);
                  }
                  this.ready = true;
                },
                handleItemClick: function handleItemClick() {
                  const parent = this.$parent;
                  if (parent && parent.type === 'card') {
                    const index = parent.items.indexOf(this);
                    parent.setActiveItem(index);
                  }
                },
              },

              computed: {
                parentDirection: function parentDirection() {
                  return this.$parent.direction;
                },
                itemStyle: function itemStyle() {
                  const translateType = this.parentDirection === 'vertical' ? 'translateY' : 'translateX';
                  const value = `${translateType}(${this.translate}px) scale(${this.scale})`;
                  const style = {
                    transform: value,
                  };
                  return Object(util_.autoprefixer)(style);
                },
              },

              created: function created() {
                this.$parent && this.$parent.updateItems();
              },
              destroyed: function destroyed() {
                this.$parent && this.$parent.updateItems();
              },
            });
            // CONCATENATED MODULE: ./packages/carousel/src/item.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_itemvue_type_script_lang_js_ = (itemvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/carousel/src/item.vue

            /* normalize component */

            const item_component = normalizeComponent(
              src_itemvue_type_script_lang_js_,
              itemvue_type_template_id_1801ae19_render,
              itemvue_type_template_id_1801ae19_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let item_api; }
            item_component.options.__file = 'packages/carousel/src/item.vue';
            /* harmony default export */ const src_item = (item_component.exports);
            // CONCATENATED MODULE: ./packages/carousel-item/index.js

            /* istanbul ignore next */
            src_item.install = function (Vue) {
              Vue.component(src_item.name, src_item);
            };

            /* harmony default export */ const carousel_item = (src_item);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/collapse/src/collapse.vue?vue&type=template&id=461d57f4&
            const collapsevue_type_template_id_461d57f4_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-collapse',
                  attrs: { role: 'tablist', 'aria-multiselectable': 'true' },
                },
                [_vm._t('default')],
                2,
              );
            };
            const collapsevue_type_template_id_461d57f4_staticRenderFns = [];
            collapsevue_type_template_id_461d57f4_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/collapse/src/collapse.vue?vue&type=template&id=461d57f4&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/collapse/src/collapse.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //

            /* harmony default export */ const collapsevue_type_script_lang_js_ = ({
              name: 'ElCollapse',

              componentName: 'ElCollapse',

              props: {
                accordion: Boolean,
                value: {
                  type: [Array, String, Number],
                  default: function _default() {
                    return [];
                  },
                },
              },

              data: function data() {
                return {
                  activeNames: [].concat(this.value),
                };
              },
              provide: function provide() {
                return {
                  collapse: this,
                };
              },

              watch: {
                value: function value(_value) {
                  this.activeNames = [].concat(_value);
                },
              },

              methods: {
                setActiveNames: function setActiveNames(activeNames) {
                  activeNames = [].concat(activeNames);
                  const value = this.accordion ? activeNames[0] : activeNames;
                  this.activeNames = activeNames;
                  this.$emit('input', value);
                  this.$emit('change', value);
                },
                handleItemClick: function handleItemClick(item) {
                  if (this.accordion) {
                    this.setActiveNames((this.activeNames[0] || this.activeNames[0] === 0) && this.activeNames[0] === item.name ? '' : item.name);
                  } else {
                    const activeNames = this.activeNames.slice(0);
                    const index = activeNames.indexOf(item.name);

                    if (index > -1) {
                      activeNames.splice(index, 1);
                    } else {
                      activeNames.push(item.name);
                    }
                    this.setActiveNames(activeNames);
                  }
                },
              },

              created: function created() {
                this.$on('item-click', this.handleItemClick);
              },
            });
            // CONCATENATED MODULE: ./packages/collapse/src/collapse.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_collapsevue_type_script_lang_js_ = (collapsevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/collapse/src/collapse.vue

            /* normalize component */

            const collapse_component = normalizeComponent(
              src_collapsevue_type_script_lang_js_,
              collapsevue_type_template_id_461d57f4_render,
              collapsevue_type_template_id_461d57f4_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let collapse_api; }
            collapse_component.options.__file = 'packages/collapse/src/collapse.vue';
            /* harmony default export */ const collapse = (collapse_component.exports);
            // CONCATENATED MODULE: ./packages/collapse/index.js

            /* istanbul ignore next */
            collapse.install = function (Vue) {
              Vue.component(collapse.name, collapse);
            };

            /* harmony default export */ const packages_collapse = (collapse);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/collapse/src/collapse-item.vue?vue&type=template&id=2d05faac&
            const collapse_itemvue_type_template_id_2d05faac_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-collapse-item',
                  class: { 'is-active': _vm.isActive, 'is-disabled': _vm.disabled },
                },
                [
                  _c(
                    'div',
                    {
                      attrs: {
                        role: 'tab',
                        'aria-expanded': _vm.isActive,
                        'aria-controls': `el-collapse-content-${_vm.id}`,
                        'aria-describedby': `el-collapse-content-${_vm.id}`,
                      },
                    },
                    [
                      _c(
                        'div',
                        {
                          staticClass: 'el-collapse-item__header',
                          class: {
                            focusing: _vm.focusing,
                            'is-active': _vm.isActive,
                          },
                          attrs: {
                            role: 'button',
                            id: `el-collapse-head-${_vm.id}`,
                            tabindex: _vm.disabled ? undefined : 0,
                          },
                          on: {
                            click: _vm.handleHeaderClick,
                            keyup($event) {
                              if (
                                !('button' in $event)
                    && _vm._k($event.keyCode, 'space', 32, $event.key, [
                      ' ',
                      'Spacebar',
                    ])
                    && _vm._k($event.keyCode, 'enter', 13, $event.key, 'Enter')
                              ) {
                                return null;
                              }
                              $event.stopPropagation();
                              return _vm.handleEnterClick($event);
                            },
                            focus: _vm.handleFocus,
                            blur($event) {
                              _vm.focusing = false;
                            },
                          },
                        },
                        [
                          _vm._t('title', [_vm._v(_vm._s(_vm.title))]),
                          _c('i', {
                            staticClass: 'el-collapse-item__arrow el-icon-arrow-right',
                            class: { 'is-active': _vm.isActive },
                          }),
                        ],
                        2,
                      ),
                    ],
                  ),
                  _c('el-collapse-transition', [
                    _c(
                      'div',
                      {
                        directives: [
                          {
                            name: 'show',
                            rawName: 'v-show',
                            value: _vm.isActive,
                            expression: 'isActive',
                          },
                        ],
                        staticClass: 'el-collapse-item__wrap',
                        attrs: {
                          role: 'tabpanel',
                          'aria-hidden': !_vm.isActive,
                          'aria-labelledby': `el-collapse-head-${_vm.id}`,
                          id: `el-collapse-content-${_vm.id}`,
                        },
                      },
                      [
                        _c(
                          'div',
                          { staticClass: 'el-collapse-item__content' },
                          [_vm._t('default')],
                          2,
                        ),
                      ],
                    ),
                  ]),
                ],
                1,
              );
            };
            const collapse_itemvue_type_template_id_2d05faac_staticRenderFns = [];
            collapse_itemvue_type_template_id_2d05faac_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/collapse/src/collapse-item.vue?vue&type=template&id=2d05faac&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/collapse/src/collapse-item.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const collapse_itemvue_type_script_lang_js_ = ({
              name: 'ElCollapseItem',

              componentName: 'ElCollapseItem',

              mixins: [emitter_default.a],

              components: { ElCollapseTransition: collapse_transition_default.a },

              data: function data() {
                return {
                  contentWrapStyle: {
                    height: 'auto',
                    display: 'block',
                  },
                  contentHeight: 0,
                  focusing: false,
                  isClick: false,
                  id: Object(util_.generateId)(),
                };
              },

              inject: ['collapse'],

              props: {
                title: String,
                name: {
                  type: [String, Number],
                  default: function _default() {
                    return this._uid;
                  },
                },
                disabled: Boolean,
              },

              computed: {
                isActive: function isActive() {
                  return this.collapse.activeNames.indexOf(this.name) > -1;
                },
              },

              methods: {
                handleFocus: function handleFocus() {
                  const _this = this;

                  setTimeout(() => {
                    if (!_this.isClick) {
                      _this.focusing = true;
                    } else {
                      _this.isClick = false;
                    }
                  }, 50);
                },
                handleHeaderClick: function handleHeaderClick() {
                  if (this.disabled) return;
                  this.dispatch('ElCollapse', 'item-click', this);
                  this.focusing = false;
                  this.isClick = true;
                },
                handleEnterClick: function handleEnterClick() {
                  this.dispatch('ElCollapse', 'item-click', this);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/collapse/src/collapse-item.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_collapse_itemvue_type_script_lang_js_ = (collapse_itemvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/collapse/src/collapse-item.vue

            /* normalize component */

            const collapse_item_component = normalizeComponent(
              src_collapse_itemvue_type_script_lang_js_,
              collapse_itemvue_type_template_id_2d05faac_render,
              collapse_itemvue_type_template_id_2d05faac_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let collapse_item_api; }
            collapse_item_component.options.__file = 'packages/collapse/src/collapse-item.vue';
            /* harmony default export */ const collapse_item = (collapse_item_component.exports);
            // CONCATENATED MODULE: ./packages/collapse-item/index.js

            /* istanbul ignore next */
            collapse_item.install = function (Vue) {
              Vue.component(collapse_item.name, collapse_item);
            };

            /* harmony default export */ const packages_collapse_item = (collapse_item);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader/src/cascader.vue?vue&type=template&id=032537a6&
            const cascadervue_type_template_id_032537a6_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  directives: [
                    {
                      name: 'clickoutside',
                      rawName: 'v-clickoutside',
                      value() {
                        return _vm.toggleDropDownVisible(false);
                      },
                      expression: '() => toggleDropDownVisible(false)',
                    },
                  ],
                  ref: 'reference',
                  class: [
                    'el-cascader',
                    _vm.realSize && `el-cascader--${_vm.realSize}`,
                    { 'is-disabled': _vm.isDisabled },
                  ],
                  on: {
                    mouseenter($event) {
                      _vm.inputHover = true;
                    },
                    mouseleave($event) {
                      _vm.inputHover = false;
                    },
                    click() {
                      return _vm.toggleDropDownVisible(_vm.readonly ? undefined : true);
                    },
                    keydown: _vm.handleKeyDown,
                  },
                },
                [
                  _c(
                    'el-input',
                    {
                      ref: 'input',
                      class: { 'is-focus': _vm.dropDownVisible },
                      attrs: {
                        size: _vm.realSize,
                        placeholder: _vm.placeholder,
                        readonly: _vm.readonly,
                        disabled: _vm.isDisabled,
                        'validate-event': false,
                      },
                      on: {
                        focus: _vm.handleFocus,
                        blur: _vm.handleBlur,
                        input: _vm.handleInput,
                      },
                      model: {
                        value: _vm.multiple ? _vm.presentText : _vm.inputValue,
                        callback($$v) {
                          _vm.multiple ? _vm.presentText : (_vm.inputValue = $$v);
                        },
                        expression: 'multiple ? presentText : inputValue',
                      },
                    },
                    [
                      _c('template', { slot: 'suffix' }, [
                        _vm.clearBtnVisible
                          ? _c('i', {
                            key: 'clear',
                            staticClass: 'el-input__icon el-icon-circle-close',
                            on: {
                              click($event) {
                                $event.stopPropagation();
                                return _vm.handleClear($event);
                              },
                            },
                          })
                          : _c('i', {
                            key: 'arrow-down',
                            class: [
                              'el-input__icon',
                              'el-icon-arrow-down',
                              _vm.dropDownVisible && 'is-reverse',
                            ],
                            on: {
                              click($event) {
                                $event.stopPropagation();
                                _vm.toggleDropDownVisible();
                              },
                            },
                          }),
                      ]),
                    ],
                    2,
                  ),
                  _vm.multiple
                    ? _c(
                      'div',
                      { staticClass: 'el-cascader__tags' },
                      [
                        _vm._l(_vm.presentTags, (tag, index) => _c(
                          'el-tag',
                          {
                            key: tag.key,
                            attrs: {
                              type: 'info',
                              size: _vm.tagSize,
                              hit: tag.hitState,
                              closable: tag.closable,
                              'disable-transitions': '',
                            },
                            on: {
                              close($event) {
                                _vm.deleteTag(index);
                              },
                            },
                          },
                          [_c('span', [_vm._v(_vm._s(tag.text))])],
                        )),
                        _vm.filterable && !_vm.isDisabled
                          ? _c('input', {
                            directives: [
                              {
                                name: 'model',
                                rawName: 'v-model.trim',
                                value: _vm.inputValue,
                                expression: 'inputValue',
                                modifiers: { trim: true },
                              },
                            ],
                            staticClass: 'el-cascader__search-input',
                            attrs: {
                              type: 'text',
                              placeholder: _vm.presentTags.length ? '' : _vm.placeholder,
                            },
                            domProps: { value: _vm.inputValue },
                            on: {
                              input: [
                                function ($event) {
                                  if ($event.target.composing) {
                                    return;
                                  }
                                  _vm.inputValue = $event.target.value.trim();
                                },
                                function (e) {
                                  return _vm.handleInput(_vm.inputValue, e);
                                },
                              ],
                              click($event) {
                                $event.stopPropagation();
                                _vm.toggleDropDownVisible(true);
                              },
                              keydown($event) {
                                if (
                                  !('button' in $event)
                          && _vm._k(
                            $event.keyCode,
                            'delete',
                            [8, 46],
                            $event.key,
                            ['Backspace', 'Delete', 'Del'],
                          )
                                ) {
                                  return null;
                                }
                                return _vm.handleDelete($event);
                              },
                              blur($event) {
                                _vm.$forceUpdate();
                              },
                            },
                          })
                          : _vm._e(),
                      ],
                      2,
                    )
                    : _vm._e(),
                  _c(
                    'transition',
                    {
                      attrs: { name: 'el-zoom-in-top' },
                      on: { 'after-leave': _vm.handleDropdownLeave },
                    },
                    [
                      _c(
                        'div',
                        {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: _vm.dropDownVisible,
                              expression: 'dropDownVisible',
                            },
                          ],
                          ref: 'popper',
                          class: ['el-popper', 'el-cascader__dropdown', _vm.popperClass],
                        },
                        [
                          _c('el-cascader-panel', {
                            directives: [
                              {
                                name: 'show',
                                rawName: 'v-show',
                                value: !_vm.filtering,
                                expression: '!filtering',
                              },
                            ],
                            ref: 'panel',
                            attrs: {
                              options: _vm.options,
                              props: _vm.config,
                              border: false,
                              'render-label': _vm.$scopedSlots.default,
                            },
                            on: {
                              'expand-change': _vm.handleExpandChange,
                              close($event) {
                                _vm.toggleDropDownVisible(false);
                              },
                            },
                            model: {
                              value: _vm.checkedValue,
                              callback($$v) {
                                _vm.checkedValue = $$v;
                              },
                              expression: 'checkedValue',
                            },
                          }),
                          _vm.filterable
                            ? _c(
                              'el-scrollbar',
                              {
                                directives: [
                                  {
                                    name: 'show',
                                    rawName: 'v-show',
                                    value: _vm.filtering,
                                    expression: 'filtering',
                                  },
                                ],
                                ref: 'suggestionPanel',
                                staticClass: 'el-cascader__suggestion-panel',
                                attrs: {
                                  tag: 'ul',
                                  'view-class': 'el-cascader__suggestion-list',
                                },
                                nativeOn: {
                                  keydown($event) {
                                    return _vm.handleSuggestionKeyDown($event);
                                  },
                                },
                              },
                              [
                                _vm.suggestions.length
                                  ? _vm._l(_vm.suggestions, (item, index) => _c(
                                    'li',
                                    {
                                      key: item.uid,
                                      class: [
                                        'el-cascader__suggestion-item',
                                        item.checked && 'is-checked',
                                      ],
                                      attrs: { tabindex: -1 },
                                      on: {
                                        click($event) {
                                          _vm.handleSuggestionClick(index);
                                        },
                                      },
                                    },
                                    [
                                      _c('span', [_vm._v(_vm._s(item.text))]),
                                      item.checked
                                        ? _c('i', { staticClass: 'el-icon-check' })
                                        : _vm._e(),
                                    ],
                                  ))
                                  : _vm._t('empty', [
                                    _c(
                                      'li',
                                      { staticClass: 'el-cascader__empty-text' },
                                      [_vm._v(_vm._s(_vm.t('el.cascader.noMatch')))],
                                    ),
                                  ]),
                              ],
                              2,
                            )
                            : _vm._e(),
                        ],
                        1,
                      ),
                    ],
                  ),
                ],
                1,
              );
            };
            const cascadervue_type_template_id_032537a6_staticRenderFns = [];
            cascadervue_type_template_id_032537a6_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/cascader/src/cascader.vue?vue&type=template&id=032537a6&

            // EXTERNAL MODULE: external "element-ui/lib/cascader-panel"
            const cascader_panel_ = __webpack_require__(42);
            const cascader_panel_default = /* #__PURE__ */__webpack_require__.n(cascader_panel_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/aria-utils"
            const aria_utils_ = __webpack_require__(34);
            const aria_utils_default = /* #__PURE__ */__webpack_require__.n(aria_utils_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader/src/cascader.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const KeyCode = aria_utils_default.a.keys;

            const MigratingProps = {
              expandTrigger: {
                newProp: 'expandTrigger',
                type: String,
              },
              changeOnSelect: {
                newProp: 'checkStrictly',
                type: Boolean,
              },
              hoverThreshold: {
                newProp: 'hoverThreshold',
                type: Number,
              },
            };

            const PopperMixin = {
              props: {
                placement: {
                  type: String,
                  default: 'bottom-start',
                },
                appendToBody: vue_popper_default.a.props.appendToBody,
                visibleArrow: {
                  type: Boolean,
                  default: true,
                },
                arrowOffset: vue_popper_default.a.props.arrowOffset,
                offset: vue_popper_default.a.props.offset,
                boundariesPadding: vue_popper_default.a.props.boundariesPadding,
                popperOptions: vue_popper_default.a.props.popperOptions,
              },
              methods: vue_popper_default.a.methods,
              data: vue_popper_default.a.data,
              beforeDestroy: vue_popper_default.a.beforeDestroy,
            };

            const InputSizeMap = {
              medium: 36,
              small: 32,
              mini: 28,
            };

            /* harmony default export */ const cascadervue_type_script_lang_js_ = ({
              name: 'ElCascader',

              directives: { Clickoutside: clickoutside_default.a },

              mixins: [PopperMixin, emitter_default.a, locale_default.a, migrating_default.a],

              inject: {
                elForm: {
                  default: '',
                },
                elFormItem: {
                  default: '',
                },
              },

              components: {
                ElInput: input_default.a,
                ElTag: tag_default.a,
                ElScrollbar: scrollbar_default.a,
                ElCascaderPanel: cascader_panel_default.a,
              },

              props: {
                value: {},
                options: Array,
                props: Object,
                size: String,
                placeholder: {
                  type: String,
                  default: function _default() {
                    return Object(lib_locale_.t)('el.cascader.placeholder');
                  },
                },
                disabled: Boolean,
                clearable: Boolean,
                filterable: Boolean,
                filterMethod: Function,
                separator: {
                  type: String,
                  default: ' / ',
                },
                showAllLevels: {
                  type: Boolean,
                  default: true,
                },
                collapseTags: Boolean,
                debounce: {
                  type: Number,
                  default: 300,
                },
                beforeFilter: {
                  type: Function,
                  default: function _default() {
                    return function () {};
                  },
                },
                popperClass: String,
              },

              data: function data() {
                return {
                  dropDownVisible: false,
                  checkedValue: this.value || null,
                  inputHover: false,
                  inputValue: null,
                  presentText: null,
                  presentTags: [],
                  checkedNodes: [],
                  filtering: false,
                  suggestions: [],
                  inputInitialHeight: 0,
                  pressDeleteCount: 0,
                };
              },

              computed: {
                realSize: function realSize() {
                  const _elFormItemSize = (this.elFormItem || {}).elFormItemSize;
                  return this.size || _elFormItemSize || (this.$ELEMENT || {}).size;
                },
                tagSize: function tagSize() {
                  return ['small', 'mini'].indexOf(this.realSize) > -1 ? 'mini' : 'small';
                },
                isDisabled: function isDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
                config: function config() {
                  const config = this.props || {};
                  const { $attrs } = this;

                  Object.keys(MigratingProps).forEach((oldProp) => {
                    const _MigratingProps$oldPr = MigratingProps[oldProp];
                    const { newProp } = _MigratingProps$oldPr;
                    const { type } = _MigratingProps$oldPr;

                    let oldValue = $attrs[oldProp] || $attrs[Object(util_.kebabCase)(oldProp)];
                    if (Object(shared_.isDef)(oldProp) && !Object(shared_.isDef)(config[newProp])) {
                      if (type === Boolean && oldValue === '') {
                        oldValue = true;
                      }
                      config[newProp] = oldValue;
                    }
                  });

                  return config;
                },
                multiple: function multiple() {
                  return this.config.multiple;
                },
                leafOnly: function leafOnly() {
                  return !this.config.checkStrictly;
                },
                readonly: function readonly() {
                  return !this.filterable || this.multiple;
                },
                clearBtnVisible: function clearBtnVisible() {
                  if (!this.clearable || this.isDisabled || this.filtering || !this.inputHover) {
                    return false;
                  }

                  return this.multiple ? !!this.checkedNodes.filter((node) => !node.isDisabled).length : !!this.presentText;
                },
                panel: function panel() {
                  return this.$refs.panel;
                },
              },

              watch: {
                disabled: function disabled() {
                  this.computePresentContent();
                },
                value: function value(val) {
                  if (!Object(util_.isEqual)(val, this.checkedValue)) {
                    this.checkedValue = val;
                    this.computePresentContent();
                  }
                },
                checkedValue: function checkedValue(val) {
                  const { value } = this;
                  const { dropDownVisible } = this;
                  const _config = this.config;
                  const { checkStrictly } = _config;
                  const { multiple } = _config;

                  if (!Object(util_.isEqual)(val, value) || Object(types_.isUndefined)(value)) {
                    this.computePresentContent();
                    // hide dropdown when single mode
                    if (!multiple && !checkStrictly && dropDownVisible) {
                      this.toggleDropDownVisible(false);
                    }

                    this.$emit('input', val);
                    this.$emit('change', val);
                    this.dispatch('ElFormItem', 'el.form.change', [val]);
                  }
                },

                options: {
                  handler: function handler() {
                    this.$nextTick(this.computePresentContent);
                  },
                  deep: true,
                },
                presentText: function presentText(val) {
                  this.inputValue = val;
                },
                presentTags: function presentTags(val, oldVal) {
                  if (this.multiple && (val.length || oldVal.length)) {
                    this.$nextTick(this.updateStyle);
                  }
                },
                filtering: function filtering(val) {
                  this.$nextTick(this.updatePopper);
                },
              },

              mounted: function mounted() {
                const _this = this;

                const { input } = this.$refs;

                if (input && input.$el) {
                  this.inputInitialHeight = input.$el.offsetHeight || InputSizeMap[this.realSize] || 40;
                }

                if (!Object(util_.isEmpty)(this.value)) {
                  this.computePresentContent();
                }

                this.filterHandler = debounce_default()(this.debounce, () => {
                  const { inputValue } = _this;

                  if (!inputValue) {
                    _this.filtering = false;
                    return;
                  }

                  const before = _this.beforeFilter(inputValue);
                  if (before && before.then) {
                    before.then(_this.getSuggestions);
                  } else if (before !== false) {
                    _this.getSuggestions();
                  } else {
                    _this.filtering = false;
                  }
                });

                Object(resize_event_.addResizeListener)(this.$el, this.updateStyle);
              },
              beforeDestroy: function beforeDestroy() {
                Object(resize_event_.removeResizeListener)(this.$el, this.updateStyle);
              },

              methods: {
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      'expand-trigger': 'expand-trigger is removed, use `props.expandTrigger` instead.',
                      'change-on-select': 'change-on-select is removed, use `props.checkStrictly` instead.',
                      'hover-threshold': 'hover-threshold is removed, use `props.hoverThreshold` instead',
                    },
                    events: {
                      'active-item-change': 'active-item-change is renamed to expand-change',
                    },
                  };
                },
                toggleDropDownVisible: function toggleDropDownVisible(visible) {
                  const _this2 = this;

                  if (this.isDisabled) return;

                  const { dropDownVisible } = this;
                  const { input } = this.$refs;

                  visible = Object(shared_.isDef)(visible) ? visible : !dropDownVisible;
                  if (visible !== dropDownVisible) {
                    this.dropDownVisible = visible;
                    if (visible) {
                      this.$nextTick(() => {
                        _this2.updatePopper();
                        _this2.panel.scrollIntoView();
                      });
                    }
                    input.$refs.input.setAttribute('aria-expanded', visible);
                    this.$emit('visible-change', visible);
                  }
                },
                handleDropdownLeave: function handleDropdownLeave() {
                  this.filtering = false;
                  this.inputValue = this.presentText;
                },
                handleKeyDown: function handleKeyDown(event) {
                  switch (event.keyCode) {
                    case KeyCode.enter:
                      this.toggleDropDownVisible();
                      break;
                    case KeyCode.down:
                      this.toggleDropDownVisible(true);
                      this.focusFirstNode();
                      event.preventDefault();
                      break;
                    case KeyCode.esc:
                    case KeyCode.tab:
                      this.toggleDropDownVisible(false);
                      break;
                  }
                },
                handleFocus: function handleFocus(e) {
                  this.$emit('focus', e);
                },
                handleBlur: function handleBlur(e) {
                  this.$emit('blur', e);
                },
                handleInput: function handleInput(val, event) {
                  !this.dropDownVisible && this.toggleDropDownVisible(true);

                  if (event && event.isComposing) return;
                  if (val) {
                    this.filterHandler();
                  } else {
                    this.filtering = false;
                  }
                },
                handleClear: function handleClear() {
                  this.presentText = '';
                  this.panel.clearCheckedNodes();
                },
                handleExpandChange: function handleExpandChange(value) {
                  this.$nextTick(this.updatePopper.bind(this));
                  this.$emit('expand-change', value);
                  this.$emit('active-item-change', value); // Deprecated
                },
                focusFirstNode: function focusFirstNode() {
                  const _this3 = this;

                  this.$nextTick(() => {
                    const { filtering } = _this3;
                    const _$refs = _this3.$refs;
                    const { popper } = _$refs;
                    const { suggestionPanel } = _$refs;

                    let firstNode = null;

                    if (filtering && suggestionPanel) {
                      firstNode = suggestionPanel.$el.querySelector('.el-cascader__suggestion-item');
                    } else {
                      const firstMenu = popper.querySelector('.el-cascader-menu');
                      firstNode = firstMenu.querySelector('.el-cascader-node[tabindex="-1"]');
                    }

                    if (firstNode) {
                      firstNode.focus();
                      !filtering && firstNode.click();
                    }
                  });
                },
                computePresentContent: function computePresentContent() {
                  const _this4 = this;

                  // nextTick is required, because checked nodes may not change right now
                  this.$nextTick(() => {
                    if (_this4.config.multiple) {
                      _this4.computePresentTags();
                      _this4.presentText = _this4.presentTags.length ? ' ' : null;
                    } else {
                      _this4.computePresentText();
                    }
                  });
                },
                computePresentText: function computePresentText() {
                  const { checkedValue } = this;
                  const { config } = this;

                  if (!Object(util_.isEmpty)(checkedValue)) {
                    const node = this.panel.getNodeByValue(checkedValue);
                    if (node && (config.checkStrictly || node.isLeaf)) {
                      this.presentText = node.getText(this.showAllLevels, this.separator);
                      return;
                    }
                  }
                  this.presentText = null;
                },
                computePresentTags: function computePresentTags() {
                  const { isDisabled } = this;
                  const { leafOnly } = this;
                  const { showAllLevels } = this;
                  const { separator } = this;
                  const { collapseTags } = this;

                  const checkedNodes = this.getCheckedNodes(leafOnly);
                  const tags = [];

                  const genTag = function genTag(node) {
                    return {
                      node,
                      key: node.uid,
                      text: node.getText(showAllLevels, separator),
                      hitState: false,
                      closable: !isDisabled && !node.isDisabled,
                    };
                  };

                  if (checkedNodes.length) {
                    const first = checkedNodes[0];
                    const rest = checkedNodes.slice(1);

                    const restCount = rest.length;
                    tags.push(genTag(first));

                    if (restCount) {
                      if (collapseTags) {
                        tags.push({
                          key: -1,
                          text: `+ ${restCount}`,
                          closable: false,
                        });
                      } else {
                        rest.forEach((node) => tags.push(genTag(node)));
                      }
                    }
                  }

                  this.checkedNodes = checkedNodes;
                  this.presentTags = tags;
                },
                getSuggestions: function getSuggestions() {
                  const _this5 = this;

                  let { filterMethod } = this;

                  if (!Object(types_.isFunction)(filterMethod)) {
                    filterMethod = function filterMethod(node, keyword) {
                      return node.text.includes(keyword);
                    };
                  }

                  const suggestions = this.panel.getFlattedNodes(this.leafOnly).filter((node) => {
                    if (node.isDisabled) return false;
                    node.text = node.getText(_this5.showAllLevels, _this5.separator) || '';
                    return filterMethod(node, _this5.inputValue);
                  });

                  if (this.multiple) {
                    this.presentTags.forEach((tag) => {
                      tag.hitState = false;
                    });
                  } else {
                    suggestions.forEach((node) => {
                      node.checked = Object(util_.isEqual)(_this5.checkedValue, node.getValueByOption());
                    });
                  }

                  this.filtering = true;
                  this.suggestions = suggestions;
                  this.$nextTick(this.updatePopper);
                },
                handleSuggestionKeyDown: function handleSuggestionKeyDown(event) {
                  const { keyCode } = event;
                  const { target } = event;

                  switch (keyCode) {
                    case KeyCode.enter:
                      target.click();
                      break;
                    case KeyCode.up:
                      var prev = target.previousElementSibling;
                      prev && prev.focus();
                      break;
                    case KeyCode.down:
                      var next = target.nextElementSibling;
                      next && next.focus();
                      break;
                    case KeyCode.esc:
                    case KeyCode.tab:
                      this.toggleDropDownVisible(false);
                      break;
                  }
                },
                handleDelete: function handleDelete() {
                  const { inputValue } = this;
                  const { pressDeleteCount } = this;
                  const { presentTags } = this;

                  const lastIndex = presentTags.length - 1;
                  const lastTag = presentTags[lastIndex];
                  this.pressDeleteCount = inputValue ? 0 : pressDeleteCount + 1;

                  if (!lastTag) return;

                  if (this.pressDeleteCount) {
                    if (lastTag.hitState) {
                      this.deleteTag(lastIndex);
                    } else {
                      lastTag.hitState = true;
                    }
                  }
                },
                handleSuggestionClick: function handleSuggestionClick(index) {
                  const { multiple } = this;

                  const targetNode = this.suggestions[index];

                  if (multiple) {
                    const { checked } = targetNode;

                    targetNode.doCheck(!checked);
                    this.panel.calculateMultiCheckedValue();
                  } else {
                    this.checkedValue = targetNode.getValueByOption();
                    this.toggleDropDownVisible(false);
                  }
                },
                deleteTag: function deleteTag(index) {
                  const { checkedValue } = this;

                  const val = checkedValue[index];
                  this.checkedValue = checkedValue.filter((n, i) => i !== index);
                  this.$emit('remove-tag', val);
                },
                updateStyle: function updateStyle() {
                  const { $el } = this;
                  const { inputInitialHeight } = this;

                  if (this.$isServer || !$el) return;

                  const { suggestionPanel } = this.$refs;

                  const inputInner = $el.querySelector('.el-input__inner');

                  if (!inputInner) return;

                  const tags = $el.querySelector('.el-cascader__tags');
                  let suggestionPanelEl = null;

                  if (suggestionPanel && (suggestionPanelEl = suggestionPanel.$el)) {
                    const suggestionList = suggestionPanelEl.querySelector('.el-cascader__suggestion-list');
                    suggestionList.style.minWidth = `${inputInner.offsetWidth}px`;
                  }

                  if (tags) {
                    const { offsetHeight } = tags;

                    const height = `${Math.max(offsetHeight + 6, inputInitialHeight)}px`;
                    inputInner.style.height = height;
                    this.updatePopper();
                  }
                },

                /**
     * public methods
    */
                getCheckedNodes: function getCheckedNodes(leafOnly) {
                  return this.panel.getCheckedNodes(leafOnly);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/cascader/src/cascader.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_cascadervue_type_script_lang_js_ = (cascadervue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/cascader/src/cascader.vue

            /* normalize component */

            const cascader_component = normalizeComponent(
              src_cascadervue_type_script_lang_js_,
              cascadervue_type_template_id_032537a6_render,
              cascadervue_type_template_id_032537a6_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let cascader_api; }
            cascader_component.options.__file = 'packages/cascader/src/cascader.vue';
            /* harmony default export */ const cascader = (cascader_component.exports);
            // CONCATENATED MODULE: ./packages/cascader/index.js

            /* istanbul ignore next */
            cascader.install = function (Vue) {
              Vue.component(cascader.name, cascader);
            };

            /* harmony default export */ const packages_cascader = (cascader);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/main.vue?vue&type=template&id=55c8ade7&
            const mainvue_type_template_id_55c8ade7_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  directives: [
                    {
                      name: 'clickoutside',
                      rawName: 'v-clickoutside',
                      value: _vm.hide,
                      expression: 'hide',
                    },
                  ],
                  class: [
                    'el-color-picker',
                    _vm.colorDisabled ? 'is-disabled' : '',
                    _vm.colorSize ? `el-color-picker--${_vm.colorSize}` : '',
                  ],
                },
                [
                  _vm.colorDisabled
                    ? _c('div', { staticClass: 'el-color-picker__mask' })
                    : _vm._e(),
                  _c(
                    'div',
                    {
                      staticClass: 'el-color-picker__trigger',
                      on: { click: _vm.handleTrigger },
                    },
                    [
                      _c(
                        'span',
                        {
                          staticClass: 'el-color-picker__color',
                          class: { 'is-alpha': _vm.showAlpha },
                        },
                        [
                          _c('span', {
                            staticClass: 'el-color-picker__color-inner',
                            style: {
                              backgroundColor: _vm.displayedColor,
                            },
                          }),
                          !_vm.value && !_vm.showPanelColor
                            ? _c('span', {
                              staticClass: 'el-color-picker__empty el-icon-close',
                            })
                            : _vm._e(),
                        ],
                      ),
                      _c('span', {
                        directives: [
                          {
                            name: 'show',
                            rawName: 'v-show',
                            value: _vm.value || _vm.showPanelColor,
                            expression: 'value || showPanelColor',
                          },
                        ],
                        staticClass: 'el-color-picker__icon el-icon-arrow-down',
                      }),
                    ],
                  ),
                  _c('picker-dropdown', {
                    ref: 'dropdown',
                    class: ['el-color-picker__panel', _vm.popperClass || ''],
                    attrs: {
                      color: _vm.color,
                      'show-alpha': _vm.showAlpha,
                      predefine: _vm.predefine,
                    },
                    on: { pick: _vm.confirmValue, clear: _vm.clearValue },
                    model: {
                      value: _vm.showPicker,
                      callback($$v) {
                        _vm.showPicker = $$v;
                      },
                      expression: 'showPicker',
                    },
                  }),
                ],
                1,
              );
            };
            const mainvue_type_template_id_55c8ade7_staticRenderFns = [];
            mainvue_type_template_id_55c8ade7_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/color-picker/src/main.vue?vue&type=template&id=55c8ade7&

            // CONCATENATED MODULE: ./packages/color-picker/src/color.js
            const color_typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

            function color_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

            const hsv2hsl = function hsv2hsl(hue, sat, val) {
              return [hue, sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0, hue / 2];
            };

            // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
            // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
            const isOnePointZero = function isOnePointZero(n) {
              return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
            };

            const isPercentage = function isPercentage(n) {
              return typeof n === 'string' && n.indexOf('%') !== -1;
            };

            // Take input from [0, n] and return it as [0, 1]
            const bound01 = function bound01(value, max) {
              if (isOnePointZero(value)) value = '100%';

              const processPercent = isPercentage(value);
              value = Math.min(max, Math.max(0, parseFloat(value)));

              // Automatically convert percentage into number
              if (processPercent) {
                value = parseInt(value * max, 10) / 100;
              }

              // Handle floating point rounding errors
              if (Math.abs(value - max) < 0.000001) {
                return 1;
              }

              // Convert into [0, 1] range if it isn't already
              return value % max / parseFloat(max);
            };

            const INT_HEX_MAP = {
              10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F',
            };

            const toHex = function toHex(_ref) {
              const { r } = _ref;
              const { g } = _ref;
              const { b } = _ref;

              const hexOne = function hexOne(value) {
                value = Math.min(Math.round(value), 255);
                const high = Math.floor(value / 16);
                const low = value % 16;
                return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;
              };

              if (isNaN(r) || isNaN(g) || isNaN(b)) return '';

              return `#${hexOne(r)}${hexOne(g)}${hexOne(b)}`;
            };

            const HEX_INT_MAP = {
              A: 10, B: 11, C: 12, D: 13, E: 14, F: 15,
            };

            const parseHexChannel = function parseHexChannel(hex) {
              if (hex.length === 2) {
                return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
              }

              return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
            };

            const hsl2hsv = function hsl2hsv(hue, sat, light) {
              sat /= 100;
              light /= 100;
              let smin = sat;
              const lmin = Math.max(light, 0.01);
              let sv = void 0;
              let v = void 0;

              light *= 2;
              sat *= light <= 1 ? light : 2 - light;
              smin *= lmin <= 1 ? lmin : 2 - lmin;
              v = (light + sat) / 2;
              sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);

              return {
                h: hue,
                s: sv * 100,
                v: v * 100,
              };
            };

            // `rgbToHsv`
            // Converts an RGB color value to HSV
            // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
            // *Returns:* { h, s, v } in [0,1]
            const rgb2hsv = function rgb2hsv(r, g, b) {
              r = bound01(r, 255);
              g = bound01(g, 255);
              b = bound01(b, 255);

              const max = Math.max(r, g, b);
              const min = Math.min(r, g, b);
              let h = void 0;
              let s = void 0;
              const v = max;

              const d = max - min;
              s = max === 0 ? 0 : d / max;

              if (max === min) {
                h = 0; // achromatic
              } else {
                switch (max) {
                  case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                  case g:
                    h = (b - r) / d + 2;
                    break;
                  case b:
                    h = (r - g) / d + 4;
                    break;
                }
                h /= 6;
              }

              return { h: h * 360, s: s * 100, v: v * 100 };
            };

            // `hsvToRgb`
            // Converts an HSV color value to RGB.
            // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
            // *Returns:* { r, g, b } in the set [0, 255]
            const hsv2rgb = function hsv2rgb(h, s, v) {
              h = bound01(h, 360) * 6;
              s = bound01(s, 100);
              v = bound01(v, 100);

              const i = Math.floor(h);
              const f = h - i;
              const p = v * (1 - s);
              const q = v * (1 - f * s);
              const t = v * (1 - (1 - f) * s);
              const mod = i % 6;
              const r = [v, q, p, p, t, v][mod];
              const g = [t, v, v, q, p, p][mod];
              const b = [p, p, t, v, v, q][mod];

              return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255),
              };
            };

            const Color = (function () {
              function Color(options) {
                color_classCallCheck(this, Color);

                this._hue = 0;
                this._saturation = 100;
                this._value = 100;
                this._alpha = 100;

                this.enableAlpha = false;
                this.format = 'hex';
                this.value = '';

                options = options || {};

                for (const option in options) {
                  if (options.hasOwnProperty(option)) {
                    this[option] = options[option];
                  }
                }

                this.doOnChange();
              }

              Color.prototype.set = function set(prop, value) {
                if (arguments.length === 1 && (typeof prop === 'undefined' ? 'undefined' : color_typeof(prop)) === 'object') {
                  for (const p in prop) {
                    if (prop.hasOwnProperty(p)) {
                      this.set(p, prop[p]);
                    }
                  }

                  return;
                }

                this[`_${prop}`] = value;
                this.doOnChange();
              };

              Color.prototype.get = function get(prop) {
                return this[`_${prop}`];
              };

              Color.prototype.toRgb = function toRgb() {
                return hsv2rgb(this._hue, this._saturation, this._value);
              };

              Color.prototype.fromString = function fromString(value) {
                const _this = this;

                if (!value) {
                  this._hue = 0;
                  this._saturation = 100;
                  this._value = 100;

                  this.doOnChange();
                  return;
                }

                const fromHSV = function fromHSV(h, s, v) {
                  _this._hue = Math.max(0, Math.min(360, h));
                  _this._saturation = Math.max(0, Math.min(100, s));
                  _this._value = Math.max(0, Math.min(100, v));

                  _this.doOnChange();
                };

                if (value.indexOf('hsl') !== -1) {
                  const parts = value.replace(/hsla|hsl|\(|\)/gm, '').split(/\s|,/g).filter((val) => val !== '').map((val, index) => (index > 2 ? parseFloat(val) : parseInt(val, 10)));

                  if (parts.length === 4) {
                    this._alpha = Math.floor(parseFloat(parts[3]) * 100);
                  } else if (parts.length === 3) {
                    this._alpha = 100;
                  }
                  if (parts.length >= 3) {
                    const _hsl2hsv = hsl2hsv(parts[0], parts[1], parts[2]);
                    const { h } = _hsl2hsv;
                    const { s } = _hsl2hsv;
                    const { v } = _hsl2hsv;

                    fromHSV(h, s, v);
                  }
                } else if (value.indexOf('hsv') !== -1) {
                  const _parts = value.replace(/hsva|hsv|\(|\)/gm, '').split(/\s|,/g).filter((val) => val !== '').map((val, index) => (index > 2 ? parseFloat(val) : parseInt(val, 10)));

                  if (_parts.length === 4) {
                    this._alpha = Math.floor(parseFloat(_parts[3]) * 100);
                  } else if (_parts.length === 3) {
                    this._alpha = 100;
                  }
                  if (_parts.length >= 3) {
                    fromHSV(_parts[0], _parts[1], _parts[2]);
                  }
                } else if (value.indexOf('rgb') !== -1) {
                  const _parts2 = value.replace(/rgba|rgb|\(|\)/gm, '').split(/\s|,/g).filter((val) => val !== '').map((val, index) => (index > 2 ? parseFloat(val) : parseInt(val, 10)));

                  if (_parts2.length === 4) {
                    this._alpha = Math.floor(parseFloat(_parts2[3]) * 100);
                  } else if (_parts2.length === 3) {
                    this._alpha = 100;
                  }
                  if (_parts2.length >= 3) {
                    const _rgb2hsv = rgb2hsv(_parts2[0], _parts2[1], _parts2[2]);
                    const _h = _rgb2hsv.h;
                    const _s = _rgb2hsv.s;
                    const _v = _rgb2hsv.v;

                    fromHSV(_h, _s, _v);
                  }
                } else if (value.indexOf('#') !== -1) {
                  const hex = value.replace('#', '').trim();
                  if (!/^(?:[0-9a-fA-F]{3}){1,2}|[0-9a-fA-F]{8}$/.test(hex)) return;
                  let r = void 0;
                  let g = void 0;
                  let b = void 0;

                  if (hex.length === 3) {
                    r = parseHexChannel(hex[0] + hex[0]);
                    g = parseHexChannel(hex[1] + hex[1]);
                    b = parseHexChannel(hex[2] + hex[2]);
                  } else if (hex.length === 6 || hex.length === 8) {
                    r = parseHexChannel(hex.substring(0, 2));
                    g = parseHexChannel(hex.substring(2, 4));
                    b = parseHexChannel(hex.substring(4, 6));
                  }

                  if (hex.length === 8) {
                    this._alpha = Math.floor(parseHexChannel(hex.substring(6)) / 255 * 100);
                  } else if (hex.length === 3 || hex.length === 6) {
                    this._alpha = 100;
                  }

                  const _rgb2hsv2 = rgb2hsv(r, g, b);
                  const _h2 = _rgb2hsv2.h;
                  const _s2 = _rgb2hsv2.s;
                  const _v2 = _rgb2hsv2.v;

                  fromHSV(_h2, _s2, _v2);
                }
              };

              Color.prototype.compare = function compare(color) {
                return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
              };

              Color.prototype.doOnChange = function doOnChange() {
                const { _hue } = this;
                let { _saturation } = this;
                let { _value } = this;
                let { _alpha } = this;
                let { format } = this;

                if (this.enableAlpha) {
                  switch (format) {
                    case 'hsl':
                      var hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
                      this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${_alpha / 100})`;
                      break;
                    case 'hsv':
                      this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${_alpha / 100})`;
                      break;
                    default:
                      var _hsv2rgb = hsv2rgb(_hue, _saturation, _value);
                      var { r } = _hsv2rgb;
                      var { g } = _hsv2rgb;
                      var { b } = _hsv2rgb;

                      this.value = `rgba(${r}, ${g}, ${b}, ${_alpha / 100})`;
                  }
                } else {
                  switch (format) {
                    case 'hsl':
                      var _hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
                      this.value = `hsl(${_hue}, ${Math.round(_hsl[1] * 100)}%, ${Math.round(_hsl[2] * 100)}%)`;
                      break;
                    case 'hsv':
                      this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
                      break;
                    case 'rgb':
                      var _hsv2rgb2 = hsv2rgb(_hue, _saturation, _value);
                      var _r = _hsv2rgb2.r;
                      var _g = _hsv2rgb2.g;
                      var _b = _hsv2rgb2.b;

                      this.value = `rgb(${_r}, ${_g}, ${_b})`;
                      break;
                    default:
                      this.value = toHex(hsv2rgb(_hue, _saturation, _value));
                  }
                }
              };

              return Color;
            }());

            /* harmony default export */ const src_color = (Color);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/picker-dropdown.vue?vue&type=template&id=06601625&
            const picker_dropdownvue_type_template_id_06601625_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                { attrs: { name: 'el-zoom-in-top' }, on: { 'after-leave': _vm.doDestroy } },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.showPopper,
                          expression: 'showPopper',
                        },
                      ],
                      staticClass: 'el-color-dropdown',
                    },
                    [
                      _c(
                        'div',
                        { staticClass: 'el-color-dropdown__main-wrapper' },
                        [
                          _c('hue-slider', {
                            ref: 'hue',
                            staticStyle: { float: 'right' },
                            attrs: { color: _vm.color, vertical: '' },
                          }),
                          _c('sv-panel', { ref: 'sl', attrs: { color: _vm.color } }),
                        ],
                        1,
                      ),
                      _vm.showAlpha
                        ? _c('alpha-slider', { ref: 'alpha', attrs: { color: _vm.color } })
                        : _vm._e(),
                      _vm.predefine
                        ? _c('predefine', {
                          attrs: { color: _vm.color, colors: _vm.predefine },
                        })
                        : _vm._e(),
                      _c(
                        'div',
                        { staticClass: 'el-color-dropdown__btns' },
                        [
                          _c(
                            'span',
                            { staticClass: 'el-color-dropdown__value' },
                            [
                              _c('el-input', {
                                attrs: { 'validate-event': false, size: 'mini' },
                                on: { blur: _vm.handleConfirm },
                                nativeOn: {
                                  keyup($event) {
                                    if (
                                      !('button' in $event)
                          && _vm._k(
                            $event.keyCode,
                            'enter',
                            13,
                            $event.key,
                            'Enter',
                          )
                                    ) {
                                      return null;
                                    }
                                    return _vm.handleConfirm($event);
                                  },
                                },
                                model: {
                                  value: _vm.customInput,
                                  callback($$v) {
                                    _vm.customInput = $$v;
                                  },
                                  expression: 'customInput',
                                },
                              }),
                            ],
                            1,
                          ),
                          _c(
                            'el-button',
                            {
                              staticClass: 'el-color-dropdown__link-btn',
                              attrs: { size: 'mini', type: 'text' },
                              on: {
                                click($event) {
                                  _vm.$emit('clear');
                                },
                              },
                            },
                            [
                              _vm._v(
                                `\n        ${
                                  _vm._s(_vm.t('el.colorpicker.clear'))
                                }\n      `,
                              ),
                            ],
                          ),
                          _c(
                            'el-button',
                            {
                              staticClass: 'el-color-dropdown__btn',
                              attrs: { plain: '', size: 'mini' },
                              on: { click: _vm.confirmValue },
                            },
                            [
                              _vm._v(
                                `\n        ${
                                  _vm._s(_vm.t('el.colorpicker.confirm'))
                                }\n      `,
                              ),
                            ],
                          ),
                        ],
                        1,
                      ),
                    ],
                    1,
                  ),
                ],
              );
            };
            const picker_dropdownvue_type_template_id_06601625_staticRenderFns = [];
            picker_dropdownvue_type_template_id_06601625_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/color-picker/src/components/picker-dropdown.vue?vue&type=template&id=06601625&

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/sv-panel.vue?vue&type=template&id=d8583596&
            const sv_panelvue_type_template_id_d8583596_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-color-svpanel',
                  style: {
                    backgroundColor: _vm.background,
                  },
                },
                [
                  _c('div', { staticClass: 'el-color-svpanel__white' }),
                  _c('div', { staticClass: 'el-color-svpanel__black' }),
                  _c(
                    'div',
                    {
                      staticClass: 'el-color-svpanel__cursor',
                      style: {
                        top: `${_vm.cursorTop}px`,
                        left: `${_vm.cursorLeft}px`,
                      },
                    },
                    [_c('div')],
                  ),
                ],
              );
            };
            const sv_panelvue_type_template_id_d8583596_staticRenderFns = [];
            sv_panelvue_type_template_id_d8583596_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/color-picker/src/components/sv-panel.vue?vue&type=template&id=d8583596&

            // CONCATENATED MODULE: ./packages/color-picker/src/draggable.js

            let isDragging = false;

            /* harmony default export */ const draggable = (function (element, options) {
              if (external_vue_default.a.prototype.$isServer) return;
              const moveFn = function moveFn(event) {
                if (options.drag) {
                  options.drag(event);
                }
              };
              const upFn = function upFn(event) {
                document.removeEventListener('mousemove', moveFn);
                document.removeEventListener('mouseup', upFn);
                document.onselectstart = null;
                document.ondragstart = null;

                isDragging = false;

                if (options.end) {
                  options.end(event);
                }
              };
              element.addEventListener('mousedown', (event) => {
                if (isDragging) return;
                document.onselectstart = function () {
                  return false;
                };
                document.ondragstart = function () {
                  return false;
                };

                document.addEventListener('mousemove', moveFn);
                document.addEventListener('mouseup', upFn);
                isDragging = true;

                if (options.start) {
                  options.start(event);
                }
              });
            });
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/sv-panel.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const sv_panelvue_type_script_lang_js_ = ({
              name: 'el-sl-panel',

              props: {
                color: {
                  required: true,
                },
              },

              computed: {
                colorValue: function colorValue() {
                  const hue = this.color.get('hue');
                  const value = this.color.get('value');
                  return { hue, value };
                },
              },

              watch: {
                colorValue: function colorValue() {
                  this.update();
                },
              },

              methods: {
                update: function update() {
                  const saturation = this.color.get('saturation');
                  const value = this.color.get('value');

                  const el = this.$el;
                  const width = el.clientWidth;
                  const height = el.clientHeight;

                  this.cursorLeft = saturation * width / 100;
                  this.cursorTop = (100 - value) * height / 100;

                  this.background = `hsl(${this.color.get('hue')}, 100%, 50%)`;
                },
                handleDrag: function handleDrag(event) {
                  const el = this.$el;
                  const rect = el.getBoundingClientRect();

                  let left = event.clientX - rect.left;
                  let top = event.clientY - rect.top;
                  left = Math.max(0, left);
                  left = Math.min(left, rect.width);

                  top = Math.max(0, top);
                  top = Math.min(top, rect.height);

                  this.cursorLeft = left;
                  this.cursorTop = top;
                  this.color.set({
                    saturation: left / rect.width * 100,
                    value: 100 - top / rect.height * 100,
                  });
                },
              },

              mounted: function mounted() {
                const _this = this;

                draggable(this.$el, {
                  drag: function drag(event) {
                    _this.handleDrag(event);
                  },
                  end: function end(event) {
                    _this.handleDrag(event);
                  },
                });

                this.update();
              },
              data: function data() {
                return {
                  cursorTop: 0,
                  cursorLeft: 0,
                  background: 'hsl(0, 100%, 50%)',
                };
              },
            });
            // CONCATENATED MODULE: ./packages/color-picker/src/components/sv-panel.vue?vue&type=script&lang=js&
            /* harmony default export */ const components_sv_panelvue_type_script_lang_js_ = (sv_panelvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/color-picker/src/components/sv-panel.vue

            /* normalize component */

            const sv_panel_component = normalizeComponent(
              components_sv_panelvue_type_script_lang_js_,
              sv_panelvue_type_template_id_d8583596_render,
              sv_panelvue_type_template_id_d8583596_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let sv_panel_api; }
            sv_panel_component.options.__file = 'packages/color-picker/src/components/sv-panel.vue';
            /* harmony default export */ const sv_panel = (sv_panel_component.exports);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/hue-slider.vue?vue&type=template&id=5cdc43b1&
            const hue_slidervue_type_template_id_5cdc43b1_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-color-hue-slider',
                  class: { 'is-vertical': _vm.vertical },
                },
                [
                  _c('div', {
                    ref: 'bar',
                    staticClass: 'el-color-hue-slider__bar',
                    on: { click: _vm.handleClick },
                  }),
                  _c('div', {
                    ref: 'thumb',
                    staticClass: 'el-color-hue-slider__thumb',
                    style: {
                      left: `${_vm.thumbLeft}px`,
                      top: `${_vm.thumbTop}px`,
                    },
                  }),
                ],
              );
            };
            const hue_slidervue_type_template_id_5cdc43b1_staticRenderFns = [];
            hue_slidervue_type_template_id_5cdc43b1_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/color-picker/src/components/hue-slider.vue?vue&type=template&id=5cdc43b1&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/hue-slider.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const hue_slidervue_type_script_lang_js_ = ({
              name: 'el-color-hue-slider',

              props: {
                color: {
                  required: true,
                },

                vertical: Boolean,
              },

              data: function data() {
                return {
                  thumbLeft: 0,
                  thumbTop: 0,
                };
              },

              computed: {
                hueValue: function hueValue() {
                  const hue = this.color.get('hue');
                  return hue;
                },
              },

              watch: {
                hueValue: function hueValue() {
                  this.update();
                },
              },

              methods: {
                handleClick: function handleClick(event) {
                  const { thumb } = this.$refs;
                  const { target } = event;

                  if (target !== thumb) {
                    this.handleDrag(event);
                  }
                },
                handleDrag: function handleDrag(event) {
                  const rect = this.$el.getBoundingClientRect();
                  const { thumb } = this.$refs;

                  let hue = void 0;

                  if (!this.vertical) {
                    let left = event.clientX - rect.left;
                    left = Math.min(left, rect.width - thumb.offsetWidth / 2);
                    left = Math.max(thumb.offsetWidth / 2, left);

                    hue = Math.round((left - thumb.offsetWidth / 2) / (rect.width - thumb.offsetWidth) * 360);
                  } else {
                    let top = event.clientY - rect.top;
                    top = Math.min(top, rect.height - thumb.offsetHeight / 2);
                    top = Math.max(thumb.offsetHeight / 2, top);

                    hue = Math.round((top - thumb.offsetHeight / 2) / (rect.height - thumb.offsetHeight) * 360);
                  }

                  this.color.set('hue', hue);
                },
                getThumbLeft: function getThumbLeft() {
                  if (this.vertical) return 0;
                  const el = this.$el;
                  const hue = this.color.get('hue');

                  if (!el) return 0;
                  const { thumb } = this.$refs;
                  return Math.round(hue * (el.offsetWidth - thumb.offsetWidth / 2) / 360);
                },
                getThumbTop: function getThumbTop() {
                  if (!this.vertical) return 0;
                  const el = this.$el;
                  const hue = this.color.get('hue');

                  if (!el) return 0;
                  const { thumb } = this.$refs;
                  return Math.round(hue * (el.offsetHeight - thumb.offsetHeight / 2) / 360);
                },
                update: function update() {
                  this.thumbLeft = this.getThumbLeft();
                  this.thumbTop = this.getThumbTop();
                },
              },

              mounted: function mounted() {
                const _this = this;

                const _$refs = this.$refs;
                const { bar } = _$refs;
                const { thumb } = _$refs;

                const dragConfig = {
                  drag: function drag(event) {
                    _this.handleDrag(event);
                  },
                  end: function end(event) {
                    _this.handleDrag(event);
                  },
                };

                draggable(bar, dragConfig);
                draggable(thumb, dragConfig);
                this.update();
              },
            });
            // CONCATENATED MODULE: ./packages/color-picker/src/components/hue-slider.vue?vue&type=script&lang=js&
            /* harmony default export */ const components_hue_slidervue_type_script_lang_js_ = (hue_slidervue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/color-picker/src/components/hue-slider.vue

            /* normalize component */

            const hue_slider_component = normalizeComponent(
              components_hue_slidervue_type_script_lang_js_,
              hue_slidervue_type_template_id_5cdc43b1_render,
              hue_slidervue_type_template_id_5cdc43b1_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let hue_slider_api; }
            hue_slider_component.options.__file = 'packages/color-picker/src/components/hue-slider.vue';
            /* harmony default export */ const hue_slider = (hue_slider_component.exports);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/alpha-slider.vue?vue&type=template&id=068c66cb&
            const alpha_slidervue_type_template_id_068c66cb_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-color-alpha-slider',
                  class: { 'is-vertical': _vm.vertical },
                },
                [
                  _c('div', {
                    ref: 'bar',
                    staticClass: 'el-color-alpha-slider__bar',
                    style: {
                      background: _vm.background,
                    },
                    on: { click: _vm.handleClick },
                  }),
                  _c('div', {
                    ref: 'thumb',
                    staticClass: 'el-color-alpha-slider__thumb',
                    style: {
                      left: `${_vm.thumbLeft}px`,
                      top: `${_vm.thumbTop}px`,
                    },
                  }),
                ],
              );
            };
            const alpha_slidervue_type_template_id_068c66cb_staticRenderFns = [];
            alpha_slidervue_type_template_id_068c66cb_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/color-picker/src/components/alpha-slider.vue?vue&type=template&id=068c66cb&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/alpha-slider.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const alpha_slidervue_type_script_lang_js_ = ({
              name: 'el-color-alpha-slider',

              props: {
                color: {
                  required: true,
                },
                vertical: Boolean,
              },

              watch: {
                'color._alpha': function color_alpha() {
                  this.update();
                },
                'color.value': function colorValue() {
                  this.update();
                },
              },

              methods: {
                handleClick: function handleClick(event) {
                  const { thumb } = this.$refs;
                  const { target } = event;

                  if (target !== thumb) {
                    this.handleDrag(event);
                  }
                },
                handleDrag: function handleDrag(event) {
                  const rect = this.$el.getBoundingClientRect();
                  const { thumb } = this.$refs;

                  if (!this.vertical) {
                    let left = event.clientX - rect.left;
                    left = Math.max(thumb.offsetWidth / 2, left);
                    left = Math.min(left, rect.width - thumb.offsetWidth / 2);

                    this.color.set('alpha', Math.round((left - thumb.offsetWidth / 2) / (rect.width - thumb.offsetWidth) * 100));
                  } else {
                    let top = event.clientY - rect.top;
                    top = Math.max(thumb.offsetHeight / 2, top);
                    top = Math.min(top, rect.height - thumb.offsetHeight / 2);

                    this.color.set('alpha', Math.round((top - thumb.offsetHeight / 2) / (rect.height - thumb.offsetHeight) * 100));
                  }
                },
                getThumbLeft: function getThumbLeft() {
                  if (this.vertical) return 0;
                  const el = this.$el;
                  const alpha = this.color._alpha;

                  if (!el) return 0;
                  const { thumb } = this.$refs;
                  return Math.round(alpha * (el.offsetWidth - thumb.offsetWidth / 2) / 100);
                },
                getThumbTop: function getThumbTop() {
                  if (!this.vertical) return 0;
                  const el = this.$el;
                  const alpha = this.color._alpha;

                  if (!el) return 0;
                  const { thumb } = this.$refs;
                  return Math.round(alpha * (el.offsetHeight - thumb.offsetHeight / 2) / 100);
                },
                getBackground: function getBackground() {
                  if (this.color && this.color.value) {
                    const _color$toRgb = this.color.toRgb();
                    const { r } = _color$toRgb;
                    const { g } = _color$toRgb;
                    const { b } = _color$toRgb;

                    return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;
                  }
                  return null;
                },
                update: function update() {
                  this.thumbLeft = this.getThumbLeft();
                  this.thumbTop = this.getThumbTop();
                  this.background = this.getBackground();
                },
              },

              data: function data() {
                return {
                  thumbLeft: 0,
                  thumbTop: 0,
                  background: null,
                };
              },
              mounted: function mounted() {
                const _this = this;

                const _$refs = this.$refs;
                const { bar } = _$refs;
                const { thumb } = _$refs;

                const dragConfig = {
                  drag: function drag(event) {
                    _this.handleDrag(event);
                  },
                  end: function end(event) {
                    _this.handleDrag(event);
                  },
                };

                draggable(bar, dragConfig);
                draggable(thumb, dragConfig);
                this.update();
              },
            });
            // CONCATENATED MODULE: ./packages/color-picker/src/components/alpha-slider.vue?vue&type=script&lang=js&
            /* harmony default export */ const components_alpha_slidervue_type_script_lang_js_ = (alpha_slidervue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/color-picker/src/components/alpha-slider.vue

            /* normalize component */

            const alpha_slider_component = normalizeComponent(
              components_alpha_slidervue_type_script_lang_js_,
              alpha_slidervue_type_template_id_068c66cb_render,
              alpha_slidervue_type_template_id_068c66cb_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let alpha_slider_api; }
            alpha_slider_component.options.__file = 'packages/color-picker/src/components/alpha-slider.vue';
            /* harmony default export */ const alpha_slider = (alpha_slider_component.exports);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/predefine.vue?vue&type=template&id=06e03093&
            const predefinevue_type_template_id_06e03093_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('div', { staticClass: 'el-color-predefine' }, [
                _c(
                  'div',
                  { staticClass: 'el-color-predefine__colors' },
                  _vm._l(_vm.rgbaColors, (item, index) => _c(
                    'div',
                    {
                      key: _vm.colors[index],
                      staticClass: 'el-color-predefine__color-selector',
                      class: { selected: item.selected, 'is-alpha': item._alpha < 100 },
                      on: {
                        click($event) {
                          _vm.handleSelect(index);
                        },
                      },
                    },
                    [_c('div', { style: { 'background-color': item.value } })],
                  )),
                  0,
                ),
              ]);
            };
            const predefinevue_type_template_id_06e03093_staticRenderFns = [];
            predefinevue_type_template_id_06e03093_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/color-picker/src/components/predefine.vue?vue&type=template&id=06e03093&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/predefine.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const predefinevue_type_script_lang_js_ = ({
              props: {
                colors: { type: Array, required: true },
                color: { required: true },
              },
              data: function data() {
                return {
                  rgbaColors: this.parseColors(this.colors, this.color),
                };
              },

              methods: {
                handleSelect: function handleSelect(index) {
                  this.color.fromString(this.colors[index]);
                },
                parseColors: function parseColors(colors, color) {
                  return colors.map((value) => {
                    const c = new src_color();
                    c.enableAlpha = true;
                    c.format = 'rgba';
                    c.fromString(value);
                    c.selected = c.value === color.value;
                    return c;
                  });
                },
              },
              watch: {
                '$parent.currentColor': function $parentCurrentColor(val) {
                  const color = new src_color();
                  color.fromString(val);

                  this.rgbaColors.forEach((item) => {
                    item.selected = color.compare(item);
                  });
                },
                colors: function colors(newVal) {
                  this.rgbaColors = this.parseColors(newVal, this.color);
                },
                color: function color(newVal) {
                  this.rgbaColors = this.parseColors(this.colors, newVal);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/color-picker/src/components/predefine.vue?vue&type=script&lang=js&
            /* harmony default export */ const components_predefinevue_type_script_lang_js_ = (predefinevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/color-picker/src/components/predefine.vue

            /* normalize component */

            const predefine_component = normalizeComponent(
              components_predefinevue_type_script_lang_js_,
              predefinevue_type_template_id_06e03093_render,
              predefinevue_type_template_id_06e03093_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let predefine_api; }
            predefine_component.options.__file = 'packages/color-picker/src/components/predefine.vue';
            /* harmony default export */ const predefine = (predefine_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/picker-dropdown.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const picker_dropdownvue_type_script_lang_js_ = ({
              name: 'el-color-picker-dropdown',

              mixins: [vue_popper_default.a, locale_default.a],

              components: {
                SvPanel: sv_panel,
                HueSlider: hue_slider,
                AlphaSlider: alpha_slider,
                ElInput: input_default.a,
                ElButton: button_default.a,
                Predefine: predefine,
              },

              props: {
                color: {
                  required: true,
                },
                showAlpha: Boolean,
                predefine: Array,
              },

              data: function data() {
                return {
                  customInput: '',
                };
              },

              computed: {
                currentColor: function currentColor() {
                  const parent = this.$parent;
                  return !parent.value && !parent.showPanelColor ? '' : parent.color.value;
                },
              },

              methods: {
                confirmValue: function confirmValue() {
                  this.$emit('pick');
                },
                handleConfirm: function handleConfirm() {
                  this.color.fromString(this.customInput);
                },
              },

              mounted: function mounted() {
                this.$parent.popperElm = this.popperElm = this.$el;
                this.referenceElm = this.$parent.$el;
              },

              watch: {
                showPopper: function showPopper(val) {
                  const _this = this;

                  if (val === true) {
                    this.$nextTick(() => {
                      const _$refs = _this.$refs;
                      const { sl } = _$refs;
                      const { hue } = _$refs;
                      const { alpha } = _$refs;

                      sl && sl.update();
                      hue && hue.update();
                      alpha && alpha.update();
                    });
                  }
                },

                currentColor: {
                  immediate: true,
                  handler: function handler(val) {
                    this.customInput = val;
                  },
                },
              },
            });
            // CONCATENATED MODULE: ./packages/color-picker/src/components/picker-dropdown.vue?vue&type=script&lang=js&
            /* harmony default export */ const components_picker_dropdownvue_type_script_lang_js_ = (picker_dropdownvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/color-picker/src/components/picker-dropdown.vue

            /* normalize component */

            const picker_dropdown_component = normalizeComponent(
              components_picker_dropdownvue_type_script_lang_js_,
              picker_dropdownvue_type_template_id_06601625_render,
              picker_dropdownvue_type_template_id_06601625_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let picker_dropdown_api; }
            picker_dropdown_component.options.__file = 'packages/color-picker/src/components/picker-dropdown.vue';
            /* harmony default export */ const picker_dropdown = (picker_dropdown_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const color_picker_src_mainvue_type_script_lang_js_ = ({
              name: 'ElColorPicker',

              mixins: [emitter_default.a],

              props: {
                value: String,
                showAlpha: Boolean,
                colorFormat: String,
                disabled: Boolean,
                size: String,
                popperClass: String,
                predefine: Array,
              },

              inject: {
                elForm: {
                  default: '',
                },
                elFormItem: {
                  default: '',
                },
              },

              directives: { Clickoutside: clickoutside_default.a },

              computed: {
                displayedColor: function displayedColor() {
                  if (!this.value && !this.showPanelColor) {
                    return 'transparent';
                  }

                  return this.displayedRgb(this.color, this.showAlpha);
                },
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                colorSize: function colorSize() {
                  return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
                colorDisabled: function colorDisabled() {
                  return this.disabled || (this.elForm || {}).disabled;
                },
              },

              watch: {
                value: function value(val) {
                  if (!val) {
                    this.showPanelColor = false;
                  } else if (val && val !== this.color.value) {
                    this.color.fromString(val);
                  }
                },

                color: {
                  deep: true,
                  handler: function handler() {
                    this.showPanelColor = true;
                  },
                },
                displayedColor: function displayedColor(val) {
                  if (!this.showPicker) return;
                  const currentValueColor = new src_color({
                    enableAlpha: this.showAlpha,
                    format: this.colorFormat,
                  });
                  currentValueColor.fromString(this.value);

                  const currentValueColorRgb = this.displayedRgb(currentValueColor, this.showAlpha);
                  if (val !== currentValueColorRgb) {
                    this.$emit('active-change', val);
                  }
                },
              },

              methods: {
                handleTrigger: function handleTrigger() {
                  if (this.colorDisabled) return;
                  this.showPicker = !this.showPicker;
                },
                confirmValue: function confirmValue() {
                  const { value } = this.color;
                  this.$emit('input', value);
                  this.$emit('change', value);
                  this.dispatch('ElFormItem', 'el.form.change', value);
                  this.showPicker = false;
                },
                clearValue: function clearValue() {
                  this.$emit('input', null);
                  this.$emit('change', null);
                  if (this.value !== null) {
                    this.dispatch('ElFormItem', 'el.form.change', null);
                  }
                  this.showPanelColor = false;
                  this.showPicker = false;
                  this.resetColor();
                },
                hide: function hide() {
                  this.showPicker = false;
                  this.resetColor();
                },
                resetColor: function resetColor() {
                  const _this = this;

                  this.$nextTick((_) => {
                    if (_this.value) {
                      _this.color.fromString(_this.value);
                    } else {
                      _this.showPanelColor = false;
                    }
                  });
                },
                displayedRgb: function displayedRgb(color, showAlpha) {
                  if (!(color instanceof src_color)) {
                    throw Error('color should be instance of Color Class');
                  }

                  const _color$toRgb = color.toRgb();
                  const { r } = _color$toRgb;
                  const { g } = _color$toRgb;
                  const { b } = _color$toRgb;

                  return showAlpha ? `rgba(${r}, ${g}, ${b}, ${color.get('alpha') / 100})` : `rgb(${r}, ${g}, ${b})`;
                },
              },

              mounted: function mounted() {
                const { value } = this;
                if (value) {
                  this.color.fromString(value);
                }
                this.popperElm = this.$refs.dropdown.$el;
              },
              data: function data() {
                const color = new src_color({
                  enableAlpha: this.showAlpha,
                  format: this.colorFormat,
                });

                return {
                  color,
                  showPicker: false,
                  showPanelColor: false,
                };
              },

              components: {
                PickerDropdown: picker_dropdown,
              },
            });
            // CONCATENATED MODULE: ./packages/color-picker/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_color_picker_src_mainvue_type_script_lang_js_ = (color_picker_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/color-picker/src/main.vue

            /* normalize component */

            const color_picker_src_main_component = normalizeComponent(
              packages_color_picker_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_55c8ade7_render,
              mainvue_type_template_id_55c8ade7_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let color_picker_src_main_api; }
            color_picker_src_main_component.options.__file = 'packages/color-picker/src/main.vue';
            /* harmony default export */ const color_picker_src_main = (color_picker_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/color-picker/index.js

            /* istanbul ignore next */
            color_picker_src_main.install = function (Vue) {
              Vue.component(color_picker_src_main.name, color_picker_src_main);
            };

            /* harmony default export */ const color_picker = (color_picker_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/transfer/src/main.vue?vue&type=template&id=5c654dd8&
            const mainvue_type_template_id_5c654dd8_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                { staticClass: 'el-transfer' },
                [
                  _c(
                    'transfer-panel',
                    _vm._b(
                      {
                        ref: 'leftPanel',
                        attrs: {
                          data: _vm.sourceData,
                          title: _vm.titles[0] || _vm.t('el.transfer.titles.0'),
                          'default-checked': _vm.leftDefaultChecked,
                          placeholder:
                _vm.filterPlaceholder || _vm.t('el.transfer.filterPlaceholder'),
                        },
                        on: { 'checked-change': _vm.onSourceCheckedChange },
                      },
                      'transfer-panel',
                      _vm.$props,
                      false,
                    ),
                    [_vm._t('left-footer')],
                    2,
                  ),
                  _c(
                    'div',
                    { staticClass: 'el-transfer__buttons' },
                    [
                      _c(
                        'el-button',
                        {
                          class: [
                            'el-transfer__button',
                            _vm.hasButtonTexts ? 'is-with-texts' : '',
                          ],
                          attrs: {
                            type: 'primary',
                            disabled: _vm.rightChecked.length === 0,
                          },
                          nativeOn: {
                            click($event) {
                              return _vm.addToLeft($event);
                            },
                          },
                        },
                        [
                          _c('i', { staticClass: 'el-icon-arrow-left' }),
                          _vm.buttonTexts[0] !== undefined
                            ? _c('span', [_vm._v(_vm._s(_vm.buttonTexts[0]))])
                            : _vm._e(),
                        ],
                      ),
                      _c(
                        'el-button',
                        {
                          class: [
                            'el-transfer__button',
                            _vm.hasButtonTexts ? 'is-with-texts' : '',
                          ],
                          attrs: {
                            type: 'primary',
                            disabled: _vm.leftChecked.length === 0,
                          },
                          nativeOn: {
                            click($event) {
                              return _vm.addToRight($event);
                            },
                          },
                        },
                        [
                          _vm.buttonTexts[1] !== undefined
                            ? _c('span', [_vm._v(_vm._s(_vm.buttonTexts[1]))])
                            : _vm._e(),
                          _c('i', { staticClass: 'el-icon-arrow-right' }),
                        ],
                      ),
                    ],
                    1,
                  ),
                  _c(
                    'transfer-panel',
                    _vm._b(
                      {
                        ref: 'rightPanel',
                        attrs: {
                          data: _vm.targetData,
                          title: _vm.titles[1] || _vm.t('el.transfer.titles.1'),
                          'default-checked': _vm.rightDefaultChecked,
                          placeholder:
                _vm.filterPlaceholder || _vm.t('el.transfer.filterPlaceholder'),
                        },
                        on: { 'checked-change': _vm.onTargetCheckedChange },
                      },
                      'transfer-panel',
                      _vm.$props,
                      false,
                    ),
                    [_vm._t('right-footer')],
                    2,
                  ),
                ],
                1,
              );
            };
            const mainvue_type_template_id_5c654dd8_staticRenderFns = [];
            mainvue_type_template_id_5c654dd8_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/transfer/src/main.vue?vue&type=template&id=5c654dd8&

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/transfer/src/transfer-panel.vue?vue&type=template&id=2ddab8bd&
            const transfer_panelvue_type_template_id_2ddab8bd_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('div', { staticClass: 'el-transfer-panel' }, [
                _c(
                  'p',
                  { staticClass: 'el-transfer-panel__header' },
                  [
                    _c(
                      'el-checkbox',
                      {
                        attrs: { indeterminate: _vm.isIndeterminate },
                        on: { change: _vm.handleAllCheckedChange },
                        model: {
                          value: _vm.allChecked,
                          callback($$v) {
                            _vm.allChecked = $$v;
                          },
                          expression: 'allChecked',
                        },
                      },
                      [
                        _vm._v(`\n      ${_vm._s(_vm.title)}\n      `),
                        _c('span', [_vm._v(_vm._s(_vm.checkedSummary))]),
                      ],
                    ),
                  ],
                  1,
                ),
                _c(
                  'div',
                  {
                    class: [
                      'el-transfer-panel__body',
                      _vm.hasFooter ? 'is-with-footer' : '',
                    ],
                  },
                  [
                    _vm.filterable
                      ? _c(
                        'el-input',
                        {
                          staticClass: 'el-transfer-panel__filter',
                          attrs: { size: 'small', placeholder: _vm.placeholder },
                          nativeOn: {
                            mouseenter($event) {
                              _vm.inputHover = true;
                            },
                            mouseleave($event) {
                              _vm.inputHover = false;
                            },
                          },
                          model: {
                            value: _vm.query,
                            callback($$v) {
                              _vm.query = $$v;
                            },
                            expression: 'query',
                          },
                        },
                        [
                          _c('i', {
                            class: ['el-input__icon', `el-icon-${_vm.inputIcon}`],
                            attrs: { slot: 'prefix' },
                            on: { click: _vm.clearQuery },
                            slot: 'prefix',
                          }),
                        ],
                      )
                      : _vm._e(),
                    _c(
                      'el-checkbox-group',
                      {
                        directives: [
                          {
                            name: 'show',
                            rawName: 'v-show',
                            value: !_vm.hasNoMatch && _vm.data.length > 0,
                            expression: '!hasNoMatch && data.length > 0',
                          },
                        ],
                        staticClass: 'el-transfer-panel__list',
                        class: { 'is-filterable': _vm.filterable },
                        model: {
                          value: _vm.checked,
                          callback($$v) {
                            _vm.checked = $$v;
                          },
                          expression: 'checked',
                        },
                      },
                      _vm._l(_vm.filteredData, (item) => _c(
                        'el-checkbox',
                        {
                          key: item[_vm.keyProp],
                          staticClass: 'el-transfer-panel__item',
                          attrs: {
                            label: item[_vm.keyProp],
                            disabled: item[_vm.disabledProp],
                          },
                        },
                        [_c('option-content', { attrs: { option: item } })],
                        1,
                      )),
                      1,
                    ),
                    _c(
                      'p',
                      {
                        directives: [
                          {
                            name: 'show',
                            rawName: 'v-show',
                            value: _vm.hasNoMatch,
                            expression: 'hasNoMatch',
                          },
                        ],
                        staticClass: 'el-transfer-panel__empty',
                      },
                      [_vm._v(_vm._s(_vm.t('el.transfer.noMatch')))],
                    ),
                    _c(
                      'p',
                      {
                        directives: [
                          {
                            name: 'show',
                            rawName: 'v-show',
                            value: _vm.data.length === 0 && !_vm.hasNoMatch,
                            expression: 'data.length === 0 && !hasNoMatch',
                          },
                        ],
                        staticClass: 'el-transfer-panel__empty',
                      },
                      [_vm._v(_vm._s(_vm.t('el.transfer.noData')))],
                    ),
                  ],
                  1,
                ),
                _vm.hasFooter
                  ? _c(
                    'p',
                    { staticClass: 'el-transfer-panel__footer' },
                    [_vm._t('default')],
                    2,
                  )
                  : _vm._e(),
              ]);
            };
            const transfer_panelvue_type_template_id_2ddab8bd_staticRenderFns = [];
            transfer_panelvue_type_template_id_2ddab8bd_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/transfer/src/transfer-panel.vue?vue&type=template&id=2ddab8bd&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/transfer/src/transfer-panel.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const transfer_panelvue_type_script_lang_js_ = ({
              mixins: [locale_default.a],

              name: 'ElTransferPanel',

              componentName: 'ElTransferPanel',

              components: {
                ElCheckboxGroup: checkbox_group_default.a,
                ElCheckbox: checkbox_default.a,
                ElInput: input_default.a,
                OptionContent: {
                  props: {
                    option: Object,
                  },
                  render: function render(h) {
                    const getParent = function getParent(vm) {
                      if (vm.$options.componentName === 'ElTransferPanel') {
                        return vm;
                      } if (vm.$parent) {
                        return getParent(vm.$parent);
                      }
                      return vm;
                    };
                    const panel = getParent(this);
                    const transfer = panel.$parent || panel;
                    return panel.renderContent ? panel.renderContent(h, this.option) : transfer.$scopedSlots.default ? transfer.$scopedSlots.default({ option: this.option }) : h('span', [this.option[panel.labelProp] || this.option[panel.keyProp]]);
                  },
                },
              },

              props: {
                data: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                renderContent: Function,
                placeholder: String,
                title: String,
                filterable: Boolean,
                format: Object,
                filterMethod: Function,
                defaultChecked: Array,
                props: Object,
              },

              data: function data() {
                return {
                  checked: [],
                  allChecked: false,
                  query: '',
                  inputHover: false,
                  checkChangeByUser: true,
                };
              },

              watch: {
                checked: function checked(val, oldVal) {
                  this.updateAllChecked();
                  if (this.checkChangeByUser) {
                    const movedKeys = val.concat(oldVal).filter((v) => val.indexOf(v) === -1 || oldVal.indexOf(v) === -1);
                    this.$emit('checked-change', val, movedKeys);
                  } else {
                    this.$emit('checked-change', val);
                    this.checkChangeByUser = true;
                  }
                },
                data: function data() {
                  const _this = this;

                  const checked = [];
                  const filteredDataKeys = this.filteredData.map((item) => item[_this.keyProp]);
                  this.checked.forEach((item) => {
                    if (filteredDataKeys.indexOf(item) > -1) {
                      checked.push(item);
                    }
                  });
                  this.checkChangeByUser = false;
                  this.checked = checked;
                },
                checkableData: function checkableData() {
                  this.updateAllChecked();
                },

                defaultChecked: {
                  immediate: true,
                  handler: function handler(val, oldVal) {
                    const _this2 = this;

                    if (oldVal && val.length === oldVal.length && val.every((item) => oldVal.indexOf(item) > -1)) return;
                    const checked = [];
                    const checkableDataKeys = this.checkableData.map((item) => item[_this2.keyProp]);
                    val.forEach((item) => {
                      if (checkableDataKeys.indexOf(item) > -1) {
                        checked.push(item);
                      }
                    });
                    this.checkChangeByUser = false;
                    this.checked = checked;
                  },
                },
              },

              computed: {
                filteredData: function filteredData() {
                  const _this3 = this;

                  return this.data.filter((item) => {
                    if (typeof _this3.filterMethod === 'function') {
                      return _this3.filterMethod(_this3.query, item);
                    }
                    const label = item[_this3.labelProp] || item[_this3.keyProp].toString();
                    return label.toLowerCase().indexOf(_this3.query.toLowerCase()) > -1;
                  });
                },
                checkableData: function checkableData() {
                  const _this4 = this;

                  return this.filteredData.filter((item) => !item[_this4.disabledProp]);
                },
                checkedSummary: function checkedSummary() {
                  const checkedLength = this.checked.length;
                  const dataLength = this.data.length;
                  const _format = this.format;
                  const { noChecked } = _format;
                  const { hasChecked } = _format;

                  if (noChecked && hasChecked) {
                    return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength).replace(/\${total}/g, dataLength) : noChecked.replace(/\${total}/g, dataLength);
                  }
                  return `${checkedLength}/${dataLength}`;
                },
                isIndeterminate: function isIndeterminate() {
                  const checkedLength = this.checked.length;
                  return checkedLength > 0 && checkedLength < this.checkableData.length;
                },
                hasNoMatch: function hasNoMatch() {
                  return this.query.length > 0 && this.filteredData.length === 0;
                },
                inputIcon: function inputIcon() {
                  return this.query.length > 0 && this.inputHover ? 'circle-close' : 'search';
                },
                labelProp: function labelProp() {
                  return this.props.label || 'label';
                },
                keyProp: function keyProp() {
                  return this.props.key || 'key';
                },
                disabledProp: function disabledProp() {
                  return this.props.disabled || 'disabled';
                },
                hasFooter: function hasFooter() {
                  return !!this.$slots.default;
                },
              },

              methods: {
                updateAllChecked: function updateAllChecked() {
                  const _this5 = this;

                  const checkableDataKeys = this.checkableData.map((item) => item[_this5.keyProp]);
                  this.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every((item) => _this5.checked.indexOf(item) > -1);
                },
                handleAllCheckedChange: function handleAllCheckedChange(value) {
                  const _this6 = this;

                  this.checked = value ? this.checkableData.map((item) => item[_this6.keyProp]) : [];
                },
                clearQuery: function clearQuery() {
                  if (this.inputIcon === 'circle-close') {
                    this.query = '';
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/transfer/src/transfer-panel.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_transfer_panelvue_type_script_lang_js_ = (transfer_panelvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/transfer/src/transfer-panel.vue

            /* normalize component */

            const transfer_panel_component = normalizeComponent(
              src_transfer_panelvue_type_script_lang_js_,
              transfer_panelvue_type_template_id_2ddab8bd_render,
              transfer_panelvue_type_template_id_2ddab8bd_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let transfer_panel_api; }
            transfer_panel_component.options.__file = 'packages/transfer/src/transfer-panel.vue';
            /* harmony default export */ const transfer_panel = (transfer_panel_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/transfer/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const transfer_src_mainvue_type_script_lang_js_ = ({
              name: 'ElTransfer',

              mixins: [emitter_default.a, locale_default.a, migrating_default.a],

              components: {
                TransferPanel: transfer_panel,
                ElButton: button_default.a,
              },

              props: {
                data: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                titles: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                buttonTexts: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                filterPlaceholder: {
                  type: String,
                  default: '',
                },
                filterMethod: Function,
                leftDefaultChecked: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                rightDefaultChecked: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                renderContent: Function,
                value: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                format: {
                  type: Object,
                  default: function _default() {
                    return {};
                  },
                },
                filterable: Boolean,
                props: {
                  type: Object,
                  default: function _default() {
                    return {
                      label: 'label',
                      key: 'key',
                      disabled: 'disabled',
                    };
                  },
                },
                targetOrder: {
                  type: String,
                  default: 'original',
                },
              },

              data: function data() {
                return {
                  leftChecked: [],
                  rightChecked: [],
                };
              },

              computed: {
                dataObj: function dataObj() {
                  const { key } = this.props;
                  return this.data.reduce((o, cur) => (o[cur[key]] = cur) && o, {});
                },
                sourceData: function sourceData() {
                  const _this = this;

                  return this.data.filter((item) => _this.value.indexOf(item[_this.props.key]) === -1);
                },
                targetData: function targetData() {
                  const _this2 = this;

                  if (this.targetOrder === 'original') {
                    return this.data.filter((item) => _this2.value.indexOf(item[_this2.props.key]) > -1);
                  }
                  return this.value.reduce((arr, cur) => {
                    const val = _this2.dataObj[cur];
                    if (val) {
                      arr.push(val);
                    }
                    return arr;
                  }, []);
                },
                hasButtonTexts: function hasButtonTexts() {
                  return this.buttonTexts.length === 2;
                },
              },

              watch: {
                value: function value(val) {
                  this.dispatch('ElFormItem', 'el.form.change', val);
                },
              },

              methods: {
                getMigratingConfig: function getMigratingConfig() {
                  return {
                    props: {
                      'footer-format': 'footer-format is renamed to format.',
                    },
                  };
                },
                onSourceCheckedChange: function onSourceCheckedChange(val, movedKeys) {
                  this.leftChecked = val;
                  if (movedKeys === undefined) return;
                  this.$emit('left-check-change', val, movedKeys);
                },
                onTargetCheckedChange: function onTargetCheckedChange(val, movedKeys) {
                  this.rightChecked = val;
                  if (movedKeys === undefined) return;
                  this.$emit('right-check-change', val, movedKeys);
                },
                addToLeft: function addToLeft() {
                  const currentValue = this.value.slice();
                  this.rightChecked.forEach((item) => {
                    const index = currentValue.indexOf(item);
                    if (index > -1) {
                      currentValue.splice(index, 1);
                    }
                  });
                  this.$emit('input', currentValue);
                  this.$emit('change', currentValue, 'left', this.rightChecked);
                },
                addToRight: function addToRight() {
                  const _this3 = this;

                  let currentValue = this.value.slice();
                  const itemsToBeMoved = [];
                  const { key } = this.props;
                  this.data.forEach((item) => {
                    const itemKey = item[key];
                    if (_this3.leftChecked.indexOf(itemKey) > -1 && _this3.value.indexOf(itemKey) === -1) {
                      itemsToBeMoved.push(itemKey);
                    }
                  });
                  currentValue = this.targetOrder === 'unshift' ? itemsToBeMoved.concat(currentValue) : currentValue.concat(itemsToBeMoved);
                  this.$emit('input', currentValue);
                  this.$emit('change', currentValue, 'right', this.leftChecked);
                },
                clearQuery: function clearQuery(which) {
                  if (which === 'left') {
                    this.$refs.leftPanel.query = '';
                  } else if (which === 'right') {
                    this.$refs.rightPanel.query = '';
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/transfer/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_transfer_src_mainvue_type_script_lang_js_ = (transfer_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/transfer/src/main.vue

            /* normalize component */

            const transfer_src_main_component = normalizeComponent(
              packages_transfer_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_5c654dd8_render,
              mainvue_type_template_id_5c654dd8_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let transfer_src_main_api; }
            transfer_src_main_component.options.__file = 'packages/transfer/src/main.vue';
            /* harmony default export */ const transfer_src_main = (transfer_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/transfer/index.js

            /* istanbul ignore next */
            transfer_src_main.install = function (Vue) {
              Vue.component(transfer_src_main.name, transfer_src_main);
            };

            /* harmony default export */ const transfer = (transfer_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/container/src/main.vue?vue&type=template&id=5bf181d4&
            const mainvue_type_template_id_5bf181d4_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'section',
                { staticClass: 'el-container', class: { 'is-vertical': _vm.isVertical } },
                [_vm._t('default')],
                2,
              );
            };
            const mainvue_type_template_id_5bf181d4_staticRenderFns = [];
            mainvue_type_template_id_5bf181d4_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/container/src/main.vue?vue&type=template&id=5bf181d4&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/container/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const container_src_mainvue_type_script_lang_js_ = ({
              name: 'ElContainer',

              componentName: 'ElContainer',

              props: {
                direction: String,
              },

              computed: {
                isVertical: function isVertical() {
                  if (this.direction === 'vertical') {
                    return true;
                  } if (this.direction === 'horizontal') {
                    return false;
                  }
                  return this.$slots && this.$slots.default ? this.$slots.default.some((vnode) => {
                    const tag = vnode.componentOptions && vnode.componentOptions.tag;
                    return tag === 'el-header' || tag === 'el-footer';
                  }) : false;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/container/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_container_src_mainvue_type_script_lang_js_ = (container_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/container/src/main.vue

            /* normalize component */

            const container_src_main_component = normalizeComponent(
              packages_container_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_5bf181d4_render,
              mainvue_type_template_id_5bf181d4_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let container_src_main_api; }
            container_src_main_component.options.__file = 'packages/container/src/main.vue';
            /* harmony default export */ const container_src_main = (container_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/container/index.js

            /* istanbul ignore next */
            container_src_main.install = function (Vue) {
              Vue.component(container_src_main.name, container_src_main);
            };

            /* harmony default export */ const packages_container = (container_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/header/src/main.vue?vue&type=template&id=2b296ab2&
            const mainvue_type_template_id_2b296ab2_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'header',
                { staticClass: 'el-header', style: { height: _vm.height } },
                [_vm._t('default')],
                2,
              );
            };
            const mainvue_type_template_id_2b296ab2_staticRenderFns = [];
            mainvue_type_template_id_2b296ab2_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/header/src/main.vue?vue&type=template&id=2b296ab2&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/header/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const header_src_mainvue_type_script_lang_js_ = ({
              name: 'ElHeader',

              componentName: 'ElHeader',

              props: {
                height: {
                  type: String,
                  default: '60px',
                },
              },
            });
            // CONCATENATED MODULE: ./packages/header/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_header_src_mainvue_type_script_lang_js_ = (header_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/header/src/main.vue

            /* normalize component */

            const header_src_main_component = normalizeComponent(
              packages_header_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_2b296ab2_render,
              mainvue_type_template_id_2b296ab2_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let header_src_main_api; }
            header_src_main_component.options.__file = 'packages/header/src/main.vue';
            /* harmony default export */ const header_src_main = (header_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/header/index.js

            /* istanbul ignore next */
            header_src_main.install = function (Vue) {
              Vue.component(header_src_main.name, header_src_main);
            };

            /* harmony default export */ const header = (header_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/aside/src/main.vue?vue&type=template&id=03411dbf&
            const mainvue_type_template_id_03411dbf_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'aside',
                { staticClass: 'el-aside', style: { width: _vm.width } },
                [_vm._t('default')],
                2,
              );
            };
            const mainvue_type_template_id_03411dbf_staticRenderFns = [];
            mainvue_type_template_id_03411dbf_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/aside/src/main.vue?vue&type=template&id=03411dbf&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/aside/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const aside_src_mainvue_type_script_lang_js_ = ({
              name: 'ElAside',

              componentName: 'ElAside',

              props: {
                width: {
                  type: String,
                  default: '300px',
                },
              },
            });
            // CONCATENATED MODULE: ./packages/aside/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_aside_src_mainvue_type_script_lang_js_ = (aside_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/aside/src/main.vue

            /* normalize component */

            const aside_src_main_component = normalizeComponent(
              packages_aside_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_03411dbf_render,
              mainvue_type_template_id_03411dbf_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let aside_src_main_api; }
            aside_src_main_component.options.__file = 'packages/aside/src/main.vue';
            /* harmony default export */ const aside_src_main = (aside_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/aside/index.js

            /* istanbul ignore next */
            aside_src_main.install = function (Vue) {
              Vue.component(aside_src_main.name, aside_src_main);
            };

            /* harmony default export */ const aside = (aside_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/main/src/main.vue?vue&type=template&id=2a3a7406&
            const mainvue_type_template_id_2a3a7406_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('main', { staticClass: 'el-main' }, [_vm._t('default')], 2);
            };
            const mainvue_type_template_id_2a3a7406_staticRenderFns = [];
            mainvue_type_template_id_2a3a7406_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/main/src/main.vue?vue&type=template&id=2a3a7406&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/main/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const main_src_mainvue_type_script_lang_js_ = ({
              name: 'ElMain',
              componentName: 'ElMain',
            });
            // CONCATENATED MODULE: ./packages/main/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_main_src_mainvue_type_script_lang_js_ = (main_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/main/src/main.vue

            /* normalize component */

            const main_src_main_component = normalizeComponent(
              packages_main_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_2a3a7406_render,
              mainvue_type_template_id_2a3a7406_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let main_src_main_api; }
            main_src_main_component.options.__file = 'packages/main/src/main.vue';
            /* harmony default export */ const main_src_main = (main_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/main/index.js

            /* istanbul ignore next */
            main_src_main.install = function (Vue) {
              Vue.component(main_src_main.name, main_src_main);
            };

            /* harmony default export */ const packages_main = (main_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/footer/src/main.vue?vue&type=template&id=80210338&
            const mainvue_type_template_id_80210338_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'footer',
                { staticClass: 'el-footer', style: { height: _vm.height } },
                [_vm._t('default')],
                2,
              );
            };
            const mainvue_type_template_id_80210338_staticRenderFns = [];
            mainvue_type_template_id_80210338_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/footer/src/main.vue?vue&type=template&id=80210338&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/footer/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const footer_src_mainvue_type_script_lang_js_ = ({
              name: 'ElFooter',

              componentName: 'ElFooter',

              props: {
                height: {
                  type: String,
                  default: '60px',
                },
              },
            });
            // CONCATENATED MODULE: ./packages/footer/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_footer_src_mainvue_type_script_lang_js_ = (footer_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/footer/src/main.vue

            /* normalize component */

            const footer_src_main_component = normalizeComponent(
              packages_footer_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_80210338_render,
              mainvue_type_template_id_80210338_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let footer_src_main_api; }
            footer_src_main_component.options.__file = 'packages/footer/src/main.vue';
            /* harmony default export */ const footer_src_main = (footer_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/footer/index.js

            /* istanbul ignore next */
            footer_src_main.install = function (Vue) {
              Vue.component(footer_src_main.name, footer_src_main);
            };

            /* harmony default export */ const footer = (footer_src_main);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/timeline/src/main.vue?vue&type=script&lang=js&

            /* harmony default export */ const timeline_src_mainvue_type_script_lang_js_ = ({
              name: 'ElTimeline',

              props: {
                reverse: {
                  type: Boolean,
                  default: false,
                },
              },

              provide: function provide() {
                return {
                  timeline: this,
                };
              },
              render: function render() {
                const h = arguments[0];

                const { reverse } = this;
                const classes = {
                  'el-timeline': true,
                  'is-reverse': reverse,
                };
                let slots = this.$slots.default || [];
                if (reverse) {
                  slots = slots.reverse();
                }
                return h(
                  'ul',
                  { class: classes },
                  [slots],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/timeline/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_timeline_src_mainvue_type_script_lang_js_ = (timeline_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/timeline/src/main.vue
            let main_render; let
              main_staticRenderFns;

            /* normalize component */

            const timeline_src_main_component = normalizeComponent(
              packages_timeline_src_mainvue_type_script_lang_js_,
              main_render,
              main_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let timeline_src_main_api; }
            timeline_src_main_component.options.__file = 'packages/timeline/src/main.vue';
            /* harmony default export */ const timeline_src_main = (timeline_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/timeline/index.js

            /* istanbul ignore next */
            timeline_src_main.install = function (Vue) {
              Vue.component(timeline_src_main.name, timeline_src_main);
            };

            /* harmony default export */ const timeline = (timeline_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/timeline/src/item.vue?vue&type=template&id=61a69e50&
            const itemvue_type_template_id_61a69e50_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('li', { staticClass: 'el-timeline-item' }, [
                _c('div', { staticClass: 'el-timeline-item__tail' }),
                !_vm.$slots.dot
                  ? _c(
                    'div',
                    {
                      staticClass: 'el-timeline-item__node',
                      class: [
                        `el-timeline-item__node--${_vm.size || ''}`,
                        `el-timeline-item__node--${_vm.type || ''}`,
                      ],
                      style: {
                        backgroundColor: _vm.color,
                      },
                    },
                    [
                      _vm.icon
                        ? _c('i', {
                          staticClass: 'el-timeline-item__icon',
                          class: _vm.icon,
                        })
                        : _vm._e(),
                    ],
                  )
                  : _vm._e(),
                _vm.$slots.dot
                  ? _c('div', { staticClass: 'el-timeline-item__dot' }, [_vm._t('dot')], 2)
                  : _vm._e(),
                _c('div', { staticClass: 'el-timeline-item__wrapper' }, [
                  !_vm.hideTimestamp && _vm.placement === 'top'
                    ? _c('div', { staticClass: 'el-timeline-item__timestamp is-top' }, [
                      _vm._v(`\n      ${_vm._s(_vm.timestamp)}\n    `),
                    ])
                    : _vm._e(),
                  _c(
                    'div',
                    { staticClass: 'el-timeline-item__content' },
                    [_vm._t('default')],
                    2,
                  ),
                  !_vm.hideTimestamp && _vm.placement === 'bottom'
                    ? _c('div', { staticClass: 'el-timeline-item__timestamp is-bottom' }, [
                      _vm._v(`\n      ${_vm._s(_vm.timestamp)}\n    `),
                    ])
                    : _vm._e(),
                ]),
              ]);
            };
            const itemvue_type_template_id_61a69e50_staticRenderFns = [];
            itemvue_type_template_id_61a69e50_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/timeline/src/item.vue?vue&type=template&id=61a69e50&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/timeline/src/item.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const timeline_src_itemvue_type_script_lang_js_ = ({
              name: 'ElTimelineItem',

              inject: ['timeline'],

              props: {
                timestamp: String,

                hideTimestamp: {
                  type: Boolean,
                  default: false,
                },

                placement: {
                  type: String,
                  default: 'bottom',
                },

                type: String,

                color: String,

                size: {
                  type: String,
                  default: 'normal',
                },

                icon: String,
              },
            });
            // CONCATENATED MODULE: ./packages/timeline/src/item.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_timeline_src_itemvue_type_script_lang_js_ = (timeline_src_itemvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/timeline/src/item.vue

            /* normalize component */

            const src_item_component = normalizeComponent(
              packages_timeline_src_itemvue_type_script_lang_js_,
              itemvue_type_template_id_61a69e50_render,
              itemvue_type_template_id_61a69e50_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let src_item_api; }
            src_item_component.options.__file = 'packages/timeline/src/item.vue';
            /* harmony default export */ const timeline_src_item = (src_item_component.exports);
            // CONCATENATED MODULE: ./packages/timeline-item/index.js

            /* istanbul ignore next */
            timeline_src_item.install = function (Vue) {
              Vue.component(timeline_src_item.name, timeline_src_item);
            };

            /* harmony default export */ const timeline_item = (timeline_src_item);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/link/src/main.vue?vue&type=template&id=01cf3b65&
            const mainvue_type_template_id_01cf3b65_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'a',
                _vm._b(
                  {
                    class: [
                      'el-link',
                      _vm.type ? `el-link--${_vm.type}` : '',
                      _vm.disabled && 'is-disabled',
                      _vm.underline && !_vm.disabled && 'is-underline',
                    ],
                    attrs: { href: _vm.disabled ? null : _vm.href },
                    on: { click: _vm.handleClick },
                  },
                  'a',
                  _vm.$attrs,
                  false,
                ),
                [
                  _vm.icon ? _c('i', { class: _vm.icon }) : _vm._e(),
                  _vm.$slots.default
                    ? _c('span', { staticClass: 'el-link--inner' }, [_vm._t('default')], 2)
                    : _vm._e(),
                  _vm.$slots.icon ? [_vm.$slots.icon ? _vm._t('icon') : _vm._e()] : _vm._e(),
                ],
                2,
              );
            };
            const mainvue_type_template_id_01cf3b65_staticRenderFns = [];
            mainvue_type_template_id_01cf3b65_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/link/src/main.vue?vue&type=template&id=01cf3b65&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/link/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const link_src_mainvue_type_script_lang_js_ = ({
              name: 'ElLink',

              props: {
                type: {
                  type: String,
                  default: 'default',
                },
                underline: {
                  type: Boolean,
                  default: true,
                },
                disabled: Boolean,
                href: String,
                icon: String,
              },

              methods: {
                handleClick: function handleClick(event) {
                  if (!this.disabled) {
                    if (!this.href) {
                      this.$emit('click', event);
                    }
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/link/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_link_src_mainvue_type_script_lang_js_ = (link_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/link/src/main.vue

            /* normalize component */

            const link_src_main_component = normalizeComponent(
              packages_link_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_01cf3b65_render,
              mainvue_type_template_id_01cf3b65_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let link_src_main_api; }
            link_src_main_component.options.__file = 'packages/link/src/main.vue';
            /* harmony default export */ const link_src_main = (link_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/link/index.js

            /* istanbul ignore next */
            link_src_main.install = function (Vue) {
              Vue.component(link_src_main.name, link_src_main);
            };

            /* harmony default export */ const packages_link = (link_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/divider/src/main.vue?vue&type=template&id=7fa02a7e&functional=true&
            const mainvue_type_template_id_7fa02a7e_functional_true_render = function (_h, _vm) {
              const { _c } = _vm;
              return _c(
                'div',
                _vm._g(
                  _vm._b(
                    {
                      class: [
                        _vm.data.staticClass,
                        'el-divider',
                        `el-divider--${_vm.props.direction}`,
                      ],
                    },
                    'div',
                    _vm.data.attrs,
                    false,
                  ),
                  _vm.listeners,
                ),
                [
                  _vm.slots().default && _vm.props.direction !== 'vertical'
                    ? _c(
                      'div',
                      { class: ['el-divider__text', `is-${_vm.props.contentPosition}`] },
                      [_vm._t('default')],
                      2,
                    )
                    : _vm._e(),
                ],
              );
            };
            const mainvue_type_template_id_7fa02a7e_functional_true_staticRenderFns = [];
            mainvue_type_template_id_7fa02a7e_functional_true_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/divider/src/main.vue?vue&type=template&id=7fa02a7e&functional=true&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/divider/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const divider_src_mainvue_type_script_lang_js_ = ({
              name: 'ElDivider',
              props: {
                direction: {
                  type: String,
                  default: 'horizontal',
                  validator: function validator(val) {
                    return ['horizontal', 'vertical'].indexOf(val) !== -1;
                  },
                },
                contentPosition: {
                  type: String,
                  default: 'center',
                  validator: function validator(val) {
                    return ['left', 'center', 'right'].indexOf(val) !== -1;
                  },
                },
              },
            });
            // CONCATENATED MODULE: ./packages/divider/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_divider_src_mainvue_type_script_lang_js_ = (divider_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/divider/src/main.vue

            /* normalize component */

            const divider_src_main_component = normalizeComponent(
              packages_divider_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_7fa02a7e_functional_true_render,
              mainvue_type_template_id_7fa02a7e_functional_true_staticRenderFns,
              true,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let divider_src_main_api; }
            divider_src_main_component.options.__file = 'packages/divider/src/main.vue';
            /* harmony default export */ const divider_src_main = (divider_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/divider/index.js

            /* istanbul ignore next */
            divider_src_main.install = function (Vue) {
              Vue.component(divider_src_main.name, divider_src_main);
            };

            /* harmony default export */ const divider = (divider_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/image/src/main.vue?vue&type=template&id=44d84a7c&
            const mainvue_type_template_id_44d84a7c_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                { staticClass: 'el-image' },
                [
                  _vm.loading
                    ? _vm._t('placeholder', [
                      _c('div', { staticClass: 'el-image__placeholder' }),
                    ])
                    : _vm.error
                      ? _vm._t('error', [
                        _c('div', { staticClass: 'el-image__error' }, [
                          _vm._v(_vm._s(_vm.t('el.image.error'))),
                        ]),
                      ])
                      : _c(
                        'img',
                        _vm._g(
                          _vm._b(
                            {
                              staticClass: 'el-image__inner',
                              class: {
                                'el-image__inner--center': _vm.alignCenter,
                                'el-image__preview': _vm.preview,
                              },
                              style: _vm.imageStyle,
                              attrs: { src: _vm.src },
                              on: { click: _vm.clickHandler },
                            },
                            'img',
                            _vm.$attrs,
                            false,
                          ),
                          _vm.$listeners,
                        ),
                      ),
                  _vm.preview
                    ? [
                      _vm.showViewer
                        ? _c('image-viewer', {
                          attrs: {
                            'z-index': _vm.zIndex,
                            'initial-index': _vm.imageIndex,
                            'on-close': _vm.closeViewer,
                            'url-list': _vm.previewSrcList,
                          },
                        })
                        : _vm._e(),
                    ]
                    : _vm._e(),
                ],
                2,
              );
            };
            const mainvue_type_template_id_44d84a7c_staticRenderFns = [];
            mainvue_type_template_id_44d84a7c_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/image/src/main.vue?vue&type=template&id=44d84a7c&

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/image/src/image-viewer.vue?vue&type=template&id=5e73b307&
            const image_viewervue_type_template_id_5e73b307_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('transition', { attrs: { name: 'viewer-fade' } }, [
                _c(
                  'div',
                  {
                    ref: 'el-image-viewer__wrapper',
                    staticClass: 'el-image-viewer__wrapper',
                    style: { 'z-index': _vm.zIndex },
                    attrs: { tabindex: '-1' },
                  },
                  [
                    _c('div', {
                      staticClass: 'el-image-viewer__mask',
                      on: {
                        click($event) {
                          if ($event.target !== $event.currentTarget) {
                            return null;
                          }
                          return _vm.handleMaskClick($event);
                        },
                      },
                    }),
                    _c(
                      'span',
                      {
                        staticClass: 'el-image-viewer__btn el-image-viewer__close',
                        on: { click: _vm.hide },
                      },
                      [_c('i', { staticClass: 'el-icon-close' })],
                    ),
                    !_vm.isSingle
                      ? [
                        _c(
                          'span',
                          {
                            staticClass: 'el-image-viewer__btn el-image-viewer__prev',
                            class: { 'is-disabled': !_vm.infinite && _vm.isFirst },
                            on: { click: _vm.prev },
                          },
                          [_c('i', { staticClass: 'el-icon-arrow-left' })],
                        ),
                        _c(
                          'span',
                          {
                            staticClass: 'el-image-viewer__btn el-image-viewer__next',
                            class: { 'is-disabled': !_vm.infinite && _vm.isLast },
                            on: { click: _vm.next },
                          },
                          [_c('i', { staticClass: 'el-icon-arrow-right' })],
                        ),
                      ]
                      : _vm._e(),
                    _c(
                      'div',
                      { staticClass: 'el-image-viewer__btn el-image-viewer__actions' },
                      [
                        _c('div', { staticClass: 'el-image-viewer__actions__inner' }, [
                          _c('i', {
                            staticClass: 'el-icon-zoom-out',
                            on: {
                              click($event) {
                                _vm.handleActions('zoomOut');
                              },
                            },
                          }),
                          _c('i', {
                            staticClass: 'el-icon-zoom-in',
                            on: {
                              click($event) {
                                _vm.handleActions('zoomIn');
                              },
                            },
                          }),
                          _c('i', { staticClass: 'el-image-viewer__actions__divider' }),
                          _c('i', { class: _vm.mode.icon, on: { click: _vm.toggleMode } }),
                          _c('i', { staticClass: 'el-image-viewer__actions__divider' }),
                          _c('i', {
                            staticClass: 'el-icon-refresh-left',
                            on: {
                              click($event) {
                                _vm.handleActions('anticlocelise');
                              },
                            },
                          }),
                          _c('i', {
                            staticClass: 'el-icon-refresh-right',
                            on: {
                              click($event) {
                                _vm.handleActions('clocelise');
                              },
                            },
                          }),
                        ]),
                      ],
                    ),
                    _c(
                      'div',
                      { staticClass: 'el-image-viewer__canvas' },
                      _vm._l(_vm.urlList, (url, i) => (i === _vm.index
                        ? _c('img', {
                          key: url,
                          ref: 'img',
                          refInFor: true,
                          staticClass: 'el-image-viewer__img',
                          style: _vm.imgStyle,
                          attrs: { src: _vm.currentImg },
                          on: {
                            load: _vm.handleImgLoad,
                            error: _vm.handleImgError,
                            mousedown: _vm.handleMouseDown,
                          },
                        })
                        : _vm._e())),
                      0,
                    ),
                  ],
                  2,
                ),
              ]);
            };
            const image_viewervue_type_template_id_5e73b307_staticRenderFns = [];
            image_viewervue_type_template_id_5e73b307_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/image/src/image-viewer.vue?vue&type=template&id=5e73b307&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/image/src/image-viewer.vue?vue&type=script&lang=js&
            const image_viewervue_type_script_lang_js_extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const Mode = {
              CONTAIN: {
                name: 'contain',
                icon: 'el-icon-full-screen',
              },
              ORIGINAL: {
                name: 'original',
                icon: 'el-icon-c-scale-to-original',
              },
            };

            const mousewheelEventName = Object(util_.isFirefox)() ? 'DOMMouseScroll' : 'mousewheel';

            /* harmony default export */ const image_viewervue_type_script_lang_js_ = ({
              name: 'elImageViewer',

              props: {
                urlList: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                zIndex: {
                  type: Number,
                  default: 2000,
                },
                onSwitch: {
                  type: Function,
                  default: function _default() {},
                },
                onClose: {
                  type: Function,
                  default: function _default() {},
                },
                initialIndex: {
                  type: Number,
                  default: 0,
                },
                appendToBody: {
                  type: Boolean,
                  default: true,
                },
                maskClosable: {
                  type: Boolean,
                  default: true,
                },
              },

              data: function data() {
                return {
                  index: this.initialIndex,
                  isShow: false,
                  infinite: true,
                  loading: false,
                  mode: Mode.CONTAIN,
                  transform: {
                    scale: 1,
                    deg: 0,
                    offsetX: 0,
                    offsetY: 0,
                    enableTransition: false,
                  },
                };
              },

              computed: {
                isSingle: function isSingle() {
                  return this.urlList.length <= 1;
                },
                isFirst: function isFirst() {
                  return this.index === 0;
                },
                isLast: function isLast() {
                  return this.index === this.urlList.length - 1;
                },
                currentImg: function currentImg() {
                  return this.urlList[this.index];
                },
                imgStyle: function imgStyle() {
                  const _transform = this.transform;
                  const { scale } = _transform;
                  const { deg } = _transform;
                  const { offsetX } = _transform;
                  const { offsetY } = _transform;
                  const { enableTransition } = _transform;

                  const style = {
                    transform: `scale(${scale}) rotate(${deg}deg)`,
                    transition: enableTransition ? 'transform .3s' : '',
                    'margin-left': `${offsetX}px`,
                    'margin-top': `${offsetY}px`,
                  };
                  if (this.mode === Mode.CONTAIN) {
                    style.maxWidth = style.maxHeight = '100%';
                  }
                  return style;
                },
              },
              watch: {
                index: {
                  handler: function handler(val) {
                    this.reset();
                    this.onSwitch(val);
                  },
                },
                currentImg: function currentImg(val) {
                  const _this = this;

                  this.$nextTick((_) => {
                    const $img = _this.$refs.img[0];
                    if (!$img.complete) {
                      _this.loading = true;
                    }
                  });
                },
              },
              methods: {
                hide: function hide() {
                  this.deviceSupportUninstall();
                  this.onClose();
                },
                deviceSupportInstall: function deviceSupportInstall() {
                  const _this2 = this;

                  this._keyDownHandler = Object(util_.rafThrottle)((e) => {
                    const { keyCode } = e;
                    switch (keyCode) {
                      // ESC
                      case 27:
                        _this2.hide();
                        break;
                        // SPACE
                      case 32:
                        _this2.toggleMode();
                        break;
                        // LEFT_ARROW
                      case 37:
                        _this2.prev();
                        break;
                        // UP_ARROW
                      case 38:
                        _this2.handleActions('zoomIn');
                        break;
                        // RIGHT_ARROW
                      case 39:
                        _this2.next();
                        break;
                        // DOWN_ARROW
                      case 40:
                        _this2.handleActions('zoomOut');
                        break;
                    }
                  });
                  this._mouseWheelHandler = Object(util_.rafThrottle)((e) => {
                    const delta = e.wheelDelta ? e.wheelDelta : -e.detail;
                    if (delta > 0) {
                      _this2.handleActions('zoomIn', {
                        zoomRate: 0.015,
                        enableTransition: false,
                      });
                    } else {
                      _this2.handleActions('zoomOut', {
                        zoomRate: 0.015,
                        enableTransition: false,
                      });
                    }
                  });
                  Object(dom_.on)(document, 'keydown', this._keyDownHandler);
                  Object(dom_.on)(document, mousewheelEventName, this._mouseWheelHandler);
                },
                deviceSupportUninstall: function deviceSupportUninstall() {
                  Object(dom_.off)(document, 'keydown', this._keyDownHandler);
                  Object(dom_.off)(document, mousewheelEventName, this._mouseWheelHandler);
                  this._keyDownHandler = null;
                  this._mouseWheelHandler = null;
                },
                handleImgLoad: function handleImgLoad(e) {
                  this.loading = false;
                },
                handleImgError: function handleImgError(e) {
                  this.loading = false;
                  e.target.alt = '加载失败';
                },
                handleMouseDown: function handleMouseDown(e) {
                  const _this3 = this;

                  if (this.loading || e.button !== 0) return;

                  const _transform2 = this.transform;
                  const { offsetX } = _transform2;
                  const { offsetY } = _transform2;

                  const startX = e.pageX;
                  const startY = e.pageY;
                  this._dragHandler = Object(util_.rafThrottle)((ev) => {
                    _this3.transform.offsetX = offsetX + ev.pageX - startX;
                    _this3.transform.offsetY = offsetY + ev.pageY - startY;
                  });
                  Object(dom_.on)(document, 'mousemove', this._dragHandler);
                  Object(dom_.on)(document, 'mouseup', (ev) => {
                    Object(dom_.off)(document, 'mousemove', _this3._dragHandler);
                  });

                  e.preventDefault();
                },
                handleMaskClick: function handleMaskClick() {
                  if (this.maskClosable) {
                    this.hide();
                  }
                },
                reset: function reset() {
                  this.transform = {
                    scale: 1,
                    deg: 0,
                    offsetX: 0,
                    offsetY: 0,
                    enableTransition: false,
                  };
                },
                toggleMode: function toggleMode() {
                  if (this.loading) return;

                  const modeNames = Object.keys(Mode);
                  const modeValues = Object.values(Mode);
                  const index = modeValues.indexOf(this.mode);
                  const nextIndex = (index + 1) % modeNames.length;
                  this.mode = Mode[modeNames[nextIndex]];
                  this.reset();
                },
                prev: function prev() {
                  if (this.isFirst && !this.infinite) return;
                  const len = this.urlList.length;
                  this.index = (this.index - 1 + len) % len;
                },
                next: function next() {
                  if (this.isLast && !this.infinite) return;
                  const len = this.urlList.length;
                  this.index = (this.index + 1) % len;
                },
                handleActions: function handleActions(action) {
                  const options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                  if (this.loading) return;

                  const _zoomRate$rotateDeg$e = {
                    zoomRate: 0.2,
                    rotateDeg: 90,
                    enableTransition: true,
                    ...options,
                  };
                  const { zoomRate } = _zoomRate$rotateDeg$e;
                  const { rotateDeg } = _zoomRate$rotateDeg$e;
                  const { enableTransition } = _zoomRate$rotateDeg$e;

                  const { transform } = this;

                  switch (action) {
                    case 'zoomOut':
                      if (transform.scale > 0.2) {
                        transform.scale = parseFloat((transform.scale - zoomRate).toFixed(3));
                      }
                      break;
                    case 'zoomIn':
                      transform.scale = parseFloat((transform.scale + zoomRate).toFixed(3));
                      break;
                    case 'clocelise':
                      transform.deg += rotateDeg;
                      break;
                    case 'anticlocelise':
                      transform.deg -= rotateDeg;
                      break;
                  }
                  transform.enableTransition = enableTransition;
                },
              },
              mounted: function mounted() {
                this.deviceSupportInstall();
                if (this.appendToBody) {
                  document.body.appendChild(this.$el);
                }
                // add tabindex then wrapper can be focusable via Javascript
                // focus wrapper so arrow key can't cause inner scroll behavior underneath
                this.$refs['el-image-viewer__wrapper'].focus();
              },
              destroyed: function destroyed() {
                // if appendToBody is true, remove DOM node after destroy
                if (this.appendToBody && this.$el && this.$el.parentNode) {
                  this.$el.parentNode.removeChild(this.$el);
                }
              },
            });
            // CONCATENATED MODULE: ./packages/image/src/image-viewer.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_image_viewervue_type_script_lang_js_ = (image_viewervue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/image/src/image-viewer.vue

            /* normalize component */

            const image_viewer_component = normalizeComponent(
              src_image_viewervue_type_script_lang_js_,
              image_viewervue_type_template_id_5e73b307_render,
              image_viewervue_type_template_id_5e73b307_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let image_viewer_api; }
            image_viewer_component.options.__file = 'packages/image/src/image-viewer.vue';
            /* harmony default export */ const image_viewer = (image_viewer_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/image/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const isSupportObjectFit = function isSupportObjectFit() {
              return document.documentElement.style.objectFit !== undefined;
            };

            const ObjectFit = {
              NONE: 'none',
              CONTAIN: 'contain',
              COVER: 'cover',
              FILL: 'fill',
              SCALE_DOWN: 'scale-down',
            };

            let prevOverflow = '';

            /* harmony default export */ const image_src_mainvue_type_script_lang_js_ = ({
              name: 'ElImage',

              mixins: [locale_default.a],
              inheritAttrs: false,

              components: {
                ImageViewer: image_viewer,
              },

              props: {
                src: String,
                fit: String,
                lazy: Boolean,
                scrollContainer: {},
                previewSrcList: {
                  type: Array,
                  default: function _default() {
                    return [];
                  },
                },
                zIndex: {
                  type: Number,
                  default: 2000,
                },
              },

              data: function data() {
                return {
                  loading: true,
                  error: false,
                  show: !this.lazy,
                  imageWidth: 0,
                  imageHeight: 0,
                  showViewer: false,
                };
              },

              computed: {
                imageStyle: function imageStyle() {
                  const { fit } = this;

                  if (!this.$isServer && fit) {
                    return isSupportObjectFit() ? { 'object-fit': fit } : this.getImageStyle(fit);
                  }
                  return {};
                },
                alignCenter: function alignCenter() {
                  return !this.$isServer && !isSupportObjectFit() && this.fit !== ObjectFit.FILL;
                },
                preview: function preview() {
                  const { previewSrcList } = this;

                  return Array.isArray(previewSrcList) && previewSrcList.length > 0;
                },
                imageIndex: function imageIndex() {
                  let previewIndex = 0;
                  const srcIndex = this.previewSrcList.indexOf(this.src);
                  if (srcIndex >= 0) {
                    previewIndex = srcIndex;
                  }
                  return previewIndex;
                },
              },

              watch: {
                src: function src(val) {
                  this.show && this.loadImage();
                },
                show: function show(val) {
                  val && this.loadImage();
                },
              },

              mounted: function mounted() {
                if (this.lazy) {
                  this.addLazyLoadListener();
                } else {
                  this.loadImage();
                }
              },
              beforeDestroy: function beforeDestroy() {
                this.lazy && this.removeLazyLoadListener();
              },

              methods: {
                loadImage: function loadImage() {
                  const _this = this;

                  if (this.$isServer) return;

                  // reset status
                  this.loading = true;
                  this.error = false;

                  const img = new Image();
                  img.onload = function (e) {
                    return _this.handleLoad(e, img);
                  };
                  img.onerror = this.handleError.bind(this);

                  // bind html attrs
                  // so it can behave consistently
                  Object.keys(this.$attrs).forEach((key) => {
                    const value = _this.$attrs[key];
                    img.setAttribute(key, value);
                  });
                  img.src = this.src;
                },
                handleLoad: function handleLoad(e, img) {
                  this.imageWidth = img.width;
                  this.imageHeight = img.height;
                  this.loading = false;
                  this.error = false;
                },
                handleError: function handleError(e) {
                  this.loading = false;
                  this.error = true;
                  this.$emit('error', e);
                },
                handleLazyLoad: function handleLazyLoad() {
                  if (Object(dom_.isInContainer)(this.$el, this._scrollContainer)) {
                    this.show = true;
                    this.removeLazyLoadListener();
                  }
                },
                addLazyLoadListener: function addLazyLoadListener() {
                  if (this.$isServer) return;

                  const { scrollContainer } = this;

                  let _scrollContainer = null;

                  if (Object(types_.isHtmlElement)(scrollContainer)) {
                    _scrollContainer = scrollContainer;
                  } else if (Object(types_.isString)(scrollContainer)) {
                    _scrollContainer = document.querySelector(scrollContainer);
                  } else {
                    _scrollContainer = Object(dom_.getScrollContainer)(this.$el);
                  }

                  if (_scrollContainer) {
                    this._scrollContainer = _scrollContainer;
                    this._lazyLoadHandler = throttle_default()(200, this.handleLazyLoad);
                    Object(dom_.on)(_scrollContainer, 'scroll', this._lazyLoadHandler);
                    this.handleLazyLoad();
                  }
                },
                removeLazyLoadListener: function removeLazyLoadListener() {
                  const { _scrollContainer } = this;
                  const { _lazyLoadHandler } = this;

                  if (this.$isServer || !_scrollContainer || !_lazyLoadHandler) return;

                  Object(dom_.off)(_scrollContainer, 'scroll', _lazyLoadHandler);
                  this._scrollContainer = null;
                  this._lazyLoadHandler = null;
                },

                /**
     * simulate object-fit behavior to compatible with IE11 and other browsers which not support object-fit
     */
                getImageStyle: function getImageStyle(fit) {
                  const { imageWidth } = this;
                  const { imageHeight } = this;
                  const _$el = this.$el;
                  const containerWidth = _$el.clientWidth;
                  const containerHeight = _$el.clientHeight;

                  if (!imageWidth || !imageHeight || !containerWidth || !containerHeight) return {};

                  const imageAspectRatio = imageWidth / imageHeight;
                  const containerAspectRatio = containerWidth / containerHeight;

                  if (fit === ObjectFit.SCALE_DOWN) {
                    const isSmaller = imageWidth < containerWidth && imageHeight < containerHeight;
                    fit = isSmaller ? ObjectFit.NONE : ObjectFit.CONTAIN;
                  }

                  switch (fit) {
                    case ObjectFit.NONE:
                      return { width: 'auto', height: 'auto' };
                    case ObjectFit.CONTAIN:
                      return imageAspectRatio < containerAspectRatio ? { width: 'auto' } : { height: 'auto' };
                    case ObjectFit.COVER:
                      return imageAspectRatio < containerAspectRatio ? { height: 'auto' } : { width: 'auto' };
                    default:
                      return {};
                  }
                },
                clickHandler: function clickHandler() {
                  // don't show viewer when preview is false
                  if (!this.preview) {
                    return;
                  }
                  // prevent body scroll
                  prevOverflow = document.body.style.overflow;
                  document.body.style.overflow = 'hidden';
                  this.showViewer = true;
                },
                closeViewer: function closeViewer() {
                  document.body.style.overflow = prevOverflow;
                  this.showViewer = false;
                },
              },
            });
            // CONCATENATED MODULE: ./packages/image/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_image_src_mainvue_type_script_lang_js_ = (image_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/image/src/main.vue

            /* normalize component */

            const image_src_main_component = normalizeComponent(
              packages_image_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_44d84a7c_render,
              mainvue_type_template_id_44d84a7c_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let image_src_main_api; }
            image_src_main_component.options.__file = 'packages/image/src/main.vue';
            /* harmony default export */ const image_src_main = (image_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/image/index.js

            /* istanbul ignore next */
            image_src_main.install = function (Vue) {
              Vue.component(image_src_main.name, image_src_main);
            };

            /* harmony default export */ const packages_image = (image_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/calendar/src/main.vue?vue&type=template&id=6d9756be&
            const mainvue_type_template_id_6d9756be_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('div', { staticClass: 'el-calendar' }, [
                _c('div', { staticClass: 'el-calendar__header' }, [
                  _c('div', { staticClass: 'el-calendar__title' }, [
                    _vm._v(`\n      ${_vm._s(_vm.i18nDate)}\n    `),
                  ]),
                  _vm.validatedRange.length === 0
                    ? _c(
                      'div',
                      { staticClass: 'el-calendar__button-group' },
                      [
                        _c(
                          'el-button-group',
                          [
                            _c(
                              'el-button',
                              {
                                attrs: { type: 'plain', size: 'mini' },
                                on: {
                                  click($event) {
                                    _vm.selectDate('prev-month');
                                  },
                                },
                              },
                              [
                                _vm._v(
                                  `\n          ${
                                    _vm._s(_vm.t('el.datepicker.prevMonth'))
                                  }\n        `,
                                ),
                              ],
                            ),
                            _c(
                              'el-button',
                              {
                                attrs: { type: 'plain', size: 'mini' },
                                on: {
                                  click($event) {
                                    _vm.selectDate('today');
                                  },
                                },
                              },
                              [
                                _vm._v(
                                  `\n          ${
                                    _vm._s(_vm.t('el.datepicker.today'))
                                  }\n        `,
                                ),
                              ],
                            ),
                            _c(
                              'el-button',
                              {
                                attrs: { type: 'plain', size: 'mini' },
                                on: {
                                  click($event) {
                                    _vm.selectDate('next-month');
                                  },
                                },
                              },
                              [
                                _vm._v(
                                  `\n          ${
                                    _vm._s(_vm.t('el.datepicker.nextMonth'))
                                  }\n        `,
                                ),
                              ],
                            ),
                          ],
                          1,
                        ),
                      ],
                      1,
                    )
                    : _vm._e(),
                ]),
                _vm.validatedRange.length === 0
                  ? _c(
                    'div',
                    { key: 'no-range', staticClass: 'el-calendar__body' },
                    [
                      _c('date-table', {
                        attrs: {
                          date: _vm.date,
                          'selected-day': _vm.realSelectedDay,
                          'first-day-of-week': _vm.realFirstDayOfWeek,
                        },
                        on: { pick: _vm.pickDay },
                      }),
                    ],
                    1,
                  )
                  : _c(
                    'div',
                    { key: 'has-range', staticClass: 'el-calendar__body' },
                    _vm._l(_vm.validatedRange, (range, index) => _c('date-table', {
                      key: index,
                      attrs: {
                        date: range[0],
                        'selected-day': _vm.realSelectedDay,
                        range,
                        'hide-header': index !== 0,
                        'first-day-of-week': _vm.realFirstDayOfWeek,
                      },
                      on: { pick: _vm.pickDay },
                    })),
                    1,
                  ),
              ]);
            };
            const mainvue_type_template_id_6d9756be_staticRenderFns = [];
            mainvue_type_template_id_6d9756be_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/calendar/src/main.vue?vue&type=template&id=6d9756be&

            // EXTERNAL MODULE: external "element-ui/lib/utils/date"
            const date_ = __webpack_require__(20);
            const date_default = /* #__PURE__ */__webpack_require__.n(date_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/calendar/src/date-table.vue?vue&type=script&lang=js&

            /* harmony default export */ const src_date_tablevue_type_script_lang_js_ = ({
              props: {
                selectedDay: String, // formated date yyyy-MM-dd
                range: {
                  type: Array,
                  validator: function validator(val) {
                    if (!(val && val.length)) return true;
                    const start = val[0];
                    const end = val[1];

                    return Object(date_util_.validateRangeInOneMonth)(start, end);
                  },
                },
                date: Date,
                hideHeader: Boolean,
                firstDayOfWeek: Number,
              },

              inject: ['elCalendar'],

              methods: {
                toNestedArr: function toNestedArr(days) {
                  return Object(date_util_.range)(days.length / 7).map((_, index) => {
                    const start = index * 7;
                    return days.slice(start, start + 7);
                  });
                },
                getFormateDate: function getFormateDate(day, type) {
                  if (!day || ['prev', 'current', 'next'].indexOf(type) === -1) {
                    throw new Error('invalid day or type');
                  }
                  let prefix = this.curMonthDatePrefix;
                  if (type === 'prev') {
                    prefix = this.prevMonthDatePrefix;
                  } else if (type === 'next') {
                    prefix = this.nextMonthDatePrefix;
                  }
                  day = (`00${day}`).slice(-2);
                  return `${prefix}-${day}`;
                },
                getCellClass: function getCellClass(_ref) {
                  const { text } = _ref;
                  const { type } = _ref;

                  const classes = [type];
                  if (type === 'current') {
                    const date = this.getFormateDate(text, type);
                    if (date === this.selectedDay) {
                      classes.push('is-selected');
                    }
                    if (date === this.formatedToday) {
                      classes.push('is-today');
                    }
                  }
                  return classes;
                },
                pickDay: function pickDay(_ref2) {
                  const { text } = _ref2;
                  const { type } = _ref2;

                  const date = this.getFormateDate(text, type);
                  this.$emit('pick', date);
                },
                cellRenderProxy: function cellRenderProxy(_ref3) {
                  const { text } = _ref3;
                  const { type } = _ref3;
                  const h = this.$createElement;

                  const render = this.elCalendar.$scopedSlots.dateCell;
                  if (!render) return h('span', [text]);

                  const day = this.getFormateDate(text, type);
                  const date = new Date(day);
                  const data = {
                    isSelected: this.selectedDay === day,
                    type: `${type}-month`,
                    day,
                  };
                  return render({ date, data });
                },
              },

              computed: {
                WEEK_DAYS: function WEEK_DAYS() {
                  return Object(date_util_.getI18nSettings)().dayNames;
                },
                prevMonthDatePrefix: function prevMonthDatePrefix() {
                  const temp = new Date(this.date.getTime());
                  temp.setDate(0);
                  return date_default.a.format(temp, 'yyyy-MM');
                },
                curMonthDatePrefix: function curMonthDatePrefix() {
                  return date_default.a.format(this.date, 'yyyy-MM');
                },
                nextMonthDatePrefix: function nextMonthDatePrefix() {
                  const temp = new Date(this.date.getFullYear(), this.date.getMonth() + 1, 1);
                  return date_default.a.format(temp, 'yyyy-MM');
                },
                formatedToday: function formatedToday() {
                  return this.elCalendar.formatedToday;
                },
                isInRange: function isInRange() {
                  return this.range && this.range.length;
                },
                rows: function rows() {
                  let days = [];
                  // if range exists, should render days in range.
                  if (this.isInRange) {
                    const _range = this.range;
                    const start = _range[0];
                    const end = _range[1];

                    const currentMonthRange = Object(date_util_.range)(end.getDate() - start.getDate() + 1).map((_, index) => ({
                      text: start.getDate() + index,
                      type: 'current',
                    }));
                    let remaining = currentMonthRange.length % 7;
                    remaining = remaining === 0 ? 0 : 7 - remaining;
                    const nextMonthRange = Object(date_util_.range)(remaining).map((_, index) => ({
                      text: index + 1,
                      type: 'next',
                    }));
                    days = currentMonthRange.concat(nextMonthRange);
                  } else {
                    const { date } = this;
                    let firstDay = Object(date_util_.getFirstDayOfMonth)(date);
                    firstDay = firstDay === 0 ? 7 : firstDay;
                    const firstDayOfWeek = typeof this.firstDayOfWeek === 'number' ? this.firstDayOfWeek : 1;
                    const prevMonthDays = Object(date_util_.getPrevMonthLastDays)(date, firstDay - firstDayOfWeek).map((day) => ({
                      text: day,
                      type: 'prev',
                    }));
                    const currentMonthDays = Object(date_util_.getMonthDays)(date).map((day) => ({
                      text: day,
                      type: 'current',
                    }));
                    days = [].concat(prevMonthDays, currentMonthDays);
                    const nextMonthDays = Object(date_util_.range)(42 - days.length).map((_, index) => ({
                      text: index + 1,
                      type: 'next',
                    }));
                    days = days.concat(nextMonthDays);
                  }
                  return this.toNestedArr(days);
                },
                weekDays: function weekDays() {
                  const start = this.firstDayOfWeek;
                  const { WEEK_DAYS } = this;

                  if (typeof start !== 'number' || start === 0) {
                    return WEEK_DAYS.slice();
                  }
                  return WEEK_DAYS.slice(start).concat(WEEK_DAYS.slice(0, start));
                },
              },

              render: function render() {
                const _this = this;

                const h = arguments[0];

                const thead = this.hideHeader ? null : h('thead', [this.weekDays.map((day) => h(
                  'th',
                  { key: day },
                  [day],
                ))]);
                return h(
                  'table',
                  {
                    class: {
                      'el-calendar-table': true,
                      'is-range': this.isInRange,
                    },
                    attrs: {
                      cellspacing: '0',
                      cellpadding: '0',
                    },
                  },
                  [thead, h('tbody', [this.rows.map((row, index) => h(
                    'tr',
                    {
                      class: {
                        'el-calendar-table__row': true,
                        'el-calendar-table__row--hide-border': index === 0 && _this.hideHeader,
                      },
                      key: index,
                    },
                    [row.map((cell, key) => h(
                      'td',
                      {
 key,
                        'class': _this.getCellClass(cell),
                        on: {
                          'click': _this.pickDay.bind(_this, cell),
                        },
                      },
                      [h(
                        'div',
                        { class: 'el-calendar-day' },
                        [_this.cellRenderProxy(cell)],
                      )],
                    ))],
                  ))])],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/calendar/src/date-table.vue?vue&type=script&lang=js&
            /* harmony default export */ const calendar_src_date_tablevue_type_script_lang_js_ = (src_date_tablevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/calendar/src/date-table.vue
            let date_table_render; let
              date_table_staticRenderFns;

            /* normalize component */

            const src_date_table_component = normalizeComponent(
              calendar_src_date_tablevue_type_script_lang_js_,
              date_table_render,
              date_table_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let src_date_table_api; }
            src_date_table_component.options.__file = 'packages/calendar/src/date-table.vue';
            /* harmony default export */ const src_date_table = (src_date_table_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/calendar/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const validTypes = ['prev-month', 'today', 'next-month'];
            const weekDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const oneDay = 86400000;

            /* harmony default export */ const calendar_src_mainvue_type_script_lang_js_ = ({
              name: 'ElCalendar',

              mixins: [locale_default.a],

              components: {
                DateTable: src_date_table,
                ElButton: button_default.a,
                ElButtonGroup: button_group_default.a,
              },

              props: {
                value: [Date, String, Number],
                range: {
                  type: Array,
                  validator: function validator(range) {
                    if (Array.isArray(range)) {
                      return range.length === 2 && range.every((item) => typeof item === 'string' || typeof item === 'number' || item instanceof Date);
                    }
                    return true;
                  },
                },
                firstDayOfWeek: {
                  type: Number,
                  default: 1,
                },
              },

              provide: function provide() {
                return {
                  elCalendar: this,
                };
              },

              methods: {
                pickDay: function pickDay(day) {
                  this.realSelectedDay = day;
                },
                selectDate: function selectDate(type) {
                  if (validTypes.indexOf(type) === -1) {
                    throw new Error(`invalid type ${type}`);
                  }
                  let day = '';
                  if (type === 'prev-month') {
                    day = `${this.prevMonthDatePrefix}-01`;
                  } else if (type === 'next-month') {
                    day = `${this.nextMonthDatePrefix}-01`;
                  } else {
                    day = this.formatedToday;
                  }

                  if (day === this.formatedDate) return;
                  this.pickDay(day);
                },
                toDate: function toDate(val) {
                  if (!val) {
                    throw new Error('invalid val');
                  }
                  return val instanceof Date ? val : new Date(val);
                },
                rangeValidator: function rangeValidator(date, isStart) {
                  const firstDayOfWeek = this.realFirstDayOfWeek;
                  const expected = isStart ? firstDayOfWeek : firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
                  const message = `${isStart ? 'start' : 'end'} of range should be ${weekDays[expected]}.`;
                  if (date.getDay() !== expected) {
                    console.warn('[ElementCalendar]', message, 'Invalid range will be ignored.');
                    return false;
                  }
                  return true;
                },
              },

              computed: {
                prevMonthDatePrefix: function prevMonthDatePrefix() {
                  const temp = new Date(this.date.getTime());
                  temp.setDate(0);
                  return date_default.a.format(temp, 'yyyy-MM');
                },
                curMonthDatePrefix: function curMonthDatePrefix() {
                  return date_default.a.format(this.date, 'yyyy-MM');
                },
                nextMonthDatePrefix: function nextMonthDatePrefix() {
                  const temp = new Date(this.date.getFullYear(), this.date.getMonth() + 1, 1);
                  return date_default.a.format(temp, 'yyyy-MM');
                },
                formatedDate: function formatedDate() {
                  return date_default.a.format(this.date, 'yyyy-MM-dd');
                },
                i18nDate: function i18nDate() {
                  const year = this.date.getFullYear();
                  const month = this.date.getMonth() + 1;
                  return `${year} ${this.t('el.datepicker.year')} ${this.t(`el.datepicker.month${month}`)}`;
                },
                formatedToday: function formatedToday() {
                  return date_default.a.format(this.now, 'yyyy-MM-dd');
                },

                realSelectedDay: {
                  get: function get() {
                    if (!this.value) return this.selectedDay;
                    return this.formatedDate;
                  },
                  set: function set(val) {
                    this.selectedDay = val;
                    const date = new Date(val);
                    this.$emit('input', date);
                  },
                },

                date: function date() {
                  if (!this.value) {
                    if (this.realSelectedDay) {
                      const d = this.selectedDay.split('-');
                      return new Date(d[0], d[1] - 1, d[2]);
                    } if (this.validatedRange.length) {
                      return this.validatedRange[0][0];
                    }
                    return this.now;
                  }
                  return this.toDate(this.value);
                },

                // if range is valid, we get a two-digit array
                validatedRange: function validatedRange() {
                  const _this = this;

                  let { range } = this;
                  if (!range) return [];
                  range = range.reduce((prev, val, index) => {
                    const date = _this.toDate(val);
                    if (_this.rangeValidator(date, index === 0)) {
                      prev = prev.concat(date);
                    }
                    return prev;
                  }, []);
                  if (range.length === 2) {
                    const _range = range;
                    const start = _range[0];
                    const end = _range[1];

                    if (start > end) {
                      console.warn('[ElementCalendar]end time should be greater than start time');
                      return [];
                    }
                    // start time and end time in one month
                    if (Object(date_util_.validateRangeInOneMonth)(start, end)) {
                      return [[start, end]];
                    }
                    const data = [];
                    let startDay = new Date(start.getFullYear(), start.getMonth() + 1, 1);
                    const lastDay = this.toDate(startDay.getTime() - oneDay);
                    if (!Object(date_util_.validateRangeInOneMonth)(startDay, end)) {
                      console.warn('[ElementCalendar]start time and end time interval must not exceed two months');
                      return [];
                    }
                    // 第一个月的时间范围
                    data.push([start, lastDay]);
                    // 下一月的时间范围，需要计算一下该月的第一个周起始日
                    const firstDayOfWeek = this.realFirstDayOfWeek;
                    const nextMontFirstDay = startDay.getDay();
                    let interval = 0;
                    if (nextMontFirstDay !== firstDayOfWeek) {
                      if (firstDayOfWeek === 0) {
                        interval = 7 - nextMontFirstDay;
                      } else {
                        interval = firstDayOfWeek - nextMontFirstDay;
                        interval = interval > 0 ? interval : 7 + interval;
                      }
                    }
                    startDay = this.toDate(startDay.getTime() + interval * oneDay);
                    if (startDay.getDate() < end.getDate()) {
                      data.push([startDay, end]);
                    }
                    return data;
                  }
                  return [];
                },
                realFirstDayOfWeek: function realFirstDayOfWeek() {
                  if (this.firstDayOfWeek < 1 || this.firstDayOfWeek > 6) {
                    return 0;
                  }
                  return Math.floor(this.firstDayOfWeek);
                },
              },

              data: function data() {
                return {
                  selectedDay: '',
                  now: new Date(),
                };
              },
            });
            // CONCATENATED MODULE: ./packages/calendar/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_calendar_src_mainvue_type_script_lang_js_ = (calendar_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/calendar/src/main.vue

            /* normalize component */

            const calendar_src_main_component = normalizeComponent(
              packages_calendar_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_6d9756be_render,
              mainvue_type_template_id_6d9756be_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let calendar_src_main_api; }
            calendar_src_main_component.options.__file = 'packages/calendar/src/main.vue';
            /* harmony default export */ const calendar_src_main = (calendar_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/calendar/index.js

            /* istanbul ignore next */
            calendar_src_main.install = function (Vue) {
              Vue.component(calendar_src_main.name, calendar_src_main);
            };

            /* harmony default export */ const calendar = (calendar_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/backtop/src/main.vue?vue&type=template&id=257dd4a9&
            const mainvue_type_template_id_257dd4a9_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('transition', { attrs: { name: 'el-fade-in' } }, [
                _vm.visible
                  ? _c(
                    'div',
                    {
                      staticClass: 'el-backtop',
                      style: {
                        right: _vm.styleRight,
                        bottom: _vm.styleBottom,
                      },
                      on: {
                        click($event) {
                          $event.stopPropagation();
                          return _vm.handleClick($event);
                        },
                      },
                    },
                    [
                      _vm._t('default', [_c('el-icon', { attrs: { name: 'caret-top' } })]),
                    ],
                    2,
                  )
                  : _vm._e(),
              ]);
            };
            const mainvue_type_template_id_257dd4a9_staticRenderFns = [];
            mainvue_type_template_id_257dd4a9_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/backtop/src/main.vue?vue&type=template&id=257dd4a9&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/backtop/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const cubic = function cubic(value) {
              return Math.pow(value, 3);
            };
            const easeInOutCubic = function easeInOutCubic(value) {
              return value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2;
            };

            /* harmony default export */ const backtop_src_mainvue_type_script_lang_js_ = ({
              name: 'ElBacktop',

              props: {
                visibilityHeight: {
                  type: Number,
                  default: 200,
                },
                target: [String],
                right: {
                  type: Number,
                  default: 40,
                },
                bottom: {
                  type: Number,
                  default: 40,
                },
              },

              data: function data() {
                return {
                  el: null,
                  container: null,
                  visible: false,
                };
              },

              computed: {
                styleBottom: function styleBottom() {
                  return `${this.bottom}px`;
                },
                styleRight: function styleRight() {
                  return `${this.right}px`;
                },
              },

              mounted: function mounted() {
                this.init();
                this.throttledScrollHandler = throttle_default()(300, this.onScroll);
                this.container.addEventListener('scroll', this.throttledScrollHandler);
              },

              methods: {
                init: function init() {
                  this.container = document;
                  this.el = document.documentElement;
                  if (this.target) {
                    this.el = document.querySelector(this.target);
                    if (!this.el) {
                      throw new Error(`target is not existed: ${this.target}`);
                    }
                    this.container = this.el;
                  }
                },
                onScroll: function onScroll() {
                  const { scrollTop } = this.el;
                  this.visible = scrollTop >= this.visibilityHeight;
                },
                handleClick: function handleClick(e) {
                  this.scrollToTop();
                  this.$emit('click', e);
                },
                scrollToTop: function scrollToTop() {
                  const { el } = this;
                  const beginTime = Date.now();
                  const beginValue = el.scrollTop;
                  const rAF = window.requestAnimationFrame || function (func) {
                    return setTimeout(func, 16);
                  };
                  const frameFunc = function frameFunc() {
                    const progress = (Date.now() - beginTime) / 500;
                    if (progress < 1) {
                      el.scrollTop = beginValue * (1 - easeInOutCubic(progress));
                      rAF(frameFunc);
                    } else {
                      el.scrollTop = 0;
                    }
                  };
                  rAF(frameFunc);
                },
              },

              beforeDestroy: function beforeDestroy() {
                this.container.removeEventListener('scroll', this.throttledScrollHandler);
              },
            });
            // CONCATENATED MODULE: ./packages/backtop/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_backtop_src_mainvue_type_script_lang_js_ = (backtop_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/backtop/src/main.vue

            /* normalize component */

            const backtop_src_main_component = normalizeComponent(
              packages_backtop_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_257dd4a9_render,
              mainvue_type_template_id_257dd4a9_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let backtop_src_main_api; }
            backtop_src_main_component.options.__file = 'packages/backtop/src/main.vue';
            /* harmony default export */ const backtop_src_main = (backtop_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/backtop/index.js

            /* istanbul ignore next */
            backtop_src_main.install = function (Vue) {
              Vue.component(backtop_src_main.name, backtop_src_main);
            };

            /* harmony default export */ const backtop = (backtop_src_main);
            // CONCATENATED MODULE: ./packages/infinite-scroll/src/main.js

            const getStyleComputedProperty = function getStyleComputedProperty(element, property) {
              if (element === window) {
                element = document.documentElement;
              }

              if (element.nodeType !== 1) {
                return [];
              }
              // NOTE: 1 DOM access here
              const css = window.getComputedStyle(element, null);
              return property ? css[property] : css;
            };

            const entries = function entries(obj) {
              return Object.keys(obj || {}).map((key) => [key, obj[key]]);
            };

            const getPositionSize = function getPositionSize(el, prop) {
              return el === window || el === document ? document.documentElement[prop] : el[prop];
            };

            const getOffsetHeight = function getOffsetHeight(el) {
              return getPositionSize(el, 'offsetHeight');
            };

            const getClientHeight = function getClientHeight(el) {
              return getPositionSize(el, 'clientHeight');
            };

            const scope = 'ElInfiniteScroll';
            const attributes = {
              delay: {
                type: Number,
                default: 200,
              },
              distance: {
                type: Number,
                default: 0,
              },
              disabled: {
                type: Boolean,
                default: false,
              },
              immediate: {
                type: Boolean,
                default: true,
              },
            };

            const main_getScrollOptions = function getScrollOptions(el, vm) {
              if (!Object(types_.isHtmlElement)(el)) return {};

              return entries(attributes).reduce((map, _ref) => {
                const key = _ref[0];
                const option = _ref[1];
                const { type } = option;
                let defaultValue = option.default;

                let value = el.getAttribute(`infinite-scroll-${key}`);
                value = Object(types_.isUndefined)(vm[value]) ? value : vm[value];
                switch (type) {
                  case Number:
                    value = Number(value);
                    value = Number.isNaN(value) ? defaultValue : value;
                    break;
                  case Boolean:
                    value = Object(types_.isDefined)(value) ? value === 'false' ? false : Boolean(value) : defaultValue;
                    break;
                  default:
                    value = type(value);
                }
                map[key] = value;
                return map;
              }, {});
            };

            const getElementTop = function getElementTop(el) {
              return el.getBoundingClientRect().top;
            };

            const main_handleScroll = function handleScroll(cb) {
              const _scope = this[scope];
              const { el } = _scope;
              const { vm } = _scope;
              const { container } = _scope;
              const { observer } = _scope;

              const _getScrollOptions = main_getScrollOptions(el, vm);
              const { distance } = _getScrollOptions;
              const { disabled } = _getScrollOptions;

              if (disabled) return;

              const containerInfo = container.getBoundingClientRect();
              if (!containerInfo.width && !containerInfo.height) return;

              let shouldTrigger = false;

              if (container === el) {
                // be aware of difference between clientHeight & offsetHeight & window.getComputedStyle().height
                const scrollBottom = container.scrollTop + getClientHeight(container);
                shouldTrigger = container.scrollHeight - scrollBottom <= distance;
              } else {
                const heightBelowTop = getOffsetHeight(el) + getElementTop(el) - getElementTop(container);
                const offsetHeight = getOffsetHeight(container);
                const borderBottom = Number.parseFloat(getStyleComputedProperty(container, 'borderBottomWidth'));
                shouldTrigger = heightBelowTop - offsetHeight + borderBottom <= distance;
              }

              if (shouldTrigger && Object(types_.isFunction)(cb)) {
                cb.call(vm);
              } else if (observer) {
                observer.disconnect();
                this[scope].observer = null;
              }
            };

            /* harmony default export */ const infinite_scroll_src_main = ({
              name: 'InfiniteScroll',
              inserted: function inserted(el, binding, vnode) {
                const cb = binding.value;

                const vm = vnode.context;
                // only include vertical scroll
                const container = Object(dom_.getScrollContainer)(el, true);

                const _getScrollOptions2 = main_getScrollOptions(el, vm);
                const { delay } = _getScrollOptions2;
                const { immediate } = _getScrollOptions2;

                const onScroll = debounce_default()(delay, main_handleScroll.bind(el, cb));

                el[scope] = {
                  el, vm, container, onScroll,
                };

                if (container) {
                  container.addEventListener('scroll', onScroll);

                  if (immediate) {
                    const observer = el[scope].observer = new MutationObserver(onScroll);
                    observer.observe(container, { childList: true, subtree: true });
                    onScroll();
                  }
                }
              },
              unbind: function unbind(el) {
                const _el$scope = el[scope];
                const { container } = _el$scope;
                const { onScroll } = _el$scope;

                if (container) {
                  container.removeEventListener('scroll', onScroll);
                }
              },
            });
            // CONCATENATED MODULE: ./packages/infinite-scroll/index.js

            /* istanbul ignore next */
            infinite_scroll_src_main.install = function (Vue) {
              Vue.directive(infinite_scroll_src_main.name, infinite_scroll_src_main);
            };

            /* harmony default export */ const infinite_scroll = (infinite_scroll_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/page-header/src/main.vue?vue&type=template&id=5070954c&
            const mainvue_type_template_id_5070954c_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('div', { staticClass: 'el-page-header' }, [
                _c(
                  'div',
                  {
                    staticClass: 'el-page-header__left',
                    on: {
                      click($event) {
                        _vm.$emit('back');
                      },
                    },
                  },
                  [
                    _c('i', { staticClass: 'el-icon-back' }),
                    _c(
                      'div',
                      { staticClass: 'el-page-header__title' },
                      [_vm._t('title', [_vm._v(_vm._s(_vm.title))])],
                      2,
                    ),
                  ],
                ),
                _c(
                  'div',
                  { staticClass: 'el-page-header__content' },
                  [_vm._t('content', [_vm._v(_vm._s(_vm.content))])],
                  2,
                ),
              ]);
            };
            const mainvue_type_template_id_5070954c_staticRenderFns = [];
            mainvue_type_template_id_5070954c_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/page-header/src/main.vue?vue&type=template&id=5070954c&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/page-header/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const page_header_src_mainvue_type_script_lang_js_ = ({
              name: 'ElPageHeader',

              props: {
                title: {
                  type: String,
                  default: function _default() {
                    return Object(lib_locale_.t)('el.pageHeader.title');
                  },
                },
                content: String,
              },
            });
            // CONCATENATED MODULE: ./packages/page-header/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_page_header_src_mainvue_type_script_lang_js_ = (page_header_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/page-header/src/main.vue

            /* normalize component */

            const page_header_src_main_component = normalizeComponent(
              packages_page_header_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_5070954c_render,
              mainvue_type_template_id_5070954c_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let page_header_src_main_api; }
            page_header_src_main_component.options.__file = 'packages/page-header/src/main.vue';
            /* harmony default export */ const page_header_src_main = (page_header_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/page-header/index.js

            /* istanbul ignore next */
            page_header_src_main.install = function (Vue) {
              Vue.component(page_header_src_main.name, page_header_src_main);
            };

            /* harmony default export */ const page_header = (page_header_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader-panel/src/cascader-panel.vue?vue&type=template&id=34932346&
            const cascader_panelvue_type_template_id_34932346_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  class: ['el-cascader-panel', _vm.border && 'is-bordered'],
                  on: { keydown: _vm.handleKeyDown },
                },
                _vm._l(_vm.menus, (menu, index) => _c('cascader-menu', {
                  key: index,
                  ref: 'menu',
                  refInFor: true,
                  attrs: { index, nodes: menu },
                })),
                1,
              );
            };
            const cascader_panelvue_type_template_id_34932346_staticRenderFns = [];
            cascader_panelvue_type_template_id_34932346_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-panel.vue?vue&type=template&id=34932346&

            // EXTERNAL MODULE: external "element-ui/lib/radio"
            const radio_ = __webpack_require__(43);
            const radio_default = /* #__PURE__ */__webpack_require__.n(radio_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader-panel/src/cascader-node.vue?vue&type=script&lang=js&

            const stopPropagation = function stopPropagation(e) {
              return e.stopPropagation();
            };

            /* harmony default export */ const cascader_nodevue_type_script_lang_js_ = ({
              inject: ['panel'],

              components: {
                ElCheckbox: checkbox_default.a,
                ElRadio: radio_default.a,
              },

              props: {
                node: {
                  required: true,
                },
                nodeId: String,
              },

              computed: {
                config: function config() {
                  return this.panel.config;
                },
                isLeaf: function isLeaf() {
                  return this.node.isLeaf;
                },
                isDisabled: function isDisabled() {
                  return this.node.isDisabled;
                },
                checkedValue: function checkedValue() {
                  return this.panel.checkedValue;
                },
                isChecked: function isChecked() {
                  return this.node.isSameNode(this.checkedValue);
                },
                inActivePath: function inActivePath() {
                  return this.isInPath(this.panel.activePath);
                },
                inCheckedPath: function inCheckedPath() {
                  const _this = this;

                  if (!this.config.checkStrictly) return false;

                  return this.panel.checkedNodePaths.some((checkedPath) => _this.isInPath(checkedPath));
                },
                value: function value() {
                  return this.node.getValueByOption();
                },
              },

              methods: {
                handleExpand: function handleExpand() {
                  const _this2 = this;

                  const { panel } = this;
                  const { node } = this;
                  const { isDisabled } = this;
                  const { config } = this;
                  const { multiple } = config;
                  const { checkStrictly } = config;

                  if (!checkStrictly && isDisabled || node.loading) return;

                  if (config.lazy && !node.loaded) {
                    panel.lazyLoad(node, () => {
                      // do not use cached leaf value here, invoke this.isLeaf to get new value.
                      const { isLeaf } = _this2;

                      if (!isLeaf) _this2.handleExpand();
                      if (multiple) {
                        // if leaf sync checked state, else clear checked state
                        const checked = isLeaf ? node.checked : false;
                        _this2.handleMultiCheckChange(checked);
                      }
                    });
                  } else {
                    panel.handleExpand(node);
                  }
                },
                handleCheckChange: function handleCheckChange() {
                  const { panel } = this;
                  const { value } = this;
                  const { node } = this;

                  panel.handleCheckChange(value);
                  panel.handleExpand(node);
                },
                handleMultiCheckChange: function handleMultiCheckChange(checked) {
                  this.node.doCheck(checked);
                  this.panel.calculateMultiCheckedValue();
                },
                isInPath: function isInPath(pathNodes) {
                  const { node } = this;

                  const selectedPathNode = pathNodes[node.level - 1] || {};
                  return selectedPathNode.uid === node.uid;
                },
                renderPrefix: function renderPrefix(h) {
                  const { isLeaf } = this;
                  var {isChecked} = this;
                  var {config} = this;
                  const { checkStrictly } = config;
                  var {multiple} = config;

                  if (multiple) {
                    return this.renderCheckbox(h);
                  } if (checkStrictly) {
                    return this.renderRadio(h);
                  } if (isLeaf && isChecked) {
                    return this.renderCheckIcon(h);
                  }

                  return null;
                },
                renderPostfix: function renderPostfix(h) {
                  const { node } = this;
                  let { isLeaf } = this;

                  if (node.loading) {
                    return this.renderLoadingIcon(h);
                  } if (!isLeaf) {
                    return this.renderExpandIcon(h);
                  }

                  return null;
                },
                renderCheckbox: function renderCheckbox(h) {
                  const { node } = this;
                  const { config } = this;
                  const { isDisabled } = this;

                  const events = {
                    on: { change: this.handleMultiCheckChange },
                    nativeOn: {},
                  };

                  if (config.checkStrictly) {
                    // when every node is selectable, click event should not trigger expand event.
                    events.nativeOn.click = stopPropagation;
                  }

                  return h('el-checkbox', external_babel_helper_vue_jsx_merge_props_default()([{
                    attrs: {
                      value: node.checked,
                      indeterminate: node.indeterminate,
                      disabled: isDisabled,
                    },
                  }, events]));
                },
                renderRadio: function renderRadio(h) {
                  const { checkedValue } = this;
                  let { value } = this;
                  const { isDisabled } = this;

                  // to keep same reference if value cause radio's checked state is calculated by reference comparision;

                  if (Object(util_.isEqual)(value, checkedValue)) {
                    value = checkedValue;
                  }

                  return h(
                    'el-radio',
                    {
                      attrs: {
                        value: checkedValue,
                        label: value,
                        disabled: isDisabled,
                      },
                      on: {
                        change: this.handleCheckChange,
                      },
                      nativeOn: {
                        click: stopPropagation,
                      },
                    },
                    [h('span')],
                  );
                },
                renderCheckIcon: function renderCheckIcon(h) {
                  return h('i', { class: 'el-icon-check el-cascader-node__prefix' });
                },
                renderLoadingIcon: function renderLoadingIcon(h) {
                  return h('i', { class: 'el-icon-loading el-cascader-node__postfix' });
                },
                renderExpandIcon: function renderExpandIcon(h) {
                  return h('i', { class: 'el-icon-arrow-right el-cascader-node__postfix' });
                },
                renderContent: function renderContent(h) {
                  const { panel } = this;
                  const { node } = this;

                  const render = panel.renderLabelFn;
                  const vnode = render ? render({ node, data: node.data }) : null;

                  return h(
                    'span',
                    { class: 'el-cascader-node__label' },
                    [vnode || node.label],
                  );
                },
              },

              render: function render(h) {
                const _this3 = this;

                const { inActivePath } = this;
                const { inCheckedPath } = this;
                const { isChecked } = this;
                const { isLeaf } = this;
                const { isDisabled } = this;
                const { config } = this;
                const { nodeId } = this;
                const { expandTrigger } = config;
                const { checkStrictly } = config;
                const { multiple } = config;

                const disabled = !checkStrictly && isDisabled;
                const events = { on: {} };

                if (expandTrigger === 'click') {
                  events.on.click = this.handleExpand;
                } else {
                  events.on.mouseenter = function (e) {
                    _this3.handleExpand();
                    _this3.$emit('expand', e);
                  };
                  events.on.focus = function (e) {
                    _this3.handleExpand();
                    _this3.$emit('expand', e);
                  };
                }
                if (isLeaf && !isDisabled && !checkStrictly && !multiple) {
                  events.on.click = this.handleCheckChange;
                }

                return h(
                  'li',
                  external_babel_helper_vue_jsx_merge_props_default()([{
                    attrs: {
                      role: 'menuitem',
                      id: nodeId,
                      'aria-expanded': inActivePath,
                      tabindex: disabled ? null : -1,
                    },
                    class: {
                      'el-cascader-node': true,
                      'is-selectable': checkStrictly,
                      'in-active-path': inActivePath,
                      'in-checked-path': inCheckedPath,
                      'is-active': isChecked,
                      'is-disabled': disabled,
                    },
                  }, events]),
                  [this.renderPrefix(h), this.renderContent(h), this.renderPostfix(h)],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-node.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_cascader_nodevue_type_script_lang_js_ = (cascader_nodevue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-node.vue
            let cascader_node_render; let
              cascader_node_staticRenderFns;

            /* normalize component */

            const cascader_node_component = normalizeComponent(
              src_cascader_nodevue_type_script_lang_js_,
              cascader_node_render,
              cascader_node_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let cascader_node_api; }
            cascader_node_component.options.__file = 'packages/cascader-panel/src/cascader-node.vue';
            /* harmony default export */ const cascader_node = (cascader_node_component.exports);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader-panel/src/cascader-menu.vue?vue&type=script&lang=js&

            /* harmony default export */ const cascader_menuvue_type_script_lang_js_ = ({
              name: 'ElCascaderMenu',

              mixins: [locale_default.a],

              inject: ['panel'],

              components: {
                ElScrollbar: scrollbar_default.a,
                CascaderNode: cascader_node,
              },

              props: {
                nodes: {
                  type: Array,
                  required: true,
                },
                index: Number,
              },

              data: function data() {
                return {
                  activeNode: null,
                  hoverTimer: null,
                  id: Object(util_.generateId)(),
                };
              },

              computed: {
                isEmpty: function isEmpty() {
                  return !this.nodes.length;
                },
                menuId: function menuId() {
                  return `cascader-menu-${this.id}-${this.index}`;
                },
              },

              methods: {
                handleExpand: function handleExpand(e) {
                  this.activeNode = e.target;
                },
                handleMouseMove: function handleMouseMove(e) {
                  const { activeNode } = this;
                  const { hoverTimer } = this;
                  const { hoverZone } = this.$refs;

                  if (!activeNode || !hoverZone) return;

                  if (activeNode.contains(e.target)) {
                    clearTimeout(hoverTimer);

                    const _$el$getBoundingClien = this.$el.getBoundingClientRect();
                    const { left } = _$el$getBoundingClien;

                    const startX = e.clientX - left;
                    const _$el = this.$el;
                    const { offsetWidth } = _$el;
                    const { offsetHeight } = _$el;

                    const top = activeNode.offsetTop;
                    const bottom = top + activeNode.offsetHeight;

                    hoverZone.innerHTML = `\n          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top} L${offsetWidth} 0 V${top} Z" />\n          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom} L${offsetWidth} ${offsetHeight} V${bottom} Z" />\n        `;
                  } else if (!hoverTimer) {
                    this.hoverTimer = setTimeout(this.clearHoverZone, this.panel.config.hoverThreshold);
                  }
                },
                clearHoverZone: function clearHoverZone() {
                  const { hoverZone } = this.$refs;

                  if (!hoverZone) return;
                  hoverZone.innerHTML = '';
                },
                renderEmptyText: function renderEmptyText(h) {
                  return h(
                    'div',
                    { class: 'el-cascader-menu__empty-text' },
                    [this.t('el.cascader.noData')],
                  );
                },
                renderNodeList: function renderNodeList(h) {
                  const { menuId } = this;
                  const { isHoverMenu } = this.panel;

                  const events = { on: {} };

                  if (isHoverMenu) {
                    events.on.expand = this.handleExpand;
                  }

                  const nodes = this.nodes.map((node, index) => {
                    const { hasChildren } = node;

                    return h('cascader-node', external_babel_helper_vue_jsx_merge_props_default()([{
                      key: node.uid,
                      attrs: {
                        node,
                        'node-id': `${menuId}-${index}`,
                        'aria-haspopup': hasChildren,
                        'aria-owns': hasChildren ? menuId : null,
                      },
                    }, events]));
                  });

                  return [].concat(nodes, [isHoverMenu ? h('svg', { ref: 'hoverZone', class: 'el-cascader-menu__hover-zone' }) : null]);
                },
              },

              render: function render(h) {
                const { isEmpty } = this;
                const { menuId } = this;

                const events = { nativeOn: {} };

                // optimize hover to expand experience (#8010)
                if (this.panel.isHoverMenu) {
                  events.nativeOn.mousemove = this.handleMouseMove;
                  // events.nativeOn.mouseleave = this.clearHoverZone;
                }

                return h(
                  'el-scrollbar',
                  external_babel_helper_vue_jsx_merge_props_default()([{
                    attrs: {
                      tag: 'ul',
                      role: 'menu',
                      id: menuId,

                      'wrap-class': 'el-cascader-menu__wrap',
                      'view-class': {
                        'el-cascader-menu__list': true,
                        'is-empty': isEmpty,
                      },
                    },
                    class: 'el-cascader-menu',
                  }, events]),
                  [isEmpty ? this.renderEmptyText(h) : this.renderNodeList(h)],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-menu.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_cascader_menuvue_type_script_lang_js_ = (cascader_menuvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-menu.vue
            let cascader_menu_render; let
              cascader_menu_staticRenderFns;

            /* normalize component */

            const cascader_menu_component = normalizeComponent(
              src_cascader_menuvue_type_script_lang_js_,
              cascader_menu_render,
              cascader_menu_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let cascader_menu_api; }
            cascader_menu_component.options.__file = 'packages/cascader-panel/src/cascader-menu.vue';
            /* harmony default export */ const cascader_menu = (cascader_menu_component.exports);
            // CONCATENATED MODULE: ./packages/cascader-panel/src/node.js
            const node_createClass = (function () { function defineProperties(target, props) { for (let i = 0; i < props.length; i++) { const descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }());

            function src_node_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

            let uid = 0;

            const src_node_Node = (function () {
              function Node(data, config, parentNode) {
                src_node_classCallCheck(this, Node);

                this.data = data;
                this.config = config;
                this.parent = parentNode || null;
                this.level = !this.parent ? 1 : this.parent.level + 1;
                this.uid = uid++;

                this.initState();
                this.initChildren();
              }

              Node.prototype.initState = function initState() {
                const _config = this.config;
                const valueKey = _config.value;
                const labelKey = _config.label;

                this.value = this.data[valueKey];
                this.label = this.data[labelKey];
                this.pathNodes = this.calculatePathNodes();
                this.path = this.pathNodes.map((node) => node.value);
                this.pathLabels = this.pathNodes.map((node) => node.label);

                // lazy load
                this.loading = false;
                this.loaded = false;
              };

              Node.prototype.initChildren = function initChildren() {
                const _this = this;

                const { config } = this;

                const childrenKey = config.children;
                const childrenData = this.data[childrenKey];
                this.hasChildren = Array.isArray(childrenData);
                this.children = (childrenData || []).map((child) => new Node(child, config, _this));
              };

              Node.prototype.calculatePathNodes = function calculatePathNodes() {
                const nodes = [this];
                let { parent } = this;

                while (parent) {
                  nodes.unshift(parent);
                  parent = parent.parent;
                }

                return nodes;
              };

              Node.prototype.getPath = function getPath() {
                return this.path;
              };

              Node.prototype.getValue = function getValue() {
                return this.value;
              };

              Node.prototype.getValueByOption = function getValueByOption() {
                return this.config.emitPath ? this.getPath() : this.getValue();
              };

              Node.prototype.getText = function getText(allLevels, separator) {
                return allLevels ? this.pathLabels.join(separator) : this.label;
              };

              Node.prototype.isSameNode = function isSameNode(checkedValue) {
                const value = this.getValueByOption();
                return this.config.multiple && Array.isArray(checkedValue) ? checkedValue.some((val) => Object(util_.isEqual)(val, value)) : Object(util_.isEqual)(checkedValue, value);
              };

              Node.prototype.broadcast = function broadcast(event) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }

                const handlerName = `onParent${Object(util_.capitalize)(event)}`;

                this.children.forEach((child) => {
                  if (child) {
                    // bottom up
                    child.broadcast.apply(child, [event].concat(args));
                    child[handlerName] && child[handlerName].apply(child, args);
                  }
                });
              };

              Node.prototype.emit = function emit(event) {
                const { parent } = this;

                const handlerName = `onChild${Object(util_.capitalize)(event)}`;
                if (parent) {
                  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    args[_key2 - 1] = arguments[_key2];
                  }

                  parent[handlerName] && parent[handlerName].apply(parent, args);
                  parent.emit.apply(parent, [event].concat(args));
                }
              };

              Node.prototype.onParentCheck = function onParentCheck(checked) {
                if (!this.isDisabled) {
                  this.setCheckState(checked);
                }
              };

              Node.prototype.onChildCheck = function onChildCheck() {
                const { children } = this;

                const validChildren = children.filter((child) => !child.isDisabled);
                const checked = validChildren.length ? validChildren.every((child) => child.checked) : false;

                this.setCheckState(checked);
              };

              Node.prototype.setCheckState = function setCheckState(checked) {
                const totalNum = this.children.length;
                const checkedNum = this.children.reduce((c, p) => {
                  const num = p.checked ? 1 : p.indeterminate ? 0.5 : 0;
                  return c + num;
                }, 0);

                this.checked = checked;
                this.indeterminate = checkedNum !== totalNum && checkedNum > 0;
              };

              Node.prototype.syncCheckState = function syncCheckState(checkedValue) {
                const value = this.getValueByOption();
                const checked = this.isSameNode(checkedValue, value);

                this.doCheck(checked);
              };

              Node.prototype.doCheck = function doCheck(checked) {
                if (this.checked !== checked) {
                  if (this.config.checkStrictly) {
                    this.checked = checked;
                  } else {
                    // bottom up to unify the calculation of the indeterminate state
                    this.broadcast('check', checked);
                    this.setCheckState(checked);
                    this.emit('check');
                  }
                }
              };

              node_createClass(Node, [{
                key: 'isDisabled',
                get: function get() {
                  const { data } = this;
                  let { parent } = this;
                  let { config } = this;

                  const disabledKey = config.disabled;
                  const { checkStrictly } = config;

                  return data[disabledKey] || !checkStrictly && parent && parent.isDisabled;
                },
              }, {
                key: 'isLeaf',
                get: function get() {
                  const { data } = this;
                  let { loaded } = this;
                  let { hasChildren } = this;
                  let { children } = this;
                  const _config2 = this.config;
                  const { lazy } = _config2;
                  const leafKey = _config2.leaf;

                  if (lazy) {
                    const isLeaf = Object(shared_.isDef)(data[leafKey]) ? data[leafKey] : loaded ? !children.length : false;
                    this.hasChildren = !isLeaf;
                    return isLeaf;
                  }
                  return !hasChildren;
                },
              }]);

              return Node;
            }());

            /* harmony default export */ const src_node = (src_node_Node);
            // CONCATENATED MODULE: ./packages/cascader-panel/src/store.js
            function store_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

            const flatNodes = function flatNodes(data, leafOnly) {
              return data.reduce((res, node) => {
                if (node.isLeaf) {
                  res.push(node);
                } else {
                  !leafOnly && res.push(node);
                  res = res.concat(flatNodes(node.children, leafOnly));
                }
                return res;
              }, []);
            };

            const store_Store = (function () {
              function Store(data, config) {
                store_classCallCheck(this, Store);

                this.config = config;
                this.initNodes(data);
              }

              Store.prototype.initNodes = function initNodes(data) {
                const _this = this;

                data = Object(util_.coerceTruthyValueToArray)(data);
                this.nodes = data.map((nodeData) => new src_node(nodeData, _this.config));
                this.flattedNodes = this.getFlattedNodes(false, false);
                this.leafNodes = this.getFlattedNodes(true, false);
              };

              Store.prototype.appendNode = function appendNode(nodeData, parentNode) {
                const node = new src_node(nodeData, this.config, parentNode);
                const children = parentNode ? parentNode.children : this.nodes;

                children.push(node);
              };

              Store.prototype.appendNodes = function appendNodes(nodeDataList, parentNode) {
                const _this2 = this;

                nodeDataList = Object(util_.coerceTruthyValueToArray)(nodeDataList);
                nodeDataList.forEach((nodeData) => _this2.appendNode(nodeData, parentNode));
              };

              Store.prototype.getNodes = function getNodes() {
                return this.nodes;
              };

              Store.prototype.getFlattedNodes = function getFlattedNodes(leafOnly) {
                const cached = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

                const cachedNodes = leafOnly ? this.leafNodes : this.flattedNodes;
                return cached ? cachedNodes : flatNodes(this.nodes, leafOnly);
              };

              Store.prototype.getNodeByValue = function getNodeByValue(value) {
                if (value) {
                  const nodes = this.getFlattedNodes(false, !this.config.lazy).filter((node) => Object(util_.valueEquals)(node.path, value) || node.value === value);
                  return nodes && nodes.length ? nodes[0] : null;
                }
                return null;
              };

              return Store;
            }());

            /* harmony default export */ const cascader_panel_src_store = (store_Store);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader-panel/src/cascader-panel.vue?vue&type=script&lang=js&
            const cascader_panelvue_type_script_lang_js_extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            const cascader_panelvue_type_script_lang_js_KeyCode = aria_utils_default.a.keys;

            const DefaultProps = {
              expandTrigger: 'click', // or hover
              multiple: false,
              checkStrictly: false, // whether all nodes can be selected
              emitPath: true, // wether to emit an array of all levels value in which node is located
              lazy: false,
              lazyLoad: util_.noop,
              value: 'value',
              label: 'label',
              children: 'children',
              leaf: 'leaf',
              disabled: 'disabled',
              hoverThreshold: 500,
            };

            const cascader_panelvue_type_script_lang_js_isLeaf = function isLeaf(el) {
              return !el.getAttribute('aria-owns');
            };

            const getSibling = function getSibling(el, distance) {
              const { parentNode } = el;

              if (parentNode) {
                const siblings = parentNode.querySelectorAll('.el-cascader-node[tabindex="-1"]');
                const index = Array.prototype.indexOf.call(siblings, el);
                return siblings[index + distance] || null;
              }
              return null;
            };

            const getMenuIndex = function getMenuIndex(el, distance) {
              if (!el) return;
              const pieces = el.id.split('-');
              return Number(pieces[pieces.length - 2]);
            };

            const focusNode = function focusNode(el) {
              if (!el) return;
              el.focus();
              !cascader_panelvue_type_script_lang_js_isLeaf(el) && el.click();
            };

            const checkNode = function checkNode(el) {
              if (!el) return;

              const input = el.querySelector('input');
              if (input) {
                input.click();
              } else if (cascader_panelvue_type_script_lang_js_isLeaf(el)) {
                el.click();
              }
            };

            /* harmony default export */ const cascader_panelvue_type_script_lang_js_ = ({
              name: 'ElCascaderPanel',

              components: {
                CascaderMenu: cascader_menu,
              },

              props: {
                value: {},
                options: Array,
                props: Object,
                border: {
                  type: Boolean,
                  default: true,
                },
                renderLabel: Function,
              },

              provide: function provide() {
                return {
                  panel: this,
                };
              },
              data: function data() {
                return {
                  checkedValue: null,
                  checkedNodePaths: [],
                  store: [],
                  menus: [],
                  activePath: [],
                  loadCount: 0,
                };
              },

              computed: {
                config: function config() {
                  return merge_default()({ ...DefaultProps }, this.props || {});
                },
                multiple: function multiple() {
                  return this.config.multiple;
                },
                checkStrictly: function checkStrictly() {
                  return this.config.checkStrictly;
                },
                leafOnly: function leafOnly() {
                  return !this.checkStrictly;
                },
                isHoverMenu: function isHoverMenu() {
                  return this.config.expandTrigger === 'hover';
                },
                renderLabelFn: function renderLabelFn() {
                  return this.renderLabel || this.$scopedSlots.default;
                },
              },

              watch: {
                options: {
                  handler: function handler() {
                    this.initStore();
                  },
                  immediate: true,
                  deep: true,
                },
                value: function value() {
                  this.syncCheckedValue();
                  this.checkStrictly && this.calculateCheckedNodePaths();
                },
                checkedValue: function checkedValue(val) {
                  if (!Object(util_.isEqual)(val, this.value)) {
                    this.checkStrictly && this.calculateCheckedNodePaths();
                    this.$emit('input', val);
                    this.$emit('change', val);
                  }
                },
              },

              mounted: function mounted() {
                if (!Object(util_.isEmpty)(this.value)) {
                  this.syncCheckedValue();
                }
              },

              methods: {
                initStore: function initStore() {
                  const { config } = this;
                  const { options } = this;

                  if (config.lazy && Object(util_.isEmpty)(options)) {
                    this.lazyLoad();
                  } else {
                    this.store = new cascader_panel_src_store(options, config);
                    this.menus = [this.store.getNodes()];
                    this.syncMenuState();
                  }
                },
                syncCheckedValue: function syncCheckedValue() {
                  const { value } = this;
                  const { checkedValue } = this;

                  if (!Object(util_.isEqual)(value, checkedValue)) {
                    this.activePath = [];
                    this.checkedValue = value;
                    this.syncMenuState();
                  }
                },
                syncMenuState: function syncMenuState() {
                  const { multiple } = this;
                  const { checkStrictly } = this;

                  this.syncActivePath();
                  multiple && this.syncMultiCheckState();
                  checkStrictly && this.calculateCheckedNodePaths();
                  this.$nextTick(this.scrollIntoView);
                },
                syncMultiCheckState: function syncMultiCheckState() {
                  const _this = this;

                  const nodes = this.getFlattedNodes(this.leafOnly);

                  nodes.forEach((node) => {
                    node.syncCheckState(_this.checkedValue);
                  });
                },
                syncActivePath: function syncActivePath() {
                  const _this2 = this;

                  const { store } = this;
                  const { multiple } = this;
                  const { activePath } = this;
                  const { checkedValue } = this;

                  if (!Object(util_.isEmpty)(activePath)) {
                    const nodes = activePath.map((node) => _this2.getNodeByValue(node.getValue()));
                    this.expandNodes(nodes);
                  } else if (!Object(util_.isEmpty)(checkedValue)) {
                    const value = multiple ? checkedValue[0] : checkedValue;
                    const checkedNode = this.getNodeByValue(value) || {};
                    const _nodes = (checkedNode.pathNodes || []).slice(0, -1);
                    this.expandNodes(_nodes);
                  } else {
                    this.activePath = [];
                    this.menus = [store.getNodes()];
                  }
                },
                expandNodes: function expandNodes(nodes) {
                  const _this3 = this;

                  nodes.forEach((node) => _this3.handleExpand(node, true /* silent */));
                },
                calculateCheckedNodePaths: function calculateCheckedNodePaths() {
                  const _this4 = this;

                  const { checkedValue } = this;
                  const { multiple } = this;

                  const checkedValues = multiple ? Object(util_.coerceTruthyValueToArray)(checkedValue) : [checkedValue];
                  this.checkedNodePaths = checkedValues.map((v) => {
                    const checkedNode = _this4.getNodeByValue(v);
                    return checkedNode ? checkedNode.pathNodes : [];
                  });
                },
                handleKeyDown: function handleKeyDown(e) {
                  const { target } = e;
                  let { keyCode } = e;

                  switch (keyCode) {
                    case cascader_panelvue_type_script_lang_js_KeyCode.up:
                      var prev = getSibling(target, -1);
                      focusNode(prev);
                      break;
                    case cascader_panelvue_type_script_lang_js_KeyCode.down:
                      var next = getSibling(target, 1);
                      focusNode(next);
                      break;
                    case cascader_panelvue_type_script_lang_js_KeyCode.left:
                      var preMenu = this.$refs.menu[getMenuIndex(target) - 1];
                      if (preMenu) {
                        const expandedNode = preMenu.$el.querySelector('.el-cascader-node[aria-expanded="true"]');
                        focusNode(expandedNode);
                      }
                      break;
                    case cascader_panelvue_type_script_lang_js_KeyCode.right:
                      var nextMenu = this.$refs.menu[getMenuIndex(target) + 1];
                      if (nextMenu) {
                        const firstNode = nextMenu.$el.querySelector('.el-cascader-node[tabindex="-1"]');
                        focusNode(firstNode);
                      }
                      break;
                    case cascader_panelvue_type_script_lang_js_KeyCode.enter:
                      checkNode(target);
                      break;
                    case cascader_panelvue_type_script_lang_js_KeyCode.esc:
                    case cascader_panelvue_type_script_lang_js_KeyCode.tab:
                      this.$emit('close');
                      break;
                    default:
                  }
                },
                handleExpand: function handleExpand(node, silent) {
                  const { activePath } = this;
                  const { level } = node;

                  const path = activePath.slice(0, level - 1);
                  const menus = this.menus.slice(0, level);

                  if (!node.isLeaf) {
                    path.push(node);
                    menus.push(node.children);
                  }

                  this.activePath = path;
                  this.menus = menus;

                  if (!silent) {
                    const pathValues = path.map((node) => node.getValue());
                    const activePathValues = activePath.map((node) => node.getValue());
                    if (!Object(util_.valueEquals)(pathValues, activePathValues)) {
                      this.$emit('active-item-change', pathValues); // Deprecated
                      this.$emit('expand-change', pathValues);
                    }
                  }
                },
                handleCheckChange: function handleCheckChange(value) {
                  this.checkedValue = value;
                },
                lazyLoad: function lazyLoad(node, onFullfiled) {
                  const _this5 = this;

                  const { config } = this;

                  if (!node) {
                    node = node || { root: true, level: 0 };
                    this.store = new cascader_panel_src_store([], config);
                    this.menus = [this.store.getNodes()];
                  }
                  node.loading = true;
                  const resolve = function resolve(dataList) {
                    const parent = node.root ? null : node;
                    dataList && dataList.length && _this5.store.appendNodes(dataList, parent);
                    node.loading = false;
                    node.loaded = true;

                    // dispose default value on lazy load mode
                    if (Array.isArray(_this5.checkedValue)) {
                      const nodeValue = _this5.checkedValue[_this5.loadCount++];
                      const valueKey = _this5.config.value;
                      const leafKey = _this5.config.leaf;

                      if (Array.isArray(dataList) && dataList.filter((item) => item[valueKey] === nodeValue).length > 0) {
                        const checkedNode = _this5.store.getNodeByValue(nodeValue);

                        if (!checkedNode.data[leafKey]) {
                          _this5.lazyLoad(checkedNode, () => {
                            _this5.handleExpand(checkedNode);
                          });
                        }

                        if (_this5.loadCount === _this5.checkedValue.length) {
                          _this5.$parent.computePresentText();
                        }
                      }
                    }

                    onFullfiled && onFullfiled(dataList);
                  };
                  config.lazyLoad(node, resolve);
                },

                /**
     * public methods
    */
                calculateMultiCheckedValue: function calculateMultiCheckedValue() {
                  this.checkedValue = this.getCheckedNodes(this.leafOnly).map((node) => node.getValueByOption());
                },
                scrollIntoView: function scrollIntoView() {
                  if (this.$isServer) return;

                  const menus = this.$refs.menu || [];
                  menus.forEach((menu) => {
                    const menuElement = menu.$el;
                    if (menuElement) {
                      const container = menuElement.querySelector('.el-scrollbar__wrap');
                      const activeNode = menuElement.querySelector('.el-cascader-node.is-active') || menuElement.querySelector('.el-cascader-node.in-active-path');
                      scroll_into_view_default()(container, activeNode);
                    }
                  });
                },
                getNodeByValue: function getNodeByValue(val) {
                  return this.store.getNodeByValue(val);
                },
                getFlattedNodes: function getFlattedNodes(leafOnly) {
                  const cached = !this.config.lazy;
                  return this.store.getFlattedNodes(leafOnly, cached);
                },
                getCheckedNodes: function getCheckedNodes(leafOnly) {
                  const { checkedValue } = this;
                  let { multiple } = this;

                  if (multiple) {
                    const nodes = this.getFlattedNodes(leafOnly);
                    return nodes.filter((node) => node.checked);
                  }
                  return Object(util_.isEmpty)(checkedValue) ? [] : [this.getNodeByValue(checkedValue)];
                },
                clearCheckedNodes: function clearCheckedNodes() {
                  const { config } = this;
                  const { leafOnly } = this;
                  const { multiple } = config;
                  const { emitPath } = config;

                  if (multiple) {
                    this.getCheckedNodes(leafOnly).filter((node) => !node.isDisabled).forEach((node) => node.doCheck(false));
                    this.calculateMultiCheckedValue();
                  } else {
                    this.checkedValue = emitPath ? [] : null;
                  }
                },
              },
            });
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-panel.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_cascader_panelvue_type_script_lang_js_ = (cascader_panelvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/cascader-panel/src/cascader-panel.vue

            /* normalize component */

            const cascader_panel_component = normalizeComponent(
              src_cascader_panelvue_type_script_lang_js_,
              cascader_panelvue_type_template_id_34932346_render,
              cascader_panelvue_type_template_id_34932346_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let cascader_panel_api; }
            cascader_panel_component.options.__file = 'packages/cascader-panel/src/cascader-panel.vue';
            /* harmony default export */ const cascader_panel = (cascader_panel_component.exports);
            // CONCATENATED MODULE: ./packages/cascader-panel/index.js

            /* istanbul ignore next */
            cascader_panel.install = function (Vue) {
              Vue.component(cascader_panel.name, cascader_panel);
            };

            /* harmony default export */ const packages_cascader_panel = (cascader_panel);
            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/avatar/src/main.vue?vue&type=script&lang=js&

            /* harmony default export */ const avatar_src_mainvue_type_script_lang_js_ = ({
              name: 'ElAvatar',

              props: {
                size: {
                  type: [Number, String],
                  validator: function validator(val) {
                    if (typeof val === 'string') {
                      return ['large', 'medium', 'small'].includes(val);
                    }
                    return typeof val === 'number';
                  },
                },
                shape: {
                  type: String,
                  default: 'circle',
                  validator: function validator(val) {
                    return ['circle', 'square'].includes(val);
                  },
                },
                icon: String,
                src: String,
                alt: String,
                srcSet: String,
                error: Function,
                fit: {
                  type: String,
                  default: 'cover',
                },
              },

              data: function data() {
                return {
                  isImageExist: true,
                };
              },

              computed: {
                avatarClass: function avatarClass() {
                  const { size } = this;
                  const { icon } = this;
                  const { shape } = this;

                  const classList = ['el-avatar'];

                  if (size && typeof size === 'string') {
                    classList.push(`el-avatar--${size}`);
                  }

                  if (icon) {
                    classList.push('el-avatar--icon');
                  }

                  if (shape) {
                    classList.push(`el-avatar--${shape}`);
                  }

                  return classList.join(' ');
                },
              },

              methods: {
                handleError: function handleError() {
                  const { error } = this;

                  const errorFlag = error ? error() : undefined;
                  if (errorFlag !== false) {
                    this.isImageExist = false;
                  }
                },
                renderAvatar: function renderAvatar() {
                  const h = this.$createElement;
                  const { icon } = this;
                  const { src } = this;
                  const { alt } = this;
                  const { isImageExist } = this;
                  const { srcSet } = this;
                  const { fit } = this;

                  if (isImageExist && src) {
                    return h('img', {
                      attrs: {
                        src,

                        alt,
                        srcSet,
                      },
                      on: {
                        error: this.handleError,
                      },
                      style: { 'object-fit': fit },
                    });
                  }

                  if (icon) {
                    return h('i', { class: icon });
                  }

                  return this.$slots.default;
                },
              },

              render: function render() {
                const h = arguments[0];
                const { avatarClass } = this;
                const { size } = this;

                const sizeStyle = typeof size === 'number' ? {
                  height: `${size}px`,
                  width: `${size}px`,
                  lineHeight: `${size}px`,
                } : {};

                return h(
                  'span',
                  { class: avatarClass, style: sizeStyle },
                  [this.renderAvatar()],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/avatar/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_avatar_src_mainvue_type_script_lang_js_ = (avatar_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/avatar/src/main.vue
            let src_main_render; let
              src_main_staticRenderFns;

            /* normalize component */

            const avatar_src_main_component = normalizeComponent(
              packages_avatar_src_mainvue_type_script_lang_js_,
              src_main_render,
              src_main_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let avatar_src_main_api; }
            avatar_src_main_component.options.__file = 'packages/avatar/src/main.vue';
            /* harmony default export */ const avatar_src_main = (avatar_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/avatar/index.js

            /* istanbul ignore next */
            avatar_src_main.install = function (Vue) {
              Vue.component(avatar_src_main.name, avatar_src_main);
            };

            /* harmony default export */ const avatar = (avatar_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/drawer/src/main.vue?vue&type=template&id=a4885264&
            const mainvue_type_template_id_a4885264_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'transition',
                {
                  attrs: { name: 'el-drawer-fade' },
                  on: { 'after-enter': _vm.afterEnter, 'after-leave': _vm.afterLeave },
                },
                [
                  _c(
                    'div',
                    {
                      directives: [
                        {
                          name: 'show',
                          rawName: 'v-show',
                          value: _vm.visible,
                          expression: 'visible',
                        },
                      ],
                      staticClass: 'el-drawer__wrapper',
                      attrs: { tabindex: '-1' },
                    },
                    [
                      _c(
                        'div',
                        {
                          staticClass: 'el-drawer__container',
                          class: _vm.visible && 'el-drawer__open',
                          attrs: { role: 'document', tabindex: '-1' },
                          on: {
                            click($event) {
                              if ($event.target !== $event.currentTarget) {
                                return null;
                              }
                              return _vm.handleWrapperClick($event);
                            },
                          },
                        },
                        [
                          _c(
                            'div',
                            {
                              ref: 'drawer',
                              staticClass: 'el-drawer',
                              class: [_vm.direction, _vm.customClass],
                              style: _vm.isHorizontal
                                ? `width: ${_vm.drawerSize}`
                                : `height: ${_vm.drawerSize}`,
                              attrs: {
                                'aria-modal': 'true',
                                'aria-labelledby': 'el-drawer__title',
                                'aria-label': _vm.title,
                                role: 'dialog',
                                tabindex: '-1',
                              },
                            },
                            [
                              _vm.withHeader
                                ? _c(
                                  'header',
                                  {
                                    staticClass: 'el-drawer__header',
                                    attrs: { id: 'el-drawer__title' },
                                  },
                                  [
                                    _vm._t('title', [
                                      _c(
                                        'span',
                                        { attrs: { role: 'heading', title: _vm.title } },
                                        [_vm._v(_vm._s(_vm.title))],
                                      ),
                                    ]),
                                    _vm.showClose
                                      ? _c(
                                        'button',
                                        {
                                          staticClass: 'el-drawer__close-btn',
                                          attrs: {
                                            'aria-label':
                                      `close ${_vm.title || 'drawer'}`,
                                            type: 'button',
                                          },
                                          on: { click: _vm.closeDrawer },
                                        },
                                        [
                                          _c('i', {
                                            staticClass:
                                      'el-dialog__close el-icon el-icon-close',
                                          }),
                                        ],
                                      )
                                      : _vm._e(),
                                  ],
                                  2,
                                )
                                : _vm._e(),
                              _vm.rendered
                                ? _c(
                                  'section',
                                  { staticClass: 'el-drawer__body' },
                                  [_vm._t('default')],
                                  2,
                                )
                                : _vm._e(),
                            ],
                          ),
                        ],
                      ),
                    ],
                  ),
                ],
              );
            };
            const mainvue_type_template_id_a4885264_staticRenderFns = [];
            mainvue_type_template_id_a4885264_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/drawer/src/main.vue?vue&type=template&id=a4885264&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/drawer/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const drawer_src_mainvue_type_script_lang_js_ = ({
              name: 'ElDrawer',
              mixins: [popup_default.a, emitter_default.a],
              props: {
                appendToBody: {
                  type: Boolean,
                  default: false,
                },
                beforeClose: {
                  type: Function,
                },
                customClass: {
                  type: String,
                  default: '',
                },
                closeOnPressEscape: {
                  type: Boolean,
                  default: true,
                },
                destroyOnClose: {
                  type: Boolean,
                  default: false,
                },
                modal: {
                  type: Boolean,
                  default: true,
                },
                direction: {
                  type: String,
                  default: 'rtl',
                  validator: function validator(val) {
                    return ['ltr', 'rtl', 'ttb', 'btt'].indexOf(val) !== -1;
                  },
                },
                modalAppendToBody: {
                  type: Boolean,
                  default: true,
                },
                showClose: {
                  type: Boolean,
                  default: true,
                },
                size: {
                  type: [Number, String],
                  default: '30%',
                },
                title: {
                  type: String,
                  default: '',
                },
                visible: {
                  type: Boolean,
                },
                wrapperClosable: {
                  type: Boolean,
                  default: true,
                },
                withHeader: {
                  type: Boolean,
                  default: true,
                },
              },
              computed: {
                isHorizontal: function isHorizontal() {
                  return this.direction === 'rtl' || this.direction === 'ltr';
                },
                drawerSize: function drawerSize() {
                  return typeof this.size === 'number' ? `${this.size}px` : this.size;
                },
              },
              data: function data() {
                return {
                  closed: false,
                  prevActiveElement: null,
                };
              },

              watch: {
                visible: function visible(val) {
                  const _this = this;

                  if (val) {
                    this.closed = false;
                    this.$emit('open');
                    if (this.appendToBody) {
                      document.body.appendChild(this.$el);
                    }
                    this.prevActiveElement = document.activeElement;
                  } else {
                    if (!this.closed) this.$emit('close');
                    this.$nextTick(() => {
                      if (_this.prevActiveElement) {
                        _this.prevActiveElement.focus();
                      }
                    });
                  }
                },
              },
              methods: {
                afterEnter: function afterEnter() {
                  this.$emit('opened');
                },
                afterLeave: function afterLeave() {
                  this.$emit('closed');
                },
                hide: function hide(cancel) {
                  if (cancel !== false) {
                    this.$emit('update:visible', false);
                    this.$emit('close');
                    if (this.destroyOnClose === true) {
                      this.rendered = false;
                    }
                    this.closed = true;
                  }
                },
                handleWrapperClick: function handleWrapperClick() {
                  if (this.wrapperClosable) {
                    this.closeDrawer();
                  }
                },
                closeDrawer: function closeDrawer() {
                  if (typeof this.beforeClose === 'function') {
                    this.beforeClose(this.hide);
                  } else {
                    this.hide();
                  }
                },
                handleClose: function handleClose() {
                  // This method here will be called by PopupManger, when the `closeOnPressEscape` was set to true
                  // pressing `ESC` will call this method, and also close the drawer.
                  // This method also calls `beforeClose` if there was one.
                  this.closeDrawer();
                },
              },
              mounted: function mounted() {
                if (this.visible) {
                  this.rendered = true;
                  this.open();
                }
              },
              destroyed: function destroyed() {
                // if appendToBody is true, remove DOM node after destroy
                if (this.appendToBody && this.$el && this.$el.parentNode) {
                  this.$el.parentNode.removeChild(this.$el);
                }
              },
            });
            // CONCATENATED MODULE: ./packages/drawer/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_drawer_src_mainvue_type_script_lang_js_ = (drawer_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/drawer/src/main.vue

            /* normalize component */

            const drawer_src_main_component = normalizeComponent(
              packages_drawer_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_a4885264_render,
              mainvue_type_template_id_a4885264_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let drawer_src_main_api; }
            drawer_src_main_component.options.__file = 'packages/drawer/src/main.vue';
            /* harmony default export */ const drawer_src_main = (drawer_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/drawer/index.js

            /* istanbul ignore next */
            drawer_src_main.install = function (Vue) {
              Vue.component(drawer_src_main.name, drawer_src_main);
            };

            /* harmony default export */ const drawer = (drawer_src_main);
            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/popconfirm/src/main.vue?vue&type=template&id=048de730&
            const mainvue_type_template_id_048de730_render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'el-popover',
                _vm._b(
                  {
                    attrs: { trigger: 'click' },
                    model: {
                      value: _vm.visible,
                      callback($$v) {
                        _vm.visible = $$v;
                      },
                      expression: 'visible',
                    },
                  },
                  'el-popover',
                  _vm.$attrs,
                  false,
                ),
                [
                  _c('div', { staticClass: 'el-popconfirm' }, [
                    _c('p', { staticClass: 'el-popconfirm__main' }, [
                      !_vm.hideIcon
                        ? _c('i', {
                          staticClass: 'el-popconfirm__icon',
                          class: _vm.icon,
                          style: { color: _vm.iconColor },
                        })
                        : _vm._e(),
                      _vm._v(`\n      ${_vm._s(_vm.title)}\n    `),
                    ]),
                    _c(
                      'div',
                      { staticClass: 'el-popconfirm__action' },
                      [
                        _c(
                          'el-button',
                          {
                            attrs: { size: 'mini', type: _vm.cancelButtonType },
                            on: { click: _vm.cancel },
                          },
                          [
                            _vm._v(
                              `\n        ${
                                _vm._s(_vm.displayCancelButtonText)
                              }\n      `,
                            ),
                          ],
                        ),
                        _c(
                          'el-button',
                          {
                            attrs: { size: 'mini', type: _vm.confirmButtonType },
                            on: { click: _vm.confirm },
                          },
                          [
                            _vm._v(
                              `\n        ${
                                _vm._s(_vm.displayConfirmButtonText)
                              }\n      `,
                            ),
                          ],
                        ),
                      ],
                      1,
                    ),
                  ]),
                  _vm._t('reference', null, { slot: 'reference' }),
                ],
                2,
              );
            };
            const mainvue_type_template_id_048de730_staticRenderFns = [];
            mainvue_type_template_id_048de730_render._withStripped = true;

            // CONCATENATED MODULE: ./packages/popconfirm/src/main.vue?vue&type=template&id=048de730&

            // EXTERNAL MODULE: external "element-ui/lib/popover"
            const popover_ = __webpack_require__(44);
            const popover_default = /* #__PURE__ */__webpack_require__.n(popover_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/popconfirm/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const popconfirm_src_mainvue_type_script_lang_js_ = ({
              name: 'ElPopconfirm',
              props: {
                title: {
                  type: String,
                },
                confirmButtonText: {
                  type: String,
                },
                cancelButtonText: {
                  type: String,
                },
                confirmButtonType: {
                  type: String,
                  default: 'primary',
                },
                cancelButtonType: {
                  type: String,
                  default: 'text',
                },
                icon: {
                  type: String,
                  default: 'el-icon-question',
                },
                iconColor: {
                  type: String,
                  default: '#f90',
                },
                hideIcon: {
                  type: Boolean,
                  default: false,
                },
              },
              components: {
                ElPopover: popover_default.a,
                ElButton: button_default.a,
              },
              data: function data() {
                return {
                  visible: false,
                };
              },

              computed: {
                displayConfirmButtonText: function displayConfirmButtonText() {
                  return this.confirmButtonText || Object(lib_locale_.t)('el.popconfirm.confirmButtonText');
                },
                displayCancelButtonText: function displayCancelButtonText() {
                  return this.cancelButtonText || Object(lib_locale_.t)('el.popconfirm.cancelButtonText');
                },
              },
              methods: {
                confirm: function confirm() {
                  this.visible = false;
                  this.$emit('confirm');
                },
                cancel: function cancel() {
                  this.visible = false;
                  this.$emit('cancel');
                },
              },
            });
            // CONCATENATED MODULE: ./packages/popconfirm/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const packages_popconfirm_src_mainvue_type_script_lang_js_ = (popconfirm_src_mainvue_type_script_lang_js_);
            // CONCATENATED MODULE: ./packages/popconfirm/src/main.vue

            /* normalize component */

            const popconfirm_src_main_component = normalizeComponent(
              packages_popconfirm_src_mainvue_type_script_lang_js_,
              mainvue_type_template_id_048de730_render,
              mainvue_type_template_id_048de730_staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let popconfirm_src_main_api; }
            popconfirm_src_main_component.options.__file = 'packages/popconfirm/src/main.vue';
            /* harmony default export */ const popconfirm_src_main = (popconfirm_src_main_component.exports);
            // CONCATENATED MODULE: ./packages/popconfirm/index.js

            /* istanbul ignore next */
            popconfirm_src_main.install = function (Vue) {
              Vue.component(popconfirm_src_main.name, popconfirm_src_main);
            };

            /* harmony default export */ const popconfirm = (popconfirm_src_main);
            // CONCATENATED MODULE: ./src/index.js
            /* Automatically generated by './build/bin/build-entry.js' */

            const components = [packages_pagination, dialog, packages_autocomplete, packages_dropdown, packages_dropdown_menu, packages_dropdown_item, packages_menu, packages_submenu, packages_menu_item, packages_menu_item_group, packages_input, packages_input_number, packages_radio, packages_radio_group, packages_radio_button, packages_checkbox, packages_checkbox_button, packages_checkbox_group, packages_switch, packages_select, packages_option, packages_option_group, packages_button, packages_button_group, packages_table, packages_table_column, packages_date_picker, packages_time_select, packages_time_picker, popover, packages_tooltip, packages_breadcrumb, packages_breadcrumb_item, packages_form, packages_form_item, packages_tabs, packages_tab_pane, packages_tag, packages_tree, packages_alert, slider, packages_icon, packages_row, packages_col, packages_upload, packages_progress, packages_spinner, badge, card, rate, packages_steps, packages_step, carousel, scrollbar, carousel_item, packages_collapse, packages_collapse_item, packages_cascader, color_picker, transfer, packages_container, header, aside, packages_main, footer, timeline, timeline_item, packages_link, divider, packages_image, calendar, backtop, page_header, packages_cascader_panel, avatar, drawer, popconfirm, collapse_transition_default.a];

            const src_install = function install(Vue) {
              const opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

              lib_locale_default.a.use(opts.locale);
              lib_locale_default.a.i18n(opts.i18n);

              components.forEach((component) => {
                Vue.component(component.name, component);
              });

              Vue.use(infinite_scroll);
              Vue.use(packages_loading.directive);

              Vue.prototype.$ELEMENT = {
                size: opts.size || '',
                zIndex: opts.zIndex || 2000,
              };

              Vue.prototype.$loading = packages_loading.service;
              Vue.prototype.$msgbox = message_box;
              Vue.prototype.$alert = message_box.alert;
              Vue.prototype.$confirm = message_box.confirm;
              Vue.prototype.$prompt = message_box.prompt;
              Vue.prototype.$notify = notification;
              Vue.prototype.$message = packages_message;
            };

            /* istanbul ignore if */
            if (typeof window !== 'undefined' && window.Vue) {
              src_install(window.Vue);
            }

            /* harmony default export */ const src_0 = __webpack_exports__.default = ({
              version: '2.15.1',
              locale: lib_locale_default.a.use,
              i18n: lib_locale_default.a.i18n,
              install: src_install,
              CollapseTransition: collapse_transition_default.a,
              Loading: packages_loading,
              Pagination: packages_pagination,
              Dialog: dialog,
              Autocomplete: packages_autocomplete,
              Dropdown: packages_dropdown,
              DropdownMenu: packages_dropdown_menu,
              DropdownItem: packages_dropdown_item,
              Menu: packages_menu,
              Submenu: packages_submenu,
              MenuItem: packages_menu_item,
              MenuItemGroup: packages_menu_item_group,
              Input: packages_input,
              InputNumber: packages_input_number,
              Radio: packages_radio,
              RadioGroup: packages_radio_group,
              RadioButton: packages_radio_button,
              Checkbox: packages_checkbox,
              CheckboxButton: packages_checkbox_button,
              CheckboxGroup: packages_checkbox_group,
              Switch: packages_switch,
              Select: packages_select,
              Option: packages_option,
              OptionGroup: packages_option_group,
              Button: packages_button,
              ButtonGroup: packages_button_group,
              Table: packages_table,
              TableColumn: packages_table_column,
              DatePicker: packages_date_picker,
              TimeSelect: packages_time_select,
              TimePicker: packages_time_picker,
              Popover: popover,
              Tooltip: packages_tooltip,
              MessageBox: message_box,
              Breadcrumb: packages_breadcrumb,
              BreadcrumbItem: packages_breadcrumb_item,
              Form: packages_form,
              FormItem: packages_form_item,
              Tabs: packages_tabs,
              TabPane: packages_tab_pane,
              Tag: packages_tag,
              Tree: packages_tree,
              Alert: packages_alert,
              Notification: notification,
              Slider: slider,
              Icon: packages_icon,
              Row: packages_row,
              Col: packages_col,
              Upload: packages_upload,
              Progress: packages_progress,
              Spinner: packages_spinner,
              Message: packages_message,
              Badge: badge,
              Card: card,
              Rate: rate,
              Steps: packages_steps,
              Step: packages_step,
              Carousel: carousel,
              Scrollbar: scrollbar,
              CarouselItem: carousel_item,
              Collapse: packages_collapse,
              CollapseItem: packages_collapse_item,
              Cascader: packages_cascader,
              ColorPicker: color_picker,
              Transfer: transfer,
              Container: packages_container,
              Header: header,
              Aside: aside,
              Main: packages_main,
              Footer: footer,
              Timeline: timeline,
              TimelineItem: timeline_item,
              Link: packages_link,
              Divider: divider,
              Image: packages_image,
              Calendar: calendar,
              Backtop: backtop,
              InfiniteScroll: infinite_scroll,
              PageHeader: page_header,
              CascaderPanel: packages_cascader_panel,
              Avatar: avatar,
              Drawer: drawer,
              Popconfirm: popconfirm,
            });
            /***/ }),
          /** *** */ ])).default;
      /***/ }),

    /***/ 6167:
    /***/ (function (module, exports, __webpack_require__) {
      let __WEBPACK_AMD_DEFINE_FACTORY__; let
        __WEBPACK_AMD_DEFINE_RESULT__;

      const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

      /**
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version {{version}}
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

      //
      // Cross module loader
      // Supported: Node, AMD, Browser globals
      //
      (function (root, factory) {
        if (true) {
        // AMD. Register as an anonymous module.
          !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
          __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
            ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module))
            : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {}
      }(undefined, () => {
        const root = window;

        // default options
        const DEFAULTS = {
        // placement of the popper
          placement: 'bottom',

          gpuAcceleration: true,

          // shift popper from its origin by the given amount of pixels (can be negative)
          offset: 0,

          // the element which will act as boundary of the popper
          boundariesElement: 'viewport',

          // amount of pixel used to define a minimum distance between the boundaries and the popper
          boundariesPadding: 5,

          // popper will try to prevent overflow following this order,
          // by default, then, it could overflow on the left and on top of the boundariesElement
          preventOverflowOrder: ['left', 'right', 'top', 'bottom'],

          // the behavior used by flip to change the placement of the popper
          flipBehavior: 'flip',

          arrowElement: '[x-arrow]',

          arrowOffset: 0,

          // list of functions used to modify the offsets before they are applied to the popper
          modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],

          modifiersIgnored: [],

          forceAbsolute: false,
        };

        /**
     * Create a new Popper.js instance
     * @constructor Popper
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement|Object} popper
     *      The HTML element used as popper, or a configuration used to generate the popper.
     * @param {String} [popper.tagName='div'] The tag name of the generated popper.
     * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.
     * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.
     * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.
     * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.
     * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.
     * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.
     * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.
     * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.
     * @param {Object} options
     * @param {String} [options.placement=bottom]
     *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),
     *      left(-start, -end)`
     *
     * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']
     *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of
     *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its
     *      reference element.
     *      By default, it will look for a child node of the popper with the `x-arrow` attribute.
     *
     * @param {Boolean} [options.gpuAcceleration=true]
     *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the
     *      browser to use the GPU to accelerate the rendering.
     *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.
     *
     * @param {Number} [options.offset=0]
     *      Amount of pixels the popper will be shifted (can be negative).
     *
     * @param {String|Element} [options.boundariesElement='viewport']
     *      The element which will define the boundaries of the popper position, the popper will never be placed outside
     *      of the defined boundaries (except if `keepTogether` is enabled)
     *
     * @param {Number} [options.boundariesPadding=5]
     *      Additional padding for the boundaries
     *
     * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]
     *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,
     *      this means that the last ones will never overflow
     *
     * @param {String|Array} [options.flipBehavior='flip']
     *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to
     *      overlap its reference element. Defining `flip` as value, the placement will be flipped on
     *      its axis (`right - left`, `top - bottom`).
     *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify
     *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,
     *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)
     *
     * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]
     *      List of functions used to modify the data before they are applied to the popper, add your custom functions
     *      to this array to edit the offsets and placement.
     *      The function should reflect the @params and @returns of preventOverflow
     *
     * @param {Array} [options.modifiersIgnored=[]]
     *      Put here any built-in modifier name you want to exclude from the modifiers list
     *      The function should reflect the @params and @returns of preventOverflow
     *
     * @param {Boolean} [options.removeOnDestroy=false]
     *      Set to true if you want to automatically remove the popper when you call the `destroy` method.
     */
        function Popper(reference, popper, options) {
          this._reference = reference.jquery ? reference[0] : reference;
          this.state = {};

          // if the popper variable is a configuration object, parse it to generate an HTMLElement
          // generate a default popper if is not defined
          const isNotDefined = typeof popper === 'undefined' || popper === null;
          const isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';
          if (isNotDefined || isConfig) {
            this._popper = this.parse(isConfig ? popper : {});
          }
          // otherwise, use the given HTMLElement as popper
          else {
            this._popper = popper.jquery ? popper[0] : popper;
          }

          // with {} we create a new object with the options inside it
          this._options = { ...DEFAULTS, ...options };

          // refactoring modifiers' list
          this._options.modifiers = this._options.modifiers.map((modifier) => {
            // remove ignored modifiers
            if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return;

            // set the x-placement attribute before everything else because it could be used to add margins to the popper
            // margins needs to be calculated to get the correct popper offsets
            if (modifier === 'applyStyle') {
              this._popper.setAttribute('x-placement', this._options.placement);
            }

            // return predefined modifier identified by string or keep the custom one
            return this.modifiers[modifier] || modifier;
          });

          // make sure to apply the popper position before any computation
          this.state.position = this._getPosition(this._popper, this._reference);
          setStyle(this._popper, { position: this.state.position, top: 0 });

          // fire the first update to position the popper in the right place
          this.update();

          // setup event listeners, they will take care of update the position in specific situations
          this._setupEventListeners();
          return this;
        }

        //
        // Methods
        //
        /**
     * Destroy the popper
     * @method
     * @memberof Popper
     */
        Popper.prototype.destroy = function () {
          this._popper.removeAttribute('x-placement');
          this._popper.style.left = '';
          this._popper.style.position = '';
          this._popper.style.top = '';
          this._popper.style[getSupportedPropertyName('transform')] = '';
          this._removeEventListeners();

          // remove the popper if user explicity asked for the deletion on destroy
          if (this._options.removeOnDestroy) {
            this._popper.remove();
          }
          return this;
        };

        /**
     * Updates the position of the popper, computing the new offsets and applying the new style
     * @method
     * @memberof Popper
     */
        Popper.prototype.update = function () {
          let data = { instance: this, styles: {} };

          // store placement inside the data object, modifiers will be able to edit `placement` if needed
          // and refer to _originalPlacement to know the original value
          data.placement = this._options.placement;
          data._originalPlacement = this._options.placement;

          // compute the popper and reference offsets and put them inside data.offsets
          data.offsets = this._getOffsets(this._popper, this._reference, data.placement);

          // get boundaries
          data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);

          data = this.runModifiers(data, this._options.modifiers);

          if (typeof this.state.updateCallback === 'function') {
            this.state.updateCallback(data);
          }
        };

        /**
     * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.
     * @method
     * @memberof Popper
     * @param {Function} callback
     */
        Popper.prototype.onCreate = function (callback) {
        // the createCallbacks return as first argument the popper instance
          callback(this);
          return this;
        };

        /**
     * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations
     * used to style popper and its arrow.
     * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!
     * @method
     * @memberof Popper
     * @param {Function} callback
     */
        Popper.prototype.onUpdate = function (callback) {
          this.state.updateCallback = callback;
          return this;
        };

        /**
     * Helper used to generate poppers from a configuration file
     * @method
     * @memberof Popper
     * @param config {Object} configuration
     * @returns {HTMLElement} popper
     */
        Popper.prototype.parse = function (config) {
          const defaultConfig = {
            tagName: 'div',
            classNames: ['popper'],
            attributes: [],
            parent: root.document.body,
            content: '',
            contentType: 'text',
            arrowTagName: 'div',
            arrowClassNames: ['popper__arrow'],
            arrowAttributes: ['x-arrow'],
          };
          config = { ...defaultConfig, ...config };

          const d = root.document;

          const popper = d.createElement(config.tagName);
          addClassNames(popper, config.classNames);
          addAttributes(popper, config.attributes);
          if (config.contentType === 'node') {
            popper.appendChild(config.content.jquery ? config.content[0] : config.content);
          } else if (config.contentType === 'html') {
            popper.innerHTML = config.content;
          } else {
            popper.textContent = config.content;
          }

          if (config.arrowTagName) {
            const arrow = d.createElement(config.arrowTagName);
            addClassNames(arrow, config.arrowClassNames);
            addAttributes(arrow, config.arrowAttributes);
            popper.appendChild(arrow);
          }

          let parent = config.parent.jquery ? config.parent[0] : config.parent;

          // if the given parent is a string, use it to match an element
          // if more than one element is matched, the first one will be used as parent
          // if no elements are matched, the script will throw an error
          if (typeof parent === 'string') {
            parent = d.querySelectorAll(config.parent);
            if (parent.length > 1) {
              console.warn(`WARNING: the given \`parent\` query(${config.parent}) matched more than one element, the first one will be used`);
            }
            if (parent.length === 0) {
              throw 'ERROR: the given `parent` doesn\'t exists!';
            }
            parent = parent[0];
          }
          // if the given parent is a DOM nodes list or an array of nodes with more than one element,
          // the first one will be used as parent
          if (parent.length > 1 && parent instanceof Element === false) {
            console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');
            parent = parent[0];
          }

          // append the generated popper to its parent
          parent.appendChild(popper);

          return popper;

          /**
         * Adds class names to the given element
         * @function
         * @ignore
         * @param {HTMLElement} target
         * @param {Array} classes
         */
          function addClassNames(element, classNames) {
            classNames.forEach((className) => {
              element.classList.add(className);
            });
          }

          /**
         * Adds attributes to the given element
         * @function
         * @ignore
         * @param {HTMLElement} target
         * @param {Array} attributes
         * @example
         * addAttributes(element, [ 'data-info:foobar' ]);
         */
          function addAttributes(element, attributes) {
            attributes.forEach((attribute) => {
              element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
            });
          }
        };

        /**
     * Helper used to get the position which will be applied to the popper
     * @method
     * @memberof Popper
     * @param config {HTMLElement} popper element
     * @param reference {HTMLElement} reference element
     * @returns {String} position
     */
        Popper.prototype._getPosition = function (popper, reference) {
          const container = getOffsetParent(reference);

          if (this._options.forceAbsolute) {
            return 'absolute';
          }

          // Decide if the popper will be fixed
          // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together
          const isParentFixed = isFixed(reference, container);
          return isParentFixed ? 'fixed' : 'absolute';
        };

        /**
     * Get offsets to the popper
     * @method
     * @memberof Popper
     * @access private
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
        Popper.prototype._getOffsets = function (popper, reference, placement) {
          placement = placement.split('-')[0];
          const popperOffsets = {};

          popperOffsets.position = this.state.position;
          const isParentFixed = popperOffsets.position === 'fixed';

          //
          // Get reference element position
          //
          const referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);

          //
          // Get popper sizes
          //
          const popperRect = getOuterSizes(popper);

          //
          // Compute offsets of popper
          //

          // depending by the popper placement we have to compute its offsets slightly differently
          if (['right', 'left'].indexOf(placement) !== -1) {
            popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;
            if (placement === 'left') {
              popperOffsets.left = referenceOffsets.left - popperRect.width;
            } else {
              popperOffsets.left = referenceOffsets.right;
            }
          } else {
            popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;
            if (placement === 'top') {
              popperOffsets.top = referenceOffsets.top - popperRect.height;
            } else {
              popperOffsets.top = referenceOffsets.bottom;
            }
          }

          // Add width and height to our offsets object
          popperOffsets.width = popperRect.width;
          popperOffsets.height = popperRect.height;

          return {
            popper: popperOffsets,
            reference: referenceOffsets,
          };
        };

        /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper
     * @access private
     */
        Popper.prototype._setupEventListeners = function () {
        // NOTE: 1 DOM access here
          this.state.updateBound = this.update.bind(this);
          root.addEventListener('resize', this.state.updateBound);
          // if the boundariesElement is window we don't need to listen for the scroll event
          if (this._options.boundariesElement !== 'window') {
            let target = getScrollParent(this._reference);
            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both
            if (target === root.document.body || target === root.document.documentElement) {
              target = root;
            }
            target.addEventListener('scroll', this.state.updateBound);
            this.state.scrollTarget = target;
          }
        };

        /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper
     * @access private
     */
        Popper.prototype._removeEventListeners = function () {
        // NOTE: 1 DOM access here
          root.removeEventListener('resize', this.state.updateBound);
          if (this._options.boundariesElement !== 'window' && this.state.scrollTarget) {
            this.state.scrollTarget.removeEventListener('scroll', this.state.updateBound);
            this.state.scrollTarget = null;
          }
          this.state.updateBound = null;
        };

        /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper
     * @access private
     * @param {Object} data - Object containing the property "offsets" generated by `_getOffsets`
     * @param {Number} padding - Boundaries padding
     * @param {Element} boundariesElement - Element used to define the boundaries
     * @returns {Object} Coordinates of the boundaries
     */
        Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {
        // NOTE: 1 DOM access here
          let boundaries = {};
          let width; let
            height;
          if (boundariesElement === 'window') {
            const { body } = root.document;
            const html = root.document.documentElement;

            height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
            width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);

            boundaries = {
              top: 0,
              right: width,
              bottom: height,
              left: 0,
            };
          } else if (boundariesElement === 'viewport') {
            const offsetParent = getOffsetParent(this._popper);
            const scrollParent = getScrollParent(this._popper);
            const offsetParentRect = getOffsetRect(offsetParent);

            // Thanks the fucking native API, `document.body.scrollTop` & `document.documentElement.scrollTop`
            const getScrollTopValue = function getScrollTopValue(element) {
              return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
            };
            const getScrollLeftValue = function getScrollLeftValue(element) {
              return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
            };

            // if the popper is fixed we don't have to substract scrolling from the boundaries
            const scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
            const scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);

            boundaries = {
              top: 0 - (offsetParentRect.top - scrollTop),
              right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
              bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
              left: 0 - (offsetParentRect.left - scrollLeft),
            };
          } else if (getOffsetParent(this._popper) === boundariesElement) {
            boundaries = {
              top: 0,
              left: 0,
              right: boundariesElement.clientWidth,
              bottom: boundariesElement.clientHeight,
            };
          } else {
            boundaries = getOffsetRect(boundariesElement);
          }
          boundaries.left += padding;
          boundaries.right -= padding;
          boundaries.top += padding;
          boundaries.bottom -= padding;
          return boundaries;
        };

        /**
     * Loop trough the list of modifiers and run them in order, each of them will then edit the data object
     * @method
     * @memberof Popper
     * @access public
     * @param {Object} data
     * @param {Array} modifiers
     * @param {Function} ends
     */
        Popper.prototype.runModifiers = function (data, modifiers, ends) {
          let modifiersToRun = modifiers.slice();
          if (ends !== undefined) {
            modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
          }

          modifiersToRun.forEach((modifier) => {
            if (isFunction(modifier)) {
              data = modifier.call(this, data);
            }
          });

          return data;
        };

        /**
     * Helper used to know if the given modifier depends from another one.
     * @method
     * @memberof Popper
     * @param {String} requesting - name of requesting modifier
     * @param {String} requested - name of requested modifier
     * @returns {Boolean}
     */
        Popper.prototype.isModifierRequired = function (requesting, requested) {
          const index = getArrayKeyIndex(this._options.modifiers, requesting);
          return !!this._options.modifiers.slice(0, index).filter((modifier) => modifier === requested).length;
        };

        //
        // Modifiers
        //

        /**
     * Modifiers list
     * @namespace Popper.modifiers
     * @memberof Popper
     * @type {Object}
     */
        Popper.prototype.modifiers = {};

        /**
     * Apply the computed styles to the popper element
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The same data object
     */
        Popper.prototype.modifiers.applyStyle = function (data) {
        // apply the final offsets to the popper
        // NOTE: 1 DOM access here
          const styles = {
            position: data.offsets.popper.position,
          };

          // round top and left to avoid blurry text
          const left = Math.round(data.offsets.popper.left);
          const top = Math.round(data.offsets.popper.top);

          // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper
          // we automatically use the supported prefixed version if needed
          let prefixedProperty;
          if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {
            styles[prefixedProperty] = `translate3d(${left}px, ${top}px, 0)`;
            styles.top = 0;
            styles.left = 0;
          }
          // othwerise, we use the standard `left` and `top` properties
          else {
            styles.left = left;
            styles.top = top;
          }

          // any property present in `data.styles` will be applied to the popper,
          // in this way we can make the 3rd party modifiers add custom styles to it
          // Be aware, modifiers could override the properties defined in the previous
          // lines of this modifier!
          Object.assign(styles, data.styles);

          setStyle(this._popper, styles);

          // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)
          // NOTE: 1 DOM access here
          this._popper.setAttribute('x-placement', data.placement);

          // if the arrow modifier is required and the arrow style has been computed, apply the arrow style
          if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
            setStyle(data.arrowElement, data.offsets.arrow);
          }

          return data;
        };

        /**
     * Modifier used to shift the popper on the start or end of its reference element side
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The data object, properly modified
     */
        Popper.prototype.modifiers.shift = function (data) {
          const { placement } = data;
          const basePlacement = placement.split('-')[0];
          const shiftVariation = placement.split('-')[1];

          // if shift shiftVariation is specified, run the modifier
          if (shiftVariation) {
            const { reference } = data.offsets;
            const popper = getPopperClientRect(data.offsets.popper);

            const shiftOffsets = {
              y: {
                start: { top: reference.top },
                end: { top: reference.top + reference.height - popper.height },
              },
              x: {
                start: { left: reference.left },
                end: { left: reference.left + reference.width - popper.width },
              },
            };

            const axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';

            data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);
          }

          return data;
        };

        /**
     * Modifier used to make sure the popper does not overflows from it's boundaries
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The data object, properly modified
     */
        Popper.prototype.modifiers.preventOverflow = function (data) {
          const order = this._options.preventOverflowOrder;
          const popper = getPopperClientRect(data.offsets.popper);

          const check = {
            left: function left() {
              let { left } = popper;
              if (popper.left < data.boundaries.left) {
                left = Math.max(popper.left, data.boundaries.left);
              }
              return { left };
            },
            right: function right() {
              let { left } = popper;
              if (popper.right > data.boundaries.right) {
                left = Math.min(popper.left, data.boundaries.right - popper.width);
              }
              return { left };
            },
            top: function top() {
              let { top } = popper;
              if (popper.top < data.boundaries.top) {
                top = Math.max(popper.top, data.boundaries.top);
              }
              return { top };
            },
            bottom: function bottom() {
              let { top } = popper;
              if (popper.bottom > data.boundaries.bottom) {
                top = Math.min(popper.top, data.boundaries.bottom - popper.height);
              }
              return { top };
            },
          };

          order.forEach((direction) => {
            data.offsets.popper = Object.assign(popper, check[direction]());
          });

          return data;
        };

        /**
     * Modifier used to make sure the popper is always near its reference
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
        Popper.prototype.modifiers.keepTogether = function (data) {
          const popper = getPopperClientRect(data.offsets.popper);
          const { reference } = data.offsets;
          const f = Math.floor;

          if (popper.right < f(reference.left)) {
            data.offsets.popper.left = f(reference.left) - popper.width;
          }
          if (popper.left > f(reference.right)) {
            data.offsets.popper.left = f(reference.right);
          }
          if (popper.bottom < f(reference.top)) {
            data.offsets.popper.top = f(reference.top) - popper.height;
          }
          if (popper.top > f(reference.bottom)) {
            data.offsets.popper.top = f(reference.bottom);
          }

          return data;
        };

        /**
     * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
     * Requires the `preventOverflow` modifier before it in order to work.
     * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
        Popper.prototype.modifiers.flip = function (data) {
        // check if preventOverflow is in the list of modifiers before the flip modifier.
        // otherwise flip would not work as expected.
          if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
            console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');
            return data;
          }

          if (data.flipped && data.placement === data._originalPlacement) {
            // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
            return data;
          }

          let placement = data.placement.split('-')[0];
          let placementOpposite = getOppositePlacement(placement);
          const variation = data.placement.split('-')[1] || '';

          let flipOrder = [];
          if (this._options.flipBehavior === 'flip') {
            flipOrder = [placement, placementOpposite];
          } else {
            flipOrder = this._options.flipBehavior;
          }

          flipOrder.forEach((step, index) => {
            if (placement !== step || flipOrder.length === index + 1) {
              return;
            }

            placement = data.placement.split('-')[0];
            placementOpposite = getOppositePlacement(placement);

            const popperOffsets = getPopperClientRect(data.offsets.popper);

            // this boolean is used to distinguish right and bottom from top and left
            // they need different computations to get flipped
            const a = ['right', 'bottom'].indexOf(placement) !== -1;

            // using Math.floor because the reference offsets may contain decimals we are not going to consider here
            if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {
              // we'll use this boolean to detect any flip loop
              data.flipped = true;
              data.placement = flipOrder[index + 1];
              if (variation) {
                data.placement += `-${variation}`;
              }
              data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;

              data = this.runModifiers(data, this._options.modifiers, this._flip);
            }
          });
          return data;
        };

        /**
     * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.
     * The offsets will shift the popper on the side of its reference element.
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
        Popper.prototype.modifiers.offset = function (data) {
          const { offset } = this._options;
          const { popper } = data.offsets;

          if (data.placement.indexOf('left') !== -1) {
            popper.top -= offset;
          } else if (data.placement.indexOf('right') !== -1) {
            popper.top += offset;
          } else if (data.placement.indexOf('top') !== -1) {
            popper.left -= offset;
          } else if (data.placement.indexOf('bottom') !== -1) {
            popper.left += offset;
          }
          return data;
        };

        /**
     * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element
     * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
        Popper.prototype.modifiers.arrow = function (data) {
          let arrow = this._options.arrowElement;
          const { arrowOffset } = this._options;

          // if the arrowElement is a string, suppose it's a CSS selector
          if (typeof arrow === 'string') {
            arrow = this._popper.querySelector(arrow);
          }

          // if arrow element is not found, don't run the modifier
          if (!arrow) {
            return data;
          }

          // the arrow element must be child of its popper
          if (!this._popper.contains(arrow)) {
            console.warn('WARNING: `arrowElement` must be child of its popper element!');
            return data;
          }

          // arrow depends on keepTogether in order to work
          if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
            console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
            return data;
          }

          const arrowStyle = {};
          const placement = data.placement.split('-')[0];
          const popper = getPopperClientRect(data.offsets.popper);
          const { reference } = data.offsets;
          const isVertical = ['left', 'right'].indexOf(placement) !== -1;

          const len = isVertical ? 'height' : 'width';
          const side = isVertical ? 'top' : 'left';
          const translate = isVertical ? 'translateY' : 'translateX';
          const altSide = isVertical ? 'left' : 'top';
          const opSide = isVertical ? 'bottom' : 'right';
          const arrowSize = getOuterSizes(arrow)[len];

          //
          // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
          //

          // top/left side
          if (reference[opSide] - arrowSize < popper[side]) {
            data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
          }
          // bottom/right side
          if (reference[side] + arrowSize > popper[opSide]) {
            data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];
          }

          // compute center of the popper
          const center = reference[side] + (arrowOffset || reference[len] / 2 - arrowSize / 2);

          let sideValue = center - popper[side];

          // prevent arrow from being placed not contiguously to its popper
          sideValue = Math.max(Math.min(popper[len] - arrowSize - 8, sideValue), 8);
          arrowStyle[side] = sideValue;
          arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow

          data.offsets.arrow = arrowStyle;
          data.arrowElement = arrow;

          return data;
        };

        //
        // Helpers
        //

        /**
     * Get the outer sizes of the given element (offset size + margins)
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
        function getOuterSizes(element) {
        // NOTE: 1 DOM access here
          const _display = element.style.display;
          const _visibility = element.style.visibility;
          element.style.display = 'block'; element.style.visibility = 'hidden';
          const calcWidthToForceRepaint = element.offsetWidth;

          // original method
          const styles = root.getComputedStyle(element);
          const x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
          const y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
          const result = { width: element.offsetWidth + y, height: element.offsetHeight + x };

          // reset element styles
          element.style.display = _display; element.style.visibility = _visibility;
          return result;
        }

        /**
     * Get the opposite placement of the given one/
     * @function
     * @ignore
     * @argument {String} placement
     * @returns {String} flipped placement
     */
        function getOppositePlacement(placement) {
          const hash = {
            left: 'right', right: 'left', bottom: 'top', top: 'bottom',
          };
          return placement.replace(/left|right|bottom|top/g, (matched) => hash[matched]);
        }

        /**
     * Given the popper offsets, generate an output similar to getBoundingClientRect
     * @function
     * @ignore
     * @argument {Object} popperOffsets
     * @returns {Object} ClientRect like output
     */
        function getPopperClientRect(popperOffsets) {
          const offsets = { ...popperOffsets };
          offsets.right = offsets.left + offsets.width;
          offsets.bottom = offsets.top + offsets.height;
          return offsets;
        }

        /**
     * Given an array and the key to find, returns its index
     * @function
     * @ignore
     * @argument {Array} arr
     * @argument keyToFind
     * @returns index or null
     */
        function getArrayKeyIndex(arr, keyToFind) {
          let i = 0;
          let key;
          for (key in arr) {
            if (arr[key] === keyToFind) {
              return i;
            }
            i++;
          }
          return null;
        }

        /**
     * Get CSS computed property of the given element
     * @function
     * @ignore
     * @argument {Eement} element
     * @argument {String} property
     */
        function getStyleComputedProperty(element, property) {
        // NOTE: 1 DOM access here
          const css = root.getComputedStyle(element, null);
          return css[property];
        }

        /**
     * Returns the offset parent of the given element
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Element} offset parent
     */
        function getOffsetParent(element) {
        // NOTE: 1 DOM access here
          const { offsetParent } = element;
          return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;
        }

        /**
     * Returns the scrolling parent of the given element
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Element} offset parent
     */
        function getScrollParent(element) {
          const parent = element.parentNode;

          if (!parent) {
            return element;
          }

          if (parent === root.document) {
            // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is
            // greater than 0 and return the proper element
            if (root.document.body.scrollTop || root.document.body.scrollLeft) {
              return root.document.body;
            }
            return root.document.documentElement;
          }

          // Firefox want us to check `-x` and `-y` variations as well
          if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {
            // If the detected scrollParent is body, we perform an additional check on its parentNode
            // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise
            // fixes issue #65
            return parent;
          }
          return getScrollParent(element.parentNode);
        }

        /**
     * Check if the given element is fixed or is inside a fixed parent
     * @function
     * @ignore
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
        function isFixed(element) {
          if (element === root.document.body) {
            return false;
          }
          if (getStyleComputedProperty(element, 'position') === 'fixed') {
            return true;
          }
          return element.parentNode ? isFixed(element.parentNode) : element;
        }

        /**
     * Set the style to the given popper
     * @function
     * @ignore
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles - Object with a list of properties and values which will be applied to the element
     */
        function setStyle(element, styles) {
          function is_numeric(n) {
            return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
          }
          Object.keys(styles).forEach((prop) => {
            let unit = '';
            // add unit if the value is numeric and is one of the following
            if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
              unit = 'px';
            }
            element.style[prop] = styles[prop] + unit;
          });
        }

        /**
     * Check if the given variable is a function
     * @function
     * @ignore
     * @argument {*} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
        function isFunction(functionToCheck) {
          const getType = {};
          return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
        }

        /**
     * Get the position of the given element, relative to its offset parent
     * @function
     * @ignore
     * @param {Element} element
     * @return {Object} position - Coordinates of the element and its `scrollTop`
     */
        function getOffsetRect(element) {
          const elementRect = {
            width: element.offsetWidth,
            height: element.offsetHeight,
            left: element.offsetLeft,
            top: element.offsetTop,
          };

          elementRect.right = elementRect.left + elementRect.width;
          elementRect.bottom = elementRect.top + elementRect.height;

          // position
          return elementRect;
        }

        /**
     * Get bounding client rect of given element
     * @function
     * @ignore
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
        function getBoundingClientRect(element) {
          const rect = element.getBoundingClientRect();

          // whether the IE version is lower than 11
          const isIE = navigator.userAgent.indexOf('MSIE') != -1;

          // fix ie document bounding top always 0 bug
          const rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;

          return {
            left: rect.left,
            top: rectTop,
            right: rect.right,
            bottom: rect.bottom,
            width: rect.right - rect.left,
            height: rect.bottom - rectTop,
          };
        }

        /**
     * Given an element and one of its parents, return the offset
     * @function
     * @ignore
     * @param {HTMLElement} element
     * @param {HTMLElement} parent
     * @return {Object} rect
     */
        function getOffsetRectRelativeToCustomParent(element, parent, fixed) {
          const elementRect = getBoundingClientRect(element);
          const parentRect = getBoundingClientRect(parent);

          if (fixed) {
            const scrollParent = getScrollParent(parent);
            parentRect.top += scrollParent.scrollTop;
            parentRect.bottom += scrollParent.scrollTop;
            parentRect.left += scrollParent.scrollLeft;
            parentRect.right += scrollParent.scrollLeft;
          }

          const rect = {
            top: elementRect.top - parentRect.top,
            left: elementRect.left - parentRect.left,
            bottom: elementRect.top - parentRect.top + elementRect.height,
            right: elementRect.left - parentRect.left + elementRect.width,
            width: elementRect.width,
            height: elementRect.height,
          };
          return rect;
        }

        /**
     * Get the prefixed supported property name
     * @function
     * @ignore
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase)
     */
        function getSupportedPropertyName(property) {
          const prefixes = ['', 'ms', 'webkit', 'moz', 'o'];

          for (let i = 0; i < prefixes.length; i++) {
            const toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;
            if (typeof root.document.body.style[toCheck] !== 'undefined') {
              return toCheck;
            }
          }
          return null;
        }

        /**
     * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source
     * objects to a target object. It will return the target object.
     * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway
     * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
     * @function
     * @ignore
     */
        if (!Object.assign) {
          Object.defineProperty(Object, 'assign', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: function value(target) {
              if (target === undefined || target === null) {
                throw new TypeError('Cannot convert first argument to object');
              }

              const to = Object(target);
              for (let i = 1; i < arguments.length; i++) {
                let nextSource = arguments[i];
                if (nextSource === undefined || nextSource === null) {
                  continue;
                }
                nextSource = Object(nextSource);

                const keysArray = Object.keys(nextSource);
                for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
                  const nextKey = keysArray[nextIndex];
                  const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                  if (desc !== undefined && desc.enumerable) {
                    to[nextKey] = nextSource[nextKey];
                  }
                }
              }
              return to;
            },
          });
        }

        return Popper;
      }));
      /***/ }),

    /***/ 6438:
    /***/ (function (module, exports, __webpack_require__) {
      // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
      const $keys = __webpack_require__('03d6');
      const hiddenKeys = __webpack_require__('9742').concat('length', 'prototype');

      exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return $keys(O, hiddenKeys);
      };
      /***/ }),

    /***/ '658f':
    /***/ (function (module, exports, __webpack_require__) {
      __webpack_require__('6858');
      const global = __webpack_require__('ef08');
      const hide = __webpack_require__('051b');
      const Iterators = __webpack_require__('8a0d');
      const TO_STRING_TAG = __webpack_require__('cc15')('toStringTag');

      const DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,'
  + 'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,'
  + 'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,'
  + 'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,'
  + 'TextTrackList,TouchList').split(',');

      for (let i = 0; i < DOMIterables.length; i++) {
        const NAME = DOMIterables[i];
        const Collection = global[NAME];
        const proto = Collection && Collection.prototype;
        if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
        Iterators[NAME] = Iterators.Array;
      }
      /***/ }),

    /***/ 6858:
    /***/ (function (module, exports, __webpack_require__) {
      const addToUnscopables = __webpack_require__('2f9a');
      const step = __webpack_require__('ea34');
      const Iterators = __webpack_require__('8a0d');
      const toIObject = __webpack_require__('6ca1');

      // 22.1.3.4 Array.prototype.entries()
      // 22.1.3.13 Array.prototype.keys()
      // 22.1.3.29 Array.prototype.values()
      // 22.1.3.30 Array.prototype[@@iterator]()
      module.exports = __webpack_require__('393a')(Array, 'Array', function (iterated, kind) {
        this._t = toIObject(iterated); // target
        this._i = 0; // next index
        this._k = kind; // kind
        // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
      }, function () {
        const O = this._t;
        const kind = this._k;
        const index = this._i++;
        if (!O || index >= O.length) {
          this._t = undefined;
          return step(1);
        }
        if (kind == 'keys') return step(0, index);
        if (kind == 'values') return step(0, O[index]);
        return step(0, [index, O[index]]);
      }, 'values');

      // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
      Iterators.Arguments = Iterators.Array;

      addToUnscopables('keys');
      addToUnscopables('values');
      addToUnscopables('entries');
      /***/ }),

    /***/ '693d':
    /***/ (function (module, exports, __webpack_require__) {
      // ECMAScript 6 symbols shim
      const global = __webpack_require__('ef08');
      const has = __webpack_require__('9c0e');
      const DESCRIPTORS = __webpack_require__('0bad');
      const $export = __webpack_require__('512c');
      const redefine = __webpack_require__('ba01');
      const META = __webpack_require__('e34a').KEY;
      const $fails = __webpack_require__('4b8b');
      const shared = __webpack_require__('b367');
      const setToStringTag = __webpack_require__('92f0');
      const uid = __webpack_require__('8b1a');
      const wks = __webpack_require__('cc15');
      const wksExt = __webpack_require__('fcd4');
      const wksDefine = __webpack_require__('e198');
      const enumKeys = __webpack_require__('0ae2');
      const isArray = __webpack_require__('4ebc');
      const anObject = __webpack_require__('77e9');
      const isObject = __webpack_require__('7a41');
      const toObject = __webpack_require__('0983');
      const toIObject = __webpack_require__('6ca1');
      const toPrimitive = __webpack_require__('3397');
      const createDesc = __webpack_require__('10db');
      const _create = __webpack_require__('6f4f');
      const gOPNExt = __webpack_require__('1836');
      const $GOPD = __webpack_require__('4d20');
      const $GOPS = __webpack_require__('fed5');
      const $DP = __webpack_require__('1a14');
      const $keys = __webpack_require__('9876');
      const gOPD = $GOPD.f;
      const dP = $DP.f;
      const gOPN = gOPNExt.f;
      let $Symbol = global.Symbol;
      const $JSON = global.JSON;
      const _stringify = $JSON && $JSON.stringify;
      const PROTOTYPE = 'prototype';
      const HIDDEN = wks('_hidden');
      const TO_PRIMITIVE = wks('toPrimitive');
      const isEnum = {}.propertyIsEnumerable;
      const SymbolRegistry = shared('symbol-registry');
      const AllSymbols = shared('symbols');
      const OPSymbols = shared('op-symbols');
      const ObjectProto = Object[PROTOTYPE];
      const USE_NATIVE = typeof $Symbol === 'function' && !!$GOPS.f;
      const { QObject } = global;
      // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
      let setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

      // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
      const setSymbolDesc = DESCRIPTORS && $fails(() => _create(dP({}, 'a', {
        get() { return dP(this, 'a', { value: 7 }).a; },
      })).a != 7) ? function (it, key, D) {
          const protoDesc = gOPD(ObjectProto, key);
          if (protoDesc) delete ObjectProto[key];
          dP(it, key, D);
          if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
        } : dP;

      const wrap = function (tag) {
        const sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
        sym._k = tag;
        return sym;
      };

      const isSymbol = USE_NATIVE && typeof $Symbol.iterator === 'symbol' ? function (it) {
        return typeof it === 'symbol';
      } : function (it) {
        return it instanceof $Symbol;
      };

      var $defineProperty = function defineProperty(it, key, D) {
        if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
        anObject(it);
        key = toPrimitive(key, true);
        anObject(D);
        if (has(AllSymbols, key)) {
          if (!D.enumerable) {
            if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
            it[HIDDEN][key] = true;
          } else {
            if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
            D = _create(D, { enumerable: createDesc(0, false) });
          } return setSymbolDesc(it, key, D);
        } return dP(it, key, D);
      };
      const $defineProperties = function defineProperties(it, P) {
        anObject(it);
        const keys = enumKeys(P = toIObject(P));
        let i = 0;
        const l = keys.length;
        let key;
        while (l > i) $defineProperty(it, key = keys[i++], P[key]);
        return it;
      };
      const $create = function create(it, P) {
        return P === undefined ? _create(it) : $defineProperties(_create(it), P);
      };
      const $propertyIsEnumerable = function propertyIsEnumerable(key) {
        const E = isEnum.call(this, key = toPrimitive(key, true));
        if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
        return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
      };
      const $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
        it = toIObject(it);
        key = toPrimitive(key, true);
        if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
        const D = gOPD(it, key);
        if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
        return D;
      };
      const $getOwnPropertyNames = function getOwnPropertyNames(it) {
        const names = gOPN(toIObject(it));
        const result = [];
        let i = 0;
        let key;
        while (names.length > i) {
          if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
        } return result;
      };
      const $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
        const IS_OP = it === ObjectProto;
        const names = gOPN(IS_OP ? OPSymbols : toIObject(it));
        const result = [];
        let i = 0;
        let key;
        while (names.length > i) {
          if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
        } return result;
      };

      // 19.4.1.1 Symbol([description])
      if (!USE_NATIVE) {
        $Symbol = function Symbol() {
          if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
          const tag = uid(arguments.length > 0 ? arguments[0] : undefined);
          var $set = function (value) {
            if (this === ObjectProto) $set.call(OPSymbols, value);
            if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
            setSymbolDesc(this, tag, createDesc(1, value));
          };
          if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
          return wrap(tag);
        };
        redefine($Symbol[PROTOTYPE], 'toString', function toString() {
          return this._k;
        });

        $GOPD.f = $getOwnPropertyDescriptor;
        $DP.f = $defineProperty;
        __webpack_require__('6438').f = gOPNExt.f = $getOwnPropertyNames;
        __webpack_require__('1917').f = $propertyIsEnumerable;
        $GOPS.f = $getOwnPropertySymbols;

        if (DESCRIPTORS && !__webpack_require__('e444')) {
          redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
        }

        wksExt.f = function (name) {
          return wrap(wks(name));
        };
      }

      $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

      for (let es6Symbols = (
        // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
          'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
        ).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

      for (let wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

      $export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
        // 19.4.2.1 Symbol.for(key)
        for(key) {
          return has(SymbolRegistry, key += '')
            ? SymbolRegistry[key]
            : SymbolRegistry[key] = $Symbol(key);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function keyFor(sym) {
          if (!isSymbol(sym)) throw TypeError(`${sym} is not a symbol!`);
          for (const key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
        },
        useSetter() { setter = true; },
        useSimple() { setter = false; },
      });

      $export($export.S + $export.F * !USE_NATIVE, 'Object', {
        // 19.1.2.2 Object.create(O [, Properties])
        create: $create,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: $defineProperty,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: $defineProperties,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: $getOwnPropertyNames,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: $getOwnPropertySymbols,
      });

      // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
      // https://bugs.chromium.org/p/v8/issues/detail?id=3443
      const FAILS_ON_PRIMITIVES = $fails(() => { $GOPS.f(1); });

      $export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
        getOwnPropertySymbols: function getOwnPropertySymbols(it) {
          return $GOPS.f(toObject(it));
        },
      });

      // 24.3.2 JSON.stringify(value [, replacer [, space]])
      $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(() => {
        const S = $Symbol();
        // MS Edge converts symbol values to JSON as {}
        // WebKit converts symbol values to JSON as null
        // V8 throws on boxed symbols
        return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
      })), 'JSON', {
        stringify: function stringify(it) {
          const args = [it];
          let i = 1;
          let replacer; let
            $replacer;
          while (arguments.length > i) args.push(arguments[i++]);
          $replacer = replacer = args[1];
          if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
          if (!isArray(replacer)) {
            replacer = function (key, value) {
              if (typeof $replacer === 'function') value = $replacer.call(this, key, value);
              if (!isSymbol(value)) return value;
            };
          }
          args[1] = replacer;
          return _stringify.apply($JSON, args);
        },
      });

      // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
      $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__('051b')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
      // 19.4.3.5 Symbol.prototype[@@toStringTag]
      setToStringTag($Symbol, 'Symbol');
      // 20.2.1.9 Math[@@toStringTag]
      setToStringTag(Math, 'Math', true);
      // 24.3.3 JSON[@@toStringTag]
      setToStringTag(global.JSON, 'JSON', true);
      /***/ }),

    /***/ '6ac9':
    /***/ (function (module, exports, __webpack_require__) {
      module.exports =
        /** *** */ (function (modules) { // webpackBootstrap
          /** *** */ 	// The module cache
          /** *** */ 	const installedModules = {};
          /** *** */
          /** *** */ 	// The require function
          /** *** */ 	function __webpack_require__(moduleId) {
            /** *** */
            /** *** */ 		// Check if module is in cache
            /** *** */ 		if (installedModules[moduleId]) {
              /** *** */ 			return installedModules[moduleId].exports;
              /** *** */ 		}
            /** *** */ 		// Create a new module (and put it into the cache)
            /** *** */ 		const module = installedModules[moduleId] = {
              /** *** */ 			i: moduleId,
              /** *** */ 			l: false,
              /** *** */ 			exports: {},
              /** *** */ 		};
            /** *** */
            /** *** */ 		// Execute the module function
            /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /** *** */
            /** *** */ 		// Flag the module as loaded
            /** *** */ 		module.l = true;
            /** *** */
            /** *** */ 		// Return the exports of the module
            /** *** */ 		return module.exports;
            /** *** */ 	}
          /** *** */
          /** *** */
          /** *** */ 	// expose the modules object (__webpack_modules__)
          /** *** */ 	__webpack_require__.m = modules;
          /** *** */
          /** *** */ 	// expose the module cache
          /** *** */ 	__webpack_require__.c = installedModules;
          /** *** */
          /** *** */ 	// define getter function for harmony exports
          /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
            /** *** */ 		if (!__webpack_require__.o(exports, name)) {
              /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
              /** *** */ 		}
            /** *** */ 	};
          /** *** */
          /** *** */ 	// define __esModule on exports
          /** *** */ 	__webpack_require__.r = function (exports) {
            /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
              /** *** */ 		}
            /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
            /** *** */ 	};
          /** *** */
          /** *** */ 	// create a fake namespace object
          /** *** */ 	// mode & 1: value is a module id, require it
          /** *** */ 	// mode & 2: merge all properties of value into the ns
          /** *** */ 	// mode & 4: return value when already ns object
          /** *** */ 	// mode & 8|1: behave like require
          /** *** */ 	__webpack_require__.t = function (value, mode) {
            /** *** */ 		if (mode & 1) value = __webpack_require__(value);
            /** *** */ 		if (mode & 8) return value;
            /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /** *** */ 		const ns = Object.create(null);
            /** *** */ 		__webpack_require__.r(ns);
            /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
            /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
            /** *** */ 		return ns;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
          /** *** */ 	__webpack_require__.n = function (module) {
            /** *** */ 		const getter = module && module.__esModule
            /** *** */ 			? function getDefault() { return module.default; }
            /** *** */ 			: function getModuleExports() { return module; };
            /** *** */ 		__webpack_require__.d(getter, 'a', getter);
            /** *** */ 		return getter;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// Object.prototype.hasOwnProperty.call
          /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
          /** *** */
          /** *** */ 	// __webpack_public_path__
          /** *** */ 	__webpack_require__.p = '/dist/';
          /** *** */
          /** *** */
          /** *** */ 	// Load entry module and return exports
          /** *** */ 	return __webpack_require__(__webpack_require__.s = 74);
          /** *** */ }({

          /***/ 0:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'a', () => normalizeComponent);
            /* globals __VUE_SSR_CONTEXT__ */

            // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
            // This module is a runtime utility for cleaner component module output and will
            // be included in the final webpack user bundle.

            function normalizeComponent(
              scriptExports,
              render,
              staticRenderFns,
              functionalTemplate,
              injectStyles,
              scopeId,
              moduleIdentifier, /* server only */
              shadowMode, /* vue-cli only */
            ) {
              // Vue.extend constructor export interop
              const options = typeof scriptExports === 'function'
                ? scriptExports.options
                : scriptExports;

              // render functions
              if (render) {
                options.render = render;
                options.staticRenderFns = staticRenderFns;
                options._compiled = true;
              }

              // functional template
              if (functionalTemplate) {
                options.functional = true;
              }

              // scopedId
              if (scopeId) {
                options._scopeId = `data-v-${scopeId}`;
              }

              let hook;
              if (moduleIdentifier) { // server build
                hook = function (context) {
                  // 2.3 injection
                  context = context // cached call
        || (this.$vnode && this.$vnode.ssrContext) // stateful
        || (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
                  // 2.2 with runInNewContext: true
                  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                    context = __VUE_SSR_CONTEXT__;
                  }
                  // inject component styles
                  if (injectStyles) {
                    injectStyles.call(this, context);
                  }
                  // register component module identifier for async chunk inferrence
                  if (context && context._registeredComponents) {
                    context._registeredComponents.add(moduleIdentifier);
                  }
                };
                // used by ssr in case component is cached and beforeCreate
                // never gets called
                options._ssrRegister = hook;
              } else if (injectStyles) {
                hook = shadowMode
                  ? function () { injectStyles.call(this, this.$root.$options.shadowRoot); }
                  : injectStyles;
              }

              if (hook) {
                if (options.functional) {
                  // for template-only hot-reload because in that case the render fn doesn't
                  // go through the normalizer
                  options._injectStyles = hook;
                  // register for functioal component in vue file
                  const originalRender = options.render;
                  options.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context);
                  };
                } else {
                  // inject component registration as beforeCreate hook
                  const existing = options.beforeCreate;
                  options.beforeCreate = existing
                    ? [].concat(existing, hook)
                    : [hook];
                }
              }

              return {
                exports: scriptExports,
                options,
              };
            }
            /***/ }),

          /***/ 2:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('5924');
            /***/ }),

          /***/ 3:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8122');
            /***/ }),

          /***/ 5:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('e974');
            /***/ }),

          /***/ 7:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('8bbf');
            /***/ }),

          /***/ 74:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/popover/src/main.vue?vue&type=template&id=52060272&
            const render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'span',
                [
                  _c(
                    'transition',
                    {
                      attrs: { name: _vm.transition },
                      on: {
                        'after-enter': _vm.handleAfterEnter,
                        'after-leave': _vm.handleAfterLeave,
                      },
                    },
                    [
                      _c(
                        'div',
                        {
                          directives: [
                            {
                              name: 'show',
                              rawName: 'v-show',
                              value: !_vm.disabled && _vm.showPopper,
                              expression: '!disabled && showPopper',
                            },
                          ],
                          ref: 'popper',
                          staticClass: 'el-popover el-popper',
                          class: [_vm.popperClass, _vm.content && 'el-popover--plain'],
                          style: { width: `${_vm.width}px` },
                          attrs: {
                            role: 'tooltip',
                            id: _vm.tooltipId,
                            'aria-hidden':
                  _vm.disabled || !_vm.showPopper ? 'true' : 'false',
                          },
                        },
                        [
                          _vm.title
                            ? _c('div', {
                              staticClass: 'el-popover__title',
                              domProps: { textContent: _vm._s(_vm.title) },
                            })
                            : _vm._e(),
                          _vm._t('default', [_vm._v(_vm._s(_vm.content))]),
                        ],
                        2,
                      ),
                    ],
                  ),
                  _c(
                    'span',
                    { ref: 'wrapper', staticClass: 'el-popover__reference-wrapper' },
                    [_vm._t('reference')],
                    2,
                  ),
                ],
                1,
              );
            };
            const staticRenderFns = [];
            render._withStripped = true;

            // CONCATENATED MODULE: ./packages/popover/src/main.vue?vue&type=template&id=52060272&

            // EXTERNAL MODULE: external "element-ui/lib/utils/vue-popper"
            const vue_popper_ = __webpack_require__(5);
            const vue_popper_default = /* #__PURE__ */__webpack_require__.n(vue_popper_);

            // EXTERNAL MODULE: external "element-ui/lib/utils/dom"
            const dom_ = __webpack_require__(2);

            // EXTERNAL MODULE: external "element-ui/lib/utils/util"
            const util_ = __webpack_require__(3);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/popover/src/main.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const mainvue_type_script_lang_js_ = ({
              name: 'ElPopover',

              mixins: [vue_popper_default.a],

              props: {
                trigger: {
                  type: String,
                  default: 'click',
                  validator: function validator(value) {
                    return ['click', 'focus', 'hover', 'manual'].indexOf(value) > -1;
                  },
                },
                openDelay: {
                  type: Number,
                  default: 0,
                },
                closeDelay: {
                  type: Number,
                  default: 200,
                },
                title: String,
                disabled: Boolean,
                content: String,
                reference: {},
                popperClass: String,
                width: {},
                visibleArrow: {
                  default: true,
                },
                arrowOffset: {
                  type: Number,
                  default: 0,
                },
                transition: {
                  type: String,
                  default: 'fade-in-linear',
                },
                tabindex: {
                  type: Number,
                  default: 0,
                },
              },

              computed: {
                tooltipId: function tooltipId() {
                  return `el-popover-${Object(util_.generateId)()}`;
                },
              },
              watch: {
                showPopper: function showPopper(val) {
                  if (this.disabled) {
                    return;
                  }
                  val ? this.$emit('show') : this.$emit('hide');
                },
              },

              mounted: function mounted() {
                const _this = this;

                let reference = this.referenceElm = this.reference || this.$refs.reference;
                const popper = this.popper || this.$refs.popper;

                if (!reference && this.$refs.wrapper.children) {
                  reference = this.referenceElm = this.$refs.wrapper.children[0];
                }
                // 可访问性
                if (reference) {
                  Object(dom_.addClass)(reference, 'el-popover__reference');
                  reference.setAttribute('aria-describedby', this.tooltipId);
                  reference.setAttribute('tabindex', this.tabindex); // tab序列
                  popper.setAttribute('tabindex', 0);

                  if (this.trigger !== 'click') {
                    Object(dom_.on)(reference, 'focusin', () => {
                      _this.handleFocus();
                      const instance = reference.__vue__;
                      if (instance && typeof instance.focus === 'function') {
                        instance.focus();
                      }
                    });
                    Object(dom_.on)(popper, 'focusin', this.handleFocus);
                    Object(dom_.on)(reference, 'focusout', this.handleBlur);
                    Object(dom_.on)(popper, 'focusout', this.handleBlur);
                  }
                  Object(dom_.on)(reference, 'keydown', this.handleKeydown);
                  Object(dom_.on)(reference, 'click', this.handleClick);
                }
                if (this.trigger === 'click') {
                  Object(dom_.on)(reference, 'click', this.doToggle);
                  Object(dom_.on)(document, 'click', this.handleDocumentClick);
                } else if (this.trigger === 'hover') {
                  Object(dom_.on)(reference, 'mouseenter', this.handleMouseEnter);
                  Object(dom_.on)(popper, 'mouseenter', this.handleMouseEnter);
                  Object(dom_.on)(reference, 'mouseleave', this.handleMouseLeave);
                  Object(dom_.on)(popper, 'mouseleave', this.handleMouseLeave);
                } else if (this.trigger === 'focus') {
                  if (this.tabindex < 0) {
                    console.warn('[Element Warn][Popover]a negative taindex means that the element cannot be focused by tab key');
                  }
                  if (reference.querySelector('input, textarea')) {
                    Object(dom_.on)(reference, 'focusin', this.doShow);
                    Object(dom_.on)(reference, 'focusout', this.doClose);
                  } else {
                    Object(dom_.on)(reference, 'mousedown', this.doShow);
                    Object(dom_.on)(reference, 'mouseup', this.doClose);
                  }
                }
              },
              beforeDestroy: function beforeDestroy() {
                this.cleanup();
              },
              deactivated: function deactivated() {
                this.cleanup();
              },

              methods: {
                doToggle: function doToggle() {
                  this.showPopper = !this.showPopper;
                },
                doShow: function doShow() {
                  this.showPopper = true;
                },
                doClose: function doClose() {
                  this.showPopper = false;
                },
                handleFocus: function handleFocus() {
                  Object(dom_.addClass)(this.referenceElm, 'focusing');
                  if (this.trigger === 'click' || this.trigger === 'focus') this.showPopper = true;
                },
                handleClick: function handleClick() {
                  Object(dom_.removeClass)(this.referenceElm, 'focusing');
                },
                handleBlur: function handleBlur() {
                  Object(dom_.removeClass)(this.referenceElm, 'focusing');
                  if (this.trigger === 'click' || this.trigger === 'focus') this.showPopper = false;
                },
                handleMouseEnter: function handleMouseEnter() {
                  const _this2 = this;

                  clearTimeout(this._timer);
                  if (this.openDelay) {
                    this._timer = setTimeout(() => {
                      _this2.showPopper = true;
                    }, this.openDelay);
                  } else {
                    this.showPopper = true;
                  }
                },
                handleKeydown: function handleKeydown(ev) {
                  if (ev.keyCode === 27 && this.trigger !== 'manual') {
                    // esc
                    this.doClose();
                  }
                },
                handleMouseLeave: function handleMouseLeave() {
                  const _this3 = this;

                  clearTimeout(this._timer);
                  if (this.closeDelay) {
                    this._timer = setTimeout(() => {
                      _this3.showPopper = false;
                    }, this.closeDelay);
                  } else {
                    this.showPopper = false;
                  }
                },
                handleDocumentClick: function handleDocumentClick(e) {
                  let reference = this.reference || this.$refs.reference;
                  const popper = this.popper || this.$refs.popper;

                  if (!reference && this.$refs.wrapper.children) {
                    reference = this.referenceElm = this.$refs.wrapper.children[0];
                  }
                  if (!this.$el || !reference || this.$el.contains(e.target) || reference.contains(e.target) || !popper || popper.contains(e.target)) return;
                  this.showPopper = false;
                },
                handleAfterEnter: function handleAfterEnter() {
                  this.$emit('after-enter');
                },
                handleAfterLeave: function handleAfterLeave() {
                  this.$emit('after-leave');
                  this.doDestroy();
                },
                cleanup: function cleanup() {
                  if (this.openDelay || this.closeDelay) {
                    clearTimeout(this._timer);
                  }
                },
              },

              destroyed: function destroyed() {
                const { reference } = this;

                Object(dom_.off)(reference, 'click', this.doToggle);
                Object(dom_.off)(reference, 'mouseup', this.doClose);
                Object(dom_.off)(reference, 'mousedown', this.doShow);
                Object(dom_.off)(reference, 'focusin', this.doShow);
                Object(dom_.off)(reference, 'focusout', this.doClose);
                Object(dom_.off)(reference, 'mousedown', this.doShow);
                Object(dom_.off)(reference, 'mouseup', this.doClose);
                Object(dom_.off)(reference, 'mouseleave', this.handleMouseLeave);
                Object(dom_.off)(reference, 'mouseenter', this.handleMouseEnter);
                Object(dom_.off)(document, 'click', this.handleDocumentClick);
              },
            });
            // CONCATENATED MODULE: ./packages/popover/src/main.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_mainvue_type_script_lang_js_ = (mainvue_type_script_lang_js_);
            // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
            const componentNormalizer = __webpack_require__(0);

            // CONCATENATED MODULE: ./packages/popover/src/main.vue

            /* normalize component */

            const component = Object(componentNormalizer['a' /* default */])(
              src_mainvue_type_script_lang_js_,
              render,
              staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let api; }
            component.options.__file = 'packages/popover/src/main.vue';
            /* harmony default export */ const main = (component.exports);
            // CONCATENATED MODULE: ./packages/popover/src/directive.js
            const getReference = function getReference(el, binding, vnode) {
              const _ref = binding.expression ? binding.value : binding.arg;
              const popper = vnode.context.$refs[_ref];
              if (popper) {
                if (Array.isArray(popper)) {
                  popper[0].$refs.reference = el;
                } else {
                  popper.$refs.reference = el;
                }
              }
            };

            /* harmony default export */ const directive = ({
              bind: function bind(el, binding, vnode) {
                getReference(el, binding, vnode);
              },
              inserted: function inserted(el, binding, vnode) {
                getReference(el, binding, vnode);
              },
            });
            // EXTERNAL MODULE: external "vue"
            const external_vue_ = __webpack_require__(7);
            const external_vue_default = /* #__PURE__ */__webpack_require__.n(external_vue_);

            // CONCATENATED MODULE: ./packages/popover/index.js

            external_vue_default.a.directive('popover', directive);

            /* istanbul ignore next */
            main.install = function (Vue) {
              Vue.directive('popover', directive);
              Vue.component(main.name, main);
            };
            main.directive = directive;

            /* harmony default export */ const popover = __webpack_exports__.default = (main);
            /***/ }),

          /** *** */ }));
      /***/ }),

    /***/ '6b7c':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      const _locale = __webpack_require__('4897');

      exports.default = {
        methods: {
          t: function t() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return _locale.t.apply(this, args);
          },
        },
      };
      /***/ }),

    /***/ '6ca1':
    /***/ (function (module, exports, __webpack_require__) {
      // to indexed object, toObject with fallback for non-array-like ES3 strings
      const IObject = __webpack_require__('9fbb');
      const defined = __webpack_require__('c901');
      module.exports = function (it) {
        return IObject(defined(it));
      };
      /***/ }),

    /***/ '6dd8':
    /***/ (function (module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* WEBPACK VAR INJECTION */(function (global) { /**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
        /* eslint-disable require-jsdoc, valid-jsdoc */
        const MapShim = (function () {
          if (typeof Map !== 'undefined') {
            return Map;
          }
          /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
          function getIndex(arr, key) {
            let result = -1;
            arr.some((entry, index) => {
              if (entry[0] === key) {
                result = index;
                return true;
              }
              return false;
            });
            return result;
          }
          return /** @class */ (function () {
            function class_1() {
              this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, 'size', {
            /**
             * @returns {boolean}
             */
              get() {
                return this.__entries__.length;
              },
              enumerable: true,
              configurable: true,
            });
            /**
         * @param {*} key
         * @returns {*}
         */
            class_1.prototype.get = function (key) {
              const index = getIndex(this.__entries__, key);
              const entry = this.__entries__[index];
              return entry && entry[1];
            };
            /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
            class_1.prototype.set = function (key, value) {
              const index = getIndex(this.__entries__, key);
              if (~index) {
                this.__entries__[index][1] = value;
              } else {
                this.__entries__.push([key, value]);
              }
            };
            /**
         * @param {*} key
         * @returns {void}
         */
            class_1.prototype.delete = function (key) {
              const entries = this.__entries__;
              const index = getIndex(entries, key);
              if (~index) {
                entries.splice(index, 1);
              }
            };
            /**
         * @param {*} key
         * @returns {void}
         */
            class_1.prototype.has = function (key) {
              return !!~getIndex(this.__entries__, key);
            };
            /**
         * @returns {void}
         */
            class_1.prototype.clear = function () {
              this.__entries__.splice(0);
            };
            /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
            class_1.prototype.forEach = function (callback, ctx) {
              if (ctx === void 0) { ctx = null; }
              for (let _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                const entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
              }
            };
            return class_1;
          }());
        }());

        /**
 * Detects whether window and document objects are available in current environment.
 */
        const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

        // Returns global object of a current environment.
        const global$1 = (function () {
          if (typeof global !== 'undefined' && global.Math === Math) {
            return global;
          }
          if (typeof self !== 'undefined' && self.Math === Math) {
            return self;
          }
          if (typeof window !== 'undefined' && window.Math === Math) {
            return window;
          }
          // eslint-disable-next-line no-new-func
          return Function('return this')();
        }());

        /**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
        const requestAnimationFrame$1 = (function () {
          if (typeof requestAnimationFrame === 'function') {
            // It's required to use a bounded function because IE sometimes throws
            // an "Invalid calling object" error if rAF is invoked without the global
            // object on the left hand side.
            return requestAnimationFrame.bind(global$1);
          }
          return function (callback) { return setTimeout(() => callback(Date.now()), 1000 / 60); };
        }());

        // Defines minimum timeout before adding a trailing call.
        const trailingTimeout = 2;
        /**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
        function throttle(callback, delay) {
          let leadingCall = false; let trailingCall = false; let
            lastCallTime = 0;
          /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
          function resolvePending() {
            if (leadingCall) {
              leadingCall = false;
              callback();
            }
            if (trailingCall) {
              proxy();
            }
          }
          /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
          function timeoutCallback() {
            requestAnimationFrame$1(resolvePending);
          }
          /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
          function proxy() {
            const timeStamp = Date.now();
            if (leadingCall) {
            // Reject immediately following calls.
              if (timeStamp - lastCallTime < trailingTimeout) {
                return;
              }
              // Schedule new call to be in invoked when the pending one is resolved.
              // This is important for "transitions" which never actually start
              // immediately so there is a chance that we might miss one if change
              // happens amids the pending invocation.
              trailingCall = true;
            } else {
              leadingCall = true;
              trailingCall = false;
              setTimeout(timeoutCallback, delay);
            }
            lastCallTime = timeStamp;
          }
          return proxy;
        }

        // Minimum delay before invoking the update of observers.
        const REFRESH_DELAY = 20;
        // A list of substrings of CSS properties used to find transition events that
        // might affect dimensions of observed elements.
        const transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
        // Check if MutationObserver is available.
        const mutationObserverSupported = typeof MutationObserver !== 'undefined';
        /**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
        const ResizeObserverController = /** @class */ (function () {
          /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
          function ResizeObserverController() {
            /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
            this.connected_ = false;
            /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
            this.mutationEventsAdded_ = false;
            /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
            this.mutationsObserver_ = null;
            /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
          }
          /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
          ResizeObserverController.prototype.addObserver = function (observer) {
            if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
            }
            // Add listeners if they haven't been added yet.
            if (!this.connected_) {
              this.connect_();
            }
          };
          /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
          ResizeObserverController.prototype.removeObserver = function (observer) {
            const observers = this.observers_;
            const index = observers.indexOf(observer);
            // Remove observer if it's present in registry.
            if (~index) {
              observers.splice(index, 1);
            }
            // Remove listeners if controller has no connected observers.
            if (!observers.length && this.connected_) {
              this.disconnect_();
            }
          };
          /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
          ResizeObserverController.prototype.refresh = function () {
            const changesDetected = this.updateObservers_();
            // Continue running updates if changes have been detected as there might
            // be future ones caused by CSS transitions.
            if (changesDetected) {
              this.refresh();
            }
          };
          /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
          ResizeObserverController.prototype.updateObservers_ = function () {
            // Collect observers that have active observations.
            const activeObservers = this.observers_.filter((observer) => (observer.gatherActive(), observer.hasActive()));
            // Deliver notifications in a separate cycle in order to avoid any
            // collisions between observers, e.g. when multiple instances of
            // ResizeObserver are tracking the same element and the callback of one
            // of them changes content dimensions of the observed target. Sometimes
            // this may result in notifications being blocked for the rest of observers.
            activeObservers.forEach((observer) => observer.broadcastActive());
            return activeObservers.length > 0;
          };
          /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
          ResizeObserverController.prototype.connect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already added.
            if (!isBrowser || this.connected_) {
              return;
            }
            // Subscription to the "Transitionend" event is used as a workaround for
            // delayed transitions. This way it's possible to capture at least the
            // final state of an element.
            document.addEventListener('transitionend', this.onTransitionEnd_);
            window.addEventListener('resize', this.refresh);
            if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true,
              });
            } else {
              document.addEventListener('DOMSubtreeModified', this.refresh);
              this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
          };
          /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
          ResizeObserverController.prototype.disconnect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already removed.
            if (!isBrowser || !this.connected_) {
              return;
            }
            document.removeEventListener('transitionend', this.onTransitionEnd_);
            window.removeEventListener('resize', this.refresh);
            if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
              document.removeEventListener('DOMSubtreeModified', this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
          };
          /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
          ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
            const _b = _a.propertyName; const
              propertyName = _b === void 0 ? '' : _b;
            // Detect whether transition may affect dimensions of an element.
            const isReflowProperty = transitionKeys.some((key) => !!~propertyName.indexOf(key));
            if (isReflowProperty) {
              this.refresh();
            }
          };
          /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
          ResizeObserverController.getInstance = function () {
            if (!this.instance_) {
              this.instance_ = new ResizeObserverController();
            }
            return this.instance_;
          };
          /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
          ResizeObserverController.instance_ = null;
          return ResizeObserverController;
        }());

        /**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
        const defineConfigurable = (function (target, props) {
          for (let _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            const key = _a[_i];
            Object.defineProperty(target, key, {
              value: props[key],
              enumerable: false,
              writable: false,
              configurable: true,
            });
          }
          return target;
        });

        /**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
        const getWindowOf = (function (target) {
          // Assume that the element is an instance of Node, which means that it
          // has the "ownerDocument" property from which we can retrieve a
          // corresponding global object.
          const ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
          // Return the local global object if it's not possible extract one from
          // provided element.
          return ownerGlobal || global$1;
        });

        // Placeholder of an empty content rectangle.
        const emptyRect = createRectInit(0, 0, 0, 0);
        /**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
        function toFloat(value) {
          return parseFloat(value) || 0;
        }
        /**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
        function getBordersSize(styles) {
          const positions = [];
          for (let _i = 1; _i < arguments.length; _i++) {
            positions[_i - 1] = arguments[_i];
          }
          return positions.reduce((size, position) => {
            const value = styles[`border-${position}-width`];
            return size + toFloat(value);
          }, 0);
        }
        /**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
        function getPaddings(styles) {
          const positions = ['top', 'right', 'bottom', 'left'];
          const paddings = {};
          for (let _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
            const position = positions_1[_i];
            const value = styles[`padding-${position}`];
            paddings[position] = toFloat(value);
          }
          return paddings;
        }
        /**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
        function getSVGContentRect(target) {
          const bbox = target.getBBox();
          return createRectInit(0, 0, bbox.width, bbox.height);
        }
        /**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
        function getHTMLElementContentRect(target) {
          // Client width & height properties can't be
          // used exclusively as they provide rounded values.
          const { clientWidth } = target;
          const { clientHeight } = target;
          // By this condition we can catch all non-replaced inline, hidden and
          // detached elements. Though elements with width & height properties less
          // than 0.5 will be discarded as well.
          //
          // Without it we would need to implement separate methods for each of
          // those cases and it's not possible to perform a precise and performance
          // effective test for hidden elements. E.g. even jQuery's ':visible' filter
          // gives wrong results for elements with width & height less than 0.5.
          if (!clientWidth && !clientHeight) {
            return emptyRect;
          }
          const styles = getWindowOf(target).getComputedStyle(target);
          const paddings = getPaddings(styles);
          const horizPad = paddings.left + paddings.right;
          const vertPad = paddings.top + paddings.bottom;
          // Computed styles of width & height are being used because they are the
          // only dimensions available to JS that contain non-rounded values. It could
          // be possible to utilize the getBoundingClientRect if only it's data wasn't
          // affected by CSS transformations let alone paddings, borders and scroll bars.
          let width = toFloat(styles.width); let
            height = toFloat(styles.height);
          // Width & height include paddings and borders when the 'border-box' box
          // model is applied (except for IE).
          if (styles.boxSizing === 'border-box') {
            // Following conditions are required to handle Internet Explorer which
            // doesn't include paddings and borders to computed CSS dimensions.
            //
            // We can say that if CSS dimensions + paddings are equal to the "client"
            // properties then it's either IE, and thus we don't need to subtract
            // anything, or an element merely doesn't have paddings/borders styles.
            if (Math.round(width + horizPad) !== clientWidth) {
              width -= getBordersSize(styles, 'left', 'right') + horizPad;
            }
            if (Math.round(height + vertPad) !== clientHeight) {
              height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
            }
          }
          // Following steps can't be applied to the document's root element as its
          // client[Width/Height] properties represent viewport area of the window.
          // Besides, it's as well not necessary as the <html> itself neither has
          // rendered scroll bars nor it can be clipped.
          if (!isDocumentElement(target)) {
            // In some browsers (only in Firefox, actually) CSS width & height
            // include scroll bars size which can be removed at this step as scroll
            // bars are the only difference between rounded dimensions + paddings
            // and "client" properties, though that is not always true in Chrome.
            const vertScrollbar = Math.round(width + horizPad) - clientWidth;
            const horizScrollbar = Math.round(height + vertPad) - clientHeight;
            // Chrome has a rather weird rounding of "client" properties.
            // E.g. for an element with content width of 314.2px it sometimes gives
            // the client width of 315px and for the width of 314.7px it may give
            // 314px. And it doesn't happen all the time. So just ignore this delta
            // as a non-relevant.
            if (Math.abs(vertScrollbar) !== 1) {
              width -= vertScrollbar;
            }
            if (Math.abs(horizScrollbar) !== 1) {
              height -= horizScrollbar;
            }
          }
          return createRectInit(paddings.left, paddings.top, width, height);
        }
        /**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
        const isSVGGraphicsElement = (function () {
          // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
          // interface.
          if (typeof SVGGraphicsElement !== 'undefined') {
            return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
          }
          // If it's so, then check that element is at least an instance of the
          // SVGElement and that it has the "getBBox" method.
          // eslint-disable-next-line no-extra-parens
          return function (target) {
            return (target instanceof getWindowOf(target).SVGElement
        && typeof target.getBBox === 'function');
          };
        }());
        /**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
        function isDocumentElement(target) {
          return target === getWindowOf(target).document.documentElement;
        }
        /**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
        function getContentRect(target) {
          if (!isBrowser) {
            return emptyRect;
          }
          if (isSVGGraphicsElement(target)) {
            return getSVGContentRect(target);
          }
          return getHTMLElementContentRect(target);
        }
        /**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
        function createReadOnlyRect(_a) {
          const { x } = _a;
          const { y } = _a;
          const { width } = _a;
          const { height } = _a;
          // If DOMRectReadOnly is available use it as a prototype for the rectangle.
          const Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
          const rect = Object.create(Constr.prototype);
          // Rectangle's properties are not writable and non-enumerable.
          defineConfigurable(rect, {
            x,
            y,
            width,
            height,
            top: y,
            right: x + width,
            bottom: height + y,
            left: x,
          });
          return rect;
        }
        /**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
        function createRectInit(x, y, width, height) {
          return {
            x, y, width, height,
          };
        }

        /**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
        const ResizeObservation = /** @class */ (function () {
          /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
          function ResizeObservation(target) {
            /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
            this.broadcastWidth = 0;
            /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
            this.broadcastHeight = 0;
            /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
          }
          /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
          ResizeObservation.prototype.isActive = function () {
            const rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return (rect.width !== this.broadcastWidth
            || rect.height !== this.broadcastHeight);
          };
          /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
          ResizeObservation.prototype.broadcastRect = function () {
            const rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
          };
          return ResizeObservation;
        }());

        const ResizeObserverEntry = /** @class */ (function () {
          /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
          function ResizeObserverEntry(target, rectInit) {
            const contentRect = createReadOnlyRect(rectInit);
            // According to the specification following properties are not writable
            // and are also not enumerable in the native implementation.
            //
            // Property accessors are not being used as they'd require to define a
            // private WeakMap storage which may cause memory leaks in browsers that
            // don't support this type of collections.
            defineConfigurable(this, { target, contentRect });
          }
          return ResizeObserverEntry;
        }());

        const ResizeObserverSPI = /** @class */ (function () {
          /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
          function ResizeObserverSPI(callback, controller, callbackCtx) {
            /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
            this.activeObservations_ = [];
            /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
            this.observations_ = new MapShim();
            if (typeof callback !== 'function') {
              throw new TypeError('The callback provided as parameter 1 is not a function.');
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
          }
          /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
          ResizeObserverSPI.prototype.observe = function (target) {
            if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            const observations = this.observations_;
            // Do nothing if element is already being observed.
            if (observations.has(target)) {
              return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            // Force the update of observations.
            this.controller_.refresh();
          };
          /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
          ResizeObserverSPI.prototype.unobserve = function (target) {
            if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            const observations = this.observations_;
            // Do nothing if element is not being observed.
            if (!observations.has(target)) {
              return;
            }
            observations.delete(target);
            if (!observations.size) {
              this.controller_.removeObserver(this);
            }
          };
          /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
          ResizeObserverSPI.prototype.disconnect = function () {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
          };
          /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
          ResizeObserverSPI.prototype.gatherActive = function () {
            const _this = this;
            this.clearActive();
            this.observations_.forEach((observation) => {
              if (observation.isActive()) {
                _this.activeObservations_.push(observation);
              }
            });
          };
          /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
          ResizeObserverSPI.prototype.broadcastActive = function () {
            // Do nothing if observer doesn't have active observations.
            if (!this.hasActive()) {
              return;
            }
            const ctx = this.callbackCtx_;
            // Create ResizeObserverEntry instance for every active observation.
            const entries = this.activeObservations_.map((observation) => new ResizeObserverEntry(observation.target, observation.broadcastRect()));
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
          };
          /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
          ResizeObserverSPI.prototype.clearActive = function () {
            this.activeObservations_.splice(0);
          };
          /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
          ResizeObserverSPI.prototype.hasActive = function () {
            return this.activeObservations_.length > 0;
          };
          return ResizeObserverSPI;
        }());

        // Registry of internal observers. If WeakMap is not available use current shim
        // for the Map collection as it has all required methods and because WeakMap
        // can't be fully polyfilled anyway.
        const observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
        /**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
        const ResizeObserver = /** @class */ (function () {
          /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
          function ResizeObserver(callback) {
            if (!(this instanceof ResizeObserver)) {
              throw new TypeError('Cannot call a class as a function.');
            }
            if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
            }
            const controller = ResizeObserverController.getInstance();
            const observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
          }
          return ResizeObserver;
        }());
        // Expose public methods of ResizeObserver.
        [
          'observe',
          'unobserve',
          'disconnect',
        ].forEach((method) => {
          ResizeObserver.prototype[method] = function () {
            let _a;
            return (_a = observers.get(this))[method].apply(_a, arguments);
          };
        });

        const index = (function () {
          // Export existing implementation if available.
          if (typeof global$1.ResizeObserver !== 'undefined') {
            return global$1.ResizeObserver;
          }
          return ResizeObserver;
        }());

        /* harmony default export */ __webpack_exports__.default = (index);
        /* WEBPACK VAR INJECTION */ }.call(this, __webpack_require__('c8ba')));
      /***/ }),

    /***/ '6f4f':
    /***/ (function (module, exports, __webpack_require__) {
      // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
      const anObject = __webpack_require__('77e9');
      const dPs = __webpack_require__('85e7');
      const enumBugKeys = __webpack_require__('9742');
      const IE_PROTO = __webpack_require__('5a94')('IE_PROTO');
      const Empty = function () { /* empty */ };
      const PROTOTYPE = 'prototype';

      // Create object with fake `null` prototype: use iframe Object with cleared prototype
      var createDict = function () {
        // Thrash, waste and sodomy: IE GC bug
        const iframe = __webpack_require__('05f5')('iframe');
        let i = enumBugKeys.length;
        const lt = '<';
        const gt = '>';
        let iframeDocument;
        iframe.style.display = 'none';
        __webpack_require__('9141').appendChild(iframe);
        iframe.src = 'javascript:'; // eslint-disable-line no-script-url
        // createDict = iframe.contentWindow.Object;
        // html.removeChild(iframe);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(`${lt}script${gt}document.F=Object${lt}/script${gt}`);
        iframeDocument.close();
        createDict = iframeDocument.F;
        while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
        return createDict();
      };

      module.exports = Object.create || function create(O, Properties) {
        let result;
        if (O !== null) {
          Empty[PROTOTYPE] = anObject(O);
          result = new Empty();
          Empty[PROTOTYPE] = null;
          // add "__proto__" for Object.getPrototypeOf polyfill
          result[IE_PROTO] = O;
        } else result = createDict();
        return Properties === undefined ? result : dPs(result, Properties);
      };
      /***/ }),

    /***/ '722f':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

      const _ariaUtils = __webpack_require__('e452');

      const _ariaUtils2 = _interopRequireDefault(_ariaUtils);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      /**
 * @constructor
 * @desc Dialog object providing modal focus management.
 *
 * Assumptions: The element serving as the dialog container is present in the
 * DOM and hidden. The dialog container has role='dialog'.
 *
 * @param dialogId
 *          The ID of the element serving as the dialog container.
 * @param focusAfterClosed
 *          Either the DOM node or the ID of the DOM node to focus when the
 *          dialog closes.
 * @param focusFirst
 *          Optional parameter containing either the DOM node or the ID of the
 *          DOM node to focus when the dialog opens. If not specified, the
 *          first focusable element in the dialog will receive focus.
 */
      var aria = aria || {};
      let tabEvent;

      aria.Dialog = function (dialog, focusAfterClosed, focusFirst) {
        const _this = this;

        this.dialogNode = dialog;
        if (this.dialogNode === null || this.dialogNode.getAttribute('role') !== 'dialog') {
          throw new Error('Dialog() requires a DOM element with ARIA role of dialog.');
        }

        if (typeof focusAfterClosed === 'string') {
          this.focusAfterClosed = document.getElementById(focusAfterClosed);
        } else if ((typeof focusAfterClosed === 'undefined' ? 'undefined' : _typeof(focusAfterClosed)) === 'object') {
          this.focusAfterClosed = focusAfterClosed;
        } else {
          this.focusAfterClosed = null;
        }

        if (typeof focusFirst === 'string') {
          this.focusFirst = document.getElementById(focusFirst);
        } else if ((typeof focusFirst === 'undefined' ? 'undefined' : _typeof(focusFirst)) === 'object') {
          this.focusFirst = focusFirst;
        } else {
          this.focusFirst = null;
        }

        if (this.focusFirst) {
          this.focusFirst.focus();
        } else {
          _ariaUtils2.default.focusFirstDescendant(this.dialogNode);
        }

        this.lastFocus = document.activeElement;
        tabEvent = function tabEvent(e) {
          _this.trapFocus(e);
        };
        this.addListeners();
      };

      aria.Dialog.prototype.addListeners = function () {
        document.addEventListener('focus', tabEvent, true);
      };

      aria.Dialog.prototype.removeListeners = function () {
        document.removeEventListener('focus', tabEvent, true);
      };

      aria.Dialog.prototype.closeDialog = function () {
        const _this2 = this;

        this.removeListeners();
        if (this.focusAfterClosed) {
          setTimeout(() => {
            _this2.focusAfterClosed.focus();
          });
        }
      };

      aria.Dialog.prototype.trapFocus = function (event) {
        if (_ariaUtils2.default.IgnoreUtilFocusChanges) {
          return;
        }
        if (this.dialogNode.contains(event.target)) {
          this.lastFocus = event.target;
        } else {
          _ariaUtils2.default.focusFirstDescendant(this.dialogNode);
          if (this.lastFocus === document.activeElement) {
            _ariaUtils2.default.focusLastDescendant(this.dialogNode);
          }
          this.lastFocus = document.activeElement;
        }
      };

      exports.default = aria.Dialog;
      /***/ }),

    /***/ '77e9':
    /***/ (function (module, exports, __webpack_require__) {
      const isObject = __webpack_require__('7a41');
      module.exports = function (it) {
        if (!isObject(it)) throw TypeError(`${it} is not an object!`);
        return it;
      };
      /***/ }),

    /***/ '7a41':
    /***/ (function (module, exports) {
      module.exports = function (it) {
        return typeof it === 'object' ? it !== null : typeof it === 'function';
      };
      /***/ }),

    /***/ '7b3e':
    /***/ (function (module, exports, __webpack_require__) {
      /**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

      const ExecutionEnvironment = __webpack_require__('a3de');

      let useHasFeature;
      if (ExecutionEnvironment.canUseDOM) {
        useHasFeature = document.implementation
    && document.implementation.hasFeature
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    && document.implementation.hasFeature('', '') !== true;
      }

      /**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
      function isEventSupported(eventNameSuffix, capture) {
        if (!ExecutionEnvironment.canUseDOM
      || capture && !('addEventListener' in document)) {
          return false;
        }

        const eventName = `on${eventNameSuffix}`;
        let isSupported = eventName in document;

        if (!isSupported) {
          const element = document.createElement('div');
          element.setAttribute(eventName, 'return;');
          isSupported = typeof element[eventName] === 'function';
        }

        if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
          // This is the only way to test support for the `wheel` event in IE9+.
          isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
        }

        return isSupported;
      }

      module.exports = isEventSupported;
      /***/ }),

    /***/ '7f4d':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      exports.default = function (target) {
        for (let i = 1, j = arguments.length; i < j; i++) {
          const source = arguments[i] || {};
          for (const prop in source) {
            if (source.hasOwnProperty(prop)) {
              const value = source[prop];
              if (value !== undefined) {
                target[prop] = value;
              }
            }
          }
        }

        return target;
      };
      /***/ }),

    /***/ '7fc1':
    /***/ (function (module, exports, __webpack_require__) {
      module.exports =
        /** *** */ (function (modules) { // webpackBootstrap
          /** *** */ 	// The module cache
          /** *** */ 	const installedModules = {};
          /** *** */
          /** *** */ 	// The require function
          /** *** */ 	function __webpack_require__(moduleId) {
            /** *** */
            /** *** */ 		// Check if module is in cache
            /** *** */ 		if (installedModules[moduleId]) {
              /** *** */ 			return installedModules[moduleId].exports;
              /** *** */ 		}
            /** *** */ 		// Create a new module (and put it into the cache)
            /** *** */ 		const module = installedModules[moduleId] = {
              /** *** */ 			i: moduleId,
              /** *** */ 			l: false,
              /** *** */ 			exports: {},
              /** *** */ 		};
            /** *** */
            /** *** */ 		// Execute the module function
            /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /** *** */
            /** *** */ 		// Flag the module as loaded
            /** *** */ 		module.l = true;
            /** *** */
            /** *** */ 		// Return the exports of the module
            /** *** */ 		return module.exports;
            /** *** */ 	}
          /** *** */
          /** *** */
          /** *** */ 	// expose the modules object (__webpack_modules__)
          /** *** */ 	__webpack_require__.m = modules;
          /** *** */
          /** *** */ 	// expose the module cache
          /** *** */ 	__webpack_require__.c = installedModules;
          /** *** */
          /** *** */ 	// define getter function for harmony exports
          /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
            /** *** */ 		if (!__webpack_require__.o(exports, name)) {
              /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
              /** *** */ 		}
            /** *** */ 	};
          /** *** */
          /** *** */ 	// define __esModule on exports
          /** *** */ 	__webpack_require__.r = function (exports) {
            /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
              /** *** */ 		}
            /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
            /** *** */ 	};
          /** *** */
          /** *** */ 	// create a fake namespace object
          /** *** */ 	// mode & 1: value is a module id, require it
          /** *** */ 	// mode & 2: merge all properties of value into the ns
          /** *** */ 	// mode & 4: return value when already ns object
          /** *** */ 	// mode & 8|1: behave like require
          /** *** */ 	__webpack_require__.t = function (value, mode) {
            /** *** */ 		if (mode & 1) value = __webpack_require__(value);
            /** *** */ 		if (mode & 8) return value;
            /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /** *** */ 		const ns = Object.create(null);
            /** *** */ 		__webpack_require__.r(ns);
            /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
            /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
            /** *** */ 		return ns;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
          /** *** */ 	__webpack_require__.n = function (module) {
            /** *** */ 		const getter = module && module.__esModule
            /** *** */ 			? function getDefault() { return module.default; }
            /** *** */ 			: function getModuleExports() { return module; };
            /** *** */ 		__webpack_require__.d(getter, 'a', getter);
            /** *** */ 		return getter;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// Object.prototype.hasOwnProperty.call
          /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
          /** *** */
          /** *** */ 	// __webpack_public_path__
          /** *** */ 	__webpack_require__.p = '/dist/';
          /** *** */
          /** *** */
          /** *** */ 	// Load entry module and return exports
          /** *** */ 	return __webpack_require__(__webpack_require__.s = 86);
          /** *** */ }({

          /***/ 0:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'a', () => normalizeComponent);
            /* globals __VUE_SSR_CONTEXT__ */

            // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
            // This module is a runtime utility for cleaner component module output and will
            // be included in the final webpack user bundle.

            function normalizeComponent(
              scriptExports,
              render,
              staticRenderFns,
              functionalTemplate,
              injectStyles,
              scopeId,
              moduleIdentifier, /* server only */
              shadowMode, /* vue-cli only */
            ) {
              // Vue.extend constructor export interop
              const options = typeof scriptExports === 'function'
                ? scriptExports.options
                : scriptExports;

              // render functions
              if (render) {
                options.render = render;
                options.staticRenderFns = staticRenderFns;
                options._compiled = true;
              }

              // functional template
              if (functionalTemplate) {
                options.functional = true;
              }

              // scopedId
              if (scopeId) {
                options._scopeId = `data-v-${scopeId}`;
              }

              let hook;
              if (moduleIdentifier) { // server build
                hook = function (context) {
                  // 2.3 injection
                  context = context // cached call
        || (this.$vnode && this.$vnode.ssrContext) // stateful
        || (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
                  // 2.2 with runInNewContext: true
                  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                    context = __VUE_SSR_CONTEXT__;
                  }
                  // inject component styles
                  if (injectStyles) {
                    injectStyles.call(this, context);
                  }
                  // register component module identifier for async chunk inferrence
                  if (context && context._registeredComponents) {
                    context._registeredComponents.add(moduleIdentifier);
                  }
                };
                // used by ssr in case component is cached and beforeCreate
                // never gets called
                options._ssrRegister = hook;
              } else if (injectStyles) {
                hook = shadowMode
                  ? function () { injectStyles.call(this, this.$root.$options.shadowRoot); }
                  : injectStyles;
              }

              if (hook) {
                if (options.functional) {
                  // for template-only hot-reload because in that case the render fn doesn't
                  // go through the normalizer
                  options._injectStyles = hook;
                  // register for functioal component in vue file
                  const originalRender = options.render;
                  options.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context);
                  };
                } else {
                  // inject component registration as beforeCreate hook
                  const existing = options.beforeCreate;
                  options.beforeCreate = existing
                    ? [].concat(existing, hook)
                    : [hook];
                }
              }

              return {
                exports: scriptExports,
                options,
              };
            }
            /***/ }),

          /***/ 4:
          /***/ (function (module, exports) {
            module.exports = __webpack_require__('d010');
            /***/ }),

          /***/ 86:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-group.vue?vue&type=template&id=7289a290&
            const render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-checkbox-group',
                  attrs: { role: 'group', 'aria-label': 'checkbox-group' },
                },
                [_vm._t('default')],
                2,
              );
            };
            const staticRenderFns = [];
            render._withStripped = true;

            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue?vue&type=template&id=7289a290&

            // EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"
            const emitter_ = __webpack_require__(4);
            const emitter_default = /* #__PURE__ */__webpack_require__.n(emitter_);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-group.vue?vue&type=script&lang=js&

            /* harmony default export */ const checkbox_groupvue_type_script_lang_js_ = ({
              name: 'ElCheckboxGroup',

              componentName: 'ElCheckboxGroup',

              mixins: [emitter_default.a],

              inject: {
                elFormItem: {
                  default: '',
                },
              },

              props: {
                value: {},
                disabled: Boolean,
                min: Number,
                max: Number,
                size: String,
                fill: String,
                textColor: String,
              },

              computed: {
                _elFormItemSize: function _elFormItemSize() {
                  return (this.elFormItem || {}).elFormItemSize;
                },
                checkboxGroupSize: function checkboxGroupSize() {
                  return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
                },
              },

              watch: {
                value: function value(_value) {
                  this.dispatch('ElFormItem', 'el.form.change', [_value]);
                },
              },
            });
            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_checkbox_groupvue_type_script_lang_js_ = (checkbox_groupvue_type_script_lang_js_);
            // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
            const componentNormalizer = __webpack_require__(0);

            // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue

            /* normalize component */

            const component = Object(componentNormalizer['a' /* default */])(
              src_checkbox_groupvue_type_script_lang_js_,
              render,
              staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let api; }
            component.options.__file = 'packages/checkbox/src/checkbox-group.vue';
            /* harmony default export */ const checkbox_group = (component.exports);
            // CONCATENATED MODULE: ./packages/checkbox-group/index.js

            /* istanbul ignore next */
            checkbox_group.install = function (Vue) {
              Vue.component(checkbox_group.name, checkbox_group);
            };

            /* harmony default export */ const packages_checkbox_group = __webpack_exports__.default = (checkbox_group);
            /***/ }),

          /** *** */ }));
      /***/ }),

    /***/ 8119:
    /***/ (function (module, exports, __webpack_require__) {
      __webpack_require__('693d');
      __webpack_require__('dfe5');
      __webpack_require__('301c');
      __webpack_require__('4e71');
      module.exports = __webpack_require__('5524').Symbol;
      /***/ }),

    /***/ 8122:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;
      exports.isEmpty = exports.isEqual = exports.arrayEquals = exports.looseEqual = exports.capitalize = exports.kebabCase = exports.autoprefixer = exports.isFirefox = exports.isEdge = exports.isIE = exports.coerceTruthyValueToArray = exports.arrayFind = exports.arrayFindIndex = exports.escapeRegexpString = exports.valueEquals = exports.generateId = exports.getValueByPath = undefined;

      const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

      exports.noop = noop;
      exports.hasOwn = hasOwn;
      exports.toObject = toObject;
      exports.getPropByPath = getPropByPath;
      exports.rafThrottle = rafThrottle;
      exports.objToArray = objToArray;

      const _vue = __webpack_require__('8bbf');

      const _vue2 = _interopRequireDefault(_vue);

      const _types = __webpack_require__('a742');

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      const { hasOwnProperty } = Object.prototype;

      function noop() {}

      function hasOwn(obj, key) {
        return hasOwnProperty.call(obj, key);
      }

      function extend(to, _from) {
        for (const key in _from) {
          to[key] = _from[key];
        }
        return to;
      }

      function toObject(arr) {
        const res = {};
        for (let i = 0; i < arr.length; i++) {
          if (arr[i]) {
            extend(res, arr[i]);
          }
        }
        return res;
      }

      const getValueByPath = exports.getValueByPath = function getValueByPath(object, prop) {
        prop = prop || '';
        const paths = prop.split('.');
        let current = object;
        let result = null;
        for (let i = 0, j = paths.length; i < j; i++) {
          const path = paths[i];
          if (!current) break;

          if (i === j - 1) {
            result = current[path];
            break;
          }
          current = current[path];
        }
        return result;
      };

      function getPropByPath(obj, path, strict) {
        let tempObj = obj;
        path = path.replace(/\[(\w+)\]/g, '.$1');
        path = path.replace(/^\./, '');

        const keyArr = path.split('.');
        let i = 0;
        for (let len = keyArr.length; i < len - 1; ++i) {
          if (!tempObj && !strict) break;
          const key = keyArr[i];
          if (key in tempObj) {
            tempObj = tempObj[key];
          } else {
            if (strict) {
              throw new Error('please transfer a valid prop path to form item!');
            }
            break;
          }
        }
        return {
          o: tempObj,
          k: keyArr[i],
          v: tempObj ? tempObj[keyArr[i]] : null,
        };
      }

      const generateId = exports.generateId = function generateId() {
        return Math.floor(Math.random() * 10000);
      };

      const valueEquals = exports.valueEquals = function valueEquals(a, b) {
        // see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
        if (a === b) return true;
        if (!(a instanceof Array)) return false;
        if (!(b instanceof Array)) return false;
        if (a.length !== b.length) return false;
        for (let i = 0; i !== a.length; ++i) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      };

      const escapeRegexpString = exports.escapeRegexpString = function escapeRegexpString() {
        const value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        return String(value).replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
      };

      // TODO: use native Array.find, Array.findIndex when IE support is dropped
      const arrayFindIndex = exports.arrayFindIndex = function arrayFindIndex(arr, pred) {
        for (let i = 0; i !== arr.length; ++i) {
          if (pred(arr[i])) {
            return i;
          }
        }
        return -1;
      };

      const arrayFind = exports.arrayFind = function arrayFind(arr, pred) {
        const idx = arrayFindIndex(arr, pred);
        return idx !== -1 ? arr[idx] : undefined;
      };

      // coerce truthy value to array
      const coerceTruthyValueToArray = exports.coerceTruthyValueToArray = function coerceTruthyValueToArray(val) {
        if (Array.isArray(val)) {
          return val;
        } if (val) {
          return [val];
        }
        return [];
      };

      const isIE = exports.isIE = function isIE() {
        return !_vue2.default.prototype.$isServer && !isNaN(Number(document.documentMode));
      };

      const isEdge = exports.isEdge = function isEdge() {
        return !_vue2.default.prototype.$isServer && navigator.userAgent.indexOf('Edge') > -1;
      };

      const isFirefox = exports.isFirefox = function isFirefox() {
        return !_vue2.default.prototype.$isServer && !!window.navigator.userAgent.match(/firefox/i);
      };

      const autoprefixer = exports.autoprefixer = function autoprefixer(style) {
        if ((typeof style === 'undefined' ? 'undefined' : _typeof(style)) !== 'object') return style;
        const rules = ['transform', 'transition', 'animation'];
        const prefixes = ['ms-', 'webkit-'];
        rules.forEach((rule) => {
          const value = style[rule];
          if (rule && value) {
            prefixes.forEach((prefix) => {
              style[prefix + rule] = value;
            });
          }
        });
        return style;
      };

      const kebabCase = exports.kebabCase = function kebabCase(str) {
        const hyphenateRE = /([^-])([A-Z])/g;
        return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
      };

      const capitalize = exports.capitalize = function capitalize(str) {
        if (!(0, _types.isString)(str)) return str;
        return str.charAt(0).toUpperCase() + str.slice(1);
      };

      const looseEqual = exports.looseEqual = function looseEqual(a, b) {
        const isObjectA = (0, _types.isObject)(a);
        const isObjectB = (0, _types.isObject)(b);
        if (isObjectA && isObjectB) {
          return JSON.stringify(a) === JSON.stringify(b);
        } if (!isObjectA && !isObjectB) {
          return String(a) === String(b);
        }
        return false;
      };

      const arrayEquals = exports.arrayEquals = function arrayEquals(arrayA, arrayB) {
        arrayA = arrayA || [];
        arrayB = arrayB || [];

        if (arrayA.length !== arrayB.length) {
          return false;
        }

        for (let i = 0; i < arrayA.length; i++) {
          if (!looseEqual(arrayA[i], arrayB[i])) {
            return false;
          }
        }

        return true;
      };

      const isEqual = exports.isEqual = function isEqual(value1, value2) {
        if (Array.isArray(value1) && Array.isArray(value2)) {
          return arrayEquals(value1, value2);
        }
        return looseEqual(value1, value2);
      };

      const isEmpty = exports.isEmpty = function isEmpty(val) {
        // null or undefined
        if (val == null) return true;

        if (typeof val === 'boolean') return false;

        if (typeof val === 'number') return !val;

        if (val instanceof Error) return val.message === '';

        switch (Object.prototype.toString.call(val)) {
          // String or Array
          case '[object String]':
          case '[object Array]':
            return !val.length;

            // Map or Set or File
          case '[object File]':
          case '[object Map]':
          case '[object Set]':
          {
            return !val.size;
          }
          // Plain Object
          case '[object Object]':
          {
            return !Object.keys(val).length;
          }
        }

        return false;
      };

      function rafThrottle(fn) {
        let locked = false;
        return function () {
          const _this = this;

          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (locked) return;
          locked = true;
          window.requestAnimationFrame((_) => {
            fn.apply(_this, args);
            locked = false;
          });
        };
      }

      function objToArray(obj) {
        if (Array.isArray(obj)) {
          return obj;
        }
        return isEmpty(obj) ? [] : [obj];
      }
      /***/ }),

    /***/ '845f':
    /***/ (function (module, exports, __webpack_require__) {
      module.exports =
        /** *** */ (function (modules) { // webpackBootstrap
          /** *** */ 	// The module cache
          /** *** */ 	const installedModules = {};
          /** *** */
          /** *** */ 	// The require function
          /** *** */ 	function __webpack_require__(moduleId) {
            /** *** */
            /** *** */ 		// Check if module is in cache
            /** *** */ 		if (installedModules[moduleId]) {
              /** *** */ 			return installedModules[moduleId].exports;
              /** *** */ 		}
            /** *** */ 		// Create a new module (and put it into the cache)
            /** *** */ 		const module = installedModules[moduleId] = {
              /** *** */ 			i: moduleId,
              /** *** */ 			l: false,
              /** *** */ 			exports: {},
              /** *** */ 		};
            /** *** */
            /** *** */ 		// Execute the module function
            /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /** *** */
            /** *** */ 		// Flag the module as loaded
            /** *** */ 		module.l = true;
            /** *** */
            /** *** */ 		// Return the exports of the module
            /** *** */ 		return module.exports;
            /** *** */ 	}
          /** *** */
          /** *** */
          /** *** */ 	// expose the modules object (__webpack_modules__)
          /** *** */ 	__webpack_require__.m = modules;
          /** *** */
          /** *** */ 	// expose the module cache
          /** *** */ 	__webpack_require__.c = installedModules;
          /** *** */
          /** *** */ 	// define getter function for harmony exports
          /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
            /** *** */ 		if (!__webpack_require__.o(exports, name)) {
              /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
              /** *** */ 		}
            /** *** */ 	};
          /** *** */
          /** *** */ 	// define __esModule on exports
          /** *** */ 	__webpack_require__.r = function (exports) {
            /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
              /** *** */ 		}
            /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
            /** *** */ 	};
          /** *** */
          /** *** */ 	// create a fake namespace object
          /** *** */ 	// mode & 1: value is a module id, require it
          /** *** */ 	// mode & 2: merge all properties of value into the ns
          /** *** */ 	// mode & 4: return value when already ns object
          /** *** */ 	// mode & 8|1: behave like require
          /** *** */ 	__webpack_require__.t = function (value, mode) {
            /** *** */ 		if (mode & 1) value = __webpack_require__(value);
            /** *** */ 		if (mode & 8) return value;
            /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /** *** */ 		const ns = Object.create(null);
            /** *** */ 		__webpack_require__.r(ns);
            /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
            /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
            /** *** */ 		return ns;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
          /** *** */ 	__webpack_require__.n = function (module) {
            /** *** */ 		const getter = module && module.__esModule
            /** *** */ 			? function getDefault() { return module.default; }
            /** *** */ 			: function getModuleExports() { return module; };
            /** *** */ 		__webpack_require__.d(getter, 'a', getter);
            /** *** */ 		return getter;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// Object.prototype.hasOwnProperty.call
          /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
          /** *** */
          /** *** */ 	// __webpack_public_path__
          /** *** */ 	__webpack_require__.p = '/dist/';
          /** *** */
          /** *** */
          /** *** */ 	// Load entry module and return exports
          /** *** */ 	return __webpack_require__(__webpack_require__.s = 99);
          /** *** */ }({

          /***/ 0:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'a', () => normalizeComponent);
            /* globals __VUE_SSR_CONTEXT__ */

            // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
            // This module is a runtime utility for cleaner component module output and will
            // be included in the final webpack user bundle.

            function normalizeComponent(
              scriptExports,
              render,
              staticRenderFns,
              functionalTemplate,
              injectStyles,
              scopeId,
              moduleIdentifier, /* server only */
              shadowMode, /* vue-cli only */
            ) {
              // Vue.extend constructor export interop
              const options = typeof scriptExports === 'function'
                ? scriptExports.options
                : scriptExports;

              // render functions
              if (render) {
                options.render = render;
                options.staticRenderFns = staticRenderFns;
                options._compiled = true;
              }

              // functional template
              if (functionalTemplate) {
                options.functional = true;
              }

              // scopedId
              if (scopeId) {
                options._scopeId = `data-v-${scopeId}`;
              }

              let hook;
              if (moduleIdentifier) { // server build
                hook = function (context) {
                  // 2.3 injection
                  context = context // cached call
        || (this.$vnode && this.$vnode.ssrContext) // stateful
        || (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
                  // 2.2 with runInNewContext: true
                  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                    context = __VUE_SSR_CONTEXT__;
                  }
                  // inject component styles
                  if (injectStyles) {
                    injectStyles.call(this, context);
                  }
                  // register component module identifier for async chunk inferrence
                  if (context && context._registeredComponents) {
                    context._registeredComponents.add(moduleIdentifier);
                  }
                };
                // used by ssr in case component is cached and beforeCreate
                // never gets called
                options._ssrRegister = hook;
              } else if (injectStyles) {
                hook = shadowMode
                  ? function () { injectStyles.call(this, this.$root.$options.shadowRoot); }
                  : injectStyles;
              }

              if (hook) {
                if (options.functional) {
                  // for template-only hot-reload because in that case the render fn doesn't
                  // go through the normalizer
                  options._injectStyles = hook;
                  // register for functioal component in vue file
                  const originalRender = options.render;
                  options.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context);
                  };
                } else {
                  // inject component registration as beforeCreate hook
                  const existing = options.beforeCreate;
                  options.beforeCreate = existing
                    ? [].concat(existing, hook)
                    : [hook];
                }
              }

              return {
                exports: scriptExports,
                options,
              };
            }
            /***/ }),

          /***/ 99:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button-group.vue?vue&type=template&id=3d8661d0&
            const render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c('div', { staticClass: 'el-button-group' }, [_vm._t('default')], 2);
            };
            const staticRenderFns = [];
            render._withStripped = true;

            // CONCATENATED MODULE: ./packages/button/src/button-group.vue?vue&type=template&id=3d8661d0&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button-group.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //

            /* harmony default export */ const button_groupvue_type_script_lang_js_ = ({
              name: 'ElButtonGroup',
            });
            // CONCATENATED MODULE: ./packages/button/src/button-group.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_button_groupvue_type_script_lang_js_ = (button_groupvue_type_script_lang_js_);
            // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
            const componentNormalizer = __webpack_require__(0);

            // CONCATENATED MODULE: ./packages/button/src/button-group.vue

            /* normalize component */

            const component = Object(componentNormalizer['a' /* default */])(
              src_button_groupvue_type_script_lang_js_,
              render,
              staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let api; }
            component.options.__file = 'packages/button/src/button-group.vue';
            /* harmony default export */ const button_group = (component.exports);
            // CONCATENATED MODULE: ./packages/button-group/index.js

            /* istanbul ignore next */
            button_group.install = function (Vue) {
              Vue.component(button_group.name, button_group);
            };

            /* harmony default export */ const packages_button_group = __webpack_exports__.default = (button_group);
            /***/ }),

          /** *** */ }));
      /***/ }),

    /***/ '85e7':
    /***/ (function (module, exports, __webpack_require__) {
      const dP = __webpack_require__('1a14');
      const anObject = __webpack_require__('77e9');
      const getKeys = __webpack_require__('9876');

      module.exports = __webpack_require__('0bad') ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        const keys = getKeys(Properties);
        const { length } = keys;
        let i = 0;
        let P;
        while (length > i) dP.f(O, P = keys[i++], Properties[P]);
        return O;
      };
      /***/ }),

    /***/ 8875:
    /***/ (function (module, exports, __webpack_require__) {
      let __WEBPACK_AMD_DEFINE_FACTORY__; let __WEBPACK_AMD_DEFINE_ARRAY__; let
        __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
      // MIT license
      // source: https://github.com/amiller-gh/currentScript-polyfill

      // added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

      (function (root, factory) {
        if (true) {
          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
          __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
            ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {}
      }(typeof self !== 'undefined' ? self : this, () => {
        function getCurrentScript() {
          const descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript');
          // for chrome
          if (!descriptor && 'currentScript' in document && document.currentScript) {
            return document.currentScript;
          }

          // for other browsers with native support for currentScript
          if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
            return document.currentScript;
          }

          // IE 8-10 support script readyState
          // IE 11+ & Firefox support stack trace
          try {
            throw new Error();
          } catch (err) {
            // Find the second match for the "at" string to get file src url from stack.
            const ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig;
            const ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig;
            const stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack);
            const scriptLocation = (stackDetails && stackDetails[1]) || false;
            const line = (stackDetails && stackDetails[2]) || false;
            const currentLocation = document.location.href.replace(document.location.hash, '');
            let pageSource;
            let inlineScriptSourceRegExp;
            let inlineScriptSource;
            const scripts = document.getElementsByTagName('script'); // Live NodeList collection

            if (scriptLocation === currentLocation) {
              pageSource = document.documentElement.outerHTML;
              inlineScriptSourceRegExp = new RegExp(`(?:[^\\n]+?\\n){0,${line - 2}}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*`, 'i');
              inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
            }

            for (let i = 0; i < scripts.length; i++) {
              // If ready state is interactive, return the script tag
              if (scripts[i].readyState === 'interactive') {
                return scripts[i];
              }

              // If src matches, return the script tag
              if (scripts[i].src === scriptLocation) {
                return scripts[i];
              }

              // If inline source matches, return the script tag
              if (
                scriptLocation === currentLocation
          && scripts[i].innerHTML
          && scripts[i].innerHTML.trim() === inlineScriptSource
              ) {
                return scripts[i];
              }
            }

            // If no match, return null
            return null;
          }
        }

        return getCurrentScript;
      }));
      /***/ }),

    /***/ '8a0d':
    /***/ (function (module, exports) {
      module.exports = {};
      /***/ }),

    /***/ '8b1a':
    /***/ (function (module, exports) {
      let id = 0;
      const px = Math.random();
      module.exports = function (key) {
        return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
      };
      /***/ }),

    /***/ '8bbc':
    /***/ (function (module, exports, __webpack_require__) {
      module.exports =
        /** *** */ (function (modules) { // webpackBootstrap
          /** *** */ 	// The module cache
          /** *** */ 	const installedModules = {};
          /** *** */
          /** *** */ 	// The require function
          /** *** */ 	function __webpack_require__(moduleId) {
            /** *** */
            /** *** */ 		// Check if module is in cache
            /** *** */ 		if (installedModules[moduleId]) {
              /** *** */ 			return installedModules[moduleId].exports;
              /** *** */ 		}
            /** *** */ 		// Create a new module (and put it into the cache)
            /** *** */ 		const module = installedModules[moduleId] = {
              /** *** */ 			i: moduleId,
              /** *** */ 			l: false,
              /** *** */ 			exports: {},
              /** *** */ 		};
            /** *** */
            /** *** */ 		// Execute the module function
            /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /** *** */
            /** *** */ 		// Flag the module as loaded
            /** *** */ 		module.l = true;
            /** *** */
            /** *** */ 		// Return the exports of the module
            /** *** */ 		return module.exports;
            /** *** */ 	}
          /** *** */
          /** *** */
          /** *** */ 	// expose the modules object (__webpack_modules__)
          /** *** */ 	__webpack_require__.m = modules;
          /** *** */
          /** *** */ 	// expose the module cache
          /** *** */ 	__webpack_require__.c = installedModules;
          /** *** */
          /** *** */ 	// define getter function for harmony exports
          /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
            /** *** */ 		if (!__webpack_require__.o(exports, name)) {
              /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
              /** *** */ 		}
            /** *** */ 	};
          /** *** */
          /** *** */ 	// define __esModule on exports
          /** *** */ 	__webpack_require__.r = function (exports) {
            /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
              /** *** */ 		}
            /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
            /** *** */ 	};
          /** *** */
          /** *** */ 	// create a fake namespace object
          /** *** */ 	// mode & 1: value is a module id, require it
          /** *** */ 	// mode & 2: merge all properties of value into the ns
          /** *** */ 	// mode & 4: return value when already ns object
          /** *** */ 	// mode & 8|1: behave like require
          /** *** */ 	__webpack_require__.t = function (value, mode) {
            /** *** */ 		if (mode & 1) value = __webpack_require__(value);
            /** *** */ 		if (mode & 8) return value;
            /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /** *** */ 		const ns = Object.create(null);
            /** *** */ 		__webpack_require__.r(ns);
            /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
            /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
            /** *** */ 		return ns;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
          /** *** */ 	__webpack_require__.n = function (module) {
            /** *** */ 		const getter = module && module.__esModule
            /** *** */ 			? function getDefault() { return module.default; }
            /** *** */ 			: function getModuleExports() { return module; };
            /** *** */ 		__webpack_require__.d(getter, 'a', getter);
            /** *** */ 		return getter;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// Object.prototype.hasOwnProperty.call
          /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
          /** *** */
          /** *** */ 	// __webpack_public_path__
          /** *** */ 	__webpack_require__.p = '/dist/';
          /** *** */
          /** *** */
          /** *** */ 	// Load entry module and return exports
          /** *** */ 	return __webpack_require__(__webpack_require__.s = 124);
          /** *** */ }({

          /***/ 0:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'a', () => normalizeComponent);
            /* globals __VUE_SSR_CONTEXT__ */

            // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
            // This module is a runtime utility for cleaner component module output and will
            // be included in the final webpack user bundle.

            function normalizeComponent(
              scriptExports,
              render,
              staticRenderFns,
              functionalTemplate,
              injectStyles,
              scopeId,
              moduleIdentifier, /* server only */
              shadowMode, /* vue-cli only */
            ) {
              // Vue.extend constructor export interop
              const options = typeof scriptExports === 'function'
                ? scriptExports.options
                : scriptExports;

              // render functions
              if (render) {
                options.render = render;
                options.staticRenderFns = staticRenderFns;
                options._compiled = true;
              }

              // functional template
              if (functionalTemplate) {
                options.functional = true;
              }

              // scopedId
              if (scopeId) {
                options._scopeId = `data-v-${scopeId}`;
              }

              let hook;
              if (moduleIdentifier) { // server build
                hook = function (context) {
                  // 2.3 injection
                  context = context // cached call
        || (this.$vnode && this.$vnode.ssrContext) // stateful
        || (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
                  // 2.2 with runInNewContext: true
                  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                    context = __VUE_SSR_CONTEXT__;
                  }
                  // inject component styles
                  if (injectStyles) {
                    injectStyles.call(this, context);
                  }
                  // register component module identifier for async chunk inferrence
                  if (context && context._registeredComponents) {
                    context._registeredComponents.add(moduleIdentifier);
                  }
                };
                // used by ssr in case component is cached and beforeCreate
                // never gets called
                options._ssrRegister = hook;
              } else if (injectStyles) {
                hook = shadowMode
                  ? function () { injectStyles.call(this, this.$root.$options.shadowRoot); }
                  : injectStyles;
              }

              if (hook) {
                if (options.functional) {
                  // for template-only hot-reload because in that case the render fn doesn't
                  // go through the normalizer
                  options._injectStyles = hook;
                  // register for functioal component in vue file
                  const originalRender = options.render;
                  options.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context);
                  };
                } else {
                  // inject component registration as beforeCreate hook
                  const existing = options.beforeCreate;
                  options.beforeCreate = existing
                    ? [].concat(existing, hook)
                    : [hook];
                }
              }

              return {
                exports: scriptExports,
                options,
              };
            }
            /***/ }),

          /***/ 124:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tag/src/tag.vue?vue&type=script&lang=js&

            /* harmony default export */ const tagvue_type_script_lang_js_ = ({
              name: 'ElTag',
              props: {
                text: String,
                closable: Boolean,
                type: String,
                hit: Boolean,
                disableTransitions: Boolean,
                color: String,
                size: String,
                effect: {
                  type: String,
                  default: 'light',
                  validator: function validator(val) {
                    return ['dark', 'light', 'plain'].indexOf(val) !== -1;
                  },
                },
              },
              methods: {
                handleClose: function handleClose(event) {
                  event.stopPropagation();
                  this.$emit('close', event);
                },
                handleClick: function handleClick(event) {
                  this.$emit('click', event);
                },
              },
              computed: {
                tagSize: function tagSize() {
                  return this.size || (this.$ELEMENT || {}).size;
                },
              },
              render: function render(h) {
                const { type } = this;
                const { tagSize } = this;
                const { hit } = this;
                const { effect } = this;

                const classes = ['el-tag', type ? `el-tag--${type}` : '', tagSize ? `el-tag--${tagSize}` : '', effect ? `el-tag--${effect}` : '', hit && 'is-hit'];
                const tagEl = h(
                  'span',
                  {
                    class: classes,
                    style: { backgroundColor: this.color },
                    on: {
                      click: this.handleClick,
                    },
                  },
                  [this.$slots.default, this.closable && h('i', {
                    class: 'el-tag__close el-icon-close',
                    on: {
                      click: this.handleClose,
                    },
                  })],
                );

                return this.disableTransitions ? tagEl : h(
                  'transition',
                  {
                    attrs: { name: 'el-zoom-in-center' },
                  },
                  [tagEl],
                );
              },
            });
            // CONCATENATED MODULE: ./packages/tag/src/tag.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_tagvue_type_script_lang_js_ = (tagvue_type_script_lang_js_);
            // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
            const componentNormalizer = __webpack_require__(0);

            // CONCATENATED MODULE: ./packages/tag/src/tag.vue
            let render; let
              staticRenderFns;

            /* normalize component */

            const component = Object(componentNormalizer['a' /* default */])(
              src_tagvue_type_script_lang_js_,
              render,
              staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let api; }
            component.options.__file = 'packages/tag/src/tag.vue';
            /* harmony default export */ const tag = (component.exports);
            // CONCATENATED MODULE: ./packages/tag/index.js

            /* istanbul ignore next */
            tag.install = function (Vue) {
              Vue.component(tag.name, tag);
            };

            /* harmony default export */ const packages_tag = __webpack_exports__.default = (tag);
            /***/ }),

          /** *** */ }));
      /***/ }),

    /***/ '8bbf':
    /***/ (function (module, exports) {
      module.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;
      /***/ }),

    /***/ '8eb7':
    /***/ (function (module, exports) {
      /**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @providesModule UserAgent_DEPRECATED
 */

      /**
 *  Provides entirely client-side User Agent and OS detection. You should prefer
 *  the non-deprecated UserAgent module when possible, which exposes our
 *  authoritative server-side PHP-based detection to the client.
 *
 *  Usage is straightforward:
 *
 *    if (UserAgent_DEPRECATED.ie()) {
 *      //  IE
 *    }
 *
 *  You can also do version checks:
 *
 *    if (UserAgent_DEPRECATED.ie() >= 7) {
 *      //  IE7 or better
 *    }
 *
 *  The browser functions will return NaN if the browser does not match, so
 *  you can also do version compares the other way:
 *
 *    if (UserAgent_DEPRECATED.ie() < 7) {
 *      //  IE6 or worse
 *    }
 *
 *  Note that the version is a float and may include a minor version number,
 *  so you should always use range operators to perform comparisons, not
 *  strict equality.
 *
 *  **Note:** You should **strongly** prefer capability detection to browser
 *  version detection where it's reasonable:
 *
 *    http://www.quirksmode.org/js/support.html
 *
 *  Further, we have a large number of mature wrapper functions and classes
 *  which abstract away many browser irregularities. Check the documentation,
 *  grep for things, or ask on javascript@lists.facebook.com before writing yet
 *  another copy of "event || window.event".
 *
 */

      let _populated = false;

      // Browsers
      let _ie; let _firefox; let _opera; let _webkit; let
        _chrome;

      // Actual IE browser for compatibility mode
      let _ie_real_version;

      // Platforms
      let _osx; let _windows; let _linux; let
        _android;

      // Architectures
      let _win64;

      // Devices
      let _iphone; let _ipad; let
        _native;

      let _mobile;

      function _populate() {
        if (_populated) {
          return;
        }

        _populated = true;

        // To work around buggy JS libraries that can't handle multi-digit
        // version numbers, Opera 10's user agent string claims it's Opera
        // 9, then later includes a Version/X.Y field:
        //
        // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
        const uas = navigator.userAgent;
        let agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
        const os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);

        _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
        _ipad = /\b(iP[ao]d)/.exec(uas);
        _android = /Android/i.exec(uas);
        _native = /FBAN\/\w+;/i.exec(uas);
        _mobile = /Mobile/i.exec(uas);

        // Note that the IE team blog would have you believe you should be checking
        // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
        // from either x64 or ia64;  so ultimately, you should just check for Win64
        // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
        // Windows will send 'WOW64' instead.
        _win64 = !!(/Win64/.exec(uas));

        if (agent) {
          _ie = agent[1] ? parseFloat(agent[1]) : (
            agent[5] ? parseFloat(agent[5]) : NaN);
          // IE compatibility mode
          if (_ie && document && document.documentMode) {
            _ie = document.documentMode;
          }
          // grab the "true" ie version from the trident token if available
          const trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
          _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;

          _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
          _opera = agent[3] ? parseFloat(agent[3]) : NaN;
          _webkit = agent[4] ? parseFloat(agent[4]) : NaN;
          if (_webkit) {
            // We do not add the regexp to the above test, because it will always
            // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
            // the userAgent string.
            agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
            _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
          } else {
            _chrome = NaN;
          }
        } else {
          _ie = _firefox = _opera = _chrome = _webkit = NaN;
        }

        if (os) {
          if (os[1]) {
            // Detect OS X version.  If no version number matches, set _osx to true.
            // Version examples:  10, 10_6_1, 10.7
            // Parses version number as a float, taking only first two sets of
            // digits.  If only one set of digits is found, returns just the major
            // version number.
            const ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);

            _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
          } else {
            _osx = false;
          }
          _windows = !!os[2];
          _linux = !!os[3];
        } else {
          _osx = _windows = _linux = false;
        }
      }

      var UserAgent_DEPRECATED = {

        /**
   *  Check if the UA is Internet Explorer.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
        ie() {
          return _populate() || _ie;
        },

        /**
   * Check if we're in Internet Explorer compatibility mode.
   *
   * @return bool true if in compatibility mode, false if
   * not compatibility mode or not ie
   */
        ieCompatibilityMode() {
          return _populate() || (_ie_real_version > _ie);
        },

        /**
   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
   * only need this because Skype can't handle 64-bit IE yet.  We need to remove
   * this when we don't need it -- tracked by #601957.
   */
        ie64() {
          return UserAgent_DEPRECATED.ie() && _win64;
        },

        /**
   *  Check if the UA is Firefox.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
        firefox() {
          return _populate() || _firefox;
        },

        /**
   *  Check if the UA is Opera.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
        opera() {
          return _populate() || _opera;
        },

        /**
   *  Check if the UA is WebKit.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
        webkit() {
          return _populate() || _webkit;
        },

        /**
   *  For Push
   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
   */
        safari() {
          return UserAgent_DEPRECATED.webkit();
        },

        /**
   *  Check if the UA is a Chrome browser.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
        chrome() {
          return _populate() || _chrome;
        },

        /**
   *  Check if the user is running Windows.
   *
   *  @return bool `true' if the user's OS is Windows.
   */
        windows() {
          return _populate() || _windows;
        },

        /**
   *  Check if the user is running Mac OS X.
   *
   *  @return float|bool   Returns a float if a version number is detected,
   *                       otherwise true/false.
   */
        osx() {
          return _populate() || _osx;
        },

        /**
   * Check if the user is running Linux.
   *
   * @return bool `true' if the user's OS is some flavor of Linux.
   */
        linux() {
          return _populate() || _linux;
        },

        /**
   * Check if the user is running on an iPhone or iPod platform.
   *
   * @return bool `true' if the user is running some flavor of the
   *    iPhone OS.
   */
        iphone() {
          return _populate() || _iphone;
        },

        mobile() {
          return _populate() || (_iphone || _ipad || _android || _mobile);
        },

        nativeApp() {
          // webviews inside of the native apps
          return _populate() || _native;
        },

        android() {
          return _populate() || _android;
        },

        ipad() {
          return _populate() || _ipad;
        },
      };

      module.exports = UserAgent_DEPRECATED;
      /***/ }),

    /***/ 9141:
    /***/ (function (module, exports, __webpack_require__) {
      const { document } = __webpack_require__('ef08');
      module.exports = document && document.documentElement;
      /***/ }),

    /***/ '92f0':
    /***/ (function (module, exports, __webpack_require__) {
      const def = __webpack_require__('1a14').f;
      const has = __webpack_require__('9c0e');
      const TAG = __webpack_require__('cc15')('toStringTag');

      module.exports = function (it, tag, stat) {
        if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
      };
      /***/ }),

    /***/ '92fa':
    /***/ (function (module, exports) {
      const nestRE = /^(attrs|props|on|nativeOn|class|style|hook)$/;

      module.exports = function mergeJSXProps(objs) {
        return objs.reduce((a, b) => {
          let aa; let bb; let key; let nestedKey; let
            temp;
          for (key in b) {
            aa = a[key];
            bb = b[key];
            if (aa && nestRE.test(key)) {
              // normalize class
              if (key === 'class') {
                if (typeof aa === 'string') {
                  temp = aa;
                  a[key] = aa = {};
                  aa[temp] = true;
                }
                if (typeof bb === 'string') {
                  temp = bb;
                  b[key] = bb = {};
                  bb[temp] = true;
                }
              }
              if (key === 'on' || key === 'nativeOn' || key === 'hook') {
                // merge functions
                for (nestedKey in bb) {
                  aa[nestedKey] = mergeFn(aa[nestedKey], bb[nestedKey]);
                }
              } else if (Array.isArray(aa)) {
                a[key] = aa.concat(bb);
              } else if (Array.isArray(bb)) {
                a[key] = [aa].concat(bb);
              } else {
                for (nestedKey in bb) {
                  aa[nestedKey] = bb[nestedKey];
                }
              }
            } else {
              a[key] = b[key];
            }
          }
          return a;
        }, {});
      };

      function mergeFn(a, b) {
        return function () {
          a && a.apply(this, arguments);
          b && b.apply(this, arguments);
        };
      }
      /***/ }),

    /***/ 9619:
    /***/ (function (module, exports, __webpack_require__) {
      const throttle = __webpack_require__('597f');
      const debounce = __webpack_require__('0e15');

      module.exports = {
        throttle,
        debounce,
      };
      /***/ }),

    /***/ 9742:
    /***/ (function (module, exports) {
      // IE 8- don't enum bug keys
      module.exports = (
        'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
      ).split(',');
      /***/ }),

    /***/ 9876:
    /***/ (function (module, exports, __webpack_require__) {
      // 19.1.2.14 / 15.2.3.14 Object.keys(O)
      const $keys = __webpack_require__('03d6');
      const enumBugKeys = __webpack_require__('9742');

      module.exports = Object.keys || function keys(O) {
        return $keys(O, enumBugKeys);
      };
      /***/ }),

    /***/ '9c0c':
    /***/ (function (module, exports, __webpack_require__) {
      // optional / simple context binding
      const aFunction = __webpack_require__('1609');
      module.exports = function (fn, that, length) {
        aFunction(fn);
        if (that === undefined) return fn;
        switch (length) {
          case 1: return function (a) {
            return fn.call(that, a);
          };
          case 2: return function (a, b) {
            return fn.call(that, a, b);
          };
          case 3: return function (a, b, c) {
            return fn.call(that, a, b, c);
          };
        }
        return function (/* ...args */) {
          return fn.apply(that, arguments);
        };
      };
      /***/ }),

    /***/ '9c0e':
    /***/ (function (module, exports) {
      const { hasOwnProperty } = {};
      module.exports = function (it, key) {
        return hasOwnProperty.call(it, key);
      };
      /***/ }),

    /***/ '9d11':
    /***/ (function (module, exports, __webpack_require__) {
      const toInteger = __webpack_require__('fc5e');
      const { max } = Math;
      const { min } = Math;
      module.exports = function (index, length) {
        index = toInteger(index);
        return index < 0 ? max(index + length, 0) : min(index, length);
      };
      /***/ }),

    /***/ '9d7e':
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

      exports.default = function (Vue) {
        /**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */

        function template(string) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          if (args.length === 1 && _typeof(args[0]) === 'object') {
            args = args[0];
          }

          if (!args || !args.hasOwnProperty) {
            args = {};
          }

          return string.replace(RE_NARGS, (match, prefix, i, index) => {
            let result = void 0;

            if (string[index - 1] === '{' && string[index + match.length] === '}') {
              return i;
            }
            result = (0, _util.hasOwn)(args, i) ? args[i] : null;
            if (result === null || result === undefined) {
              return '';
            }

            return result;
          });
        }

        return template;
      };

      var _util = __webpack_require__('8122');

      var RE_NARGS = /(%|)\{([0-9a-zA-Z_]+)\}/g;
      /**
 *  String format template
 *  - Inspired:
 *    https://github.com/Matt-Esch/string-template/index.js
 */
      /***/ }),

    /***/ '9fbb':
    /***/ (function (module, exports, __webpack_require__) {
      // fallback for non-array-like ES3 and non-enumerable old V8 strings
      const cof = __webpack_require__('4d88');
      // eslint-disable-next-line no-prototype-builtins
      module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
        return cof(it) == 'String' ? it.split('') : Object(it);
      };
      /***/ }),

    /***/ a15e:
    /***/ (function (module, __webpack_exports__, __webpack_require__) {
      // ESM COMPAT FLAG
      __webpack_require__.r(__webpack_exports__);

      // EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/extends.js
      const helpers_extends = __webpack_require__('41b2');
      const extends_default = /* #__PURE__ */__webpack_require__.n(helpers_extends);

      // EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/typeof.js
      const helpers_typeof = __webpack_require__('1098');
      const typeof_default = /* #__PURE__ */__webpack_require__.n(helpers_typeof);

      // CONCATENATED MODULE: ./node_modules/async-validator/es/util.js

      const formatRegExp = /%[sdj%]/g;

      const warning = function warning() {};

      // don't print warning message when in production env or node runtime
      if (false) {}

      function format() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        let i = 1;
        const f = args[0];
        const len = args.length;
        if (typeof f === 'function') {
          return f.apply(null, args.slice(1));
        }
        if (typeof f === 'string') {
          let str = String(f).replace(formatRegExp, (x) => {
            if (x === '%%') {
              return '%';
            }
            if (i >= len) {
              return x;
            }
            switch (x) {
              case '%s':
                return String(args[i++]);
              case '%d':
                return Number(args[i++]);
              case '%j':
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return '[Circular]';
                }
                break;
              default:
                return x;
            }
          });
          for (let arg = args[i]; i < len; arg = args[++i]) {
            str += ` ${arg}`;
          }
          return str;
        }
        return f;
      }

      function isNativeStringType(type) {
        return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'pattern';
      }

      function isEmptyValue(value, type) {
        if (value === undefined || value === null) {
          return true;
        }
        if (type === 'array' && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type) && typeof value === 'string' && !value) {
          return true;
        }
        return false;
      }

      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0;
      }

      function asyncParallelArray(arr, func, callback) {
        const results = [];
        let total = 0;
        const arrLength = arr.length;

        function count(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === arrLength) {
            callback(results);
          }
        }

        arr.forEach((a) => {
          func(a, count);
        });
      }

      function asyncSerialArray(arr, func, callback) {
        let index = 0;
        const arrLength = arr.length;

        function next(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          const original = index;
          index += 1;
          if (original < arrLength) {
            func(arr[original], next);
          } else {
            callback([]);
          }
        }

        next([]);
      }

      function flattenObjArr(objArr) {
        const ret = [];
        Object.keys(objArr).forEach((k) => {
          ret.push.apply(ret, objArr[k]);
        });
        return ret;
      }

      function asyncMap(objArr, option, func, callback) {
        if (option.first) {
          const flattenArr = flattenObjArr(objArr);
          return asyncSerialArray(flattenArr, func, callback);
        }
        let firstFields = option.firstFields || [];
        if (firstFields === true) {
          firstFields = Object.keys(objArr);
        }
        const objArrKeys = Object.keys(objArr);
        const objArrLength = objArrKeys.length;
        let total = 0;
        const results = [];
        const next = function next(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
          }
        };
        objArrKeys.forEach((key) => {
          const arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      }

      function complementError(rule) {
        return function (oe) {
          if (oe && oe.message) {
            oe.field = oe.field || rule.fullField;
            return oe;
          }
          return {
            message: oe,
            field: oe.field || rule.fullField,
          };
        };
      }

      function deepMerge(target, source) {
        if (source) {
          for (const s in source) {
            if (source.hasOwnProperty(s)) {
              const value = source[s];
              if ((typeof value === 'undefined' ? 'undefined' : typeof_default()(value)) === 'object' && typeof_default()(target[s]) === 'object') {
                target[s] = extends_default()({}, target[s], value);
              } else {
                target[s] = value;
              }
            }
          }
        }
        return target;
      }
      // CONCATENATED MODULE: ./node_modules/async-validator/es/rule/required.js

      /**
 *  Rule for validating required fields.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function required(rule, value, source, errors, options, type) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
          errors.push(format(options.messages.required, rule.fullField));
        }
      }

      /* harmony default export */ const rule_required = (required);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/rule/whitespace.js

      /**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function whitespace(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === '') {
          errors.push(format(options.messages.whitespace, rule.fullField));
        }
      }

      /* harmony default export */ const rule_whitespace = (whitespace);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/rule/type.js

      /* eslint max-len:0 */

      const pattern = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
        url: new RegExp('^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$', 'i'),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
      };

      var types = {
        integer: function integer(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        float: function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array(value) {
          return Array.isArray(value);
        },
        regexp: function regexp(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e) {
            return false;
          }
        },
        date: function date(value) {
          return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function';
        },
        number: function number(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === 'number';
        },
        object: function object(value) {
          return (typeof value === 'undefined' ? 'undefined' : typeof_default()(value)) === 'object' && !types.array(value);
        },
        method: function method(value) {
          return typeof value === 'function';
        },
        email: function email(value) {
          return typeof value === 'string' && !!value.match(pattern.email) && value.length < 255;
        },
        url: function url(value) {
          return typeof value === 'string' && !!value.match(pattern.url);
        },
        hex: function hex(value) {
          return typeof value === 'string' && !!value.match(pattern.hex);
        },
      };

      /**
 *  Rule for validating the type of a value.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function type_type(rule, value, source, errors, options) {
        if (rule.required && value === undefined) {
          rule_required(rule, value, source, errors, options);
          return;
        }
        const custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
        const ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
          }
          // straight typeof check
        } else if (ruleType && (typeof value === 'undefined' ? 'undefined' : typeof_default()(value)) !== rule.type) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      }

      /* harmony default export */ const rule_type = (type_type);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/rule/range.js

      /**
 *  Rule for validating minimum and maximum allowed values.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function range(rule, value, source, errors, options) {
        const len = typeof rule.len === 'number';
        const min = typeof rule.min === 'number';
        const max = typeof rule.max === 'number';
        // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）
        const spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        let val = value;
        let key = null;
        const num = typeof value === 'number';
        const str = typeof value === 'string';
        const arr = Array.isArray(value);
        if (num) {
          key = 'number';
        } else if (str) {
          key = 'string';
        } else if (arr) {
          key = 'array';
        }
        // if the value is not of a supported type for range validation
        // the validation rule rule should use the
        // type property to also test for a particular type
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          // 处理码点大于U+010000的文字length属性不准确的bug，如"𠮷𠮷𠮷".lenght !== 3
          val = value.replace(spRegexp, '_').length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format(options.messages[key].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format(options.messages[key].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      }

      /* harmony default export */ const rule_range = (range);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/rule/enum.js

      const ENUM = 'enum';

      /**
 *  Rule for validating a value exists in an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function enumerable(rule, value, source, errors, options) {
        rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];
        if (rule[ENUM].indexOf(value) === -1) {
          errors.push(format(options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')));
        }
      }

      /* harmony default export */ const rule_enum = (enumerable);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/rule/pattern.js

      /**
 *  Rule for validating a regular expression pattern.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function pattern_pattern(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            // if a RegExp instance is passed, reset `lastIndex` in case its `global`
            // flag is accidentally set to `true`, which in a validation scenario
            // is not necessary and the result might be misleading
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === 'string') {
            const _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      }

      /* harmony default export */ const rule_pattern = (pattern_pattern);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/rule/index.js

      /* harmony default export */ const es_rule = ({
        required: rule_required,
        whitespace: rule_whitespace,
        type: rule_type,
        range: rule_range,
        enum: rule_enum,
        pattern: rule_pattern,
      });
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/string.js

      /**
 *  Performs validation for string types.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function string(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, 'string') && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options, 'string');
          if (!isEmptyValue(value, 'string')) {
            es_rule.type(rule, value, source, errors, options);
            es_rule.range(rule, value, source, errors, options);
            es_rule.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              es_rule.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_string = (string);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/method.js

      /**
 *  Validates a function.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function method(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options);
          if (value !== undefined) {
            es_rule.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_method = (method);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/number.js

      /**
 *  Validates a number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function number(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options);
          if (value !== undefined) {
            es_rule.type(rule, value, source, errors, options);
            es_rule.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_number = (number);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/boolean.js

      /**
 *  Validates a boolean.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function boolean_boolean(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options);
          if (value !== undefined) {
            es_rule.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_boolean = (boolean_boolean);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/regexp.js

      /**
 *  Validates the regular expression type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function regexp(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            es_rule.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_regexp = (regexp);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/integer.js

      /**
 *  Validates a number is an integer.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function integer(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options);
          if (value !== undefined) {
            es_rule.type(rule, value, source, errors, options);
            es_rule.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_integer = (integer);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/float.js

      /**
 *  Validates a number is a floating point number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function floatFn(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options);
          if (value !== undefined) {
            es_rule.type(rule, value, source, errors, options);
            es_rule.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_float = (floatFn);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/array.js

      /**
 *  Validates an array.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function array(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, 'array') && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options, 'array');
          if (!isEmptyValue(value, 'array')) {
            es_rule.type(rule, value, source, errors, options);
            es_rule.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_array = (array);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/object.js

      /**
 *  Validates an object.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function object_object(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options);
          if (value !== undefined) {
            es_rule.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_object = (object_object);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/enum.js

      const enum_ENUM = 'enum';

      /**
 *  Validates an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function enum_enumerable(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options);
          if (value) {
            es_rule[enum_ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_enum = (enum_enumerable);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/pattern.js

      /**
 *  Validates a regular expression pattern.
 *
 *  Performs validation when a rule only contains
 *  a pattern property but is not declared as a string type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
      function validator_pattern_pattern(rule, value, callback, source, options) {
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, 'string') && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, 'string')) {
            es_rule.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_pattern = (validator_pattern_pattern);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/date.js

      function date(rule, value, callback, source, options) {
        // console.log('integer rule called %j', rule);
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        // console.log('validate on %s value', value);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            let dateObject = void 0;

            if (typeof value === 'number') {
              dateObject = new Date(value);
            } else {
              dateObject = value;
            }

            es_rule.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              es_rule.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_date = (date);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/required.js

      function required_required(rule, value, callback, source, options) {
        const errors = [];
        const type = Array.isArray(value) ? 'array' : typeof value === 'undefined' ? 'undefined' : typeof_default()(value);
        es_rule.required(rule, value, source, errors, options, type);
        callback(errors);
      }

      /* harmony default export */ const validator_required = (required_required);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/type.js

      function validator_type_type(rule, value, callback, source, options) {
        const ruleType = rule.type;
        const errors = [];
        const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          es_rule.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            es_rule.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      }

      /* harmony default export */ const validator_type = (validator_type_type);
      // CONCATENATED MODULE: ./node_modules/async-validator/es/validator/index.js

      /* harmony default export */ const es_validator = ({
        string: validator_string,
        method: validator_method,
        number: validator_number,
        boolean: validator_boolean,
        regexp: validator_regexp,
        integer: validator_integer,
        float: validator_float,
        array: validator_array,
        object: validator_object,
        enum: validator_enum,
        pattern: validator_pattern,
        date: validator_date,
        url: validator_type,
        hex: validator_type,
        email: validator_type,
        required: validator_required,
      });
      // CONCATENATED MODULE: ./node_modules/async-validator/es/messages.js
      function newMessages() {
        return {
          default: 'Validation error on field %s',
          required: '%s is required',
          enum: '%s must be one of %s',
          whitespace: '%s cannot be empty',
          date: {
            format: '%s date %s is invalid for format %s',
            parse: '%s date could not be parsed, %s is invalid ',
            invalid: '%s date %s is invalid',
          },
          types: {
            string: '%s is not a %s',
            method: '%s is not a %s (function)',
            array: '%s is not an %s',
            object: '%s is not an %s',
            number: '%s is not a %s',
            date: '%s is not a %s',
            boolean: '%s is not a %s',
            integer: '%s is not an %s',
            float: '%s is not a %s',
            regexp: '%s is not a valid %s',
            email: '%s is not a valid %s',
            url: '%s is not a valid %s',
            hex: '%s is not a valid %s',
          },
          string: {
            len: '%s must be exactly %s characters',
            min: '%s must be at least %s characters',
            max: '%s cannot be longer than %s characters',
            range: '%s must be between %s and %s characters',
          },
          number: {
            len: '%s must equal %s',
            min: '%s cannot be less than %s',
            max: '%s cannot be greater than %s',
            range: '%s must be between %s and %s',
          },
          array: {
            len: '%s must be exactly %s in length',
            min: '%s cannot be less than %s in length',
            max: '%s cannot be greater than %s in length',
            range: '%s must be between %s and %s in length',
          },
          pattern: {
            mismatch: '%s value %s does not match pattern %s',
          },
          clone: function clone() {
            const cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          },
        };
      }

      const messages_messages = newMessages();
      // CONCATENATED MODULE: ./node_modules/async-validator/es/index.js

      /**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */
      function Schema(descriptor) {
        this.rules = null;
        this._messages = messages_messages;
        this.define(descriptor);
      }

      Schema.prototype = {
        messages: function messages(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        },
        define: function define(rules) {
          if (!rules) {
            throw new Error('Cannot configure a schema with no rules');
          }
          if ((typeof rules === 'undefined' ? 'undefined' : typeof_default()(rules)) !== 'object' || Array.isArray(rules)) {
            throw new Error('Rules must be an object');
          }
          this.rules = {};
          let z = void 0;
          let item = void 0;
          for (z in rules) {
            if (rules.hasOwnProperty(z)) {
              item = rules[z];
              this.rules[z] = Array.isArray(item) ? item : [item];
            }
          }
        },
        validate: function validate(source_) {
          const _this = this;

          const o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          const oc = arguments[2];

          let source = source_;
          let options = o;
          let callback = oc;
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback();
            }
            return;
          }
          function complete(results) {
            let i = void 0;
            let field = void 0;
            let errors = [];
            let fields = {};

            function add(e) {
              if (Array.isArray(e)) {
                errors = errors.concat.apply(errors, e);
              } else {
                errors.push(e);
              }
            }

            for (i = 0; i < results.length; i++) {
              add(results[i]);
            }
            if (!errors.length) {
              errors = null;
              fields = null;
            } else {
              for (i = 0; i < errors.length; i++) {
                field = errors[i].field;
                fields[field] = fields[field] || [];
                fields[field].push(errors[i]);
              }
            }
            callback(errors, fields);
          }

          if (options.messages) {
            let messages = this.messages();
            if (messages === messages_messages) {
              messages = newMessages();
            }
            deepMerge(messages, options.messages);
            options.messages = messages;
          } else {
            options.messages = this.messages();
          }
          let arr = void 0;
          let value = void 0;
          const series = {};
          const keys = options.keys || Object.keys(this.rules);
          keys.forEach((z) => {
            arr = _this.rules[z];
            value = source[z];
            arr.forEach((r) => {
              let rule = r;
              if (typeof rule.transform === 'function') {
                if (source === source_) {
                  source = extends_default()({}, source);
                }
                value = source[z] = rule.transform(value);
              }
              if (typeof rule === 'function') {
                rule = {
                  validator: rule,
                };
              } else {
                rule = extends_default()({}, rule);
              }
              rule.validator = _this.getValidationMethod(rule);
              rule.field = z;
              rule.fullField = rule.fullField || z;
              rule.type = _this.getType(rule);
              if (!rule.validator) {
                return;
              }
              series[z] = series[z] || [];
              series[z].push({
                rule,
                value,
                source,
                field: z,
              });
            });
          });
          const errorFields = {};
          asyncMap(series, options, (data, doIt) => {
            const { rule } = data;
            let deep = (rule.type === 'object' || rule.type === 'array') && (typeof_default()(rule.fields) === 'object' || typeof_default()(rule.defaultField) === 'object');
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullfield(key, schema) {
              return extends_default()({}, schema, {
                fullField: `${rule.fullField}.${key}`,
              });
            }

            function cb() {
              const e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

              let errors = e;
              if (!Array.isArray(errors)) {
                errors = [errors];
              }
              if (errors.length) {
                warning('async-validator:', errors);
              }
              if (errors.length && rule.message) {
                errors = [].concat(rule.message);
              }

              errors = errors.map(complementError(rule));

              if (options.first && errors.length) {
                errorFields[rule.field] = 1;
                return doIt(errors);
              }
              if (!deep) {
                doIt(errors);
              } else {
                // if rule is required but the target object
                // does not exist fail at the rule level and don't
                // go deeper
                if (rule.required && !data.value) {
                  if (rule.message) {
                    errors = [].concat(rule.message).map(complementError(rule));
                  } else if (options.error) {
                    errors = [options.error(rule, format(options.messages.required, rule.field))];
                  } else {
                    errors = [];
                  }
                  return doIt(errors);
                }

                let fieldsSchema = {};
                if (rule.defaultField) {
                  for (const k in data.value) {
                    if (data.value.hasOwnProperty(k)) {
                      fieldsSchema[k] = rule.defaultField;
                    }
                  }
                }
                fieldsSchema = extends_default()({}, fieldsSchema, data.rule.fields);
                for (const f in fieldsSchema) {
                  if (fieldsSchema.hasOwnProperty(f)) {
                    const fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
                    fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
                  }
                }
                const schema = new Schema(fieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, (errs) => {
                  doIt(errs && errs.length ? errors.concat(errs) : errs);
                });
              }
            }

            const res = rule.validator(rule, data.value, cb, data.source, options);
            if (res && res.then) {
              res.then(() => cb(), (e) => cb(e));
            }
          }, (results) => {
            complete(results);
          });
        },
        getType: function getType(rule) {
          if (rule.type === undefined && rule.pattern instanceof RegExp) {
            rule.type = 'pattern';
          }
          if (typeof rule.validator !== 'function' && rule.type && !es_validator.hasOwnProperty(rule.type)) {
            throw new Error(format('Unknown rule type %s', rule.type));
          }
          return rule.type || 'string';
        },
        getValidationMethod: function getValidationMethod(rule) {
          if (typeof rule.validator === 'function') {
            return rule.validator;
          }
          const keys = Object.keys(rule);
          const messageIndex = keys.indexOf('message');
          if (messageIndex !== -1) {
            keys.splice(messageIndex, 1);
          }
          if (keys.length === 1 && keys[0] === 'required') {
            return es_validator.required;
          }
          return es_validator[this.getType(rule)] || false;
        },
      };

      Schema.register = function register(type, validator) {
        if (typeof validator !== 'function') {
          throw new Error('Cannot register a validator by type, validator is not a function');
        }
        es_validator[type] = validator;
      };

      Schema.messages = messages_messages;

      /* harmony default export */ const es = __webpack_exports__.default = (Schema);
      /***/ }),

    /***/ a3de:
    /***/ (function (module, exports, __webpack_require__) {
      /**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

      /* jslint evil: true */

      const canUseDOM = !!(
        typeof window !== 'undefined'
  && window.document
  && window.document.createElement
      );

      /**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
      const ExecutionEnvironment = {

        canUseDOM,

        canUseWorkers: typeof Worker !== 'undefined',

        canUseEventListeners:
    canUseDOM && !!(window.addEventListener || window.attachEvent),

        canUseViewport: canUseDOM && !!window.screen,

        isInWorker: !canUseDOM, // For now, this is true - might change in the future.

      };

      module.exports = ExecutionEnvironment;
      /***/ }),

    /***/ a742:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;
      exports.isString = isString;
      exports.isObject = isObject;
      exports.isHtmlElement = isHtmlElement;
      function isString(obj) {
        return Object.prototype.toString.call(obj) === '[object String]';
      }

      function isObject(obj) {
        return Object.prototype.toString.call(obj) === '[object Object]';
      }

      function isHtmlElement(node) {
        return node && node.nodeType === Node.ELEMENT_NODE;
      }

      const isFunction = exports.isFunction = function isFunction(functionToCheck) {
        const getType = {};
        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
      };

      const isUndefined = exports.isUndefined = function isUndefined(val) {
        return val === void 0;
      };

      const isDefined = exports.isDefined = function isDefined(val) {
        return val !== undefined && val !== null;
      };
      /***/ }),

    /***/ b367:
    /***/ (function (module, exports, __webpack_require__) {
      const core = __webpack_require__('5524');
      const global = __webpack_require__('ef08');
      const SHARED = '__core-js_shared__';
      const store = global[SHARED] || (global[SHARED] = {});

      (module.exports = function (key, value) {
        return store[key] || (store[key] = value !== undefined ? value : {});
      })('versions', []).push({
        version: core.version,
        mode: __webpack_require__('e444') ? 'pure' : 'global',
        copyright: '© 2020 Denis Pushkarev (zloirock.ru)',
      });
      /***/ }),

    /***/ b449:
    /***/ (function (module, exports, __webpack_require__) {

      // extracted by mini-css-extract-plugin

      /***/ }),

    /***/ b9c7:
    /***/ (function (module, exports, __webpack_require__) {
      __webpack_require__('e507');
      module.exports = __webpack_require__('5524').Object.assign;
      /***/ }),

    /***/ ba01:
    /***/ (function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__('051b');
      /***/ }),

    /***/ c098:
    /***/ (function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__('d4af');
      /***/ }),

    /***/ c284:
    /***/ (function (module, exports, __webpack_require__) {
      module.exports =
        /** *** */ (function (modules) { // webpackBootstrap
          /** *** */ 	// The module cache
          /** *** */ 	const installedModules = {};
          /** *** */
          /** *** */ 	// The require function
          /** *** */ 	function __webpack_require__(moduleId) {
            /** *** */
            /** *** */ 		// Check if module is in cache
            /** *** */ 		if (installedModules[moduleId]) {
              /** *** */ 			return installedModules[moduleId].exports;
              /** *** */ 		}
            /** *** */ 		// Create a new module (and put it into the cache)
            /** *** */ 		const module = installedModules[moduleId] = {
              /** *** */ 			i: moduleId,
              /** *** */ 			l: false,
              /** *** */ 			exports: {},
              /** *** */ 		};
            /** *** */
            /** *** */ 		// Execute the module function
            /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /** *** */
            /** *** */ 		// Flag the module as loaded
            /** *** */ 		module.l = true;
            /** *** */
            /** *** */ 		// Return the exports of the module
            /** *** */ 		return module.exports;
            /** *** */ 	}
          /** *** */
          /** *** */
          /** *** */ 	// expose the modules object (__webpack_modules__)
          /** *** */ 	__webpack_require__.m = modules;
          /** *** */
          /** *** */ 	// expose the module cache
          /** *** */ 	__webpack_require__.c = installedModules;
          /** *** */
          /** *** */ 	// define getter function for harmony exports
          /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
            /** *** */ 		if (!__webpack_require__.o(exports, name)) {
              /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
              /** *** */ 		}
            /** *** */ 	};
          /** *** */
          /** *** */ 	// define __esModule on exports
          /** *** */ 	__webpack_require__.r = function (exports) {
            /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
              /** *** */ 		}
            /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
            /** *** */ 	};
          /** *** */
          /** *** */ 	// create a fake namespace object
          /** *** */ 	// mode & 1: value is a module id, require it
          /** *** */ 	// mode & 2: merge all properties of value into the ns
          /** *** */ 	// mode & 4: return value when already ns object
          /** *** */ 	// mode & 8|1: behave like require
          /** *** */ 	__webpack_require__.t = function (value, mode) {
            /** *** */ 		if (mode & 1) value = __webpack_require__(value);
            /** *** */ 		if (mode & 8) return value;
            /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /** *** */ 		const ns = Object.create(null);
            /** *** */ 		__webpack_require__.r(ns);
            /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
            /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
            /** *** */ 		return ns;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
          /** *** */ 	__webpack_require__.n = function (module) {
            /** *** */ 		const getter = module && module.__esModule
            /** *** */ 			? function getDefault() { return module.default; }
            /** *** */ 			: function getModuleExports() { return module; };
            /** *** */ 		__webpack_require__.d(getter, 'a', getter);
            /** *** */ 		return getter;
            /** *** */ 	};
          /** *** */
          /** *** */ 	// Object.prototype.hasOwnProperty.call
          /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
          /** *** */
          /** *** */ 	// __webpack_public_path__
          /** *** */ 	__webpack_require__.p = '/dist/';
          /** *** */
          /** *** */
          /** *** */ 	// Load entry module and return exports
          /** *** */ 	return __webpack_require__(__webpack_require__.s = 119);
          /** *** */ }({

          /***/ 0:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'a', () => normalizeComponent);
            /* globals __VUE_SSR_CONTEXT__ */

            // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
            // This module is a runtime utility for cleaner component module output and will
            // be included in the final webpack user bundle.

            function normalizeComponent(
              scriptExports,
              render,
              staticRenderFns,
              functionalTemplate,
              injectStyles,
              scopeId,
              moduleIdentifier, /* server only */
              shadowMode, /* vue-cli only */
            ) {
              // Vue.extend constructor export interop
              const options = typeof scriptExports === 'function'
                ? scriptExports.options
                : scriptExports;

              // render functions
              if (render) {
                options.render = render;
                options.staticRenderFns = staticRenderFns;
                options._compiled = true;
              }

              // functional template
              if (functionalTemplate) {
                options.functional = true;
              }

              // scopedId
              if (scopeId) {
                options._scopeId = `data-v-${scopeId}`;
              }

              let hook;
              if (moduleIdentifier) { // server build
                hook = function (context) {
                  // 2.3 injection
                  context = context // cached call
        || (this.$vnode && this.$vnode.ssrContext) // stateful
        || (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
                  // 2.2 with runInNewContext: true
                  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                    context = __VUE_SSR_CONTEXT__;
                  }
                  // inject component styles
                  if (injectStyles) {
                    injectStyles.call(this, context);
                  }
                  // register component module identifier for async chunk inferrence
                  if (context && context._registeredComponents) {
                    context._registeredComponents.add(moduleIdentifier);
                  }
                };
                // used by ssr in case component is cached and beforeCreate
                // never gets called
                options._ssrRegister = hook;
              } else if (injectStyles) {
                hook = shadowMode
                  ? function () { injectStyles.call(this, this.$root.$options.shadowRoot); }
                  : injectStyles;
              }

              if (hook) {
                if (options.functional) {
                  // for template-only hot-reload because in that case the render fn doesn't
                  // go through the normalizer
                  options._injectStyles = hook;
                  // register for functioal component in vue file
                  const originalRender = options.render;
                  options.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context);
                  };
                } else {
                  // inject component registration as beforeCreate hook
                  const existing = options.beforeCreate;
                  options.beforeCreate = existing
                    ? [].concat(existing, hook)
                    : [hook];
                }
              }

              return {
                exports: scriptExports,
                options,
              };
            }
            /***/ }),

          /***/ 119:
          /***/ (function (module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);

            // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/progress/src/progress.vue?vue&type=template&id=229ee406&
            const render = function () {
              const _vm = this;
              const _h = _vm.$createElement;
              const _c = _vm._self._c || _h;
              return _c(
                'div',
                {
                  staticClass: 'el-progress',
                  class: [
                    `el-progress--${_vm.type}`,
                    _vm.status ? `is-${_vm.status}` : '',
                    {
                      'el-progress--without-text': !_vm.showText,
                      'el-progress--text-inside': _vm.textInside,
                    },
                  ],
                  attrs: {
                    role: 'progressbar',
                    'aria-valuenow': _vm.percentage,
                    'aria-valuemin': '0',
                    'aria-valuemax': '100',
                  },
                },
                [
                  _vm.type === 'line'
                    ? _c('div', { staticClass: 'el-progress-bar' }, [
                      _c(
                        'div',
                        {
                          staticClass: 'el-progress-bar__outer',
                          style: { height: `${_vm.strokeWidth}px` },
                        },
                        [
                          _c(
                            'div',
                            {
                              staticClass: 'el-progress-bar__inner',
                              style: _vm.barStyle,
                            },
                            [
                              _vm.showText && _vm.textInside
                                ? _c(
                                  'div',
                                  { staticClass: 'el-progress-bar__innerText' },
                                  [_vm._v(_vm._s(_vm.content))],
                                )
                                : _vm._e(),
                            ],
                          ),
                        ],
                      ),
                    ])
                    : _c(
                      'div',
                      {
                        staticClass: 'el-progress-circle',
                        style: { height: `${_vm.width}px`, width: `${_vm.width}px` },
                      },
                      [
                        _c('svg', { attrs: { viewBox: '0 0 100 100' } }, [
                          _c('path', {
                            staticClass: 'el-progress-circle__track',
                            style: _vm.trailPathStyle,
                            attrs: {
                              d: _vm.trackPath,
                              stroke: '#e5e9f2',
                              'stroke-width': _vm.relativeStrokeWidth,
                              fill: 'none',
                            },
                          }),
                          _c('path', {
                            staticClass: 'el-progress-circle__path',
                            style: _vm.circlePathStyle,
                            attrs: {
                              d: _vm.trackPath,
                              stroke: _vm.stroke,
                              fill: 'none',
                              'stroke-linecap': _vm.strokeLinecap,
                              'stroke-width': _vm.percentage ? _vm.relativeStrokeWidth : 0,
                            },
                          }),
                        ]),
                      ],
                    ),
                  _vm.showText && !_vm.textInside
                    ? _c(
                      'div',
                      {
                        staticClass: 'el-progress__text',
                        style: { fontSize: `${_vm.progressTextSize}px` },
                      },
                      [
                        !_vm.status
                          ? [_vm._v(_vm._s(_vm.content))]
                          : _c('i', { class: _vm.iconClass }),
                      ],
                      2,
                    )
                    : _vm._e(),
                ],
              );
            };
            const staticRenderFns = [];
            render._withStripped = true;

            // CONCATENATED MODULE: ./packages/progress/src/progress.vue?vue&type=template&id=229ee406&

            // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/progress/src/progress.vue?vue&type=script&lang=js&
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //
            //

            /* harmony default export */ const progressvue_type_script_lang_js_ = ({
              name: 'ElProgress',
              props: {
                type: {
                  type: String,
                  default: 'line',
                  validator: function validator(val) {
                    return ['line', 'circle', 'dashboard'].indexOf(val) > -1;
                  },
                },
                percentage: {
                  type: Number,
                  default: 0,
                  required: true,
                  validator: function validator(val) {
                    return val >= 0 && val <= 100;
                  },
                },
                status: {
                  type: String,
                  validator: function validator(val) {
                    return ['success', 'exception', 'warning'].indexOf(val) > -1;
                  },
                },
                strokeWidth: {
                  type: Number,
                  default: 6,
                },
                strokeLinecap: {
                  type: String,
                  default: 'round',
                },
                textInside: {
                  type: Boolean,
                  default: false,
                },
                width: {
                  type: Number,
                  default: 126,
                },
                showText: {
                  type: Boolean,
                  default: true,
                },
                color: {
                  type: [String, Array, Function],
                  default: '',
                },
                format: Function,
              },
              computed: {
                barStyle: function barStyle() {
                  const style = {};
                  style.width = `${this.percentage}%`;
                  style.backgroundColor = this.getCurrentColor(this.percentage);
                  return style;
                },
                relativeStrokeWidth: function relativeStrokeWidth() {
                  return (this.strokeWidth / this.width * 100).toFixed(1);
                },
                radius: function radius() {
                  if (this.type === 'circle' || this.type === 'dashboard') {
                    return parseInt(50 - parseFloat(this.relativeStrokeWidth) / 2, 10);
                  }
                  return 0;
                },
                trackPath: function trackPath() {
                  const { radius } = this;
                  const isDashboard = this.type === 'dashboard';
                  return `\n        M 50 50\n        m 0 ${isDashboard ? '' : '-'}${radius}\n        a ${radius} ${radius} 0 1 1 0 ${isDashboard ? '-' : ''}${radius * 2}\n        a ${radius} ${radius} 0 1 1 0 ${isDashboard ? '' : '-'}${radius * 2}\n        `;
                },
                perimeter: function perimeter() {
                  return 2 * Math.PI * this.radius;
                },
                rate: function rate() {
                  return this.type === 'dashboard' ? 0.75 : 1;
                },
                strokeDashoffset: function strokeDashoffset() {
                  const offset = -1 * this.perimeter * (1 - this.rate) / 2;
                  return `${offset}px`;
                },
                trailPathStyle: function trailPathStyle() {
                  return {
                    strokeDasharray: `${this.perimeter * this.rate}px, ${this.perimeter}px`,
                    strokeDashoffset: this.strokeDashoffset,
                  };
                },
                circlePathStyle: function circlePathStyle() {
                  return {
                    strokeDasharray: `${this.perimeter * this.rate * (this.percentage / 100)}px, ${this.perimeter}px`,
                    strokeDashoffset: this.strokeDashoffset,
                    transition: 'stroke-dasharray 0.6s ease 0s, stroke 0.6s ease',
                  };
                },
                stroke: function stroke() {
                  let ret = void 0;
                  if (this.color) {
                    ret = this.getCurrentColor(this.percentage);
                  } else {
                    switch (this.status) {
                      case 'success':
                        ret = '#13ce66';
                        break;
                      case 'exception':
                        ret = '#ff4949';
                        break;
                      case 'warning':
                        ret = '#e6a23c';
                        break;
                      default:
                        ret = '#20a0ff';
                    }
                  }
                  return ret;
                },
                iconClass: function iconClass() {
                  if (this.status === 'warning') {
                    return 'el-icon-warning';
                  }
                  if (this.type === 'line') {
                    return this.status === 'success' ? 'el-icon-circle-check' : 'el-icon-circle-close';
                  }
                  return this.status === 'success' ? 'el-icon-check' : 'el-icon-close';
                },
                progressTextSize: function progressTextSize() {
                  return this.type === 'line' ? 12 + this.strokeWidth * 0.4 : this.width * 0.111111 + 2;
                },
                content: function content() {
                  if (typeof this.format === 'function') {
                    return this.format(this.percentage) || '';
                  }
                  return `${this.percentage}%`;
                },
              },
              methods: {
                getCurrentColor: function getCurrentColor(percentage) {
                  if (typeof this.color === 'function') {
                    return this.color(percentage);
                  } if (typeof this.color === 'string') {
                    return this.color;
                  }
                  return this.getLevelColor(percentage);
                },
                getLevelColor: function getLevelColor(percentage) {
                  const colorArray = this.getColorArray().sort((a, b) => a.percentage - b.percentage);

                  for (let i = 0; i < colorArray.length; i++) {
                    if (colorArray[i].percentage > percentage) {
                      return colorArray[i].color;
                    }
                  }
                  return colorArray[colorArray.length - 1].color;
                },
                getColorArray: function getColorArray() {
                  const { color } = this;
                  const span = 100 / color.length;
                  return color.map((seriesColor, index) => {
                    if (typeof seriesColor === 'string') {
                      return {
                        color: seriesColor,
                        percentage: (index + 1) * span,
                      };
                    }
                    return seriesColor;
                  });
                },
              },
            });
            // CONCATENATED MODULE: ./packages/progress/src/progress.vue?vue&type=script&lang=js&
            /* harmony default export */ const src_progressvue_type_script_lang_js_ = (progressvue_type_script_lang_js_);
            // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
            const componentNormalizer = __webpack_require__(0);

            // CONCATENATED MODULE: ./packages/progress/src/progress.vue

            /* normalize component */

            const component = Object(componentNormalizer['a' /* default */])(
              src_progressvue_type_script_lang_js_,
              render,
              staticRenderFns,
              false,
              null,
              null,
              null,

            );

            /* hot reload */
            if (false) { let api; }
            component.options.__file = 'packages/progress/src/progress.vue';
            /* harmony default export */ const progress = (component.exports);
            // CONCATENATED MODULE: ./packages/progress/index.js

            /* istanbul ignore next */
            progress.install = function (Vue) {
              Vue.component(progress.name, progress);
            };

            /* harmony default export */ const packages_progress = __webpack_exports__.default = (progress);
            /***/ }),

          /** *** */ }));
      /***/ }),

    /***/ c56a:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;

      exports.default = function (instance, callback) {
        const speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;
        const once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        if (!instance || !callback) throw new Error('instance & callback is required');
        let called = false;
        const afterLeaveCallback = function afterLeaveCallback() {
          if (called) return;
          called = true;
          if (callback) {
            callback.apply(null, arguments);
          }
        };
        if (once) {
          instance.$once('after-leave', afterLeaveCallback);
        } else {
          instance.$on('after-leave', afterLeaveCallback);
        }
        setTimeout(() => {
          afterLeaveCallback();
        }, speed + 100);
      };

      /**
   * Bind after-leave event for vue instance. Make sure after-leave is called in any browsers.
   *
   * @param {Vue} instance Vue instance.
   * @param {Function} callback callback of after-leave event
   * @param {Number} speed the speed of transition, default value is 300ms
   * @param {Boolean} once weather bind after-leave once. default value is false.
   */
      /***/ }),

    /***/ c8ba:
    /***/ (function (module, exports) {
      let g;

      // This works in non-strict mode
      g = (function () {
        return this;
      }());

      try {
        // This works if eval is allowed (see CSP)
        g = g || new Function('return this')();
      } catch (e) {
        // This works if the window reference is available
        if (typeof window === 'object') g = window;
      }

      // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}

      module.exports = g;
      /***/ }),

    /***/ c901:
    /***/ (function (module, exports) {
      // 7.2.1 RequireObjectCoercible(argument)
      module.exports = function (it) {
        if (it == undefined) throw TypeError(`Can't call method on  ${it}`);
        return it;
      };
      /***/ }),

    /***/ cc15:
    /***/ (function (module, exports, __webpack_require__) {
      const store = __webpack_require__('b367')('wks');
      const uid = __webpack_require__('8b1a');
      const { Symbol } = __webpack_require__('ef08');
      const USE_SYMBOL = typeof Symbol === 'function';

      const $exports = module.exports = function (name) {
        return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)(`Symbol.${name}`));
      };

      $exports.store = store;
      /***/ }),

    /***/ ce7a:
    /***/ (function (module, exports, __webpack_require__) {
      // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
      const has = __webpack_require__('9c0e');
      const toObject = __webpack_require__('0983');
      const IE_PROTO = __webpack_require__('5a94')('IE_PROTO');
      const ObjectProto = Object.prototype;

      module.exports = Object.getPrototypeOf || function (O) {
        O = toObject(O);
        if (has(O, IE_PROTO)) return O[IE_PROTO];
        if (typeof O.constructor === 'function' && O instanceof O.constructor) {
          return O.constructor.prototype;
        } return O instanceof Object ? ObjectProto : null;
      };
      /***/ }),

    /***/ d010:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;
      function _broadcast(componentName, eventName, params) {
        this.$children.forEach((child) => {
          const name = child.$options.componentName;

          if (name === componentName) {
            child.$emit.apply(child, [eventName].concat(params));
          } else {
            _broadcast.apply(child, [componentName, eventName].concat([params]));
          }
        });
      }
      exports.default = {
        methods: {
          dispatch: function dispatch(componentName, eventName, params) {
            let parent = this.$parent || this.$root;
            let name = parent.$options.componentName;

            while (parent && (!name || name !== componentName)) {
              parent = parent.$parent;

              if (parent) {
                name = parent.$options.componentName;
              }
            }
            if (parent) {
              parent.$emit.apply(parent, [eventName].concat(params));
            }
          },
          broadcast: function broadcast(componentName, eventName, params) {
            _broadcast.call(this, componentName, eventName, params);
          },
        },
      };
      /***/ }),

    /***/ d16a:
    /***/ (function (module, exports, __webpack_require__) {
      // 7.1.15 ToLength
      const toInteger = __webpack_require__('fc5e');
      const { min } = Math;
      module.exports = function (it) {
        return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
      };
      /***/ }),

    /***/ d397:
    /***/ (function (module, exports, __webpack_require__) {
      exports.__esModule = true;
      exports.isDef = isDef;
      exports.isKorean = isKorean;
      function isDef(val) {
        return val !== undefined && val !== null;
      }
      function isKorean(text) {
        const reg = /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi;
        return reg.test(text);
      }
      /***/ }),

    /***/ d4af:
    /***/ (function (module, exports, __webpack_require__) {
      /**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule normalizeWheel
 * @typechecks
 */

      const UserAgent_DEPRECATED = __webpack_require__('8eb7');

      const isEventSupported = __webpack_require__('7b3e');

      // Reasonable defaults
      const PIXEL_STEP = 10;
      const LINE_HEIGHT = 40;
      const PAGE_HEIGHT = 800;

      /**
 * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
 * complicated, thus this doc is long and (hopefully) detailed enough to answer
 * your questions.
 *
 * If you need to react to the mouse wheel in a predictable way, this code is
 * like your bestest friend. * hugs *
 *
 * As of today, there are 4 DOM event types you can listen to:
 *
 *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
 *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
 *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
 *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
 *
 * So what to do?  The is the best:
 *
 *   normalizeWheel.getEventType();
 *
 * In your event callback, use this code to get sane interpretation of the
 * deltas.  This code will return an object with properties:
 *
 *   spinX   -- normalized spin speed (use for zoom) - x plane
 *   spinY   -- " - y plane
 *   pixelX  -- normalized distance (to pixels) - x plane
 *   pixelY  -- " - y plane
 *
 * Wheel values are provided by the browser assuming you are using the wheel to
 * scroll a web page by a number of lines or pixels (or pages).  Values can vary
 * significantly on different platforms and browsers, forgetting that you can
 * scroll at different speeds.  Some devices (like trackpads) emit more events
 * at smaller increments with fine granularity, and some emit massive jumps with
 * linear speed or acceleration.
 *
 * This code does its best to normalize the deltas for you:
 *
 *   - spin is trying to normalize how far the wheel was spun (or trackpad
 *     dragged).  This is super useful for zoom support where you want to
 *     throw away the chunky scroll steps on the PC and make those equal to
 *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
 *     resolve a single slow step on a wheel to 1.
 *
 *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
 *     get the crazy differences between browsers, but at least it'll be in
 *     pixels!
 *
 *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
 *     should translate to positive value zooming IN, negative zooming OUT.
 *     This matches the newer 'wheel' event.
 *
 * Why are there spinX, spinY (or pixels)?
 *
 *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
 *     with a mouse.  It results in side-scrolling in the browser by default.
 *
 *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
 *
 *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
 *     probably is by browsers in conjunction with fancy 3D controllers .. but
 *     you know.
 *
 * Implementation info:
 *
 * Examples of 'wheel' event if you scroll slowly (down) by one step with an
 * average mouse:
 *
 *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
 *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
 *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
 *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
 *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
 *
 * On the trackpad:
 *
 *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
 *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
 *
 * On other/older browsers.. it's more complicated as there can be multiple and
 * also missing delta values.
 *
 * The 'wheel' event is more standard:
 *
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
 *
 * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
 * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
 * backward compatibility with older events.  Those other values help us
 * better normalize spin speed.  Example of what the browsers provide:
 *
 *                          | event.wheelDelta | event.detail
 *        ------------------+------------------+--------------
 *          Safari v5/OS X  |       -120       |       0
 *          Safari v5/Win7  |       -120       |       0
 *         Chrome v17/OS X  |       -120       |       0
 *         Chrome v17/Win7  |       -120       |       0
 *                IE9/Win7  |       -120       |   undefined
 *         Firefox v4/OS X  |     undefined    |       1
 *         Firefox v4/Win7  |     undefined    |       3
 *
 */
      function normalizeWheel(/* object */ event) /* object */ {
        let sX = 0; let sY = 0; // spinX, spinY
        let pX = 0; let
          pY = 0; // pixelX, pixelY

        // Legacy
        if ('detail' in event) { sY = event.detail; }
        if ('wheelDelta' in event) { sY = -event.wheelDelta / 120; }
        if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
        if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

        // side scrolling on FF with DOMMouseScroll
        if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
          sX = sY;
          sY = 0;
        }

        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;

        if ('deltaY' in event) { pY = event.deltaY; }
        if ('deltaX' in event) { pX = event.deltaX; }

        if ((pX || pY) && event.deltaMode) {
          if (event.deltaMode == 1) { // delta in LINE units
            pX *= LINE_HEIGHT;
            pY *= LINE_HEIGHT;
          } else { // delta in PAGE units
            pX *= PAGE_HEIGHT;
            pY *= PAGE_HEIGHT;
          }
        }

        // Fall-back if spin cannot be determined
        if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
        if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

        return {
          spinX: sX,
          spinY: sY,
          pixelX: pX,
          pixelY: pY,
        };
      }

      /**
 * The best combination if you prefer spinX + spinY normalization.  It favors
 * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
 * 'wheel' event, making spin speed determination impossible.
 */
      normalizeWheel.getEventType = function () /* string */ {
        return (UserAgent_DEPRECATED.firefox())
          ? 'DOMMouseScroll'
          : (isEventSupported('wheel'))
            ? 'wheel'
            : 'mousewheel';
      };

      module.exports = normalizeWheel;
      /***/ }),

    /***/ d7d1:
    /***/ (function (module, exports, __webpack_require__) {
      let __WEBPACK_AMD_DEFINE_RESULT__;

      /* Modified from https://github.com/taylorhakes/fecha
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Taylor Hakes
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 *     The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*eslint-disable*/
// 把 YYYY-MM-DD 改成了 yyyy-MM-dd
(function (main) {
  'use strict';

  /**
   * Parse or format dates
   * @class fecha
   */

  var fecha = {};
  var token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = '\\d\\d?';
  var threeDigits = '\\d{3}';
  var fourDigits = '\\d{4}';
  var word = '[^\\s]+';
  var literal = /\[([^]*?)\]/gm;
  var noop = function noop() {};

  function regexEscape(str) {
    return str.replace(/[|\\{()[^$+*?.-]/g, '\\$&');
  }

  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }

  function monthUpdate(arrName) {
    return function (d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
      if (~index) {
        d.month = index;
      }
    };
  }

  function pad(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  }

  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };

  var formatFlags = {
    D: function D(dateObj) {
      return dateObj.getDay();
    },
    DD: function DD(dateObj) {
      return pad(dateObj.getDay());
    },
    Do: function Do(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function d(dateObj) {
      return dateObj.getDate();
    },
    dd: function dd(dateObj) {
      return pad(dateObj.getDate());
    },
    ddd: function ddd(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function dddd(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function M(dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function MM(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function MMM(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function MMMM(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    yy: function yy(dateObj) {
      return pad(String(dateObj.getFullYear()), 4).substr(2);
    },
    yyyy: function yyyy(dateObj) {
      return pad(dateObj.getFullYear(), 4);
    },
    h: function h(dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function hh(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function H(dateObj) {
      return dateObj.getHours();
    },
    HH: function HH(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function m(dateObj) {
      return dateObj.getMinutes();
    },
    mm: function mm(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function s(dateObj) {
      return dateObj.getSeconds();
    },
    ss: function ss(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function S(dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function SS(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function SSS(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function a(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function A(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function ZZ(dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };

  var parseFlags = {
    d: [twoDigits, function (d, v) {
      d.day = v;
    }],
    Do: [twoDigits + word, function (d, v) {
      d.day = parseInt(v, 10);
    }],
    M: [twoDigits, function (d, v) {
      d.month = v - 1;
    }],
    yy: [twoDigits, function (d, v) {
      var da = new Date(),
          cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function (d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function (d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function (d, v) {
      d.second = v;
    }],
    yyyy: [fourDigits, function (d, v) {
      d.year = v;
    }],
    S: ['\\d', function (d, v) {
      d.millisecond = v * 100;
    }],
    SS: ['\\d{2}', function (d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function (d, v) {
      d.millisecond = v;
    }],
    D: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function (d, v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: ['[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z', function (d, v) {
      var parts = (v + '').match(/([+-]|\d\d)/gi),
          minutes;

      if (parts) {
        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.dd = parseFlags.d;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.DD = parseFlags.D;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a;

  // Some common format strings
  fecha.masks = {
    default: 'ddd MMM dd yyyy HH:mm:ss',
    shortDate: 'M/D/yy',
    mediumDate: 'MMM d, yyyy',
    longDate: 'MMMM d, yyyy',
    fullDate: 'dddd, MMMM d, yyyy',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };

  /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   */
  fecha.format = function (dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }

    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw new Error('Invalid Date in fecha.format');
    }

    mask = fecha.masks[mask] || mask || fecha.masks['default'];

    var literals = [];

    // Make literals inactive by replacing them with ??
    mask = mask.replace(literal, function ($0, $1) {
      literals.push($1);
      return '@@@';
    });
    // Apply formatting rules
    mask = mask.replace(token, function ($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    });
    // Inline literal values back into the formatted value
    return mask.replace(/@@@/g, function () {
      return literals.shift();
    });
  };

  /**
   * Parse a date string into an object, changes - into /
   * @method parse
   * @param {string} dateStr Date string
   * @param {string} format Date parse format
   * @returns {Date|boolean}
   */
  fecha.parse = function (dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof format !== 'string') {
      throw new Error('Invalid format in fecha.parse');
    }

    format = fecha.masks[format] || format;

    // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
    if (dateStr.length > 1000) {
      return null;
    }

    var dateInfo = {};
    var parseInfo = [];
    var literals = [];
    format = format.replace(literal, function ($0, $1) {
      literals.push($1);
      return '@@@';
    });
    var newFormat = regexEscape(format).replace(token, function ($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        parseInfo.push(info[1]);
        return '(' + info[0] + ')';
      }

      return $0;
    });
    newFormat = newFormat.replace(/@@@/g, function () {
      return literals.shift();
    });
    var matches = dateStr.match(new RegExp(newFormat, 'i'));
    if (!matches) {
      return null;
    }

    for (var i = 1; i < matches.length; i++) {
      parseInfo[i - 1](dateInfo, matches[i], i18n);
    }

    var today = new Date();
    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }

    var date;
    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }
    return date;
  };

  /* istanbul ignore next */
  if ( true && module.exports) {
    module.exports = fecha;
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return fecha;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(undefined);

/***/ }),

/***/ "d940":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.validateRangeInOneMonth = exports.extractTimeFormat = exports.extractDateFormat = exports.nextYear = exports.prevYear = exports.nextMonth = exports.prevMonth = exports.changeYearMonthAndClampDate = exports.timeWithinRange = exports.limitTimeRange = exports.clearMilliseconds = exports.clearTime = exports.modifyWithTimeString = exports.modifyTime = exports.modifyDate = exports.range = exports.getRangeMinutes = exports.getMonthDays = exports.getPrevMonthLastDays = exports.getRangeHours = exports.getWeekNumber = exports.getStartDateOfMonth = exports.nextDate = exports.prevDate = exports.getFirstDayOfMonth = exports.getDayCountOfYear = exports.getDayCountOfMonth = exports.parseDate = exports.formatDate = exports.isDateObject = exports.isDate = exports.toDate = exports.getI18nSettings = undefined;

var _date = __webpack_require__("d7d1");

var _date2 = _interopRequireDefault(_date);

var _locale = __webpack_require__("4897");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var weeks = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
var months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];

var newArray = function newArray(start, end) {
  var result = [];
  for (var i = start; i <= end; i++) {
    result.push(i);
  }
  return result;
};

var getI18nSettings = exports.getI18nSettings = function getI18nSettings() {
  return {
    dayNamesShort: weeks.map(function (week) {
      return (0, _locale.t)('el.datepicker.weeks.' + week);
    }),
    dayNames: weeks.map(function (week) {
      return (0, _locale.t)('el.datepicker.weeks.' + week);
    }),
    monthNamesShort: months.map(function (month) {
      return (0, _locale.t)('el.datepicker.months.' + month);
    }),
    monthNames: months.map(function (month, index) {
      return (0, _locale.t)('el.datepicker.month' + (index + 1));
    }),
    amPm: ['am', 'pm']
  };
};

var toDate = exports.toDate = function toDate(date) {
  return isDate(date) ? new Date(date) : null;
};

var isDate = exports.isDate = function isDate(date) {
  if (date === null || date === undefined) return false;
  if (isNaN(new Date(date).getTime())) return false;
  if (Array.isArray(date)) return false; // deal with `new Date([ new Date() ]) -> new Date()`
  return true;
};

var isDateObject = exports.isDateObject = function isDateObject(val) {
  return val instanceof Date;
};

var formatDate = exports.formatDate = function formatDate(date, format) {
  date = toDate(date);
  if (!date) return '';
  return _date2.default.format(date, format || 'yyyy-MM-dd', getI18nSettings());
};

var parseDate = exports.parseDate = function parseDate(string, format) {
  return _date2.default.parse(string, format || 'yyyy-MM-dd', getI18nSettings());
};

var getDayCountOfMonth = exports.getDayCountOfMonth = function getDayCountOfMonth(year, month) {
  if (month === 3 || month === 5 || month === 8 || month === 10) {
    return 30;
  }

  if (month === 1) {
    if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
      return 29;
    } else {
      return 28;
    }
  }

  return 31;
};

var getDayCountOfYear = exports.getDayCountOfYear = function getDayCountOfYear(year) {
  var isLeapYear = year % 400 === 0 || year % 100 !== 0 && year % 4 === 0;
  return isLeapYear ? 366 : 365;
};

var getFirstDayOfMonth = exports.getFirstDayOfMonth = function getFirstDayOfMonth(date) {
  var temp = new Date(date.getTime());
  temp.setDate(1);
  return temp.getDay();
};

// see: https://stackoverflow.com/questions/3674539/incrementing-a-date-in-javascript
// {prev, next} Date should work for Daylight Saving Time
// Adding 24 * 60 * 60 * 1000 does not work in the above scenario
var prevDate = exports.prevDate = function prevDate(date) {
  var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return new Date(date.getFullYear(), date.getMonth(), date.getDate() - amount);
};

var nextDate = exports.nextDate = function nextDate(date) {
  var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return new Date(date.getFullYear(), date.getMonth(), date.getDate() + amount);
};

var getStartDateOfMonth = exports.getStartDateOfMonth = function getStartDateOfMonth(year, month) {
  var result = new Date(year, month, 1);
  var day = result.getDay();

  if (day === 0) {
    return prevDate(result, 7);
  } else {
    return prevDate(result, day);
  }
};

var getWeekNumber = exports.getWeekNumber = function getWeekNumber(src) {
  if (!isDate(src)) return null;
  var date = new Date(src.getTime());
  date.setHours(0, 0, 0, 0);
  // Thursday in current week decides the year.
  date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
  // January 4 is always in week 1.
  var week1 = new Date(date.getFullYear(), 0, 4);
  // Adjust to Thursday in week 1 and count number of weeks from date to week 1.
  // Rounding should be fine for Daylight Saving Time. Its shift should never be more than 12 hours.
  return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
};

var getRangeHours = exports.getRangeHours = function getRangeHours(ranges) {
  var hours = [];
  var disabledHours = [];

  (ranges || []).forEach(function (range) {
    var value = range.map(function (date) {
      return date.getHours();
    });

    disabledHours = disabledHours.concat(newArray(value[0], value[1]));
  });

  if (disabledHours.length) {
    for (var i = 0; i < 24; i++) {
      hours[i] = disabledHours.indexOf(i) === -1;
    }
  } else {
    for (var _i = 0; _i < 24; _i++) {
      hours[_i] = false;
    }
  }

  return hours;
};

var getPrevMonthLastDays = exports.getPrevMonthLastDays = function getPrevMonthLastDays(date, amount) {
  if (amount <= 0) return [];
  var temp = new Date(date.getTime());
  temp.setDate(0);
  var lastDay = temp.getDate();
  return range(amount).map(function (_, index) {
    return lastDay - (amount - index - 1);
  });
};

var getMonthDays = exports.getMonthDays = function getMonthDays(date) {
  var temp = new Date(date.getFullYear(), date.getMonth() + 1, 0);
  var days = temp.getDate();
  return range(days).map(function (_, index) {
    return index + 1;
  });
};

function setRangeData(arr, start, end, value) {
  for (var i = start; i < end; i++) {
    arr[i] = value;
  }
}

var getRangeMinutes = exports.getRangeMinutes = function getRangeMinutes(ranges, hour) {
  var minutes = new Array(60);

  if (ranges.length > 0) {
    ranges.forEach(function (range) {
      var start = range[0];
      var end = range[1];
      var startHour = start.getHours();
      var startMinute = start.getMinutes();
      var endHour = end.getHours();
      var endMinute = end.getMinutes();
      if (startHour === hour && endHour !== hour) {
        setRangeData(minutes, startMinute, 60, true);
      } else if (startHour === hour && endHour === hour) {
        setRangeData(minutes, startMinute, endMinute + 1, true);
      } else if (startHour !== hour && endHour === hour) {
        setRangeData(minutes, 0, endMinute + 1, true);
      } else if (startHour < hour && endHour > hour) {
        setRangeData(minutes, 0, 60, true);
      }
    });
  } else {
    setRangeData(minutes, 0, 60, true);
  }
  return minutes;
};

var range = exports.range = function range(n) {
  // see https://stackoverflow.com/questions/3746725/create-a-javascript-array-containing-1-n
  return Array.apply(null, { length: n }).map(function (_, n) {
    return n;
  });
};

var modifyDate = exports.modifyDate = function modifyDate(date, y, m, d) {
  return new Date(y, m, d, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
};

var modifyTime = exports.modifyTime = function modifyTime(date, h, m, s) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), h, m, s, date.getMilliseconds());
};

var modifyWithTimeString = exports.modifyWithTimeString = function modifyWithTimeString(date, time) {
  if (date == null || !time) {
    return date;
  }
  time = parseDate(time, 'HH:mm:ss');
  return modifyTime(date, time.getHours(), time.getMinutes(), time.getSeconds());
};

var clearTime = exports.clearTime = function clearTime(date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate());
};

var clearMilliseconds = exports.clearMilliseconds = function clearMilliseconds(date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0);
};

var limitTimeRange = exports.limitTimeRange = function limitTimeRange(date, ranges) {
  var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'HH:mm:ss';

  // TODO: refactory a more elegant solution
  if (ranges.length === 0) return date;
  var normalizeDate = function normalizeDate(date) {
    return _date2.default.parse(_date2.default.format(date, format), format);
  };
  var ndate = normalizeDate(date);
  var nranges = ranges.map(function (range) {
    return range.map(normalizeDate);
  });
  if (nranges.some(function (nrange) {
    return ndate >= nrange[0] && ndate <= nrange[1];
  })) return date;

  var minDate = nranges[0][0];
  var maxDate = nranges[0][0];

  nranges.forEach(function (nrange) {
    minDate = new Date(Math.min(nrange[0], minDate));
    maxDate = new Date(Math.max(nrange[1], minDate));
  });

  var ret = ndate < minDate ? minDate : maxDate;
  // preserve Year/Month/Date
  return modifyDate(ret, date.getFullYear(), date.getMonth(), date.getDate());
};

var timeWithinRange = exports.timeWithinRange = function timeWithinRange(date, selectableRange, format) {
  var limitedDate = limitTimeRange(date, selectableRange, format);
  return limitedDate.getTime() === date.getTime();
};

var changeYearMonthAndClampDate = exports.changeYearMonthAndClampDate = function changeYearMonthAndClampDate(date, year, month) {
  // clamp date to the number of days in `year`, `month`
  // eg: (2010-1-31, 2010, 2) => 2010-2-28
  var monthDate = Math.min(date.getDate(), getDayCountOfMonth(year, month));
  return modifyDate(date, year, month, monthDate);
};

var prevMonth = exports.prevMonth = function prevMonth(date) {
  var year = date.getFullYear();
  var month = date.getMonth();
  return month === 0 ? changeYearMonthAndClampDate(date, year - 1, 11) : changeYearMonthAndClampDate(date, year, month - 1);
};

var nextMonth = exports.nextMonth = function nextMonth(date) {
  var year = date.getFullYear();
  var month = date.getMonth();
  return month === 11 ? changeYearMonthAndClampDate(date, year + 1, 0) : changeYearMonthAndClampDate(date, year, month + 1);
};

var prevYear = exports.prevYear = function prevYear(date) {
  var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  var year = date.getFullYear();
  var month = date.getMonth();
  return changeYearMonthAndClampDate(date, year - amount, month);
};

var nextYear = exports.nextYear = function nextYear(date) {
  var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  var year = date.getFullYear();
  var month = date.getMonth();
  return changeYearMonthAndClampDate(date, year + amount, month);
};

var extractDateFormat = exports.extractDateFormat = function extractDateFormat(format) {
  return format.replace(/\W?m{1,2}|\W?ZZ/g, '').replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, '').trim();
};

var extractTimeFormat = exports.extractTimeFormat = function extractTimeFormat(format) {
  return format.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?y{2,4}/g, '').trim();
};

var validateRangeInOneMonth = exports.validateRangeInOneMonth = function validateRangeInOneMonth(start, end) {
  return start.getMonth() === end.getMonth() && start.getFullYear() === end.getFullYear();
};

/***/ }),

/***/ "dcdc":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 83);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 4:
/***/ (function(module, exports) {

module.exports = __webpack_require__("d010");

/***/ }),

/***/ 83:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox.vue?vue&type=template&id=d0387074&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "label",
    {
      staticClass: "el-checkbox",
      class: [
        _vm.border && _vm.checkboxSize
          ? "el-checkbox--" + _vm.checkboxSize
          : "",
        { "is-disabled": _vm.isDisabled },
        { "is-bordered": _vm.border },
        { "is-checked": _vm.isChecked }
      ],
      attrs: { id: _vm.id }
    },
    [
      _c(
        "span",
        {
          staticClass: "el-checkbox__input",
          class: {
            "is-disabled": _vm.isDisabled,
            "is-checked": _vm.isChecked,
            "is-indeterminate": _vm.indeterminate,
            "is-focus": _vm.focus
          },
          attrs: {
            tabindex: _vm.indeterminate ? 0 : false,
            role: _vm.indeterminate ? "checkbox" : false,
            "aria-checked": _vm.indeterminate ? "mixed" : false
          }
        },
        [
          _c("span", { staticClass: "el-checkbox__inner" }),
          _vm.trueLabel || _vm.falseLabel
            ? _c("input", {
                directives: [
                  {
                    name: "model",
                    rawName: "v-model",
                    value: _vm.model,
                    expression: "model"
                  }
                ],
                staticClass: "el-checkbox__original",
                attrs: {
                  type: "checkbox",
                  "aria-hidden": _vm.indeterminate ? "true" : "false",
                  name: _vm.name,
                  disabled: _vm.isDisabled,
                  "true-value": _vm.trueLabel,
                  "false-value": _vm.falseLabel
                },
                domProps: {
                  checked: Array.isArray(_vm.model)
                    ? _vm._i(_vm.model, null) > -1
                    : _vm._q(_vm.model, _vm.trueLabel)
                },
                on: {
                  change: [
                    function($event) {
                      var $$a = _vm.model,
                        $$el = $event.target,
                        $$c = $$el.checked ? _vm.trueLabel : _vm.falseLabel
                      if (Array.isArray($$a)) {
                        var $$v = null,
                          $$i = _vm._i($$a, $$v)
                        if ($$el.checked) {
                          $$i < 0 && (_vm.model = $$a.concat([$$v]))
                        } else {
                          $$i > -1 &&
                            (_vm.model = $$a
                              .slice(0, $$i)
                              .concat($$a.slice($$i + 1)))
                        }
                      } else {
                        _vm.model = $$c
                      }
                    },
                    _vm.handleChange
                  ],
                  focus: function($event) {
                    _vm.focus = true
                  },
                  blur: function($event) {
                    _vm.focus = false
                  }
                }
              })
            : _c("input", {
                directives: [
                  {
                    name: "model",
                    rawName: "v-model",
                    value: _vm.model,
                    expression: "model"
                  }
                ],
                staticClass: "el-checkbox__original",
                attrs: {
                  type: "checkbox",
                  "aria-hidden": _vm.indeterminate ? "true" : "false",
                  disabled: _vm.isDisabled,
                  name: _vm.name
                },
                domProps: {
                  value: _vm.label,
                  checked: Array.isArray(_vm.model)
                    ? _vm._i(_vm.model, _vm.label) > -1
                    : _vm.model
                },
                on: {
                  change: [
                    function($event) {
                      var $$a = _vm.model,
                        $$el = $event.target,
                        $$c = $$el.checked ? true : false
                      if (Array.isArray($$a)) {
                        var $$v = _vm.label,
                          $$i = _vm._i($$a, $$v)
                        if ($$el.checked) {
                          $$i < 0 && (_vm.model = $$a.concat([$$v]))
                        } else {
                          $$i > -1 &&
                            (_vm.model = $$a
                              .slice(0, $$i)
                              .concat($$a.slice($$i + 1)))
                        }
                      } else {
                        _vm.model = $$c
                      }
                    },
                    _vm.handleChange
                  ],
                  focus: function($event) {
                    _vm.focus = true
                  },
                  blur: function($event) {
                    _vm.focus = false
                  }
                }
              })
        ]
      ),
      _vm.$slots.default || _vm.label
        ? _c(
            "span",
            { staticClass: "el-checkbox__label" },
            [
              _vm._t("default"),
              !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e()
            ],
            2
          )
        : _vm._e()
    ]
  )
}
var staticRenderFns = []
render._withStripped = true


// CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue?vue&type=template&id=d0387074&

// EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"
var emitter_ = __webpack_require__(4);
var emitter_default = /*#__PURE__*/__webpack_require__.n(emitter_);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var checkboxvue_type_script_lang_js_ = ({
  name: 'ElCheckbox',

  mixins: [emitter_default.a],

  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },

  componentName: 'ElCheckbox',

  data: function data() {
    return {
      selfModel: false,
      focus: false,
      isLimitExceeded: false
    };
  },


  computed: {
    model: {
      get: function get() {
        return this.isGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
      },
      set: function set(val) {
        if (this.isGroup) {
          this.isLimitExceeded = false;
          this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (this.isLimitExceeded = true);

          this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (this.isLimitExceeded = true);

          this.isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
        } else {
          this.$emit('input', val);
          this.selfModel = val;
        }
      }
    },

    isChecked: function isChecked() {
      if ({}.toString.call(this.model) === '[object Boolean]') {
        return this.model;
      } else if (Array.isArray(this.model)) {
        return this.model.indexOf(this.label) > -1;
      } else if (this.model !== null && this.model !== undefined) {
        return this.model === this.trueLabel;
      }
    },
    isGroup: function isGroup() {
      var parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElCheckboxGroup') {
          parent = parent.$parent;
        } else {
          this._checkboxGroup = parent;
          return true;
        }
      }
      return false;
    },
    store: function store() {
      return this._checkboxGroup ? this._checkboxGroup.value : this.value;
    },


    /* used to make the isDisabled judgment under max/min props */
    isLimitDisabled: function isLimitDisabled() {
      var _checkboxGroup = this._checkboxGroup,
          max = _checkboxGroup.max,
          min = _checkboxGroup.min;

      return !!(max || min) && this.model.length >= max && !this.isChecked || this.model.length <= min && this.isChecked;
    },
    isDisabled: function isDisabled() {
      return this.isGroup ? this._checkboxGroup.disabled || this.disabled || (this.elForm || {}).disabled || this.isLimitDisabled : this.disabled || (this.elForm || {}).disabled;
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    checkboxSize: function checkboxSize() {
      var temCheckboxSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
      return this.isGroup ? this._checkboxGroup.checkboxGroupSize || temCheckboxSize : temCheckboxSize;
    }
  },

  props: {
    value: {},
    label: {},
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: String,
    trueLabel: [String, Number],
    falseLabel: [String, Number],
    id: String, /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*/
    controls: String, /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*/
    border: Boolean,
    size: String
  },

  methods: {
    addToStore: function addToStore() {
      if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
        this.model.push(this.label);
      } else {
        this.model = this.trueLabel || true;
      }
    },
    handleChange: function handleChange(ev) {
      var _this = this;

      if (this.isLimitExceeded) return;
      var value = void 0;
      if (ev.target.checked) {
        value = this.trueLabel === undefined ? true : this.trueLabel;
      } else {
        value = this.falseLabel === undefined ? false : this.falseLabel;
      }
      this.$emit('change', value, ev);
      this.$nextTick(function () {
        if (_this.isGroup) {
          _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
        }
      });
    }
  },

  created: function created() {
    this.checked && this.addToStore();
  },
  mounted: function mounted() {
    // 为indeterminate元素 添加aria-controls 属性
    if (this.indeterminate) {
      this.$el.setAttribute('aria-controls', this.controls);
    }
  },


  watch: {
    value: function value(_value) {
      this.dispatch('ElFormItem', 'el.form.change', _value);
    }
  }
});
// CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_checkboxvue_type_script_lang_js_ = (checkboxvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(0);

// CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  src_checkboxvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/checkbox/src/checkbox.vue"
/* harmony default export */ var src_checkbox = (component.exports);
// CONCATENATED MODULE: ./packages/checkbox/index.js


/* istanbul ignore next */
src_checkbox.install = function (Vue) {
  Vue.component(src_checkbox.name, src_checkbox);
};

/* harmony default export */ var packages_checkbox = __webpack_exports__["default"] = (src_checkbox);

/***/ })

/******/ });

/***/ }),

/***/ "dfe5":
/***/ (function(module, exports) {



/***/ }),

/***/ "e198":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("ef08");
var core = __webpack_require__("5524");
var LIBRARY = __webpack_require__("e444");
var wksExt = __webpack_require__("fcd4");
var defineProperty = __webpack_require__("1a14").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "e34a":
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__("8b1a")('meta');
var isObject = __webpack_require__("7a41");
var has = __webpack_require__("9c0e");
var setDesc = __webpack_require__("1a14").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__("4b8b")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "e444":
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "e450":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 114);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 10:
/***/ (function(module, exports) {

module.exports = __webpack_require__("f3ad");

/***/ }),

/***/ 114:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/input-number/src/input-number.vue?vue&type=template&id=42f8cf66&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      class: [
        "el-input-number",
        _vm.inputNumberSize ? "el-input-number--" + _vm.inputNumberSize : "",
        { "is-disabled": _vm.inputNumberDisabled },
        { "is-without-controls": !_vm.controls },
        { "is-controls-right": _vm.controlsAtRight }
      ],
      on: {
        dragstart: function($event) {
          $event.preventDefault()
        }
      }
    },
    [
      _vm.controls
        ? _c(
            "span",
            {
              directives: [
                {
                  name: "repeat-click",
                  rawName: "v-repeat-click",
                  value: _vm.decrease,
                  expression: "decrease"
                }
              ],
              staticClass: "el-input-number__decrease",
              class: { "is-disabled": _vm.minDisabled },
              attrs: { role: "button" },
              on: {
                keydown: function($event) {
                  if (
                    !("button" in $event) &&
                    _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                  ) {
                    return null
                  }
                  return _vm.decrease($event)
                }
              }
            },
            [
              _c("i", {
                class:
                  "el-icon-" + (_vm.controlsAtRight ? "arrow-down" : "minus")
              })
            ]
          )
        : _vm._e(),
      _vm.controls
        ? _c(
            "span",
            {
              directives: [
                {
                  name: "repeat-click",
                  rawName: "v-repeat-click",
                  value: _vm.increase,
                  expression: "increase"
                }
              ],
              staticClass: "el-input-number__increase",
              class: { "is-disabled": _vm.maxDisabled },
              attrs: { role: "button" },
              on: {
                keydown: function($event) {
                  if (
                    !("button" in $event) &&
                    _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                  ) {
                    return null
                  }
                  return _vm.increase($event)
                }
              }
            },
            [
              _c("i", {
                class: "el-icon-" + (_vm.controlsAtRight ? "arrow-up" : "plus")
              })
            ]
          )
        : _vm._e(),
      _c("el-input", {
        ref: "input",
        attrs: {
          value: _vm.displayValue,
          placeholder: _vm.placeholder,
          disabled: _vm.inputNumberDisabled,
          size: _vm.inputNumberSize,
          max: _vm.max,
          min: _vm.min,
          name: _vm.name,
          label: _vm.label
        },
        on: {
          blur: _vm.handleBlur,
          focus: _vm.handleFocus,
          input: _vm.handleInput,
          change: _vm.handleInputChange
        },
        nativeOn: {
          keydown: [
            function($event) {
              if (
                !("button" in $event) &&
                _vm._k($event.keyCode, "up", 38, $event.key, ["Up", "ArrowUp"])
              ) {
                return null
              }
              $event.preventDefault()
              return _vm.increase($event)
            },
            function($event) {
              if (
                !("button" in $event) &&
                _vm._k($event.keyCode, "down", 40, $event.key, [
                  "Down",
                  "ArrowDown"
                ])
              ) {
                return null
              }
              $event.preventDefault()
              return _vm.decrease($event)
            }
          ]
        }
      })
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


// CONCATENATED MODULE: ./packages/input-number/src/input-number.vue?vue&type=template&id=42f8cf66&

// EXTERNAL MODULE: external "element-ui/lib/input"
var input_ = __webpack_require__(10);
var input_default = /*#__PURE__*/__webpack_require__.n(input_);

// EXTERNAL MODULE: external "element-ui/lib/mixins/focus"
var focus_ = __webpack_require__(22);
var focus_default = /*#__PURE__*/__webpack_require__.n(focus_);

// EXTERNAL MODULE: ./src/directives/repeat-click.js
var repeat_click = __webpack_require__(30);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/input-number/src/input-number.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var input_numbervue_type_script_lang_js_ = ({
  name: 'ElInputNumber',
  mixins: [focus_default()('input')],
  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },
  directives: {
    repeatClick: repeat_click["a" /* default */]
  },
  components: {
    ElInput: input_default.a
  },
  props: {
    step: {
      type: Number,
      default: 1
    },
    stepStrictly: {
      type: Boolean,
      default: false
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: -Infinity
    },
    value: {},
    disabled: Boolean,
    size: String,
    controls: {
      type: Boolean,
      default: true
    },
    controlsPosition: {
      type: String,
      default: ''
    },
    name: String,
    label: String,
    placeholder: String,
    precision: {
      type: Number,
      validator: function validator(val) {
        return val >= 0 && val === parseInt(val, 10);
      }
    }
  },
  data: function data() {
    return {
      currentValue: 0,
      userInput: null
    };
  },

  watch: {
    value: {
      immediate: true,
      handler: function handler(value) {
        var newVal = value === undefined ? value : Number(value);
        if (newVal !== undefined) {
          if (isNaN(newVal)) {
            return;
          }

          if (this.stepStrictly) {
            var stepPrecision = this.getPrecision(this.step);
            var precisionFactor = Math.pow(10, stepPrecision);
            newVal = Math.round(newVal / this.step) * precisionFactor * this.step / precisionFactor;
          }

          if (this.precision !== undefined) {
            newVal = this.toPrecision(newVal, this.precision);
          }
        }
        if (newVal >= this.max) newVal = this.max;
        if (newVal <= this.min) newVal = this.min;
        this.currentValue = newVal;
        this.userInput = null;
        this.$emit('input', newVal);
      }
    }
  },
  computed: {
    minDisabled: function minDisabled() {
      return this._decrease(this.value, this.step) < this.min;
    },
    maxDisabled: function maxDisabled() {
      return this._increase(this.value, this.step) > this.max;
    },
    numPrecision: function numPrecision() {
      var value = this.value,
          step = this.step,
          getPrecision = this.getPrecision,
          precision = this.precision;

      var stepPrecision = getPrecision(step);
      if (precision !== undefined) {
        if (stepPrecision > precision) {
          console.warn('[Element Warn][InputNumber]precision should not be less than the decimal places of step');
        }
        return precision;
      } else {
        return Math.max(getPrecision(value), stepPrecision);
      }
    },
    controlsAtRight: function controlsAtRight() {
      return this.controls && this.controlsPosition === 'right';
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    inputNumberSize: function inputNumberSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    inputNumberDisabled: function inputNumberDisabled() {
      return this.disabled || !!(this.elForm || {}).disabled;
    },
    displayValue: function displayValue() {
      if (this.userInput !== null) {
        return this.userInput;
      }

      var currentValue = this.currentValue;

      if (typeof currentValue === 'number') {
        if (this.stepStrictly) {
          var stepPrecision = this.getPrecision(this.step);
          var precisionFactor = Math.pow(10, stepPrecision);
          currentValue = Math.round(currentValue / this.step) * precisionFactor * this.step / precisionFactor;
        }

        if (this.precision !== undefined) {
          currentValue = currentValue.toFixed(this.precision);
        }
      }

      return currentValue;
    }
  },
  methods: {
    toPrecision: function toPrecision(num, precision) {
      if (precision === undefined) precision = this.numPrecision;
      return parseFloat(Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision));
    },
    getPrecision: function getPrecision(value) {
      if (value === undefined) return 0;
      var valueString = value.toString();
      var dotPosition = valueString.indexOf('.');
      var precision = 0;
      if (dotPosition !== -1) {
        precision = valueString.length - dotPosition - 1;
      }
      return precision;
    },
    _increase: function _increase(val, step) {
      if (typeof val !== 'number' && val !== undefined) return this.currentValue;

      var precisionFactor = Math.pow(10, this.numPrecision);
      // Solve the accuracy problem of JS decimal calculation by converting the value to integer.
      return this.toPrecision((precisionFactor * val + precisionFactor * step) / precisionFactor);
    },
    _decrease: function _decrease(val, step) {
      if (typeof val !== 'number' && val !== undefined) return this.currentValue;

      var precisionFactor = Math.pow(10, this.numPrecision);

      return this.toPrecision((precisionFactor * val - precisionFactor * step) / precisionFactor);
    },
    increase: function increase() {
      if (this.inputNumberDisabled || this.maxDisabled) return;
      var value = this.value || 0;
      var newVal = this._increase(value, this.step);
      this.setCurrentValue(newVal);
    },
    decrease: function decrease() {
      if (this.inputNumberDisabled || this.minDisabled) return;
      var value = this.value || 0;
      var newVal = this._decrease(value, this.step);
      this.setCurrentValue(newVal);
    },
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
    },
    handleFocus: function handleFocus(event) {
      this.$emit('focus', event);
    },
    setCurrentValue: function setCurrentValue(newVal) {
      var oldVal = this.currentValue;
      if (typeof newVal === 'number' && this.precision !== undefined) {
        newVal = this.toPrecision(newVal, this.precision);
      }
      if (newVal >= this.max) newVal = this.max;
      if (newVal <= this.min) newVal = this.min;
      if (oldVal === newVal) return;
      this.userInput = null;
      this.$emit('input', newVal);
      this.$emit('change', newVal, oldVal);
      this.currentValue = newVal;
    },
    handleInput: function handleInput(value) {
      this.userInput = value;
    },
    handleInputChange: function handleInputChange(value) {
      var newVal = value === '' ? undefined : Number(value);
      if (!isNaN(newVal) || value === '') {
        this.setCurrentValue(newVal);
      }
      this.userInput = null;
    },
    select: function select() {
      this.$refs.input.select();
    }
  },
  mounted: function mounted() {
    var innerInput = this.$refs.input.$refs.input;
    innerInput.setAttribute('role', 'spinbutton');
    innerInput.setAttribute('aria-valuemax', this.max);
    innerInput.setAttribute('aria-valuemin', this.min);
    innerInput.setAttribute('aria-valuenow', this.currentValue);
    innerInput.setAttribute('aria-disabled', this.inputNumberDisabled);
  },
  updated: function updated() {
    if (!this.$refs || !this.$refs.input) return;
    var innerInput = this.$refs.input.$refs.input;
    innerInput.setAttribute('aria-valuenow', this.currentValue);
  }
});
// CONCATENATED MODULE: ./packages/input-number/src/input-number.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_input_numbervue_type_script_lang_js_ = (input_numbervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(0);

// CONCATENATED MODULE: ./packages/input-number/src/input-number.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  src_input_numbervue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/input-number/src/input-number.vue"
/* harmony default export */ var input_number = (component.exports);
// CONCATENATED MODULE: ./packages/input-number/index.js


/* istanbul ignore next */
input_number.install = function (Vue) {
  Vue.component(input_number.name, input_number);
};

/* harmony default export */ var packages_input_number = __webpack_exports__["default"] = (input_number);

/***/ }),

/***/ 2:
/***/ (function(module, exports) {

module.exports = __webpack_require__("5924");

/***/ }),

/***/ 22:
/***/ (function(module, exports) {

module.exports = __webpack_require__("12f2");

/***/ }),

/***/ 30:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__);


/* harmony default export */ __webpack_exports__["a"] = ({
  bind: function bind(el, binding, vnode) {
    var interval = null;
    var startTime = void 0;
    var handler = function handler() {
      return vnode.context[binding.expression].apply();
    };
    var clear = function clear() {
      if (Date.now() - startTime < 100) {
        handler();
      }
      clearInterval(interval);
      interval = null;
    };

    Object(element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__["on"])(el, 'mousedown', function (e) {
      if (e.button !== 0) return;
      startTime = Date.now();
      Object(element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__["once"])(document, 'mouseup', clear);
      clearInterval(interval);
      interval = setInterval(handler, 100);
    });
  }
});

/***/ })

/******/ });

/***/ }),

/***/ "e452":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var aria = aria || {};

aria.Utils = aria.Utils || {};

/**
 * @desc Set focus on descendant nodes until the first focusable element is
 *       found.
 * @param element
 *          DOM node for which to find the first focusable descendant.
 * @returns
 *  true if a focusable element is found and focus is set.
 */
aria.Utils.focusFirstDescendant = function (element) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];
    if (aria.Utils.attemptFocus(child) || aria.Utils.focusFirstDescendant(child)) {
      return true;
    }
  }
  return false;
};

/**
 * @desc Find the last descendant node that is focusable.
 * @param element
 *          DOM node for which to find the last focusable descendant.
 * @returns
 *  true if a focusable element is found and focus is set.
 */

aria.Utils.focusLastDescendant = function (element) {
  for (var i = element.childNodes.length - 1; i >= 0; i--) {
    var child = element.childNodes[i];
    if (aria.Utils.attemptFocus(child) || aria.Utils.focusLastDescendant(child)) {
      return true;
    }
  }
  return false;
};

/**
 * @desc Set Attempt to set focus on the current node.
 * @param element
 *          The node to attempt to focus on.
 * @returns
 *  true if element is focused.
 */
aria.Utils.attemptFocus = function (element) {
  if (!aria.Utils.isFocusable(element)) {
    return false;
  }
  aria.Utils.IgnoreUtilFocusChanges = true;
  try {
    element.focus();
  } catch (e) {}
  aria.Utils.IgnoreUtilFocusChanges = false;
  return document.activeElement === element;
};

aria.Utils.isFocusable = function (element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute('tabIndex') !== null) {
    return true;
  }

  if (element.disabled) {
    return false;
  }

  switch (element.nodeName) {
    case 'A':
      return !!element.href && element.rel !== 'ignore';
    case 'INPUT':
      return element.type !== 'hidden' && element.type !== 'file';
    case 'BUTTON':
    case 'SELECT':
    case 'TEXTAREA':
      return true;
    default:
      return false;
  }
};

/**
 * 触发一个事件
 * mouseenter, mouseleave, mouseover, keyup, change, click 等
 * @param  {Element} elm
 * @param  {String} name
 * @param  {*} opts
 */
aria.Utils.triggerEvent = function (elm, name) {
  var eventName = void 0;

  if (/^mouse|click/.test(name)) {
    eventName = 'MouseEvents';
  } else if (/^key/.test(name)) {
    eventName = 'KeyboardEvent';
  } else {
    eventName = 'HTMLEvents';
  }
  var evt = document.createEvent(eventName);

  for (var _len = arguments.length, opts = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    opts[_key - 2] = arguments[_key];
  }

  evt.initEvent.apply(evt, [name].concat(opts));
  elm.dispatchEvent ? elm.dispatchEvent(evt) : elm.fireEvent('on' + name, evt);

  return elm;
};

aria.Utils.keys = {
  tab: 9,
  enter: 13,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  esc: 27
};

exports.default = aria.Utils;

/***/ }),

/***/ "e507":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("512c");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("072d") });


/***/ }),

/***/ "e62d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function () {
  if (_vue2.default.prototype.$isServer) return 0;
  if (scrollBarWidth !== undefined) return scrollBarWidth;

  var outer = document.createElement('div');
  outer.className = 'el-scrollbar__wrap';
  outer.style.visibility = 'hidden';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);

  var widthNoScroll = outer.offsetWidth;
  outer.style.overflow = 'scroll';

  var inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);

  var widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;

  return scrollBarWidth;
};

var _vue = __webpack_require__("8bbf");

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var scrollBarWidth = void 0;

;

/***/ }),

/***/ "e772":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 53);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 3:
/***/ (function(module, exports) {

module.exports = __webpack_require__("8122");

/***/ }),

/***/ 33:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option.vue?vue&type=template&id=7a44c642&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "li",
    {
      directives: [
        {
          name: "show",
          rawName: "v-show",
          value: _vm.visible,
          expression: "visible"
        }
      ],
      staticClass: "el-select-dropdown__item",
      class: {
        selected: _vm.itemSelected,
        "is-disabled": _vm.disabled || _vm.groupDisabled || _vm.limitReached,
        hover: _vm.hover
      },
      on: {
        mouseenter: _vm.hoverItem,
        click: function($event) {
          $event.stopPropagation()
          return _vm.selectOptionClick($event)
        }
      }
    },
    [_vm._t("default", [_c("span", [_vm._v(_vm._s(_vm.currentLabel))])])],
    2
  )
}
var staticRenderFns = []
render._withStripped = true


// CONCATENATED MODULE: ./packages/select/src/option.vue?vue&type=template&id=7a44c642&

// EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"
var emitter_ = __webpack_require__(4);
var emitter_default = /*#__PURE__*/__webpack_require__.n(emitter_);

// EXTERNAL MODULE: external "element-ui/lib/utils/util"
var util_ = __webpack_require__(3);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option.vue?vue&type=script&lang=js&
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var optionvue_type_script_lang_js_ = ({
  mixins: [emitter_default.a],

  name: 'ElOption',

  componentName: 'ElOption',

  inject: ['select'],

  props: {
    value: {
      required: true
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },

  data: function data() {
    return {
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    };
  },


  computed: {
    isObject: function isObject() {
      return Object.prototype.toString.call(this.value).toLowerCase() === '[object object]';
    },
    currentLabel: function currentLabel() {
      return this.label || (this.isObject ? '' : this.value);
    },
    currentValue: function currentValue() {
      return this.value || this.label || '';
    },
    itemSelected: function itemSelected() {
      if (!this.select.multiple) {
        return this.isEqual(this.value, this.select.value);
      } else {
        return this.contains(this.select.value, this.value);
      }
    },
    limitReached: function limitReached() {
      if (this.select.multiple) {
        return !this.itemSelected && (this.select.value || []).length >= this.select.multipleLimit && this.select.multipleLimit > 0;
      } else {
        return false;
      }
    }
  },

  watch: {
    currentLabel: function currentLabel() {
      if (!this.created && !this.select.remote) this.dispatch('ElSelect', 'setSelected');
    },
    value: function value(val, oldVal) {
      var _select = this.select,
          remote = _select.remote,
          valueKey = _select.valueKey;

      if (!this.created && !remote) {
        if (valueKey && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && (typeof oldVal === 'undefined' ? 'undefined' : _typeof(oldVal)) === 'object' && val[valueKey] === oldVal[valueKey]) {
          return;
        }
        this.dispatch('ElSelect', 'setSelected');
      }
    }
  },

  methods: {
    isEqual: function isEqual(a, b) {
      if (!this.isObject) {
        return a === b;
      } else {
        var valueKey = this.select.valueKey;
        return Object(util_["getValueByPath"])(a, valueKey) === Object(util_["getValueByPath"])(b, valueKey);
      }
    },
    contains: function contains() {
      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var target = arguments[1];

      if (!this.isObject) {
        return arr && arr.indexOf(target) > -1;
      } else {
        var valueKey = this.select.valueKey;
        return arr && arr.some(function (item) {
          return Object(util_["getValueByPath"])(item, valueKey) === Object(util_["getValueByPath"])(target, valueKey);
        });
      }
    },
    handleGroupDisabled: function handleGroupDisabled(val) {
      this.groupDisabled = val;
    },
    hoverItem: function hoverItem() {
      if (!this.disabled && !this.groupDisabled) {
        this.select.hoverIndex = this.select.options.indexOf(this);
      }
    },
    selectOptionClick: function selectOptionClick() {
      if (this.disabled !== true && this.groupDisabled !== true) {
        this.dispatch('ElSelect', 'handleOptionClick', [this, true]);
      }
    },
    queryChange: function queryChange(query) {
      this.visible = new RegExp(Object(util_["escapeRegexpString"])(query), 'i').test(this.currentLabel) || this.created;
      if (!this.visible) {
        this.select.filteredOptionsCount--;
      }
    }
  },

  created: function created() {
    this.select.options.push(this);
    this.select.cachedOptions.push(this);
    this.select.optionsCount++;
    this.select.filteredOptionsCount++;

    this.$on('queryChange', this.queryChange);
    this.$on('handleGroupDisabled', this.handleGroupDisabled);
  },
  beforeDestroy: function beforeDestroy() {
    var _select2 = this.select,
        selected = _select2.selected,
        multiple = _select2.multiple;

    var selectedOptions = multiple ? selected : [selected];
    var index = this.select.cachedOptions.indexOf(this);
    var selectedIndex = selectedOptions.indexOf(this);

    // if option is not selected, remove it from cache
    if (index > -1 && selectedIndex < 0) {
      this.select.cachedOptions.splice(index, 1);
    }
    this.select.onOptionDestroy(this.select.options.indexOf(this));
  }
});
// CONCATENATED MODULE: ./packages/select/src/option.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_optionvue_type_script_lang_js_ = (optionvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(0);

// CONCATENATED MODULE: ./packages/select/src/option.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  src_optionvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/select/src/option.vue"
/* harmony default export */ var src_option = __webpack_exports__["a"] = (component.exports);

/***/ }),

/***/ 4:
/***/ (function(module, exports) {

module.exports = __webpack_require__("d010");

/***/ }),

/***/ 53:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _select_src_option__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);


/* istanbul ignore next */
_select_src_option__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].install = function (Vue) {
  Vue.component(_select_src_option__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].name, _select_src_option__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);
};

/* harmony default export */ __webpack_exports__["default"] = (_select_src_option__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ })

/******/ });

/***/ }),

/***/ "e974":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__("8bbf");

var _vue2 = _interopRequireDefault(_vue);

var _popup = __webpack_require__("5128");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PopperJS = _vue2.default.prototype.$isServer ? function () {} : __webpack_require__("6167");
var stop = function stop(e) {
  return e.stopPropagation();
};

/**
 * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.
 * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -end), left(-start, -end)
 * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).
 * @param {Boolean} [visible=false] Visibility of the popup element.
 * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.
 */
exports.default = {
  props: {
    transformOrigin: {
      type: [Boolean, String],
      default: true
    },
    placement: {
      type: String,
      default: 'bottom'
    },
    boundariesPadding: {
      type: Number,
      default: 5
    },
    reference: {},
    popper: {},
    offset: {
      default: 0
    },
    value: Boolean,
    visibleArrow: Boolean,
    arrowOffset: {
      type: Number,
      default: 35
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    popperOptions: {
      type: Object,
      default: function _default() {
        return {
          gpuAcceleration: false
        };
      }
    }
  },

  data: function data() {
    return {
      showPopper: false,
      currentPlacement: ''
    };
  },


  watch: {
    value: {
      immediate: true,
      handler: function handler(val) {
        this.showPopper = val;
        this.$emit('input', val);
      }
    },

    showPopper: function showPopper(val) {
      if (this.disabled) return;
      val ? this.updatePopper() : this.destroyPopper();
      this.$emit('input', val);
    }
  },

  methods: {
    createPopper: function createPopper() {
      var _this = this;

      if (this.$isServer) return;
      this.currentPlacement = this.currentPlacement || this.placement;
      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.currentPlacement)) {
        return;
      }

      var options = this.popperOptions;
      var popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;
      var reference = this.referenceElm = this.referenceElm || this.reference || this.$refs.reference;

      if (!reference && this.$slots.reference && this.$slots.reference[0]) {
        reference = this.referenceElm = this.$slots.reference[0].elm;
      }

      if (!popper || !reference) return;
      if (this.visibleArrow) this.appendArrow(popper);
      if (this.appendToBody) document.body.appendChild(this.popperElm);
      if (this.popperJS && this.popperJS.destroy) {
        this.popperJS.destroy();
      }

      options.placement = this.currentPlacement;
      options.offset = this.offset;
      options.arrowOffset = this.arrowOffset;
      this.popperJS = new PopperJS(reference, popper, options);
      this.popperJS.onCreate(function (_) {
        _this.$emit('created', _this);
        _this.resetTransformOrigin();
        _this.$nextTick(_this.updatePopper);
      });
      if (typeof options.onUpdate === 'function') {
        this.popperJS.onUpdate(options.onUpdate);
      }
      this.popperJS._popper.style.zIndex = _popup.PopupManager.nextZIndex();
      this.popperElm.addEventListener('click', stop);
    },
    updatePopper: function updatePopper() {
      var popperJS = this.popperJS;
      if (popperJS) {
        popperJS.update();
        if (popperJS._popper) {
          popperJS._popper.style.zIndex = _popup.PopupManager.nextZIndex();
        }
      } else {
        this.createPopper();
      }
    },
    doDestroy: function doDestroy(forceDestroy) {
      /* istanbul ignore if */
      if (!this.popperJS || this.showPopper && !forceDestroy) return;
      this.popperJS.destroy();
      this.popperJS = null;
    },
    destroyPopper: function destroyPopper() {
      if (this.popperJS) {
        this.resetTransformOrigin();
      }
    },
    resetTransformOrigin: function resetTransformOrigin() {
      if (!this.transformOrigin) return;
      var placementMap = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left'
      };
      var placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];
      var origin = placementMap[placement];
      this.popperJS._popper.style.transformOrigin = typeof this.transformOrigin === 'string' ? this.transformOrigin : ['top', 'bottom'].indexOf(placement) > -1 ? 'center ' + origin : origin + ' center';
    },
    appendArrow: function appendArrow(element) {
      var hash = void 0;
      if (this.appended) {
        return;
      }

      this.appended = true;

      for (var item in element.attributes) {
        if (/^_v-/.test(element.attributes[item].name)) {
          hash = element.attributes[item].name;
          break;
        }
      }

      var arrow = document.createElement('div');

      if (hash) {
        arrow.setAttribute(hash, '');
      }
      arrow.setAttribute('x-arrow', '');
      arrow.className = 'popper__arrow';
      element.appendChild(arrow);
    }
  },

  beforeDestroy: function beforeDestroy() {
    this.doDestroy(true);
    if (this.popperElm && this.popperElm.parentNode === document.body) {
      this.popperElm.removeEventListener('click', stop);
      document.body.removeChild(this.popperElm);
    }
  },


  // call destroy in keep-alive mode
  deactivated: function deactivated() {
    this.$options.beforeDestroy[0].call(this);
  }
};

/***/ }),

/***/ "ea34":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "eedf":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 97);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 97:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button.vue?vue&type=template&id=ca859fb4&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "button",
    {
      staticClass: "el-button",
      class: [
        _vm.type ? "el-button--" + _vm.type : "",
        _vm.buttonSize ? "el-button--" + _vm.buttonSize : "",
        {
          "is-disabled": _vm.buttonDisabled,
          "is-loading": _vm.loading,
          "is-plain": _vm.plain,
          "is-round": _vm.round,
          "is-circle": _vm.circle
        }
      ],
      attrs: {
        disabled: _vm.buttonDisabled || _vm.loading,
        autofocus: _vm.autofocus,
        type: _vm.nativeType
      },
      on: { click: _vm.handleClick }
    },
    [
      _vm.loading ? _c("i", { staticClass: "el-icon-loading" }) : _vm._e(),
      _vm.icon && !_vm.loading ? _c("i", { class: _vm.icon }) : _vm._e(),
      _vm.$slots.default ? _c("span", [_vm._t("default")], 2) : _vm._e()
    ]
  )
}
var staticRenderFns = []
render._withStripped = true


// CONCATENATED MODULE: ./packages/button/src/button.vue?vue&type=template&id=ca859fb4&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var buttonvue_type_script_lang_js_ = ({
  name: 'ElButton',

  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },

  props: {
    type: {
      type: String,
      default: 'default'
    },
    size: String,
    icon: {
      type: String,
      default: ''
    },
    nativeType: {
      type: String,
      default: 'button'
    },
    loading: Boolean,
    disabled: Boolean,
    plain: Boolean,
    autofocus: Boolean,
    round: Boolean,
    circle: Boolean
  },

  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    buttonSize: function buttonSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    buttonDisabled: function buttonDisabled() {
      return this.disabled || (this.elForm || {}).disabled;
    }
  },

  methods: {
    handleClick: function handleClick(evt) {
      this.$emit('click', evt);
    }
  }
});
// CONCATENATED MODULE: ./packages/button/src/button.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_buttonvue_type_script_lang_js_ = (buttonvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(0);

// CONCATENATED MODULE: ./packages/button/src/button.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  src_buttonvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/button/src/button.vue"
/* harmony default export */ var src_button = (component.exports);
// CONCATENATED MODULE: ./packages/button/index.js


/* istanbul ignore next */
src_button.install = function (Vue) {
  Vue.component(src_button.name, src_button);
};

/* harmony default export */ var packages_button = __webpack_exports__["default"] = (src_button);

/***/ })

/******/ });

/***/ }),

/***/ "ef08":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "f0d9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
  el: {
    colorpicker: {
      confirm: '确定',
      clear: '清空'
    },
    datepicker: {
      now: '此刻',
      today: '今天',
      cancel: '取消',
      clear: '清空',
      confirm: '确定',
      selectDate: '选择日期',
      selectTime: '选择时间',
      startDate: '开始日期',
      startTime: '开始时间',
      endDate: '结束日期',
      endTime: '结束时间',
      prevYear: '前一年',
      nextYear: '后一年',
      prevMonth: '上个月',
      nextMonth: '下个月',
      year: '年',
      month1: '1 月',
      month2: '2 月',
      month3: '3 月',
      month4: '4 月',
      month5: '5 月',
      month6: '6 月',
      month7: '7 月',
      month8: '8 月',
      month9: '9 月',
      month10: '10 月',
      month11: '11 月',
      month12: '12 月',
      // week: '周次',
      weeks: {
        sun: '日',
        mon: '一',
        tue: '二',
        wed: '三',
        thu: '四',
        fri: '五',
        sat: '六'
      },
      months: {
        jan: '一月',
        feb: '二月',
        mar: '三月',
        apr: '四月',
        may: '五月',
        jun: '六月',
        jul: '七月',
        aug: '八月',
        sep: '九月',
        oct: '十月',
        nov: '十一月',
        dec: '十二月'
      }
    },
    select: {
      loading: '加载中',
      noMatch: '无匹配数据',
      noData: '无数据',
      placeholder: '请选择'
    },
    cascader: {
      noMatch: '无匹配数据',
      loading: '加载中',
      placeholder: '请选择',
      noData: '暂无数据'
    },
    pagination: {
      goto: '前往',
      pagesize: '条/页',
      total: '共 {total} 条',
      pageClassifier: '页'
    },
    messagebox: {
      title: '提示',
      confirm: '确定',
      cancel: '取消',
      error: '输入的数据不合法!'
    },
    upload: {
      deleteTip: '按 delete 键可删除',
      delete: '删除',
      preview: '查看图片',
      continue: '继续上传'
    },
    table: {
      emptyText: '暂无数据',
      confirmFilter: '筛选',
      resetFilter: '重置',
      clearFilter: '全部',
      sumText: '合计'
    },
    tree: {
      emptyText: '暂无数据'
    },
    transfer: {
      noMatch: '无匹配数据',
      noData: '无数据',
      titles: ['列表 1', '列表 2'],
      filterPlaceholder: '请输入搜索内容',
      noCheckedFormat: '共 {total} 项',
      hasCheckedFormat: '已选 {checked}/{total} 项'
    },
    image: {
      error: '加载失败'
    },
    pageHeader: {
      title: '返回'
    },
    popconfirm: {
      confirmButtonText: '确定',
      cancelButtonText: '取消'
    }
  }
};

/***/ }),

/***/ "f3ad":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 76);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 11:
/***/ (function(module, exports) {

module.exports = __webpack_require__("2bb5");

/***/ }),

/***/ 21:
/***/ (function(module, exports) {

module.exports = __webpack_require__("d397");

/***/ }),

/***/ 4:
/***/ (function(module, exports) {

module.exports = __webpack_require__("d010");

/***/ }),

/***/ 76:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/input/src/input.vue?vue&type=template&id=343dd774&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      class: [
        _vm.type === "textarea" ? "el-textarea" : "el-input",
        _vm.inputSize ? "el-input--" + _vm.inputSize : "",
        {
          "is-disabled": _vm.inputDisabled,
          "is-exceed": _vm.inputExceed,
          "el-input-group": _vm.$slots.prepend || _vm.$slots.append,
          "el-input-group--append": _vm.$slots.append,
          "el-input-group--prepend": _vm.$slots.prepend,
          "el-input--prefix": _vm.$slots.prefix || _vm.prefixIcon,
          "el-input--suffix":
            _vm.$slots.suffix ||
            _vm.suffixIcon ||
            _vm.clearable ||
            _vm.showPassword
        }
      ],
      on: {
        mouseenter: function($event) {
          _vm.hovering = true
        },
        mouseleave: function($event) {
          _vm.hovering = false
        }
      }
    },
    [
      _vm.type !== "textarea"
        ? [
            _vm.$slots.prepend
              ? _c(
                  "div",
                  { staticClass: "el-input-group__prepend" },
                  [_vm._t("prepend")],
                  2
                )
              : _vm._e(),
            _vm.type !== "textarea"
              ? _c(
                  "input",
                  _vm._b(
                    {
                      ref: "input",
                      staticClass: "el-input__inner",
                      attrs: {
                        tabindex: _vm.tabindex,
                        type: _vm.showPassword
                          ? _vm.passwordVisible
                            ? "text"
                            : "password"
                          : _vm.type,
                        disabled: _vm.inputDisabled,
                        readonly: _vm.readonly,
                        autocomplete: _vm.autoComplete || _vm.autocomplete,
                        "aria-label": _vm.label
                      },
                      on: {
                        compositionstart: _vm.handleCompositionStart,
                        compositionupdate: _vm.handleCompositionUpdate,
                        compositionend: _vm.handleCompositionEnd,
                        input: _vm.handleInput,
                        focus: _vm.handleFocus,
                        blur: _vm.handleBlur,
                        change: _vm.handleChange
                      }
                    },
                    "input",
                    _vm.$attrs,
                    false
                  )
                )
              : _vm._e(),
            _vm.$slots.prefix || _vm.prefixIcon
              ? _c(
                  "span",
                  { staticClass: "el-input__prefix" },
                  [
                    _vm._t("prefix"),
                    _vm.prefixIcon
                      ? _c("i", {
                          staticClass: "el-input__icon",
                          class: _vm.prefixIcon
                        })
                      : _vm._e()
                  ],
                  2
                )
              : _vm._e(),
            _vm.getSuffixVisible()
              ? _c("span", { staticClass: "el-input__suffix" }, [
                  _c(
                    "span",
                    { staticClass: "el-input__suffix-inner" },
                    [
                      !_vm.showClear ||
                      !_vm.showPwdVisible ||
                      !_vm.isWordLimitVisible
                        ? [
                            _vm._t("suffix"),
                            _vm.suffixIcon
                              ? _c("i", {
                                  staticClass: "el-input__icon",
                                  class: _vm.suffixIcon
                                })
                              : _vm._e()
                          ]
                        : _vm._e(),
                      _vm.showClear
                        ? _c("i", {
                            staticClass:
                              "el-input__icon el-icon-circle-close el-input__clear",
                            on: {
                              mousedown: function($event) {
                                $event.preventDefault()
                              },
                              click: _vm.clear
                            }
                          })
                        : _vm._e(),
                      _vm.showPwdVisible
                        ? _c("i", {
                            staticClass:
                              "el-input__icon el-icon-view el-input__clear",
                            on: { click: _vm.handlePasswordVisible }
                          })
                        : _vm._e(),
                      _vm.isWordLimitVisible
                        ? _c("span", { staticClass: "el-input__count" }, [
                            _c(
                              "span",
                              { staticClass: "el-input__count-inner" },
                              [
                                _vm._v(
                                  "\n            " +
                                    _vm._s(_vm.textLength) +
                                    "/" +
                                    _vm._s(_vm.upperLimit) +
                                    "\n          "
                                )
                              ]
                            )
                          ])
                        : _vm._e()
                    ],
                    2
                  ),
                  _vm.validateState
                    ? _c("i", {
                        staticClass: "el-input__icon",
                        class: ["el-input__validateIcon", _vm.validateIcon]
                      })
                    : _vm._e()
                ])
              : _vm._e(),
            _vm.$slots.append
              ? _c(
                  "div",
                  { staticClass: "el-input-group__append" },
                  [_vm._t("append")],
                  2
                )
              : _vm._e()
          ]
        : _c(
            "textarea",
            _vm._b(
              {
                ref: "textarea",
                staticClass: "el-textarea__inner",
                style: _vm.textareaStyle,
                attrs: {
                  tabindex: _vm.tabindex,
                  disabled: _vm.inputDisabled,
                  readonly: _vm.readonly,
                  autocomplete: _vm.autoComplete || _vm.autocomplete,
                  "aria-label": _vm.label
                },
                on: {
                  compositionstart: _vm.handleCompositionStart,
                  compositionupdate: _vm.handleCompositionUpdate,
                  compositionend: _vm.handleCompositionEnd,
                  input: _vm.handleInput,
                  focus: _vm.handleFocus,
                  blur: _vm.handleBlur,
                  change: _vm.handleChange
                }
              },
              "textarea",
              _vm.$attrs,
              false
            )
          ),
      _vm.isWordLimitVisible && _vm.type === "textarea"
        ? _c("span", { staticClass: "el-input__count" }, [
            _vm._v(_vm._s(_vm.textLength) + "/" + _vm._s(_vm.upperLimit))
          ])
        : _vm._e()
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true


// CONCATENATED MODULE: ./packages/input/src/input.vue?vue&type=template&id=343dd774&

// EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"
var emitter_ = __webpack_require__(4);
var emitter_default = /*#__PURE__*/__webpack_require__.n(emitter_);

// EXTERNAL MODULE: external "element-ui/lib/mixins/migrating"
var migrating_ = __webpack_require__(11);
var migrating_default = /*#__PURE__*/__webpack_require__.n(migrating_);

// CONCATENATED MODULE: ./packages/input/src/calcTextareaHeight.js
var hiddenTextarea = void 0;

var HIDDEN_STYLE = '\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n';

var CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

function calculateNodeStyling(targetElement) {
  var style = window.getComputedStyle(targetElement);

  var boxSizing = style.getPropertyValue('box-sizing');

  var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));

  var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));

  var contextStyle = CONTEXT_STYLE.map(function (name) {
    return name + ':' + style.getPropertyValue(name);
  }).join(';');

  return { contextStyle: contextStyle, paddingSize: paddingSize, borderSize: borderSize, boxSizing: boxSizing };
}

function calcTextareaHeight(targetElement) {
  var minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
  }

  var _calculateNodeStyling = calculateNodeStyling(targetElement),
      paddingSize = _calculateNodeStyling.paddingSize,
      borderSize = _calculateNodeStyling.borderSize,
      boxSizing = _calculateNodeStyling.boxSizing,
      contextStyle = _calculateNodeStyling.contextStyle;

  hiddenTextarea.setAttribute('style', contextStyle + ';' + HIDDEN_STYLE);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';

  var height = hiddenTextarea.scrollHeight;
  var result = {};

  if (boxSizing === 'border-box') {
    height = height + borderSize;
  } else if (boxSizing === 'content-box') {
    height = height - paddingSize;
  }

  hiddenTextarea.value = '';
  var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

  if (minRows !== null) {
    var minHeight = singleRowHeight * minRows;
    if (boxSizing === 'border-box') {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result.minHeight = minHeight + 'px';
  }
  if (maxRows !== null) {
    var maxHeight = singleRowHeight * maxRows;
    if (boxSizing === 'border-box') {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result.height = height + 'px';
  hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
  hiddenTextarea = null;
  return result;
};
// EXTERNAL MODULE: external "element-ui/lib/utils/merge"
var merge_ = __webpack_require__(9);
var merge_default = /*#__PURE__*/__webpack_require__.n(merge_);

// EXTERNAL MODULE: external "element-ui/lib/utils/shared"
var shared_ = __webpack_require__(21);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/input/src/input.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







/* harmony default export */ var inputvue_type_script_lang_js_ = ({
  name: 'ElInput',

  componentName: 'ElInput',

  mixins: [emitter_default.a, migrating_default.a],

  inheritAttrs: false,

  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },

  data: function data() {
    return {
      textareaCalcStyle: {},
      hovering: false,
      focused: false,
      isComposing: false,
      passwordVisible: false
    };
  },


  props: {
    value: [String, Number],
    size: String,
    resize: String,
    form: String,
    disabled: Boolean,
    readonly: Boolean,
    type: {
      type: String,
      default: 'text'
    },
    autosize: {
      type: [Boolean, Object],
      default: false
    },
    autocomplete: {
      type: String,
      default: 'off'
    },
    /** @Deprecated in next major version */
    autoComplete: {
      type: String,
      validator: function validator(val) {
          false && false;
        return true;
      }
    },
    validateEvent: {
      type: Boolean,
      default: true
    },
    suffixIcon: String,
    prefixIcon: String,
    label: String,
    clearable: {
      type: Boolean,
      default: false
    },
    showPassword: {
      type: Boolean,
      default: false
    },
    showWordLimit: {
      type: Boolean,
      default: false
    },
    tabindex: String
  },

  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    validateState: function validateState() {
      return this.elFormItem ? this.elFormItem.validateState : '';
    },
    needStatusIcon: function needStatusIcon() {
      return this.elForm ? this.elForm.statusIcon : false;
    },
    validateIcon: function validateIcon() {
      return {
        validating: 'el-icon-loading',
        success: 'el-icon-circle-check',
        error: 'el-icon-circle-close'
      }[this.validateState];
    },
    textareaStyle: function textareaStyle() {
      return merge_default()({}, this.textareaCalcStyle, { resize: this.resize });
    },
    inputSize: function inputSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    inputDisabled: function inputDisabled() {
      return this.disabled || (this.elForm || {}).disabled;
    },
    nativeInputValue: function nativeInputValue() {
      return this.value === null || this.value === undefined ? '' : String(this.value);
    },
    showClear: function showClear() {
      return this.clearable && !this.inputDisabled && !this.readonly && this.nativeInputValue && (this.focused || this.hovering);
    },
    showPwdVisible: function showPwdVisible() {
      return this.showPassword && !this.inputDisabled && !this.readonly && (!!this.nativeInputValue || this.focused);
    },
    isWordLimitVisible: function isWordLimitVisible() {
      return this.showWordLimit && this.$attrs.maxlength && (this.type === 'text' || this.type === 'textarea') && !this.inputDisabled && !this.readonly && !this.showPassword;
    },
    upperLimit: function upperLimit() {
      return this.$attrs.maxlength;
    },
    textLength: function textLength() {
      if (typeof this.value === 'number') {
        return String(this.value).length;
      }

      return (this.value || '').length;
    },
    inputExceed: function inputExceed() {
      // show exceed style if length of initial value greater then maxlength
      return this.isWordLimitVisible && this.textLength > this.upperLimit;
    }
  },

  watch: {
    value: function value(val) {
      this.$nextTick(this.resizeTextarea);
      if (this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.change', [val]);
      }
    },

    // native input value is set explicitly
    // do not use v-model / :value in template
    // see: https://github.com/ElemeFE/element/issues/14521
    nativeInputValue: function nativeInputValue() {
      this.setNativeInputValue();
    },

    // when change between <input> and <textarea>,
    // update DOM dependent value and styles
    // https://github.com/ElemeFE/element/issues/14857
    type: function type() {
      var _this = this;

      this.$nextTick(function () {
        _this.setNativeInputValue();
        _this.resizeTextarea();
        _this.updateIconOffset();
      });
    }
  },

  methods: {
    focus: function focus() {
      this.getInput().focus();
    },
    blur: function blur() {
      this.getInput().blur();
    },
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'icon': 'icon is removed, use suffix-icon / prefix-icon instead.',
          'on-icon-click': 'on-icon-click is removed.'
        },
        events: {
          'click': 'click is removed.'
        }
      };
    },
    handleBlur: function handleBlur(event) {
      this.focused = false;
      this.$emit('blur', event);
      if (this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.blur', [this.value]);
      }
    },
    select: function select() {
      this.getInput().select();
    },
    resizeTextarea: function resizeTextarea() {
      if (this.$isServer) return;
      var autosize = this.autosize,
          type = this.type;

      if (type !== 'textarea') return;
      if (!autosize) {
        this.textareaCalcStyle = {
          minHeight: calcTextareaHeight(this.$refs.textarea).minHeight
        };
        return;
      }
      var minRows = autosize.minRows;
      var maxRows = autosize.maxRows;

      this.textareaCalcStyle = calcTextareaHeight(this.$refs.textarea, minRows, maxRows);
    },
    setNativeInputValue: function setNativeInputValue() {
      var input = this.getInput();
      if (!input) return;
      if (input.value === this.nativeInputValue) return;
      input.value = this.nativeInputValue;
    },
    handleFocus: function handleFocus(event) {
      this.focused = true;
      this.$emit('focus', event);
    },
    handleCompositionStart: function handleCompositionStart() {
      this.isComposing = true;
    },
    handleCompositionUpdate: function handleCompositionUpdate(event) {
      var text = event.target.value;
      var lastCharacter = text[text.length - 1] || '';
      this.isComposing = !Object(shared_["isKorean"])(lastCharacter);
    },
    handleCompositionEnd: function handleCompositionEnd(event) {
      if (this.isComposing) {
        this.isComposing = false;
        this.handleInput(event);
      }
    },
    handleInput: function handleInput(event) {
      // should not emit input during composition
      // see: https://github.com/ElemeFE/element/issues/10516
      if (this.isComposing) return;

      // hack for https://github.com/ElemeFE/element/issues/8548
      // should remove the following line when we don't support IE
      if (event.target.value === this.nativeInputValue) return;

      this.$emit('input', event.target.value);

      // ensure native input value is controlled
      // see: https://github.com/ElemeFE/element/issues/12850
      this.$nextTick(this.setNativeInputValue);
    },
    handleChange: function handleChange(event) {
      this.$emit('change', event.target.value);
    },
    calcIconOffset: function calcIconOffset(place) {
      var elList = [].slice.call(this.$el.querySelectorAll('.el-input__' + place) || []);
      if (!elList.length) return;
      var el = null;
      for (var i = 0; i < elList.length; i++) {
        if (elList[i].parentNode === this.$el) {
          el = elList[i];
          break;
        }
      }
      if (!el) return;
      var pendantMap = {
        suffix: 'append',
        prefix: 'prepend'
      };

      var pendant = pendantMap[place];
      if (this.$slots[pendant]) {
        el.style.transform = 'translateX(' + (place === 'suffix' ? '-' : '') + this.$el.querySelector('.el-input-group__' + pendant).offsetWidth + 'px)';
      } else {
        el.removeAttribute('style');
      }
    },
    updateIconOffset: function updateIconOffset() {
      this.calcIconOffset('prefix');
      this.calcIconOffset('suffix');
    },
    clear: function clear() {
      this.$emit('input', '');
      this.$emit('change', '');
      this.$emit('clear');
    },
    handlePasswordVisible: function handlePasswordVisible() {
      this.passwordVisible = !this.passwordVisible;
      this.focus();
    },
    getInput: function getInput() {
      return this.$refs.input || this.$refs.textarea;
    },
    getSuffixVisible: function getSuffixVisible() {
      return this.$slots.suffix || this.suffixIcon || this.showClear || this.showPassword || this.isWordLimitVisible || this.validateState && this.needStatusIcon;
    }
  },

  created: function created() {
    this.$on('inputSelect', this.select);
  },
  mounted: function mounted() {
    this.setNativeInputValue();
    this.resizeTextarea();
    this.updateIconOffset();
  },
  updated: function updated() {
    this.$nextTick(this.updateIconOffset);
  }
});
// CONCATENATED MODULE: ./packages/input/src/input.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_inputvue_type_script_lang_js_ = (inputvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(0);

// CONCATENATED MODULE: ./packages/input/src/input.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  src_inputvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/input/src/input.vue"
/* harmony default export */ var input = (component.exports);
// CONCATENATED MODULE: ./packages/input/index.js


/* istanbul ignore next */
input.install = function (Vue) {
  Vue.component(input.name, input);
};

/* harmony default export */ var packages_input = __webpack_exports__["default"] = (input);

/***/ }),

/***/ 9:
/***/ (function(module, exports) {

module.exports = __webpack_require__("7f4d");

/***/ })

/******/ });

/***/ }),

/***/ "f494":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 116);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 116:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio.vue?vue&type=template&id=69cd6268&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "label",
    {
      staticClass: "el-radio",
      class: [
        _vm.border && _vm.radioSize ? "el-radio--" + _vm.radioSize : "",
        { "is-disabled": _vm.isDisabled },
        { "is-focus": _vm.focus },
        { "is-bordered": _vm.border },
        { "is-checked": _vm.model === _vm.label }
      ],
      attrs: {
        role: "radio",
        "aria-checked": _vm.model === _vm.label,
        "aria-disabled": _vm.isDisabled,
        tabindex: _vm.tabIndex
      },
      on: {
        keydown: function($event) {
          if (
            !("button" in $event) &&
            _vm._k($event.keyCode, "space", 32, $event.key, [" ", "Spacebar"])
          ) {
            return null
          }
          $event.stopPropagation()
          $event.preventDefault()
          _vm.model = _vm.isDisabled ? _vm.model : _vm.label
        }
      }
    },
    [
      _c(
        "span",
        {
          staticClass: "el-radio__input",
          class: {
            "is-disabled": _vm.isDisabled,
            "is-checked": _vm.model === _vm.label
          }
        },
        [
          _c("span", { staticClass: "el-radio__inner" }),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.model,
                expression: "model"
              }
            ],
            ref: "radio",
            staticClass: "el-radio__original",
            attrs: {
              type: "radio",
              "aria-hidden": "true",
              name: _vm.name,
              disabled: _vm.isDisabled,
              tabindex: "-1"
            },
            domProps: {
              value: _vm.label,
              checked: _vm._q(_vm.model, _vm.label)
            },
            on: {
              focus: function($event) {
                _vm.focus = true
              },
              blur: function($event) {
                _vm.focus = false
              },
              change: [
                function($event) {
                  _vm.model = _vm.label
                },
                _vm.handleChange
              ]
            }
          })
        ]
      ),
      _c(
        "span",
        {
          staticClass: "el-radio__label",
          on: {
            keydown: function($event) {
              $event.stopPropagation()
            }
          }
        },
        [
          _vm._t("default"),
          !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e()
        ],
        2
      )
    ]
  )
}
var staticRenderFns = []
render._withStripped = true


// CONCATENATED MODULE: ./packages/radio/src/radio.vue?vue&type=template&id=69cd6268&

// EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"
var emitter_ = __webpack_require__(4);
var emitter_default = /*#__PURE__*/__webpack_require__.n(emitter_);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var radiovue_type_script_lang_js_ = ({
  name: 'ElRadio',

  mixins: [emitter_default.a],

  inject: {
    elForm: {
      default: ''
    },

    elFormItem: {
      default: ''
    }
  },

  componentName: 'ElRadio',

  props: {
    value: {},
    label: {},
    disabled: Boolean,
    name: String,
    border: Boolean,
    size: String
  },

  data: function data() {
    return {
      focus: false
    };
  },

  computed: {
    isGroup: function isGroup() {
      var parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElRadioGroup') {
          parent = parent.$parent;
        } else {
          this._radioGroup = parent;
          return true;
        }
      }
      return false;
    },

    model: {
      get: function get() {
        return this.isGroup ? this._radioGroup.value : this.value;
      },
      set: function set(val) {
        if (this.isGroup) {
          this.dispatch('ElRadioGroup', 'input', [val]);
        } else {
          this.$emit('input', val);
        }
        this.$refs.radio && (this.$refs.radio.checked = this.model === this.label);
      }
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    radioSize: function radioSize() {
      var temRadioSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
      return this.isGroup ? this._radioGroup.radioGroupSize || temRadioSize : temRadioSize;
    },
    isDisabled: function isDisabled() {
      return this.isGroup ? this._radioGroup.disabled || this.disabled || (this.elForm || {}).disabled : this.disabled || (this.elForm || {}).disabled;
    },
    tabIndex: function tabIndex() {
      return this.isDisabled || this.isGroup && this.model !== this.label ? -1 : 0;
    }
  },

  methods: {
    handleChange: function handleChange() {
      var _this = this;

      this.$nextTick(function () {
        _this.$emit('change', _this.model);
        _this.isGroup && _this.dispatch('ElRadioGroup', 'handleChange', _this.model);
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/radio/src/radio.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_radiovue_type_script_lang_js_ = (radiovue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(0);

// CONCATENATED MODULE: ./packages/radio/src/radio.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  src_radiovue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/radio/src/radio.vue"
/* harmony default export */ var src_radio = (component.exports);
// CONCATENATED MODULE: ./packages/radio/index.js


/* istanbul ignore next */
src_radio.install = function (Vue) {
  Vue.component(src_radio.name, src_radio);
};

/* harmony default export */ var packages_radio = __webpack_exports__["default"] = (src_radio);

/***/ }),

/***/ 4:
/***/ (function(module, exports) {

module.exports = __webpack_require__("d010");

/***/ })

/******/ });

/***/ }),

/***/ "f893":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("8119"), __esModule: true };

/***/ }),

/***/ "faf5":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("0bad") && !__webpack_require__("4b8b")(function () {
  return Object.defineProperty(__webpack_require__("05f5")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "ShowOverflowTooltip", function() { return /* reexport */ packages_show_overflow_tooltip; });

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/element-ui/lib/theme-chalk/index.css
var theme_chalk = __webpack_require__("0fae");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5988e21a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/show-overflow-tooltip/src/show-overflow-tooltip.vue?vue&type=template&id=2640221e&scoped=true&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('tooltip',{attrs:{"effect":_vm.effect,"disabled":!_vm.isShowTooltip,"content":_vm.content,"placement":_vm.placement}},[_c('div',{ref:"container",staticClass:"tooltip-root",on:{"mouseover":_vm.onMouseOver}},[_vm._t("default")],2)])}
var staticRenderFns = []


// CONCATENATED MODULE: ./packages/show-overflow-tooltip/src/show-overflow-tooltip.vue?vue&type=template&id=2640221e&scoped=true&

// EXTERNAL MODULE: ./node_modules/element-ui/lib/element-ui.common.js
var element_ui_common = __webpack_require__("5c96");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/show-overflow-tooltip/src/show-overflow-tooltip.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//


// 按需引入
/* harmony default export */ var show_overflow_tooltipvue_type_script_lang_js_ = ({
  name: 'show-overflow-tooltip',
  components: { Tooltip: element_ui_common["Tooltip"] },
  props: {
    effect: {
      type: String,
      default: 'light',
    },
    placement: {
      type: String,
      default: 'top',
    },
  },
  data() {
    return {
      isShowTooltip: false,
      content: '',
    };
  },
  mounted() {
    this.isContainerSqueezed();
  },
  methods: {
    onMouseOver() {
      this.isContainerSqueezed();
    },
    isContainerSqueezed() {
      const { container } = this.$refs;
      if (!container) {
        this.isShowTooltip = false;
      }
      this.isShowTooltip = container.scrollWidth !== container.clientWidth;
      this.content = container.innerText;
    },
  },
});

// CONCATENATED MODULE: ./packages/show-overflow-tooltip/src/show-overflow-tooltip.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_show_overflow_tooltipvue_type_script_lang_js_ = (show_overflow_tooltipvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./packages/show-overflow-tooltip/src/show-overflow-tooltip.vue?vue&type=style&index=0&id=2640221e&scoped=true&lang=css&
var show_overflow_tooltipvue_type_style_index_0_id_2640221e_scoped_true_lang_css_ = __webpack_require__("39d8");

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

// CONCATENATED MODULE: ./packages/show-overflow-tooltip/src/show-overflow-tooltip.vue






/* normalize component */

var component = normalizeComponent(
  src_show_overflow_tooltipvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  "2640221e",
  null
  
)

/* harmony default export */ var show_overflow_tooltip = (component.exports);
// CONCATENATED MODULE: ./packages/show-overflow-tooltip/index.js
/* eslint-disable func-names */


show_overflow_tooltip.install = function (Vue) {
  Vue.component(show_overflow_tooltip.name, show_overflow_tooltip);
};

/* harmony default export */ var packages_show_overflow_tooltip = (show_overflow_tooltip);

// CONCATENATED MODULE: ./packages/index.js
/* eslint-disable func-names */
// 引入el的样式

// 存储组件列表
const components = [packages_show_overflow_tooltip];
// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册

const install = function (Vue) {
  // 判断是否安装

  if (install.installed) return;
  // 遍历注册全局组件
  components.forEach((component) => {
    Vue.component('show-overflow-tooltip', component);
  });
};
// 判断是否是直接引入文件

if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}

/* harmony default export */ var packages_0 = ({ // 引入全部
  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装
  install,

});


// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (packages_0);



/***/ }),

/***/ "fc5e":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "fcd4":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("cc15");


/***/ }),

/***/ "fed5":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ })

/******/ }))
));